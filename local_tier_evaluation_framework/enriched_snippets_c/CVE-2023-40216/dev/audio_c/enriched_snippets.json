[
  {
    "function_name": "mixer_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2786-2847",
    "snippet": "int\nmixer_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error = EINVAL;\n\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d)\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\n\tswitch (cmd) {\n\tcase FIOASYNC:\n\t\tmixer_remove(sc, p); /* remove old entry */\n\t\tif (*(int *)addr) {\n\t\t\tstruct mixer_asyncs *ma;\n\t\t\tma = malloc(sizeof (struct mixer_asyncs),\n                                    M_DEVBUF, M_WAITOK);\n\t\t\tma->next = sc->sc_async_mixer;\n\t\t\tma->proc = p;\n\t\t\tsc->sc_async_mixer = ma;\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_MIXER_DEVINFO:\n\t\tDPRINTF((\"AUDIO_MIXER_DEVINFO\\n\"));\n\t\terror = hw->query_devinfo(sc->hw_hdl, (mixer_devinfo_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_READ:\n\t\tDPRINTF((\"AUDIO_MIXER_READ\\n\"));\n\t\terror = hw->get_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_WRITE:\n\t\tDPRINTF((\"AUDIO_MIXER_WRITE\\n\"));\n\t\terror = hw->set_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tif (!error && hw->commit_settings)\n\t\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (!error)\n\t\t\tmixer_signal(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d) result %d\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mixer_ioctl(%d,'%c',%d) result %d\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error)"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCGROUP",
          "args": [
            "cmd"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCPARM_LEN",
          "args": [
            "cmd"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mixer_signal",
          "args": [
            "sc"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2756-2764",
          "snippet": "static void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw->commit_settings",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->set_port",
          "args": [
            "sc->hw_hdl",
            "(mixer_ctrl_t *)addr"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_MIXER_WRITE\\n\")"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->get_port",
          "args": [
            "sc->hw_hdl",
            "(mixer_ctrl_t *)addr"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_MIXER_READ\\n\")"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->query_devinfo",
          "args": [
            "sc->hw_hdl",
            "(mixer_devinfo_t *)addr"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_MIXER_DEVINFO\\n\")"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->getdev",
          "args": [
            "sc->hw_hdl",
            "(audio_device_t *)addr"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_GETDEV\\n\")"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct mixer_asyncs)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mixer_remove",
          "args": [
            "sc",
            "p"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2736-2751",
          "snippet": "static void\nmixer_remove(sc, p)\n\tstruct audio_softc *sc;\n\tstruct proc *p;\n{\n\tstruct mixer_asyncs **pm, *m;\n\n\tfor(pm = &sc->sc_async_mixer; *pm; pm = &(*pm)->next) {\n\t\tif ((*pm)->proc == p) {\n\t\t\tm = *pm;\n\t\t\t*pm = m->next;\n\t\t\tfree(m, M_DEVBUF);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic void\nmixer_remove(sc, p)\n\tstruct audio_softc *sc;\n\tstruct proc *p;\n{\n\tstruct mixer_asyncs **pm, *m;\n\n\tfor(pm = &sc->sc_async_mixer; *pm; pm = &(*pm)->next) {\n\t\tif ((*pm)->proc == p) {\n\t\t\tm = *pm;\n\t\t\t*pm = m->next;\n\t\t\tfree(m, M_DEVBUF);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mixer_ioctl(%d,'%c',%d)\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff)"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCGROUP",
          "args": [
            "cmd"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCPARM_LEN",
          "args": [
            "cmd"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nmixer_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error = EINVAL;\n\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d)\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\n\tswitch (cmd) {\n\tcase FIOASYNC:\n\t\tmixer_remove(sc, p); /* remove old entry */\n\t\tif (*(int *)addr) {\n\t\t\tstruct mixer_asyncs *ma;\n\t\t\tma = malloc(sizeof (struct mixer_asyncs),\n                                    M_DEVBUF, M_WAITOK);\n\t\t\tma->next = sc->sc_async_mixer;\n\t\t\tma->proc = p;\n\t\t\tsc->sc_async_mixer = ma;\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_MIXER_DEVINFO:\n\t\tDPRINTF((\"AUDIO_MIXER_DEVINFO\\n\"));\n\t\terror = hw->query_devinfo(sc->hw_hdl, (mixer_devinfo_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_READ:\n\t\tDPRINTF((\"AUDIO_MIXER_READ\\n\"));\n\t\terror = hw->get_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_WRITE:\n\t\tDPRINTF((\"AUDIO_MIXER_WRITE\\n\"));\n\t\terror = hw->set_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tif (!error && hw->commit_settings)\n\t\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (!error)\n\t\t\tmixer_signal(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d) result %d\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}"
  },
  {
    "function_name": "mixer_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2770-2784",
    "snippet": "int\nmixer_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\n\tDPRINTF((\"mixer_close: unit %d\\n\", AUDIOUNIT(dev)));\n\t\n\tmixer_remove(sc, p);\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mixer_remove",
          "args": [
            "sc",
            "p"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2736-2751",
          "snippet": "static void\nmixer_remove(sc, p)\n\tstruct audio_softc *sc;\n\tstruct proc *p;\n{\n\tstruct mixer_asyncs **pm, *m;\n\n\tfor(pm = &sc->sc_async_mixer; *pm; pm = &(*pm)->next) {\n\t\tif ((*pm)->proc == p) {\n\t\t\tm = *pm;\n\t\t\t*pm = m->next;\n\t\t\tfree(m, M_DEVBUF);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic void\nmixer_remove(sc, p)\n\tstruct audio_softc *sc;\n\tstruct proc *p;\n{\n\tstruct mixer_asyncs **pm, *m;\n\n\tfor(pm = &sc->sc_async_mixer; *pm; pm = &(*pm)->next) {\n\t\tif ((*pm)->proc == p) {\n\t\t\tm = *pm;\n\t\t\t*pm = m->next;\n\t\t\tfree(m, M_DEVBUF);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mixer_close: unit %d\\n\", AUDIOUNIT(dev))"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nmixer_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\n\tDPRINTF((\"mixer_close: unit %d\\n\", AUDIOUNIT(dev)));\n\t\n\tmixer_remove(sc, p);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "mixer_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2756-2764",
    "snippet": "static void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "m->proc",
            "SIGIO"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}"
  },
  {
    "function_name": "mixer_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2736-2751",
    "snippet": "static void\nmixer_remove(sc, p)\n\tstruct audio_softc *sc;\n\tstruct proc *p;\n{\n\tstruct mixer_asyncs **pm, *m;\n\n\tfor(pm = &sc->sc_async_mixer; *pm; pm = &(*pm)->next) {\n\t\tif ((*pm)->proc == p) {\n\t\t\tm = *pm;\n\t\t\t*pm = m->next;\n\t\t\tfree(m, M_DEVBUF);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "m",
            "M_DEVBUF"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "audio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "493-503",
          "snippet": "void\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic void\nmixer_remove(sc, p)\n\tstruct audio_softc *sc;\n\tstruct proc *p;\n{\n\tstruct mixer_asyncs **pm, *m;\n\n\tfor(pm = &sc->sc_async_mixer; *pm; pm = &(*pm)->next) {\n\t\tif ((*pm)->proc == p) {\n\t\t\tm = *pm;\n\t\t\t*pm = m->next;\n\t\t\tfree(m, M_DEVBUF);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "mixer_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2712-2731",
    "snippet": "int\nmixer_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\tif (!sc->hw_if)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"mixer_open: dev=0x%x flags=0x%x sc=%p\\n\", dev, flags, sc));\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mixer_open: dev=0x%x flags=0x%x sc=%p\\n\", dev, flags, sc)"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nmixer_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\tif (!sc->hw_if)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"mixer_open: dev=0x%x flags=0x%x sc=%p\\n\", dev, flags, sc));\n\n\treturn (0);\n}"
  },
  {
    "function_name": "audiogetinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2632-2707",
    "snippet": "int\naudiogetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\t\n\tp->sample_rate = sc->sc_pparams.sample_rate;\n\tr->sample_rate = sc->sc_rparams.sample_rate;\n\tp->channels = sc->sc_pparams.channels;\n\tr->channels = sc->sc_rparams.channels;\n\tp->precision = sc->sc_pparams.precision;\n\tr->precision = sc->sc_rparams.precision;\n\tp->encoding = sc->sc_pparams.encoding;\n\tr->encoding = sc->sc_rparams.encoding;\n\n\tr->port = au_get_port(sc, &sc->sc_inports);\n\tp->port = au_get_port(sc, &sc->sc_outports);\n\n\tr->avail_ports = sc->sc_inports.allports;\n\tp->avail_ports = sc->sc_outports.allports;\n\n\tau_get_gain(sc, &sc->sc_inports,  &r->gain, &r->balance);\n\tau_get_gain(sc, &sc->sc_outports, &p->gain, &p->balance);\n\n\tif (sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\tai->monitor_gain = 0;\n\t\telse\n\t\t\tai->monitor_gain = \n\t\t\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t} else\n\t\tai->monitor_gain = 0;\n\n\tp->seek = sc->sc_pr.used;\n\tr->seek = sc->sc_rr.used;\n\n\tp->samples = sc->sc_pr.stamp - sc->sc_pr.drops;\n\tr->samples = sc->sc_rr.stamp - sc->sc_rr.drops;\n\n\tp->eof = sc->sc_eof;\n\tr->eof = 0;\n\n\tp->pause = sc->sc_pr.pause;\n\tr->pause = sc->sc_rr.pause;\n\n\tp->error = sc->sc_pr.drops != 0;\n\tr->error = sc->sc_rr.drops != 0;\n\n\tp->waiting = r->waiting = 0;\t\t/* open never hangs */\n\n\tp->open = (sc->sc_open & AUOPEN_WRITE) != 0;\n\tr->open = (sc->sc_open & AUOPEN_READ) != 0;\n\n\tp->active = sc->sc_pbus;\n\tr->active = sc->sc_rbus;\n\n\tp->buffer_size = sc->sc_pr.bufsize;\n\tr->buffer_size = sc->sc_rr.bufsize;\n\n\tai->blocksize = sc->sc_pr.blksize;\n\tai->hiwat = sc->sc_pr.usedhigh / sc->sc_pr.blksize;\n\tai->lowat = sc->sc_pr.usedlow / sc->sc_pr.blksize;\n\tai->mode = sc->sc_mode;\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_get_gain",
          "args": [
            "sc",
            "&sc->sc_outports",
            "&p->gain",
            "&p->balance"
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "au_get_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2189-2263",
          "snippet": "void\nau_get_gain(sc, ports, pgain, pbalance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\t*pgain;\n\tu_char\t*pbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, l, r, n;\n\tint lgain = AUDIO_MAX_GAIN/2, rgain = AUDIO_MAX_GAIN/2;\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\tgoto bad;\n\t\tct.dev = ports->master;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tif (au_get_lr_value(sc, &ct, &lgain, &rgain))\n\t\t\tgoto bad;\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, \n\t\t\t\t\t\t\t    &lgain, &rgain))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tlgain = rgain = n = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & ct.un.mask) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, &l, &r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlgain += l;\n\t\t\t\t\t\trgain += r;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 0) {\n\t\t\t\tlgain /= n;\n\t\t\t\trgain /= n;\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tif (lgain == rgain) {\t/* handles lgain==rgain==0 */\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_MID_BALANCE;\n\t} else if (lgain < rgain) {\n\t\t*pgain = rgain;\n\t\t*pbalance = (AUDIO_MID_BALANCE * lgain) / rgain;\n\t} else /* lgain > rgain */ {\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_RIGHT_BALANCE -\n\t\t\t    (AUDIO_MID_BALANCE * rgain) / lgain;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\nau_get_gain(sc, ports, pgain, pbalance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\t*pgain;\n\tu_char\t*pbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, l, r, n;\n\tint lgain = AUDIO_MAX_GAIN/2, rgain = AUDIO_MAX_GAIN/2;\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\tgoto bad;\n\t\tct.dev = ports->master;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tif (au_get_lr_value(sc, &ct, &lgain, &rgain))\n\t\t\tgoto bad;\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, \n\t\t\t\t\t\t\t    &lgain, &rgain))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tlgain = rgain = n = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & ct.un.mask) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, &l, &r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlgain += l;\n\t\t\t\t\t\trgain += r;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 0) {\n\t\t\t\tlgain /= n;\n\t\t\t\trgain /= n;\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tif (lgain == rgain) {\t/* handles lgain==rgain==0 */\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_MID_BALANCE;\n\t} else if (lgain < rgain) {\n\t\t*pgain = rgain;\n\t\t*pbalance = (AUDIO_MID_BALANCE * lgain) / rgain;\n\t} else /* lgain > rgain */ {\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_RIGHT_BALANCE -\n\t\t\t    (AUDIO_MID_BALANCE * rgain) / lgain;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "au_get_port",
          "args": [
            "sc",
            "&sc->sc_outports"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "au_get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2307-2332",
          "snippet": "int\nau_get_port(sc, ports)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n{\n\tmixer_ctrl_t ct;\n\tint i, aumask;\n\n\tif (ports->index == -1)\n\t\treturn 0;\n\tct.dev = ports->index;\n\tct.type = ports->isenum ? AUDIO_MIXER_ENUM : AUDIO_MIXER_SET;\n\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\treturn 0;\n\taumask = 0;\n\tif (ports->isenum) {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.ord == ports->misel[i])\n\t\t\t\taumask = ports->aumask[i];\n\t} else {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.mask & ports->misel[i])\n\t\t\t\taumask |= ports->aumask[i];\n\t}\n\treturn aumask;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_get_port(sc, ports)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n{\n\tmixer_ctrl_t ct;\n\tint i, aumask;\n\n\tif (ports->index == -1)\n\t\treturn 0;\n\tct.dev = ports->index;\n\tct.type = ports->isenum ? AUDIO_MIXER_ENUM : AUDIO_MIXER_SET;\n\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\treturn 0;\n\taumask = 0;\n\tif (ports->isenum) {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.ord == ports->misel[i])\n\t\t\t\taumask = ports->aumask[i];\n\t} else {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.mask & ports->misel[i])\n\t\t\t\taumask |= ports->aumask[i];\n\t}\n\treturn aumask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiogetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\t\n\tp->sample_rate = sc->sc_pparams.sample_rate;\n\tr->sample_rate = sc->sc_rparams.sample_rate;\n\tp->channels = sc->sc_pparams.channels;\n\tr->channels = sc->sc_rparams.channels;\n\tp->precision = sc->sc_pparams.precision;\n\tr->precision = sc->sc_rparams.precision;\n\tp->encoding = sc->sc_pparams.encoding;\n\tr->encoding = sc->sc_rparams.encoding;\n\n\tr->port = au_get_port(sc, &sc->sc_inports);\n\tp->port = au_get_port(sc, &sc->sc_outports);\n\n\tr->avail_ports = sc->sc_inports.allports;\n\tp->avail_ports = sc->sc_outports.allports;\n\n\tau_get_gain(sc, &sc->sc_inports,  &r->gain, &r->balance);\n\tau_get_gain(sc, &sc->sc_outports, &p->gain, &p->balance);\n\n\tif (sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\tai->monitor_gain = 0;\n\t\telse\n\t\t\tai->monitor_gain = \n\t\t\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t} else\n\t\tai->monitor_gain = 0;\n\n\tp->seek = sc->sc_pr.used;\n\tr->seek = sc->sc_rr.used;\n\n\tp->samples = sc->sc_pr.stamp - sc->sc_pr.drops;\n\tr->samples = sc->sc_rr.stamp - sc->sc_rr.drops;\n\n\tp->eof = sc->sc_eof;\n\tr->eof = 0;\n\n\tp->pause = sc->sc_pr.pause;\n\tr->pause = sc->sc_rr.pause;\n\n\tp->error = sc->sc_pr.drops != 0;\n\tr->error = sc->sc_rr.drops != 0;\n\n\tp->waiting = r->waiting = 0;\t\t/* open never hangs */\n\n\tp->open = (sc->sc_open & AUOPEN_WRITE) != 0;\n\tr->open = (sc->sc_open & AUOPEN_READ) != 0;\n\n\tp->active = sc->sc_pbus;\n\tr->active = sc->sc_rbus;\n\n\tp->buffer_size = sc->sc_pr.bufsize;\n\tr->buffer_size = sc->sc_rr.bufsize;\n\n\tai->blocksize = sc->sc_pr.blksize;\n\tai->hiwat = sc->sc_pr.usedhigh / sc->sc_pr.blksize;\n\tai->lowat = sc->sc_pr.usedlow / sc->sc_pr.blksize;\n\tai->mode = sc->sc_mode;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "audiosetinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2334-2630",
    "snippet": "int\naudiosetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tint cleared;\n\tint s, setmode, modechange = 0;\n\tint error;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params pp, rp;\n\tint np, nr;\n\tunsigned int blks;\n\tint oldpblksize, oldrblksize;\n\tint rbus, pbus;\n\tu_int gain;\n\tu_char balance;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\n\trbus = sc->sc_rbus;\n\tpbus = sc->sc_pbus;\n\terror = 0;\n\tcleared = 0;\n\n\tpp = sc->sc_pparams;\t/* Temporary encoding storage in */\n\trp = sc->sc_rparams;\t/* case setting the modes fails. */\n\tnr = np = 0;\n\n\tif (p->sample_rate != ~0) {\n\t\tpp.sample_rate = p->sample_rate;\n\t\tnp++;\n\t}\n\tif (r->sample_rate != ~0) {\n\t\trp.sample_rate = r->sample_rate;\n\t\tnr++;\n\t}\n\tif (p->encoding != ~0) {\n\t\tpp.encoding = p->encoding;\n\t\tnp++;\n\t}\t\n\tif (r->encoding != ~0) {\n\t\trp.encoding = r->encoding;\n\t\tnr++;\n\t}\n\tif (p->precision != ~0) {\n\t\tpp.precision = p->precision;\n\t\tnp++;\n\t}\n\tif (r->precision != ~0) {\n\t\trp.precision = r->precision;\n\t\tnr++;\n\t}\n\tif (p->channels != ~0) {\n\t\tpp.channels = p->channels;\n\t\tnp++;\n\t}\n\tif (r->channels != ~0) {\n\t\trp.channels = r->channels;\n\t\tnr++;\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug && nr)\n\t    audio_print_params(\"Setting record params\", &rp);\n\tif (audiodebug && np)\n\t    audio_print_params(\"Setting play params\", &pp);\n#endif\n\tif (nr && (error = audio_check_params(&rp)))\n\t\treturn error;\n\tif (np && (error = audio_check_params(&pp)))\n\t\treturn error;\n\tsetmode = 0;\n\tif (nr) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\trp.sw_code = 0;\n\t\trp.factor = 1;\n\t\tsetmode |= AUMODE_RECORD;\n\t}\n\tif (np) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tpp.sw_code = 0;\n\t\tpp.factor = 1;\n\t\tsetmode |= AUMODE_PLAY;\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tsc->sc_mode = ai->mode;\n\t\tif (sc->sc_mode & AUMODE_PLAY_ALL)\n\t\t\tsc->sc_mode |= AUMODE_PLAY;\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_full_duplex)\n\t\t\t/* Play takes precedence */\n\t\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\n\tif (modechange) {\n\t\tint indep = hw->get_props(sc->hw_hdl) & AUDIO_PROP_INDEPENDENT;\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD)\n\t\t\t\tpp = rp;\n\t\t\telse if (setmode == AUMODE_PLAY)\n\t\t\t\trp = pp;\n\t\t}\n\t\terror = hw->set_params(sc->hw_hdl, setmode,\n\t\t    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD), &pp, &rp);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD) {\n\t\t\t\tpp.sample_rate = rp.sample_rate;\n\t\t\t\tpp.encoding    = rp.encoding;\n\t\t\t\tpp.channels    = rp.channels;\n\t\t\t\tpp.precision   = rp.precision;\n\t\t\t} else if (setmode == AUMODE_PLAY) {\n\t\t\t\trp.sample_rate = pp.sample_rate;\n\t\t\t\trp.encoding    = pp.encoding;\n\t\t\t\trp.channels    = pp.channels;\n\t\t\t\trp.precision   = pp.precision;\n\t\t\t}\n\t\t}\n\t\tsc->sc_rparams = rp;\n\t\tsc->sc_pparams = pp;\n\t}\n\n\toldpblksize = sc->sc_pr.blksize;\n\toldrblksize = sc->sc_rr.blksize;\n\t/* Play params can affect the record params, so recalculate blksize. */\n\tif (nr || np) {\n\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug > 1 && nr)\n\t    audio_print_params(\"After setting record params\", &sc->sc_rparams);\n\tif (audiodebug > 1 && np)\n\t    audio_print_params(\"After setting play params\", &sc->sc_pparams);\n#endif\n\n\tif (p->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_outports, p->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_inports, r->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (p->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, p->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, r->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\t\n\tif (p->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, gain, p->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, gain, r->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (ai->monitor_gain != ~0 &&\n\t    sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = ai->monitor_gain;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (p->pause != (u_char)~0) {\n\t\tsc->sc_pr.pause = p->pause;\n\t\tif (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartp(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\tif (r->pause != (u_char)~0) {\n\t\tsc->sc_rr.pause = r->pause;\n\t\tif (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartr(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (ai->blocksize != ~0) {\n\t\t/* Block size specified explicitly. */\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\tif (ai->blocksize == 0) {\n\t\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t\t\tsc->sc_blkset = 0;\n\t\t} else {\n\t\t\tint bs = ai->blocksize;\n\t\t\tif (hw->round_blocksize)\n\t\t\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\t\t\tsc->sc_pr.blksize = sc->sc_rr.blksize = bs;\n\t\t\tsc->sc_blkset = 1;\n\t\t}\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (sc->sc_mode & AUMODE_PLAY)\n\t\t\taudio_init_play(sc);\n\t\tif (sc->sc_mode & AUMODE_RECORD)\n\t\t\taudio_init_record(sc);\n\t}\n\n\tif (hw->commit_settings) {\n\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\tif (cleared) {\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) goto err;\n\t\tif (sc->sc_pr.blksize != oldpblksize ||\n\t\t    sc->sc_rr.blksize != oldrblksize)\n\t\t\taudio_calcwater(sc);\n\t\tif ((sc->sc_mode & AUMODE_PLAY) &&\n\t\t    pbus && !sc->sc_pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error && \n\t\t    (sc->sc_mode & AUMODE_RECORD) &&\n\t\t    rbus && !sc->sc_rbus)\n\t\t\terror = audiostartr(sc);\n\terr:\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t\n\t/* Change water marks after initializing the buffers. */\n\tif (ai->hiwat != ~0) {\n\t\tblks = ai->hiwat;\n\t\tif (blks > sc->sc_pr.maxblks)\n\t\t\tblks = sc->sc_pr.maxblks;\n\t\tif (blks < 2)\n\t\t\tblks = 2;\n\t\tsc->sc_pr.usedhigh = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->lowat != ~0) {\n\t\tblks = ai->lowat;\n\t\tif (blks > sc->sc_pr.maxblks - 1)\n\t\t\tblks = sc->sc_pr.maxblks - 1;\n\t\tsc->sc_pr.usedlow = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->hiwat != ~0 || ai->lowat != ~0) {\n\t\tif (sc->sc_pr.usedlow > sc->sc_pr.usedhigh - sc->sc_pr.blksize)\n\t\t\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh - sc->sc_pr.blksize;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiostartr",
          "args": [
            "sc"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1692-1715",
          "snippet": "int\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audiostartp",
          "args": [
            "sc"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1717-1743",
          "snippet": "int\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_calcwater",
          "args": [
            "sc"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "audio_calcwater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "721-731",
          "snippet": "void\naudio_calcwater(sc)\n\tstruct audio_softc *sc;\n{\n\tsc->sc_pr.usedhigh = sc->sc_pr.end - sc->sc_pr.start;\n\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh * 3 / 4;\t/* set lowater at 75% */\n\tif (sc->sc_pr.usedlow == sc->sc_pr.usedhigh)\n\t\tsc->sc_pr.usedlow -= sc->sc_pr.blksize;\n\tsc->sc_rr.usedhigh = sc->sc_pr.end - sc->sc_pr.start - sc->sc_pr.blksize;\n\tsc->sc_rr.usedlow = 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_calcwater(sc)\n\tstruct audio_softc *sc;\n{\n\tsc->sc_pr.usedhigh = sc->sc_pr.end - sc->sc_pr.start;\n\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh * 3 / 4;\t/* set lowater at 75% */\n\tif (sc->sc_pr.usedlow == sc->sc_pr.usedhigh)\n\t\tsc->sc_pr.usedlow -= sc->sc_pr.blksize;\n\tsc->sc_rr.usedhigh = sc->sc_pr.end - sc->sc_pr.start - sc->sc_pr.blksize;\n\tsc->sc_rr.usedlow = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_initbufs",
          "args": [
            "sc"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "audio_initbufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "672-719",
          "snippet": "int\naudio_initbufs(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"audio_initbufs: mode=0x%x\\n\", sc->sc_mode));\n\taudio_init_ringbuffer(&sc->sc_rr);\n\tif (hw->init_input && (sc->sc_mode & AUMODE_RECORD)) {\n\t\terror = hw->init_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t\t\t       sc->sc_rr.end - sc->sc_rr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\taudio_init_ringbuffer(&sc->sc_pr);\n\tsc->sc_sil_count = 0;\n\tif (hw->init_output && (sc->sc_mode & AUMODE_PLAY)) {\n\t\terror = hw->init_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t\t\t\tsc->sc_pr.end - sc->sc_pr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n#define double u_long\n\tsc->sc_pnintr = 0;\n\tsc->sc_pblktime = (u_long)(\n\t    (double)sc->sc_pr.blksize * 100000 / \n\t    (double)(sc->sc_pparams.precision / NBBY * \n                     sc->sc_pparams.channels * \n\t\t     sc->sc_pparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: play blktime = %lu for %d\\n\", \n\t\t sc->sc_pblktime, sc->sc_pr.blksize));\n\tsc->sc_rnintr = 0;\n\tsc->sc_rblktime = (u_long)(\n\t    (double)sc->sc_rr.blksize * 100000 / \n\t    (double)(sc->sc_rparams.precision / NBBY * \n                     sc->sc_rparams.channels * \n\t\t     sc->sc_rparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: record blktime = %lu for %d\\n\", \n\t\t sc->sc_rblktime, sc->sc_rr.blksize));\n#undef double\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [
            "#define double u_long"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\n#define double u_long\n\nint\naudio_initbufs(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"audio_initbufs: mode=0x%x\\n\", sc->sc_mode));\n\taudio_init_ringbuffer(&sc->sc_rr);\n\tif (hw->init_input && (sc->sc_mode & AUMODE_RECORD)) {\n\t\terror = hw->init_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t\t\t       sc->sc_rr.end - sc->sc_rr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\taudio_init_ringbuffer(&sc->sc_pr);\n\tsc->sc_sil_count = 0;\n\tif (hw->init_output && (sc->sc_mode & AUMODE_PLAY)) {\n\t\terror = hw->init_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t\t\t\tsc->sc_pr.end - sc->sc_pr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n#define double u_long\n\tsc->sc_pnintr = 0;\n\tsc->sc_pblktime = (u_long)(\n\t    (double)sc->sc_pr.blksize * 100000 / \n\t    (double)(sc->sc_pparams.precision / NBBY * \n                     sc->sc_pparams.channels * \n\t\t     sc->sc_pparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: play blktime = %lu for %d\\n\", \n\t\t sc->sc_pblktime, sc->sc_pr.blksize));\n\tsc->sc_rnintr = 0;\n\tsc->sc_rblktime = (u_long)(\n\t    (double)sc->sc_rr.blksize * 100000 / \n\t    (double)(sc->sc_rparams.precision / NBBY * \n                     sc->sc_rparams.channels * \n\t\t     sc->sc_rparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: record blktime = %lu for %d\\n\", \n\t\t sc->sc_rblktime, sc->sc_rr.blksize));\n#undef double\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->commit_settings",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_init_record",
          "args": [
            "sc"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "audio_init_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "887-897",
          "snippet": "void\naudio_init_record(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->hw_if->speaker_ctl &&\n\t    (!sc->sc_full_duplex || (sc->sc_mode & AUMODE_PLAY) == 0))\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_OFF);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_init_record(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->hw_if->speaker_ctl &&\n\t    (!sc->sc_full_duplex || (sc->sc_mode & AUMODE_PLAY) == 0))\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_OFF);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_init_play",
          "args": [
            "sc"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "audio_init_play",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "902-912",
          "snippet": "void\naudio_init_play(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tsc->sc_wstamp = sc->sc_pr.stamp;\n\tif (sc->hw_if->speaker_ctl)\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_ON);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_init_play(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tsc->sc_wstamp = sc->sc_pr.stamp;\n\tif (sc->hw_if->speaker_ctl)\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_ON);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw->round_blocksize",
          "args": [
            "sc->hw_hdl",
            "bs"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_calc_blksize",
          "args": [
            "sc",
            "AUMODE_PLAY"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "audio_calc_blksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1158-1189",
          "snippet": "void\naudio_calc_blksize(sc, mode)\n\tstruct audio_softc *sc;\n\tint mode;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params *parm;\n\tstruct audio_ringbuffer *rb;\n    \tint bs;\n\n\tif (sc->sc_blkset)\n\t\treturn;\n\n\tif (mode == AUMODE_PLAY) {\n\t\tparm = &sc->sc_pparams;\n\t\trb = &sc->sc_pr;\n\t} else {\n\t\tparm = &sc->sc_rparams;\n\t\trb = &sc->sc_rr;\n\t}\n\t\n\tbs = parm->sample_rate * audio_blk_ms / 1000 *\n\t     parm->channels * parm->precision / NBBY *\n\t     parm->factor;\n\tROUNDSIZE(bs);\n\tif (hw->round_blocksize)\n\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\trb->blksize = bs;\n\n\tDPRINTF((\"audio_calc_blksize: %s blksize=%d\\n\", \n\t\t mode == AUMODE_PLAY ? \"play\" : \"record\", bs));\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_calc_blksize(sc, mode)\n\tstruct audio_softc *sc;\n\tint mode;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params *parm;\n\tstruct audio_ringbuffer *rb;\n    \tint bs;\n\n\tif (sc->sc_blkset)\n\t\treturn;\n\n\tif (mode == AUMODE_PLAY) {\n\t\tparm = &sc->sc_pparams;\n\t\trb = &sc->sc_pr;\n\t} else {\n\t\tparm = &sc->sc_rparams;\n\t\trb = &sc->sc_rr;\n\t}\n\t\n\tbs = parm->sample_rate * audio_blk_ms / 1000 *\n\t     parm->channels * parm->precision / NBBY *\n\t     parm->factor;\n\tROUNDSIZE(bs);\n\tif (hw->round_blocksize)\n\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\trb->blksize = bs;\n\n\tDPRINTF((\"audio_calc_blksize: %s blksize=%d\\n\", \n\t\t mode == AUMODE_PLAY ? \"play\" : \"record\", bs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_clear",
          "args": [
            "sc"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "audio_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1139-1156",
          "snippet": "void\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_set_gain",
          "args": [
            "sc",
            "&sc->sc_inports",
            "gain",
            "r->balance"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "au_set_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2094-2165",
          "snippet": "int\nau_set_gain(sc, ports, gain, balance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tint\tgain;\n\tint\tbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\tint l, r;\n\tu_int mask;\n\tint nset;\n\n\tif (balance == AUDIO_MID_BALANCE) {\n\t\tl = r = gain;\n\t} else if (balance < AUDIO_MID_BALANCE) {\n\t\tr = gain;\n\t\tl = (balance * gain) / AUDIO_MID_BALANCE;\n\t} else {\n\t\tl = gain;\n\t\tr = ((AUDIO_RIGHT_BALANCE - balance) * gain)\n\t\t    / AUDIO_MID_BALANCE;\n\t}\n\tDPRINTF((\"au_set_gain: gain=%d balance=%d, l=%d r=%d\\n\",\n\t\t gain, balance, l, r));\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\treturn 0; /* just ignore it silently */\n\t\tct.dev = ports->master;\n\t\terror = au_set_lr_value(sc, &ct, l, r);\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_set_lr_value(sc, &ct, l, r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmask = ct.un.mask;\n\t\t\tnset = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & mask) {\n\t\t\t\t    ct.dev = ports->miport[i];\n\t\t\t\t    if (ct.dev != -1 &&\n\t\t\t\t\tau_set_lr_value(sc, &ct, l, r) == 0)\n\t\t\t\t\t    nset++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nset == 0)\n\t\t\t\tgoto usemaster;\n\t\t}\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_set_gain(sc, ports, gain, balance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tint\tgain;\n\tint\tbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\tint l, r;\n\tu_int mask;\n\tint nset;\n\n\tif (balance == AUDIO_MID_BALANCE) {\n\t\tl = r = gain;\n\t} else if (balance < AUDIO_MID_BALANCE) {\n\t\tr = gain;\n\t\tl = (balance * gain) / AUDIO_MID_BALANCE;\n\t} else {\n\t\tl = gain;\n\t\tr = ((AUDIO_RIGHT_BALANCE - balance) * gain)\n\t\t    / AUDIO_MID_BALANCE;\n\t}\n\tDPRINTF((\"au_set_gain: gain=%d balance=%d, l=%d r=%d\\n\",\n\t\t gain, balance, l, r));\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\treturn 0; /* just ignore it silently */\n\t\tct.dev = ports->master;\n\t\terror = au_set_lr_value(sc, &ct, l, r);\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_set_lr_value(sc, &ct, l, r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmask = ct.un.mask;\n\t\t\tnset = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & mask) {\n\t\t\t\t    ct.dev = ports->miport[i];\n\t\t\t\t    if (ct.dev != -1 &&\n\t\t\t\t\tau_set_lr_value(sc, &ct, l, r) == 0)\n\t\t\t\t\t    nset++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nset == 0)\n\t\t\t\tgoto usemaster;\n\t\t}\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "au_get_gain",
          "args": [
            "sc",
            "&sc->sc_inports",
            "&gain",
            "&balance"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "au_get_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2189-2263",
          "snippet": "void\nau_get_gain(sc, ports, pgain, pbalance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\t*pgain;\n\tu_char\t*pbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, l, r, n;\n\tint lgain = AUDIO_MAX_GAIN/2, rgain = AUDIO_MAX_GAIN/2;\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\tgoto bad;\n\t\tct.dev = ports->master;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tif (au_get_lr_value(sc, &ct, &lgain, &rgain))\n\t\t\tgoto bad;\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, \n\t\t\t\t\t\t\t    &lgain, &rgain))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tlgain = rgain = n = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & ct.un.mask) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, &l, &r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlgain += l;\n\t\t\t\t\t\trgain += r;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 0) {\n\t\t\t\tlgain /= n;\n\t\t\t\trgain /= n;\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tif (lgain == rgain) {\t/* handles lgain==rgain==0 */\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_MID_BALANCE;\n\t} else if (lgain < rgain) {\n\t\t*pgain = rgain;\n\t\t*pbalance = (AUDIO_MID_BALANCE * lgain) / rgain;\n\t} else /* lgain > rgain */ {\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_RIGHT_BALANCE -\n\t\t\t    (AUDIO_MID_BALANCE * rgain) / lgain;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\nau_get_gain(sc, ports, pgain, pbalance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\t*pgain;\n\tu_char\t*pbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, l, r, n;\n\tint lgain = AUDIO_MAX_GAIN/2, rgain = AUDIO_MAX_GAIN/2;\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\tgoto bad;\n\t\tct.dev = ports->master;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tif (au_get_lr_value(sc, &ct, &lgain, &rgain))\n\t\t\tgoto bad;\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, \n\t\t\t\t\t\t\t    &lgain, &rgain))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tlgain = rgain = n = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & ct.un.mask) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, &l, &r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlgain += l;\n\t\t\t\t\t\trgain += r;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 0) {\n\t\t\t\tlgain /= n;\n\t\t\t\trgain /= n;\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tif (lgain == rgain) {\t/* handles lgain==rgain==0 */\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_MID_BALANCE;\n\t} else if (lgain < rgain) {\n\t\t*pgain = rgain;\n\t\t*pbalance = (AUDIO_MID_BALANCE * lgain) / rgain;\n\t} else /* lgain > rgain */ {\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_RIGHT_BALANCE -\n\t\t\t    (AUDIO_MID_BALANCE * rgain) / lgain;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "au_set_port",
          "args": [
            "sc",
            "&sc->sc_inports",
            "r->port"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "au_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2265-2305",
          "snippet": "int\nau_set_port(sc, ports, port)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\tport;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\n\tif (port == 0 && ports->allports == 0)\n\t\treturn 0;\t/* allow this special case */\n\n\tif (ports->index == -1)\n\t\treturn EINVAL;\n\tct.dev = ports->index;\n\tif (ports->isenum) {\n\t\tif (port & (port-1))\n\t\t\treturn EINVAL; /* Only one port allowed */\n\t\tct.type = AUDIO_MIXER_ENUM;\n\t\terror = EINVAL;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] == port) {\n\t\t\t\tct.un.ord = ports->misel[i];\n\t\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t\t\t\tbreak;\n\t\t\t}\n\t} else {\n\t\tct.type = AUDIO_MIXER_SET;\n\t\tct.un.mask = 0;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] & port) \n\t\t\t\tct.un.mask |= ports->misel[i];\n\t\tif (port != 0 && ct.un.mask == 0)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_set_port(sc, ports, port)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\tport;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\n\tif (port == 0 && ports->allports == 0)\n\t\treturn 0;\t/* allow this special case */\n\n\tif (ports->index == -1)\n\t\treturn EINVAL;\n\tct.dev = ports->index;\n\tif (ports->isenum) {\n\t\tif (port & (port-1))\n\t\t\treturn EINVAL; /* Only one port allowed */\n\t\tct.type = AUDIO_MIXER_ENUM;\n\t\terror = EINVAL;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] == port) {\n\t\t\t\tct.un.ord = ports->misel[i];\n\t\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t\t\t\tbreak;\n\t\t\t}\n\t} else {\n\t\tct.type = AUDIO_MIXER_SET;\n\t\tct.un.mask = 0;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] & port) \n\t\t\t\tct.un.mask |= ports->misel[i];\n\t\tif (port != 0 && ct.un.mask == 0)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_print_params",
          "args": [
            "\"After setting play params\"",
            "&sc->sc_pparams"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "audio_print_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "457-464",
          "snippet": "void\naudio_print_params(s, p)\n\tchar *s;\n\tstruct audio_params *p;\n{\n\tprintf(\"audio: %s sr=%ld, enc=%d, chan=%d, prec=%d\\n\", s,\n\t       p->sample_rate, p->encoding, p->channels, p->precision);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_print_params(s, p)\n\tchar *s;\n\tstruct audio_params *p;\n{\n\tprintf(\"audio: %s sr=%ld, enc=%d, chan=%d, prec=%d\\n\", s,\n\t       p->sample_rate, p->encoding, p->channels, p->precision);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw->set_params",
          "args": [
            "sc->hw_hdl",
            "setmode",
            "sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD)",
            "&pp",
            "&rp"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->get_props",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_check_params",
          "args": [
            "&pp"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "audio_check_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2017-2075",
          "snippet": "int\naudio_check_params(p)\n\tstruct audio_params *p;\n{\n\tif (p->encoding == AUDIO_ENCODING_PCM16) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\tp->encoding = AUDIO_ENCODING_SLINEAR;\n\t} else if (p->encoding == AUDIO_ENCODING_PCM8) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\treturn EINVAL;\n\t}\n\n\tif (p->encoding == AUDIO_ENCODING_SLINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n#endif\n\tif (p->encoding == AUDIO_ENCODING_ULINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n#endif\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_ADPCM:\n\t\tif (p->precision != 8)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (p->precision != 8 && p->precision != 16)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tif (p->channels < 1 || p->channels > 8)\t/* sanity check # of channels */\n\t\treturn (EINVAL);\n\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_check_params(p)\n\tstruct audio_params *p;\n{\n\tif (p->encoding == AUDIO_ENCODING_PCM16) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\tp->encoding = AUDIO_ENCODING_SLINEAR;\n\t} else if (p->encoding == AUDIO_ENCODING_PCM8) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\treturn EINVAL;\n\t}\n\n\tif (p->encoding == AUDIO_ENCODING_SLINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n#endif\n\tif (p->encoding == AUDIO_ENCODING_ULINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n#endif\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_ADPCM:\n\t\tif (p->precision != 8)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (p->precision != 8 && p->precision != 16)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tif (p->channels < 1 || p->channels > 8)\t/* sanity check # of channels */\n\t\treturn (EINVAL);\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiosetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tint cleared;\n\tint s, setmode, modechange = 0;\n\tint error;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params pp, rp;\n\tint np, nr;\n\tunsigned int blks;\n\tint oldpblksize, oldrblksize;\n\tint rbus, pbus;\n\tu_int gain;\n\tu_char balance;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\n\trbus = sc->sc_rbus;\n\tpbus = sc->sc_pbus;\n\terror = 0;\n\tcleared = 0;\n\n\tpp = sc->sc_pparams;\t/* Temporary encoding storage in */\n\trp = sc->sc_rparams;\t/* case setting the modes fails. */\n\tnr = np = 0;\n\n\tif (p->sample_rate != ~0) {\n\t\tpp.sample_rate = p->sample_rate;\n\t\tnp++;\n\t}\n\tif (r->sample_rate != ~0) {\n\t\trp.sample_rate = r->sample_rate;\n\t\tnr++;\n\t}\n\tif (p->encoding != ~0) {\n\t\tpp.encoding = p->encoding;\n\t\tnp++;\n\t}\t\n\tif (r->encoding != ~0) {\n\t\trp.encoding = r->encoding;\n\t\tnr++;\n\t}\n\tif (p->precision != ~0) {\n\t\tpp.precision = p->precision;\n\t\tnp++;\n\t}\n\tif (r->precision != ~0) {\n\t\trp.precision = r->precision;\n\t\tnr++;\n\t}\n\tif (p->channels != ~0) {\n\t\tpp.channels = p->channels;\n\t\tnp++;\n\t}\n\tif (r->channels != ~0) {\n\t\trp.channels = r->channels;\n\t\tnr++;\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug && nr)\n\t    audio_print_params(\"Setting record params\", &rp);\n\tif (audiodebug && np)\n\t    audio_print_params(\"Setting play params\", &pp);\n#endif\n\tif (nr && (error = audio_check_params(&rp)))\n\t\treturn error;\n\tif (np && (error = audio_check_params(&pp)))\n\t\treturn error;\n\tsetmode = 0;\n\tif (nr) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\trp.sw_code = 0;\n\t\trp.factor = 1;\n\t\tsetmode |= AUMODE_RECORD;\n\t}\n\tif (np) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tpp.sw_code = 0;\n\t\tpp.factor = 1;\n\t\tsetmode |= AUMODE_PLAY;\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tsc->sc_mode = ai->mode;\n\t\tif (sc->sc_mode & AUMODE_PLAY_ALL)\n\t\t\tsc->sc_mode |= AUMODE_PLAY;\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_full_duplex)\n\t\t\t/* Play takes precedence */\n\t\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\n\tif (modechange) {\n\t\tint indep = hw->get_props(sc->hw_hdl) & AUDIO_PROP_INDEPENDENT;\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD)\n\t\t\t\tpp = rp;\n\t\t\telse if (setmode == AUMODE_PLAY)\n\t\t\t\trp = pp;\n\t\t}\n\t\terror = hw->set_params(sc->hw_hdl, setmode,\n\t\t    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD), &pp, &rp);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD) {\n\t\t\t\tpp.sample_rate = rp.sample_rate;\n\t\t\t\tpp.encoding    = rp.encoding;\n\t\t\t\tpp.channels    = rp.channels;\n\t\t\t\tpp.precision   = rp.precision;\n\t\t\t} else if (setmode == AUMODE_PLAY) {\n\t\t\t\trp.sample_rate = pp.sample_rate;\n\t\t\t\trp.encoding    = pp.encoding;\n\t\t\t\trp.channels    = pp.channels;\n\t\t\t\trp.precision   = pp.precision;\n\t\t\t}\n\t\t}\n\t\tsc->sc_rparams = rp;\n\t\tsc->sc_pparams = pp;\n\t}\n\n\toldpblksize = sc->sc_pr.blksize;\n\toldrblksize = sc->sc_rr.blksize;\n\t/* Play params can affect the record params, so recalculate blksize. */\n\tif (nr || np) {\n\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug > 1 && nr)\n\t    audio_print_params(\"After setting record params\", &sc->sc_rparams);\n\tif (audiodebug > 1 && np)\n\t    audio_print_params(\"After setting play params\", &sc->sc_pparams);\n#endif\n\n\tif (p->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_outports, p->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_inports, r->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (p->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, p->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, r->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\t\n\tif (p->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, gain, p->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, gain, r->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (ai->monitor_gain != ~0 &&\n\t    sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = ai->monitor_gain;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (p->pause != (u_char)~0) {\n\t\tsc->sc_pr.pause = p->pause;\n\t\tif (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartp(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\tif (r->pause != (u_char)~0) {\n\t\tsc->sc_rr.pause = r->pause;\n\t\tif (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartr(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (ai->blocksize != ~0) {\n\t\t/* Block size specified explicitly. */\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\tif (ai->blocksize == 0) {\n\t\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t\t\tsc->sc_blkset = 0;\n\t\t} else {\n\t\t\tint bs = ai->blocksize;\n\t\t\tif (hw->round_blocksize)\n\t\t\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\t\t\tsc->sc_pr.blksize = sc->sc_rr.blksize = bs;\n\t\t\tsc->sc_blkset = 1;\n\t\t}\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (sc->sc_mode & AUMODE_PLAY)\n\t\t\taudio_init_play(sc);\n\t\tif (sc->sc_mode & AUMODE_RECORD)\n\t\t\taudio_init_record(sc);\n\t}\n\n\tif (hw->commit_settings) {\n\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\tif (cleared) {\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) goto err;\n\t\tif (sc->sc_pr.blksize != oldpblksize ||\n\t\t    sc->sc_rr.blksize != oldrblksize)\n\t\t\taudio_calcwater(sc);\n\t\tif ((sc->sc_mode & AUMODE_PLAY) &&\n\t\t    pbus && !sc->sc_pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error && \n\t\t    (sc->sc_mode & AUMODE_RECORD) &&\n\t\t    rbus && !sc->sc_rbus)\n\t\t\terror = audiostartr(sc);\n\terr:\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t\n\t/* Change water marks after initializing the buffers. */\n\tif (ai->hiwat != ~0) {\n\t\tblks = ai->hiwat;\n\t\tif (blks > sc->sc_pr.maxblks)\n\t\t\tblks = sc->sc_pr.maxblks;\n\t\tif (blks < 2)\n\t\t\tblks = 2;\n\t\tsc->sc_pr.usedhigh = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->lowat != ~0) {\n\t\tblks = ai->lowat;\n\t\tif (blks > sc->sc_pr.maxblks - 1)\n\t\t\tblks = sc->sc_pr.maxblks - 1;\n\t\tsc->sc_pr.usedlow = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->hiwat != ~0 || ai->lowat != ~0) {\n\t\tif (sc->sc_pr.usedlow > sc->sc_pr.usedhigh - sc->sc_pr.blksize)\n\t\t\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh - sc->sc_pr.blksize;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "au_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2307-2332",
    "snippet": "int\nau_get_port(sc, ports)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n{\n\tmixer_ctrl_t ct;\n\tint i, aumask;\n\n\tif (ports->index == -1)\n\t\treturn 0;\n\tct.dev = ports->index;\n\tct.type = ports->isenum ? AUDIO_MIXER_ENUM : AUDIO_MIXER_SET;\n\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\treturn 0;\n\taumask = 0;\n\tif (ports->isenum) {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.ord == ports->misel[i])\n\t\t\t\taumask = ports->aumask[i];\n\t} else {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.mask & ports->misel[i])\n\t\t\t\taumask |= ports->aumask[i];\n\t}\n\treturn aumask;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_get_port(sc, ports)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n{\n\tmixer_ctrl_t ct;\n\tint i, aumask;\n\n\tif (ports->index == -1)\n\t\treturn 0;\n\tct.dev = ports->index;\n\tct.type = ports->isenum ? AUDIO_MIXER_ENUM : AUDIO_MIXER_SET;\n\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\treturn 0;\n\taumask = 0;\n\tif (ports->isenum) {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.ord == ports->misel[i])\n\t\t\t\taumask = ports->aumask[i];\n\t} else {\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ct.un.mask & ports->misel[i])\n\t\t\t\taumask |= ports->aumask[i];\n\t}\n\treturn aumask;\n}"
  },
  {
    "function_name": "au_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2265-2305",
    "snippet": "int\nau_set_port(sc, ports, port)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\tport;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\n\tif (port == 0 && ports->allports == 0)\n\t\treturn 0;\t/* allow this special case */\n\n\tif (ports->index == -1)\n\t\treturn EINVAL;\n\tct.dev = ports->index;\n\tif (ports->isenum) {\n\t\tif (port & (port-1))\n\t\t\treturn EINVAL; /* Only one port allowed */\n\t\tct.type = AUDIO_MIXER_ENUM;\n\t\terror = EINVAL;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] == port) {\n\t\t\t\tct.un.ord = ports->misel[i];\n\t\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t\t\t\tbreak;\n\t\t\t}\n\t} else {\n\t\tct.type = AUDIO_MIXER_SET;\n\t\tct.un.mask = 0;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] & port) \n\t\t\t\tct.un.mask |= ports->misel[i];\n\t\tif (port != 0 && ct.un.mask == 0)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mixer_signal",
          "args": [
            "sc"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2756-2764",
          "snippet": "static void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->hw_if->set_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->set_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_set_port(sc, ports, port)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\tport;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\n\tif (port == 0 && ports->allports == 0)\n\t\treturn 0;\t/* allow this special case */\n\n\tif (ports->index == -1)\n\t\treturn EINVAL;\n\tct.dev = ports->index;\n\tif (ports->isenum) {\n\t\tif (port & (port-1))\n\t\t\treturn EINVAL; /* Only one port allowed */\n\t\tct.type = AUDIO_MIXER_ENUM;\n\t\terror = EINVAL;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] == port) {\n\t\t\t\tct.un.ord = ports->misel[i];\n\t\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t\t\t\tbreak;\n\t\t\t}\n\t} else {\n\t\tct.type = AUDIO_MIXER_SET;\n\t\tct.un.mask = 0;\n\t\tfor(i = 0; i < ports->nports; i++)\n\t\t\tif (ports->aumask[i] & port) \n\t\t\t\tct.un.mask |= ports->misel[i];\n\t\tif (port != 0 && ct.un.mask == 0)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\terror = sc->hw_if->set_port(sc->hw_hdl, &ct);\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}"
  },
  {
    "function_name": "au_get_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2189-2263",
    "snippet": "void\nau_get_gain(sc, ports, pgain, pbalance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\t*pgain;\n\tu_char\t*pbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, l, r, n;\n\tint lgain = AUDIO_MAX_GAIN/2, rgain = AUDIO_MAX_GAIN/2;\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\tgoto bad;\n\t\tct.dev = ports->master;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tif (au_get_lr_value(sc, &ct, &lgain, &rgain))\n\t\t\tgoto bad;\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, \n\t\t\t\t\t\t\t    &lgain, &rgain))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tlgain = rgain = n = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & ct.un.mask) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, &l, &r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlgain += l;\n\t\t\t\t\t\trgain += r;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 0) {\n\t\t\t\tlgain /= n;\n\t\t\t\trgain /= n;\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tif (lgain == rgain) {\t/* handles lgain==rgain==0 */\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_MID_BALANCE;\n\t} else if (lgain < rgain) {\n\t\t*pgain = rgain;\n\t\t*pbalance = (AUDIO_MID_BALANCE * lgain) / rgain;\n\t} else /* lgain > rgain */ {\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_RIGHT_BALANCE -\n\t\t\t    (AUDIO_MID_BALANCE * rgain) / lgain;\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "au_get_lr_value",
          "args": [
            "sc",
            "&ct",
            "&l",
            "&r"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "au_get_lr_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2167-2187",
          "snippet": "int\nau_get_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint *l, *r;\n{\n\tint error;\n\n\tct->un.value.num_channels = 2;\n\tif (sc->hw_if->get_port(sc->hw_hdl, ct) == 0) {\n\t\t*l = ct->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t*r = ct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t} else {\n\t\tct->un.value.num_channels = 1;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, ct);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*r = *l = ct->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_get_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint *l, *r;\n{\n\tint error;\n\n\tct->un.value.num_channels = 2;\n\tif (sc->hw_if->get_port(sc->hw_hdl, ct) == 0) {\n\t\t*l = ct->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t*r = ct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t} else {\n\t\tct->un.value.num_channels = 1;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, ct);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*r = *l = ct->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\nau_get_gain(sc, ports, pgain, pbalance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tu_int\t*pgain;\n\tu_char\t*pbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, l, r, n;\n\tint lgain = AUDIO_MAX_GAIN/2, rgain = AUDIO_MAX_GAIN/2;\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\tgoto bad;\n\t\tct.dev = ports->master;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tif (au_get_lr_value(sc, &ct, &lgain, &rgain))\n\t\t\tgoto bad;\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, \n\t\t\t\t\t\t\t    &lgain, &rgain))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\t\tgoto bad;\n\t\t\tct.type = AUDIO_MIXER_VALUE;\n\t\t\tlgain = rgain = n = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & ct.un.mask) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_get_lr_value(sc, &ct, &l, &r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse {\n\t\t\t\t\t\tlgain += l;\n\t\t\t\t\t\trgain += r;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 0) {\n\t\t\t\tlgain /= n;\n\t\t\t\trgain /= n;\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tif (lgain == rgain) {\t/* handles lgain==rgain==0 */\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_MID_BALANCE;\n\t} else if (lgain < rgain) {\n\t\t*pgain = rgain;\n\t\t*pbalance = (AUDIO_MID_BALANCE * lgain) / rgain;\n\t} else /* lgain > rgain */ {\n\t\t*pgain = lgain;\n\t\t*pbalance = AUDIO_RIGHT_BALANCE -\n\t\t\t    (AUDIO_MID_BALANCE * rgain) / lgain;\n\t}\n}"
  },
  {
    "function_name": "au_get_lr_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2167-2187",
    "snippet": "int\nau_get_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint *l, *r;\n{\n\tint error;\n\n\tct->un.value.num_channels = 2;\n\tif (sc->hw_if->get_port(sc->hw_hdl, ct) == 0) {\n\t\t*l = ct->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t*r = ct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t} else {\n\t\tct->un.value.num_channels = 1;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, ct);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*r = *l = ct->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "ct"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "ct"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_get_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint *l, *r;\n{\n\tint error;\n\n\tct->un.value.num_channels = 2;\n\tif (sc->hw_if->get_port(sc->hw_hdl, ct) == 0) {\n\t\t*l = ct->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\t*r = ct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t} else {\n\t\tct->un.value.num_channels = 1;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, ct);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*r = *l = ct->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "au_set_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2094-2165",
    "snippet": "int\nau_set_gain(sc, ports, gain, balance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tint\tgain;\n\tint\tbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\tint l, r;\n\tu_int mask;\n\tint nset;\n\n\tif (balance == AUDIO_MID_BALANCE) {\n\t\tl = r = gain;\n\t} else if (balance < AUDIO_MID_BALANCE) {\n\t\tr = gain;\n\t\tl = (balance * gain) / AUDIO_MID_BALANCE;\n\t} else {\n\t\tl = gain;\n\t\tr = ((AUDIO_RIGHT_BALANCE - balance) * gain)\n\t\t    / AUDIO_MID_BALANCE;\n\t}\n\tDPRINTF((\"au_set_gain: gain=%d balance=%d, l=%d r=%d\\n\",\n\t\t gain, balance, l, r));\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\treturn 0; /* just ignore it silently */\n\t\tct.dev = ports->master;\n\t\terror = au_set_lr_value(sc, &ct, l, r);\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_set_lr_value(sc, &ct, l, r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmask = ct.un.mask;\n\t\t\tnset = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & mask) {\n\t\t\t\t    ct.dev = ports->miport[i];\n\t\t\t\t    if (ct.dev != -1 &&\n\t\t\t\t\tau_set_lr_value(sc, &ct, l, r) == 0)\n\t\t\t\t\t    nset++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nset == 0)\n\t\t\t\tgoto usemaster;\n\t\t}\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mixer_signal",
          "args": [
            "sc"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2756-2764",
          "snippet": "static void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic void\nmixer_signal(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct mixer_asyncs *m;\n\n\tfor(m = sc->sc_async_mixer; m; m = m->next)\n\t\tpsignal(m->proc, SIGIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "au_set_lr_value",
          "args": [
            "sc",
            "&ct",
            "l",
            "r"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "au_set_lr_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2077-2092",
          "snippet": "int\nau_set_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint l, r;\n{\n\tct->type = AUDIO_MIXER_VALUE;\n\tct->un.value.num_channels = 2;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\tif (sc->hw_if->set_port(sc->hw_hdl, ct) == 0)\n\t\treturn 0;\n\tct->un.value.num_channels = 1;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r)/2;\n\treturn sc->hw_if->set_port(sc->hw_hdl, ct);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_set_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint l, r;\n{\n\tct->type = AUDIO_MIXER_VALUE;\n\tct->un.value.num_channels = 2;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\tif (sc->hw_if->set_port(sc->hw_hdl, ct) == 0)\n\t\treturn 0;\n\tct->un.value.num_channels = 1;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r)/2;\n\treturn sc->hw_if->set_port(sc->hw_hdl, ct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->get_port",
          "args": [
            "sc->hw_hdl",
            "&ct"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"au_set_gain: gain=%d balance=%d, l=%d r=%d\\n\",\n\t\t gain, balance, l, r)"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_set_gain(sc, ports, gain, balance)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tint\tgain;\n\tint\tbalance;\n{\n\tmixer_ctrl_t ct;\n\tint i, error;\n\tint l, r;\n\tu_int mask;\n\tint nset;\n\n\tif (balance == AUDIO_MID_BALANCE) {\n\t\tl = r = gain;\n\t} else if (balance < AUDIO_MID_BALANCE) {\n\t\tr = gain;\n\t\tl = (balance * gain) / AUDIO_MID_BALANCE;\n\t} else {\n\t\tl = gain;\n\t\tr = ((AUDIO_RIGHT_BALANCE - balance) * gain)\n\t\t    / AUDIO_MID_BALANCE;\n\t}\n\tDPRINTF((\"au_set_gain: gain=%d balance=%d, l=%d r=%d\\n\",\n\t\t gain, balance, l, r));\n\n\tif (ports->index == -1) {\n\tusemaster:\n\t\tif (ports->master == -1)\n\t\t\treturn 0; /* just ignore it silently */\n\t\tct.dev = ports->master;\n\t\terror = au_set_lr_value(sc, &ct, l, r);\n\t} else {\n\t\tct.dev = ports->index;\n\t\tif (ports->isenum) {\n\t\t\tct.type = AUDIO_MIXER_ENUM;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] == ct.un.ord) {\n\t\t\t\t\tct.dev = ports->miport[i];\n\t\t\t\t\tif (ct.dev == -1 ||\n\t\t\t\t\t    au_set_lr_value(sc, &ct, l, r))\n\t\t\t\t\t\tgoto usemaster;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tct.type = AUDIO_MIXER_SET;\n\t\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmask = ct.un.mask;\n\t\t\tnset = 0;\n\t\t\tfor(i = 0; i < ports->nports; i++) {\n\t\t\t\tif (ports->misel[i] & mask) {\n\t\t\t\t    ct.dev = ports->miport[i];\n\t\t\t\t    if (ct.dev != -1 &&\n\t\t\t\t\tau_set_lr_value(sc, &ct, l, r) == 0)\n\t\t\t\t\t    nset++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nset == 0)\n\t\t\t\tgoto usemaster;\n\t\t}\n\t}\n\tif (!error)\n\t\tmixer_signal(sc);\n\treturn error;\n}"
  },
  {
    "function_name": "au_set_lr_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2077-2092",
    "snippet": "int\nau_set_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint l, r;\n{\n\tct->type = AUDIO_MIXER_VALUE;\n\tct->un.value.num_channels = 2;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\tif (sc->hw_if->set_port(sc->hw_hdl, ct) == 0)\n\t\treturn 0;\n\tct->un.value.num_channels = 1;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r)/2;\n\treturn sc->hw_if->set_port(sc->hw_hdl, ct);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->hw_if->set_port",
          "args": [
            "sc->hw_hdl",
            "ct"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->set_port",
          "args": [
            "sc->hw_hdl",
            "ct"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_set_lr_value(sc, ct, l, r)\n\tstruct\taudio_softc *sc;\n\tmixer_ctrl_t *ct;\n\tint l, r;\n{\n\tct->type = AUDIO_MIXER_VALUE;\n\tct->un.value.num_channels = 2;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\tif (sc->hw_if->set_port(sc->hw_hdl, ct) == 0)\n\t\treturn 0;\n\tct->un.value.num_channels = 1;\n\tct->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r)/2;\n\treturn sc->hw_if->set_port(sc->hw_hdl, ct);\n}"
  },
  {
    "function_name": "audio_check_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "2017-2075",
    "snippet": "int\naudio_check_params(p)\n\tstruct audio_params *p;\n{\n\tif (p->encoding == AUDIO_ENCODING_PCM16) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\tp->encoding = AUDIO_ENCODING_SLINEAR;\n\t} else if (p->encoding == AUDIO_ENCODING_PCM8) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\treturn EINVAL;\n\t}\n\n\tif (p->encoding == AUDIO_ENCODING_SLINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n#endif\n\tif (p->encoding == AUDIO_ENCODING_ULINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n#endif\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_ADPCM:\n\t\tif (p->precision != 8)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (p->precision != 8 && p->precision != 16)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tif (p->channels < 1 || p->channels > 8)\t/* sanity check # of channels */\n\t\treturn (EINVAL);\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_check_params(p)\n\tstruct audio_params *p;\n{\n\tif (p->encoding == AUDIO_ENCODING_PCM16) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\tp->encoding = AUDIO_ENCODING_SLINEAR;\n\t} else if (p->encoding == AUDIO_ENCODING_PCM8) {\n\t\tif (p->precision == 8)\n\t\t\tp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\telse\n\t\t\treturn EINVAL;\n\t}\n\n\tif (p->encoding == AUDIO_ENCODING_SLINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n#endif\n\tif (p->encoding == AUDIO_ENCODING_ULINEAR)\n#if BYTE_ORDER == LITTLE_ENDIAN\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n#else\n\t\tp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n#endif\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_ADPCM:\n\t\tif (p->precision != 8)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (p->precision != 8 && p->precision != 16)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tif (p->channels < 1 || p->channels > 8)\t/* sanity check # of channels */\n\t\treturn (EINVAL);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "audio_rint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1929-2015",
    "snippet": "void\naudio_rint(v)\n\tvoid *v;\n{\n\tstruct audio_softc *sc = v;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb = &sc->sc_rr;\n\tint blksize;\n\tint error;\n\n        if (!sc->sc_open)\n        \treturn;         /* ignore interrupt if not open */\n\n\tadd_audio_randomness(cb);\n\n\tblksize = cb->blksize;\n\n\tcb->inp += blksize;\n\tif (cb->inp >= cb->end)\n\t\tcb->inp = cb->start;\n\tcb->stamp += blksize;\n\tif (cb->mmapped) {\n\t\tDPRINTFN(2, (\"audio_rint: mmapped inp=%p cc=%d\\n\", \n                             cb->inp, blksize));\n\t\tif (!hw->trigger_input)\n\t\t\t(void)hw->start_input(sc->hw_hdl, cb->inp, blksize,\n\t\t\t    audio_rint, (void *)sc);\n\t\treturn;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n\t{\n\t\tstruct timeval tv;\n\t\tu_long t;\n\t\tmicrotime(&tv);\n\t\tt = tv.tv_usec + 1000000 * tv.tv_sec;\n\t\tif (sc->sc_rnintr) {\n\t\t\tlong lastdelta, totdelta;\n\t\t\tlastdelta = t - sc->sc_rlastintr - sc->sc_rblktime;\n\t\t\tif (lastdelta > sc->sc_rblktime / 5) {\n\t\t\t\tprintf(\"audio: record interrupt(%d) off relative by %ld us (%lu)\\n\", \n\t\t\t\t       sc->sc_rnintr, lastdelta, sc->sc_rblktime);\n\t\t\t}\n\t\t\ttotdelta = t - sc->sc_rfirstintr - sc->sc_rblktime * sc->sc_rnintr;\n\t\t\tif (totdelta > sc->sc_rblktime / 2) {\n\t\t\t\tsc->sc_rnintr++;\n\t\t\t\tprintf(\"audio: record interrupt(%d) off absolute by %ld us (%lu)\\n\", \n\t\t\t\t       sc->sc_rnintr, totdelta, sc->sc_rblktime);\n\t\t\t\tsc->sc_rnintr++; /* avoid repeated messages */\n\t\t\t}\n\t\t} else\n\t\t\tsc->sc_rfirstintr = t;\n\t\tsc->sc_rlastintr = t;\n\t\tsc->sc_rnintr++;\n\t}\n#endif\n\n\tcb->used += blksize;\n\tif (cb->pause) {\n\t\tDPRINTFN(1, (\"audio_rint: pdrops %lu\\n\", cb->pdrops));\n\t\tcb->pdrops += blksize;\n\t\tcb->outp += blksize;\n\t\tcb->used -= blksize;\n\t} else if (cb->used + blksize >= cb->usedhigh && !cb->copying) {\n\t\tDPRINTFN(1, (\"audio_rint: drops %lu\\n\", cb->drops));\n\t\tcb->drops += blksize;\n\t\tcb->outp += blksize;\n\t\tcb->used -= blksize;\n\t}\n\n\tDPRINTFN(2, (\"audio_rint: inp=%p cc=%d used=%d\\n\", \n                     cb->inp, blksize, cb->used));\n\tif (!hw->trigger_input) {\n\t\terror = hw->start_input(sc->hw_hdl, cb->inp, blksize,\n\t\t    audio_rint, (void *)sc);\n\t\tif (error) {\n\t\t\t/* XXX does this really help? */\n\t\t\tDPRINTF((\"audio_rint: restart failed: %d\\n\", error));\n\t\t\taudio_clear(sc);\n\t\t}\n\t}\n\n\taudio_wakeup(&sc->sc_rchan);\n\tselwakeup(&sc->sc_rsel);\n\tif (sc->sc_async_audio)\n\t\tpsignal(sc->sc_async_audio, SIGIO);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sc->sc_async_audio",
            "SIGIO"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&sc->sc_rsel"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_wakeup",
          "args": [
            "&sc->sc_rchan"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_clear",
          "args": [
            "sc"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "audio_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1139-1156",
          "snippet": "void\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_rint: restart failed: %d\\n\", error)"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->start_input",
          "args": [
            "sc->hw_hdl",
            "cb->inp",
            "blksize",
            "audio_rint",
            "(void *)sc"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"audio_rint: inp=%p cc=%d used=%d\\n\", \n                     cb->inp, blksize, cb->used)"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_rint: drops %lu\\n\", cb->drops)"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_rint: pdrops %lu\\n\", cb->pdrops)"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio: record interrupt(%d) off absolute by %ld us (%lu)\\n\"",
            "sc->sc_rnintr",
            "totdelta",
            "sc->sc_rblktime"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&tv"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->start_input",
          "args": [
            "sc->hw_hdl",
            "cb->inp",
            "blksize",
            "audio_rint",
            "(void *)sc"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"audio_rint: mmapped inp=%p cc=%d\\n\", \n                             cb->inp, blksize)"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_audio_randomness",
          "args": [
            "cb"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_rint(v)\n\tvoid *v;\n{\n\tstruct audio_softc *sc = v;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb = &sc->sc_rr;\n\tint blksize;\n\tint error;\n\n        if (!sc->sc_open)\n        \treturn;         /* ignore interrupt if not open */\n\n\tadd_audio_randomness(cb);\n\n\tblksize = cb->blksize;\n\n\tcb->inp += blksize;\n\tif (cb->inp >= cb->end)\n\t\tcb->inp = cb->start;\n\tcb->stamp += blksize;\n\tif (cb->mmapped) {\n\t\tDPRINTFN(2, (\"audio_rint: mmapped inp=%p cc=%d\\n\", \n                             cb->inp, blksize));\n\t\tif (!hw->trigger_input)\n\t\t\t(void)hw->start_input(sc->hw_hdl, cb->inp, blksize,\n\t\t\t    audio_rint, (void *)sc);\n\t\treturn;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n\t{\n\t\tstruct timeval tv;\n\t\tu_long t;\n\t\tmicrotime(&tv);\n\t\tt = tv.tv_usec + 1000000 * tv.tv_sec;\n\t\tif (sc->sc_rnintr) {\n\t\t\tlong lastdelta, totdelta;\n\t\t\tlastdelta = t - sc->sc_rlastintr - sc->sc_rblktime;\n\t\t\tif (lastdelta > sc->sc_rblktime / 5) {\n\t\t\t\tprintf(\"audio: record interrupt(%d) off relative by %ld us (%lu)\\n\", \n\t\t\t\t       sc->sc_rnintr, lastdelta, sc->sc_rblktime);\n\t\t\t}\n\t\t\ttotdelta = t - sc->sc_rfirstintr - sc->sc_rblktime * sc->sc_rnintr;\n\t\t\tif (totdelta > sc->sc_rblktime / 2) {\n\t\t\t\tsc->sc_rnintr++;\n\t\t\t\tprintf(\"audio: record interrupt(%d) off absolute by %ld us (%lu)\\n\", \n\t\t\t\t       sc->sc_rnintr, totdelta, sc->sc_rblktime);\n\t\t\t\tsc->sc_rnintr++; /* avoid repeated messages */\n\t\t\t}\n\t\t} else\n\t\t\tsc->sc_rfirstintr = t;\n\t\tsc->sc_rlastintr = t;\n\t\tsc->sc_rnintr++;\n\t}\n#endif\n\n\tcb->used += blksize;\n\tif (cb->pause) {\n\t\tDPRINTFN(1, (\"audio_rint: pdrops %lu\\n\", cb->pdrops));\n\t\tcb->pdrops += blksize;\n\t\tcb->outp += blksize;\n\t\tcb->used -= blksize;\n\t} else if (cb->used + blksize >= cb->usedhigh && !cb->copying) {\n\t\tDPRINTFN(1, (\"audio_rint: drops %lu\\n\", cb->drops));\n\t\tcb->drops += blksize;\n\t\tcb->outp += blksize;\n\t\tcb->used -= blksize;\n\t}\n\n\tDPRINTFN(2, (\"audio_rint: inp=%p cc=%d used=%d\\n\", \n                     cb->inp, blksize, cb->used));\n\tif (!hw->trigger_input) {\n\t\terror = hw->start_input(sc->hw_hdl, cb->inp, blksize,\n\t\t    audio_rint, (void *)sc);\n\t\tif (error) {\n\t\t\t/* XXX does this really help? */\n\t\t\tDPRINTF((\"audio_rint: restart failed: %d\\n\", error));\n\t\t\taudio_clear(sc);\n\t\t}\n\t}\n\n\taudio_wakeup(&sc->sc_rchan);\n\tselwakeup(&sc->sc_rsel);\n\tif (sc->sc_async_audio)\n\t\tpsignal(sc->sc_async_audio, SIGIO);\n}"
  },
  {
    "function_name": "audio_pint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1802-1922",
    "snippet": "void\naudio_pint(v)\n\tvoid *v;\n{\n\tstruct audio_softc *sc = v;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tu_char *inp;\n\tint cc, ccr;\n\tint blksize;\n\tint error;\n\n        if (!sc->sc_open)\n        \treturn;         /* ignore interrupt if not open */\n\n\tblksize = cb->blksize;\n\n\tadd_audio_randomness(cb);\n\n\tcb->outp += blksize;\n\tif (cb->outp >= cb->end)\n\t\tcb->outp = cb->start;\n\tcb->stamp += blksize / sc->sc_pparams.factor;\n\tif (cb->mmapped) {\n\t\tDPRINTFN(5, (\"audio_pint: mmapped outp=%p cc=%d inp=%p\\n\", \n                             cb->outp, blksize, cb->inp));\n\t\tif (!hw->trigger_output)\n\t\t\t(void)hw->start_output(sc->hw_hdl, cb->outp,\n\t\t\t    blksize, audio_pint, (void *)sc);\n\t\treturn;\n\t}\n\t\t\n#ifdef AUDIO_INTR_TIME\n\t{\n\t\tstruct timeval tv;\n\t\tu_long t;\n\t\tmicrotime(&tv);\n\t\tt = tv.tv_usec + 1000000 * tv.tv_sec;\n\t\tif (sc->sc_pnintr) {\n\t\t\tlong lastdelta, totdelta;\n\t\t\tlastdelta = t - sc->sc_plastintr - sc->sc_pblktime;\n\t\t\tif (lastdelta > sc->sc_pblktime / 3) {\n\t\t\t\tprintf(\"audio: play interrupt(%d) off relative by %ld us (%lu)\\n\", \n\t\t\t\t       sc->sc_pnintr, lastdelta, sc->sc_pblktime);\n\t\t\t}\n\t\t\ttotdelta = t - sc->sc_pfirstintr - sc->sc_pblktime * sc->sc_pnintr;\n\t\t\tif (totdelta > sc->sc_pblktime) {\n\t\t\t\tprintf(\"audio: play interrupt(%d) off absolute by %ld us (%lu) (LOST)\\n\", \n\t\t\t\t       sc->sc_pnintr, totdelta, sc->sc_pblktime);\n\t\t\t\tsc->sc_pnintr++; /* avoid repeated messages */\n\t\t\t}\n\t\t} else\n\t\t\tsc->sc_pfirstintr = t;\n\t\tsc->sc_plastintr = t;\n\t\tsc->sc_pnintr++;\n\t}\n#endif\n\n\tcb->used -= blksize;\n\tif (cb->used < blksize) {\n\t\t/* we don't have a full block to use */\n\t\tif (cb->copying) {\n\t\t\t/* writer is in progress, don't disturb */\n\t\t\tcb->needfill = 1;\n\t\t\tDPRINTFN(1, (\"audio_pint: copying in progress\\n\"));\n\t\t} else {\n\t\t\tinp = cb->inp;\n\t\t\tcc = blksize - (inp - cb->start) % blksize;\n\t\t\tccr = cc / sc->sc_pparams.factor;\n\t\t\tif (cb->pause)\n\t\t\t\tcb->pdrops += ccr;\n\t\t\telse {\n\t\t\t\tcb->drops += ccr;\n\t\t\t\tsc->sc_playdrop += ccr;\n\t\t\t}\n\t\t\taudio_pint_silence(sc, cb, inp, cc);\n\t\t\tinp += cc;\n\t\t\tif (inp >= cb->end)\n\t\t\t\tinp = cb->start;\n\t\t\tcb->inp = inp;\n\t\t\tcb->used += cc;\n\n\t\t\t/* Clear next block so we keep ahead of the DMA. */\n\t\t\tif (cb->used + cc < cb->usedhigh)\n\t\t\t\taudio_pint_silence(sc, cb, inp, blksize);\n\t\t}\n\t}\n\n\tDPRINTFN(5, (\"audio_pint: outp=%p cc=%d\\n\", cb->outp, blksize));\n\tif (!hw->trigger_output) {\n\t\terror = hw->start_output(sc->hw_hdl, cb->outp, blksize,\n\t\t    audio_pint, (void *)sc);\n\t\tif (error) {\n\t\t\t/* XXX does this really help? */\n\t\t\tDPRINTF((\"audio_pint restart failed: %d\\n\", error));\n\t\t\taudio_clear(sc);\n\t\t}\n\t}\n\n\tDPRINTFN(2, (\"audio_pint: mode=%d pause=%d used=%d lowat=%d\\n\",\n                     sc->sc_mode, cb->pause, cb->used, cb->usedlow));\n\tif ((sc->sc_mode & AUMODE_PLAY) && !cb->pause) {\n\t\tif (cb->used <= cb->usedlow) {\n\t\t\taudio_wakeup(&sc->sc_wchan);\n\t\t\tselwakeup(&sc->sc_wsel);\n\t\t\tif (sc->sc_async_audio) {\n\t\t\t\tDPRINTFN(3, (\"audio_pint: sending SIGIO %p\\n\", \n                                             sc->sc_async_audio));\n\t\t\t\tpsignal(sc->sc_async_audio, SIGIO);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Possible to return one or more \"phantom blocks\" now. */\n\tif (!sc->sc_full_duplex && sc->sc_rchan) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tselwakeup(&sc->sc_rsel);\n\t\tif (sc->sc_async_audio)\n\t\t\tpsignal(sc->sc_async_audio, SIGIO);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sc->sc_async_audio",
            "SIGIO"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&sc->sc_rsel"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_wakeup",
          "args": [
            "&sc->sc_rchan"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sc->sc_async_audio",
            "SIGIO"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"audio_pint: sending SIGIO %p\\n\", \n                                             sc->sc_async_audio)"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&sc->sc_wsel"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"audio_pint: mode=%d pause=%d used=%d lowat=%d\\n\",\n                     sc->sc_mode, cb->pause, cb->used, cb->usedlow)"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_clear",
          "args": [
            "sc"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "audio_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1139-1156",
          "snippet": "void\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_pint restart failed: %d\\n\", error)"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->start_output",
          "args": [
            "sc->hw_hdl",
            "cb->outp",
            "blksize",
            "audio_pint",
            "(void *)sc"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"audio_pint: outp=%p cc=%d\\n\", cb->outp, blksize)"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_pint_silence",
          "args": [
            "sc",
            "cb",
            "inp",
            "blksize"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "audio_pint_silence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1759-1794",
          "snippet": "static __inline void\naudio_pint_silence(sc, cb, inp, cc)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *cb;\n\tu_char *inp;\n\tint cc;\n{\n\tu_char *s, *e, *p, *q;\n\n\tif (sc->sc_sil_count > 0) {\n\t\ts = sc->sc_sil_start; /* start of silence */\n\t\te = s + sc->sc_sil_count; /* end of silence, may be beyond end */\n\t\tp = inp;\t/* adjusted pointer to area to fill */\n\t\tif (p < s)\n\t\t\tp += cb->end - cb->start;\n\t\tq = p+cc;\n\t\t/* Check if there is already silence. */\n\t\tif (!(s <= p && p <  e &&\n\t\t      s <= q && q <= e)) {\n\t\t\tif (s <= p)\n\t\t\t\tsc->sc_sil_count = max(sc->sc_sil_count, q-s);\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\\n\", \n                                    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));\n\t\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\t} else {\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: already silent cc=%d inp=%p\\n\", cc, inp));\n\t\t\t\n\t\t}\n\t} else {\n\t\tsc->sc_sil_start = inp;\n\t\tsc->sc_sil_count = cc;\n\t\tDPRINTFN(5, (\"audio_pint_silence: start fill %p %d\\n\", \n                             inp, cc));\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_pint_silence(sc, cb, inp, cc)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *cb;\n\tu_char *inp;\n\tint cc;\n{\n\tu_char *s, *e, *p, *q;\n\n\tif (sc->sc_sil_count > 0) {\n\t\ts = sc->sc_sil_start; /* start of silence */\n\t\te = s + sc->sc_sil_count; /* end of silence, may be beyond end */\n\t\tp = inp;\t/* adjusted pointer to area to fill */\n\t\tif (p < s)\n\t\t\tp += cb->end - cb->start;\n\t\tq = p+cc;\n\t\t/* Check if there is already silence. */\n\t\tif (!(s <= p && p <  e &&\n\t\t      s <= q && q <= e)) {\n\t\t\tif (s <= p)\n\t\t\t\tsc->sc_sil_count = max(sc->sc_sil_count, q-s);\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\\n\", \n                                    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));\n\t\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\t} else {\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: already silent cc=%d inp=%p\\n\", cc, inp));\n\t\t\t\n\t\t}\n\t} else {\n\t\tsc->sc_sil_start = inp;\n\t\tsc->sc_sil_count = cc;\n\t\tDPRINTFN(5, (\"audio_pint_silence: start fill %p %d\\n\", \n                             inp, cc));\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_pint: copying in progress\\n\")"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio: play interrupt(%d) off absolute by %ld us (%lu) (LOST)\\n\"",
            "sc->sc_pnintr",
            "totdelta",
            "sc->sc_pblktime"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&tv"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->start_output",
          "args": [
            "sc->hw_hdl",
            "cb->outp",
            "blksize",
            "audio_pint",
            "(void *)sc"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"audio_pint: mmapped outp=%p cc=%d inp=%p\\n\", \n                             cb->outp, blksize, cb->inp)"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_audio_randomness",
          "args": [
            "cb"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_pint(v)\n\tvoid *v;\n{\n\tstruct audio_softc *sc = v;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tu_char *inp;\n\tint cc, ccr;\n\tint blksize;\n\tint error;\n\n        if (!sc->sc_open)\n        \treturn;         /* ignore interrupt if not open */\n\n\tblksize = cb->blksize;\n\n\tadd_audio_randomness(cb);\n\n\tcb->outp += blksize;\n\tif (cb->outp >= cb->end)\n\t\tcb->outp = cb->start;\n\tcb->stamp += blksize / sc->sc_pparams.factor;\n\tif (cb->mmapped) {\n\t\tDPRINTFN(5, (\"audio_pint: mmapped outp=%p cc=%d inp=%p\\n\", \n                             cb->outp, blksize, cb->inp));\n\t\tif (!hw->trigger_output)\n\t\t\t(void)hw->start_output(sc->hw_hdl, cb->outp,\n\t\t\t    blksize, audio_pint, (void *)sc);\n\t\treturn;\n\t}\n\t\t\n#ifdef AUDIO_INTR_TIME\n\t{\n\t\tstruct timeval tv;\n\t\tu_long t;\n\t\tmicrotime(&tv);\n\t\tt = tv.tv_usec + 1000000 * tv.tv_sec;\n\t\tif (sc->sc_pnintr) {\n\t\t\tlong lastdelta, totdelta;\n\t\t\tlastdelta = t - sc->sc_plastintr - sc->sc_pblktime;\n\t\t\tif (lastdelta > sc->sc_pblktime / 3) {\n\t\t\t\tprintf(\"audio: play interrupt(%d) off relative by %ld us (%lu)\\n\", \n\t\t\t\t       sc->sc_pnintr, lastdelta, sc->sc_pblktime);\n\t\t\t}\n\t\t\ttotdelta = t - sc->sc_pfirstintr - sc->sc_pblktime * sc->sc_pnintr;\n\t\t\tif (totdelta > sc->sc_pblktime) {\n\t\t\t\tprintf(\"audio: play interrupt(%d) off absolute by %ld us (%lu) (LOST)\\n\", \n\t\t\t\t       sc->sc_pnintr, totdelta, sc->sc_pblktime);\n\t\t\t\tsc->sc_pnintr++; /* avoid repeated messages */\n\t\t\t}\n\t\t} else\n\t\t\tsc->sc_pfirstintr = t;\n\t\tsc->sc_plastintr = t;\n\t\tsc->sc_pnintr++;\n\t}\n#endif\n\n\tcb->used -= blksize;\n\tif (cb->used < blksize) {\n\t\t/* we don't have a full block to use */\n\t\tif (cb->copying) {\n\t\t\t/* writer is in progress, don't disturb */\n\t\t\tcb->needfill = 1;\n\t\t\tDPRINTFN(1, (\"audio_pint: copying in progress\\n\"));\n\t\t} else {\n\t\t\tinp = cb->inp;\n\t\t\tcc = blksize - (inp - cb->start) % blksize;\n\t\t\tccr = cc / sc->sc_pparams.factor;\n\t\t\tif (cb->pause)\n\t\t\t\tcb->pdrops += ccr;\n\t\t\telse {\n\t\t\t\tcb->drops += ccr;\n\t\t\t\tsc->sc_playdrop += ccr;\n\t\t\t}\n\t\t\taudio_pint_silence(sc, cb, inp, cc);\n\t\t\tinp += cc;\n\t\t\tif (inp >= cb->end)\n\t\t\t\tinp = cb->start;\n\t\t\tcb->inp = inp;\n\t\t\tcb->used += cc;\n\n\t\t\t/* Clear next block so we keep ahead of the DMA. */\n\t\t\tif (cb->used + cc < cb->usedhigh)\n\t\t\t\taudio_pint_silence(sc, cb, inp, blksize);\n\t\t}\n\t}\n\n\tDPRINTFN(5, (\"audio_pint: outp=%p cc=%d\\n\", cb->outp, blksize));\n\tif (!hw->trigger_output) {\n\t\terror = hw->start_output(sc->hw_hdl, cb->outp, blksize,\n\t\t    audio_pint, (void *)sc);\n\t\tif (error) {\n\t\t\t/* XXX does this really help? */\n\t\t\tDPRINTF((\"audio_pint restart failed: %d\\n\", error));\n\t\t\taudio_clear(sc);\n\t\t}\n\t}\n\n\tDPRINTFN(2, (\"audio_pint: mode=%d pause=%d used=%d lowat=%d\\n\",\n                     sc->sc_mode, cb->pause, cb->used, cb->usedlow));\n\tif ((sc->sc_mode & AUMODE_PLAY) && !cb->pause) {\n\t\tif (cb->used <= cb->usedlow) {\n\t\t\taudio_wakeup(&sc->sc_wchan);\n\t\t\tselwakeup(&sc->sc_wsel);\n\t\t\tif (sc->sc_async_audio) {\n\t\t\t\tDPRINTFN(3, (\"audio_pint: sending SIGIO %p\\n\", \n                                             sc->sc_async_audio));\n\t\t\t\tpsignal(sc->sc_async_audio, SIGIO);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Possible to return one or more \"phantom blocks\" now. */\n\tif (!sc->sc_full_duplex && sc->sc_rchan) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tselwakeup(&sc->sc_rsel);\n\t\tif (sc->sc_async_audio)\n\t\t\tpsignal(sc->sc_async_audio, SIGIO);\n\t}\n}"
  },
  {
    "function_name": "audio_pint_silence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1759-1794",
    "snippet": "static __inline void\naudio_pint_silence(sc, cb, inp, cc)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *cb;\n\tu_char *inp;\n\tint cc;\n{\n\tu_char *s, *e, *p, *q;\n\n\tif (sc->sc_sil_count > 0) {\n\t\ts = sc->sc_sil_start; /* start of silence */\n\t\te = s + sc->sc_sil_count; /* end of silence, may be beyond end */\n\t\tp = inp;\t/* adjusted pointer to area to fill */\n\t\tif (p < s)\n\t\t\tp += cb->end - cb->start;\n\t\tq = p+cc;\n\t\t/* Check if there is already silence. */\n\t\tif (!(s <= p && p <  e &&\n\t\t      s <= q && q <= e)) {\n\t\t\tif (s <= p)\n\t\t\t\tsc->sc_sil_count = max(sc->sc_sil_count, q-s);\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\\n\", \n                                    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));\n\t\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\t} else {\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: already silent cc=%d inp=%p\\n\", cc, inp));\n\t\t\t\n\t\t}\n\t} else {\n\t\tsc->sc_sil_start = inp;\n\t\tsc->sc_sil_count = cc;\n\t\tDPRINTFN(5, (\"audio_pint_silence: start fill %p %d\\n\", \n                             inp, cc));\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_fill_silence",
          "args": [
            "&sc->sc_pparams",
            "inp",
            "cc"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "audio_fill_silence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1191-1247",
          "snippet": "void\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"audio_pint_silence: start fill %p %d\\n\", \n                             inp, cc)"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"audio_pint_silence: already silent cc=%d inp=%p\\n\", cc, inp)"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\\n\", \n                                    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start))"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "sc->sc_sil_count",
            "q-s"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_pint_silence(sc, cb, inp, cc)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *cb;\n\tu_char *inp;\n\tint cc;\n{\n\tu_char *s, *e, *p, *q;\n\n\tif (sc->sc_sil_count > 0) {\n\t\ts = sc->sc_sil_start; /* start of silence */\n\t\te = s + sc->sc_sil_count; /* end of silence, may be beyond end */\n\t\tp = inp;\t/* adjusted pointer to area to fill */\n\t\tif (p < s)\n\t\t\tp += cb->end - cb->start;\n\t\tq = p+cc;\n\t\t/* Check if there is already silence. */\n\t\tif (!(s <= p && p <  e &&\n\t\t      s <= q && q <= e)) {\n\t\t\tif (s <= p)\n\t\t\t\tsc->sc_sil_count = max(sc->sc_sil_count, q-s);\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\\n\", \n                                    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));\n\t\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\t} else {\n\t\t\tDPRINTFN(5, (\"audio_pint_silence: already silent cc=%d inp=%p\\n\", cc, inp));\n\t\t\t\n\t\t}\n\t} else {\n\t\tsc->sc_sil_start = inp;\n\t\tsc->sc_sil_count = cc;\n\t\tDPRINTFN(5, (\"audio_pint_silence: start fill %p %d\\n\", \n                             inp, cc));\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t}\n}"
  },
  {
    "function_name": "audiostartp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1717-1743",
    "snippet": "int\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audiostartp failed: %d\\n\", error)"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->start_output",
          "args": [
            "sc->hw_hdl",
            "sc->sc_pr.outp",
            "sc->sc_pr.blksize",
            "audio_pint",
            "(void *)sc"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->trigger_output",
          "args": [
            "sc->hw_hdl",
            "sc->sc_pr.start",
            "sc->sc_pr.end",
            "sc->sc_pr.blksize",
            "audio_pint",
            "(void *)sc",
            "&sc->sc_pparams"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped)"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "audiostartr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1692-1715",
    "snippet": "int\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audiostartr failed: %d\\n\", error)"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->start_input",
          "args": [
            "sc->hw_hdl",
            "sc->sc_rr.start",
            "sc->sc_rr.blksize",
            "audio_rint",
            "(void *)sc"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->trigger_input",
          "args": [
            "sc->hw_hdl",
            "sc->sc_rr.start",
            "sc->sc_rr.end",
            "sc->sc_rr.blksize",
            "audio_rint",
            "(void *)sc",
            "&sc->sc_rparams"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped)"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "audio_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1632-1690",
    "snippet": "int\naudio_mmap(dev, off, prot)\n\tdev_t dev;\n\tint off, prot;\n{\n\tint s;\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb;\n\n\tDPRINTF((\"audio_mmap: off=%d, prot=%d\\n\", off, prot));\n\n\tif (!(hw->get_props(sc->hw_hdl) & AUDIO_PROP_MMAP) || !hw->mappage)\n\t\treturn -1;\n#if 0\n/* XXX\n * The idea here was to use the protection to determine if\n * we are mapping the read or write buffer, but it fails.\n * The VM system is broken in (at least) two ways.\n * 1) If you map memory VM_PROT_WRITE you SIGSEGV\n *    when writing to it, so VM_PROT_READ|VM_PROT_WRITE\n *    has to be used for mmapping the play buffer.\n * 2) Even if calling mmap() with VM_PROT_READ|VM_PROT_WRITE\n *    audio_mmap will get called at some point with VM_PROT_READ\n *    only.\n * So, alas, we always map the play buffer for now.\n */\n\tif (prot == (VM_PROT_READ|VM_PROT_WRITE) ||\n\t    prot == VM_PROT_WRITE)\n\t\tcb = &sc->sc_pr;\n\telse if (prot == VM_PROT_READ)\n\t\tcb = &sc->sc_rr;\n\telse\n\t\treturn -1;\n#else\n\tcb = &sc->sc_pr;\n#endif\n\n\tif ((u_int)off >= cb->bufsize)\n\t\treturn -1;\n\tif (!cb->mmapped) {\n\t\tcb->mmapped = 1;\n\t\tif (cb == &sc->sc_pr) {\n\t\t\taudio_fill_silence(&sc->sc_pparams, cb->start, cb->bufsize);\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_pbus)\n\t\t\t\t(void)audiostartp(sc);\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_rbus)\n\t\t\t\t(void)audiostartr(sc);\n\t\t\tsplx(s);\n\t\t}\n\t}\n\n\treturn hw->mappage(sc->hw_hdl, cb->start, off, prot);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw->mappage",
          "args": [
            "sc->hw_hdl",
            "cb->start",
            "off",
            "prot"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiostartr",
          "args": [
            "sc"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1692-1715",
          "snippet": "int\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiostartp",
          "args": [
            "sc"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1717-1743",
          "snippet": "int\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_fill_silence",
          "args": [
            "&sc->sc_pparams",
            "cb->start",
            "cb->bufsize"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "audio_fill_silence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1191-1247",
          "snippet": "void\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw->get_props",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_mmap: off=%d, prot=%d\\n\", off, prot)"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_mmap(dev, off, prot)\n\tdev_t dev;\n\tint off, prot;\n{\n\tint s;\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb;\n\n\tDPRINTF((\"audio_mmap: off=%d, prot=%d\\n\", off, prot));\n\n\tif (!(hw->get_props(sc->hw_hdl) & AUDIO_PROP_MMAP) || !hw->mappage)\n\t\treturn -1;\n#if 0\n/* XXX\n * The idea here was to use the protection to determine if\n * we are mapping the read or write buffer, but it fails.\n * The VM system is broken in (at least) two ways.\n * 1) If you map memory VM_PROT_WRITE you SIGSEGV\n *    when writing to it, so VM_PROT_READ|VM_PROT_WRITE\n *    has to be used for mmapping the play buffer.\n * 2) Even if calling mmap() with VM_PROT_READ|VM_PROT_WRITE\n *    audio_mmap will get called at some point with VM_PROT_READ\n *    only.\n * So, alas, we always map the play buffer for now.\n */\n\tif (prot == (VM_PROT_READ|VM_PROT_WRITE) ||\n\t    prot == VM_PROT_WRITE)\n\t\tcb = &sc->sc_pr;\n\telse if (prot == VM_PROT_READ)\n\t\tcb = &sc->sc_rr;\n\telse\n\t\treturn -1;\n#else\n\tcb = &sc->sc_pr;\n#endif\n\n\tif ((u_int)off >= cb->bufsize)\n\t\treturn -1;\n\tif (!cb->mmapped) {\n\t\tcb->mmapped = 1;\n\t\tif (cb == &sc->sc_pr) {\n\t\t\taudio_fill_silence(&sc->sc_pparams, cb->start, cb->bufsize);\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_pbus)\n\t\t\t\t(void)audiostartp(sc);\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_rbus)\n\t\t\t\t(void)audiostartr(sc);\n\t\t\tsplx(s);\n\t\t}\n\t}\n\n\treturn hw->mappage(sc->hw_hdl, cb->start, off, prot);\n}"
  },
  {
    "function_name": "audio_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1595-1630",
    "snippet": "int\naudio_select(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tint s = splaudio();\n\n\tDPRINTF((\"audio_select: rw=0x%x mode=%d\\n\", rw, sc->sc_mode));\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\tif ((sc->sc_mode & AUMODE_PLAY) ?\n\t\t    sc->sc_pr.stamp > sc->sc_wstamp : \n\t\t    sc->sc_rr.used > sc->sc_rr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_rsel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tif (sc->sc_mode & AUMODE_RECORD ||\n\t\t    sc->sc_pr.used <= sc->sc_pr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_wsel);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&sc->sc_wsel"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&sc->sc_rsel"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_select: rw=0x%x mode=%d\\n\", rw, sc->sc_mode)"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_select(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tint s = splaudio();\n\n\tDPRINTF((\"audio_select: rw=0x%x mode=%d\\n\", rw, sc->sc_mode));\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\tif ((sc->sc_mode & AUMODE_PLAY) ?\n\t\t    sc->sc_pr.stamp > sc->sc_wstamp : \n\t\t    sc->sc_rr.used > sc->sc_rr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_rsel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tif (sc->sc_mode & AUMODE_RECORD ||\n\t\t    sc->sc_pr.used <= sc->sc_pr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_wsel);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "audio_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1429-1593",
    "snippet": "int\naudio_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_offset *ao;\n\tint error = 0, s, offs, fd;\n        int rbus, pbus;\n\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d)\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async_audio)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async_audio = p;\n\t\t\tDPRINTF((\"audio_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async_audio = 0;\n\t\tbreak;\n\n\tcase AUDIO_FLUSH:\n\t\tDPRINTF((\"AUDIO_FLUSH\\n\"));\n                rbus = sc->sc_rbus;\n                pbus = sc->sc_pbus;\n\t\taudio_clear(sc);\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn error;\n\t\t}\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_pbus && pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error &&\n\t\t    (sc->sc_mode & AUMODE_RECORD) && !sc->sc_rbus && rbus)\n\t\t\terror = audiostartr(sc);\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * Number of read (write) samples dropped.  We don't know where or\n\t * when they were dropped.\n\t */\n\tcase AUDIO_RERROR:\n\t\t*(int *)addr = sc->sc_rr.drops;\n\t\tbreak;\n\n\tcase AUDIO_PERROR:\n\t\t*(int *)addr = sc->sc_pr.drops;\n\t\tbreak;\n\n\t/*\n\t * Offsets into buffer.\n\t */\n\tcase AUDIO_GETIOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\tao->samples = sc->sc_rr.stamp;\n\t\tao->deltablks = (sc->sc_rr.stamp - sc->sc_rr.stamp_last) / sc->sc_rr.blksize;\n\t\tsc->sc_rr.stamp_last = sc->sc_rr.stamp;\n\t\tao->offset = sc->sc_rr.inp - sc->sc_rr.start;\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase AUDIO_GETOOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\toffs = sc->sc_pr.outp - sc->sc_pr.start + sc->sc_pr.blksize;\n\t\tif (sc->sc_pr.start + offs >= sc->sc_pr.end)\n\t\t\toffs = 0;\n\t\tao->samples = sc->sc_pr.stamp;\n\t\tao->deltablks = (sc->sc_pr.stamp - sc->sc_pr.stamp_last) / sc->sc_pr.blksize;\n\t\tsc->sc_pr.stamp_last = sc->sc_pr.stamp;\n\t\tao->offset = offs;\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * How many bytes will elapse until mike hears the first\n\t * sample of what we write next?\n\t */\n\tcase AUDIO_WSEEK:\n\t\t*(u_long *)addr = sc->sc_rr.used;\n\t\tbreak;\n\n\tcase AUDIO_SETINFO:\n\t\tDPRINTF((\"AUDIO_SETINFO mode=0x%x\\n\", sc->sc_mode));\n\t\terror = audiosetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETINFO:\n\t\tDPRINTF((\"AUDIO_GETINFO\\n\"));\n\t\terror = audiogetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_DRAIN:\n\t\tDPRINTF((\"AUDIO_DRAIN\\n\"));\n\t\terror = audio_drain(sc);\n\t\tif (!error && hw->drain)\n\t\t    error = hw->drain(sc->hw_hdl);\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_GETENC:\n\t\tDPRINTF((\"AUDIO_GETENC\\n\"));\n\t\t/* Pass read/write info down to query_encoding */\n\t\t((struct audio_encoding *)addr)->flags = sc->sc_open;\n\t\terror = hw->query_encoding(sc->hw_hdl, (struct audio_encoding *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETFD:\n\t\tDPRINTF((\"AUDIO_GETFD\\n\"));\n\t\t*(int *)addr = sc->sc_full_duplex;\n\t\tbreak;\n\n\tcase AUDIO_SETFD:\n\t\tDPRINTF((\"AUDIO_SETFD\\n\"));\n\t\tfd = *(int *)addr;\n\t\tif (hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX) {\n\t\t\tif (hw->setfd)\n\t\t\t\terror = hw->setfd(sc->hw_hdl, fd);\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t\tif (!error)\n\t\t\t\tsc->sc_full_duplex = fd;\n\t\t} else {\n\t\t\tif (fd)\n\t\t\t\terror = ENOTTY;\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase AUDIO_GETPROPS:\n\t\tDPRINTF((\"AUDIO_GETPROPS\\n\"));\n\t\t*(int *)addr = hw->get_props(sc->hw_hdl);\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF((\"audio_ioctl: unknown ioctl\\n\"));\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d) result %d\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_ioctl(%d,'%c',%d) result %d\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error)"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCGROUP",
          "args": [
            "cmd"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCPARM_LEN",
          "args": [
            "cmd"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_ioctl: unknown ioctl\\n\")"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->get_props",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_GETPROPS\\n\")"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->setfd",
          "args": [
            "sc->hw_hdl",
            "fd"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->get_props",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_SETFD\\n\")"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_GETFD\\n\")"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->query_encoding",
          "args": [
            "sc->hw_hdl",
            "(struct audio_encoding *)addr"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_GETENC\\n\")"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->getdev",
          "args": [
            "sc->hw_hdl",
            "(audio_device_t *)addr"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_GETDEV\\n\")"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->drain",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_drain",
          "args": [
            "sc"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "audio_drain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "914-971",
          "snippet": "int\naudio_drain(sc)\n\tstruct audio_softc *sc;\n{\n\tint error, drops;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tint s;\n\n        DPRINTF((\"audio_drain: enter busy=%d used=%d\\n\", \n                 sc->sc_pbus, sc->sc_pr.used));\n\tif (sc->sc_pr.mmapped || sc->sc_pr.used <= 0)\n\t\treturn 0;\n\tif (!sc->sc_pbus) {\n\t\t/* We've never started playing, probably because the\n\t\t * block was too short.  Pad it and start now.\n\t\t */\n\t\tint cc;\n\t\tu_char *inp = cb->inp;\n\n\t\tcc = cb->blksize - (inp - cb->start) % cb->blksize;\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\tinp += cc;\n\t\tif (inp >= cb->end)\n\t\t\tinp = cb->start;\n\t\ts = splaudio();\n\t\tcb->used += cc;\n\t\tcb->inp = inp;\n\t\terror = audiostartp(sc);\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/* \n\t * Play until a silence block has been played, then we\n\t * know all has been drained.\n\t * XXX This should be done some other way to avoid\n\t * playing silence.\n\t */\n#ifdef DIAGNOSTIC\n\tif (cb->copying) {\n\t\tprintf(\"audio_drain: copying in progress!?!\\n\");\n\t\tcb->copying = 0;\n\t}\n#endif\n\tdrops = cb->drops;\n\terror = 0;\n\ts = splaudio();\n\twhile (cb->drops == drops && !error) {\n\t\tDPRINTF((\"audio_drain: used=%d, drops=%ld\\n\", sc->sc_pr.used, cb->drops));\n\t\t/*\n\t\t * When the process is exiting, it ignores all signals and\n\t\t * we can't interrupt this sleep, so we set a timeout just in case.\n\t\t */\n\t\terror = audio_sleep_timo(&sc->sc_wchan, \"aud_dr\", 30*hz);\n\t}\n\tsplx(s);\n\treturn error;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_drain(sc)\n\tstruct audio_softc *sc;\n{\n\tint error, drops;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tint s;\n\n        DPRINTF((\"audio_drain: enter busy=%d used=%d\\n\", \n                 sc->sc_pbus, sc->sc_pr.used));\n\tif (sc->sc_pr.mmapped || sc->sc_pr.used <= 0)\n\t\treturn 0;\n\tif (!sc->sc_pbus) {\n\t\t/* We've never started playing, probably because the\n\t\t * block was too short.  Pad it and start now.\n\t\t */\n\t\tint cc;\n\t\tu_char *inp = cb->inp;\n\n\t\tcc = cb->blksize - (inp - cb->start) % cb->blksize;\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\tinp += cc;\n\t\tif (inp >= cb->end)\n\t\t\tinp = cb->start;\n\t\ts = splaudio();\n\t\tcb->used += cc;\n\t\tcb->inp = inp;\n\t\terror = audiostartp(sc);\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/* \n\t * Play until a silence block has been played, then we\n\t * know all has been drained.\n\t * XXX This should be done some other way to avoid\n\t * playing silence.\n\t */\n#ifdef DIAGNOSTIC\n\tif (cb->copying) {\n\t\tprintf(\"audio_drain: copying in progress!?!\\n\");\n\t\tcb->copying = 0;\n\t}\n#endif\n\tdrops = cb->drops;\n\terror = 0;\n\ts = splaudio();\n\twhile (cb->drops == drops && !error) {\n\t\tDPRINTF((\"audio_drain: used=%d, drops=%ld\\n\", sc->sc_pr.used, cb->drops));\n\t\t/*\n\t\t * When the process is exiting, it ignores all signals and\n\t\t * we can't interrupt this sleep, so we set a timeout just in case.\n\t\t */\n\t\terror = audio_sleep_timo(&sc->sc_wchan, \"aud_dr\", 30*hz);\n\t}\n\tsplx(s);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_DRAIN\\n\")"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiogetinfo",
          "args": [
            "sc",
            "(struct audio_info *)addr"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "audiogetinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2632-2707",
          "snippet": "int\naudiogetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\t\n\tp->sample_rate = sc->sc_pparams.sample_rate;\n\tr->sample_rate = sc->sc_rparams.sample_rate;\n\tp->channels = sc->sc_pparams.channels;\n\tr->channels = sc->sc_rparams.channels;\n\tp->precision = sc->sc_pparams.precision;\n\tr->precision = sc->sc_rparams.precision;\n\tp->encoding = sc->sc_pparams.encoding;\n\tr->encoding = sc->sc_rparams.encoding;\n\n\tr->port = au_get_port(sc, &sc->sc_inports);\n\tp->port = au_get_port(sc, &sc->sc_outports);\n\n\tr->avail_ports = sc->sc_inports.allports;\n\tp->avail_ports = sc->sc_outports.allports;\n\n\tau_get_gain(sc, &sc->sc_inports,  &r->gain, &r->balance);\n\tau_get_gain(sc, &sc->sc_outports, &p->gain, &p->balance);\n\n\tif (sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\tai->monitor_gain = 0;\n\t\telse\n\t\t\tai->monitor_gain = \n\t\t\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t} else\n\t\tai->monitor_gain = 0;\n\n\tp->seek = sc->sc_pr.used;\n\tr->seek = sc->sc_rr.used;\n\n\tp->samples = sc->sc_pr.stamp - sc->sc_pr.drops;\n\tr->samples = sc->sc_rr.stamp - sc->sc_rr.drops;\n\n\tp->eof = sc->sc_eof;\n\tr->eof = 0;\n\n\tp->pause = sc->sc_pr.pause;\n\tr->pause = sc->sc_rr.pause;\n\n\tp->error = sc->sc_pr.drops != 0;\n\tr->error = sc->sc_rr.drops != 0;\n\n\tp->waiting = r->waiting = 0;\t\t/* open never hangs */\n\n\tp->open = (sc->sc_open & AUOPEN_WRITE) != 0;\n\tr->open = (sc->sc_open & AUOPEN_READ) != 0;\n\n\tp->active = sc->sc_pbus;\n\tr->active = sc->sc_rbus;\n\n\tp->buffer_size = sc->sc_pr.bufsize;\n\tr->buffer_size = sc->sc_rr.bufsize;\n\n\tai->blocksize = sc->sc_pr.blksize;\n\tai->hiwat = sc->sc_pr.usedhigh / sc->sc_pr.blksize;\n\tai->lowat = sc->sc_pr.usedlow / sc->sc_pr.blksize;\n\tai->mode = sc->sc_mode;\n\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiogetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\t\n\tp->sample_rate = sc->sc_pparams.sample_rate;\n\tr->sample_rate = sc->sc_rparams.sample_rate;\n\tp->channels = sc->sc_pparams.channels;\n\tr->channels = sc->sc_rparams.channels;\n\tp->precision = sc->sc_pparams.precision;\n\tr->precision = sc->sc_rparams.precision;\n\tp->encoding = sc->sc_pparams.encoding;\n\tr->encoding = sc->sc_rparams.encoding;\n\n\tr->port = au_get_port(sc, &sc->sc_inports);\n\tp->port = au_get_port(sc, &sc->sc_outports);\n\n\tr->avail_ports = sc->sc_inports.allports;\n\tp->avail_ports = sc->sc_outports.allports;\n\n\tau_get_gain(sc, &sc->sc_inports,  &r->gain, &r->balance);\n\tau_get_gain(sc, &sc->sc_outports, &p->gain, &p->balance);\n\n\tif (sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tif (sc->hw_if->get_port(sc->hw_hdl, &ct))\n\t\t\tai->monitor_gain = 0;\n\t\telse\n\t\t\tai->monitor_gain = \n\t\t\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t} else\n\t\tai->monitor_gain = 0;\n\n\tp->seek = sc->sc_pr.used;\n\tr->seek = sc->sc_rr.used;\n\n\tp->samples = sc->sc_pr.stamp - sc->sc_pr.drops;\n\tr->samples = sc->sc_rr.stamp - sc->sc_rr.drops;\n\n\tp->eof = sc->sc_eof;\n\tr->eof = 0;\n\n\tp->pause = sc->sc_pr.pause;\n\tr->pause = sc->sc_rr.pause;\n\n\tp->error = sc->sc_pr.drops != 0;\n\tr->error = sc->sc_rr.drops != 0;\n\n\tp->waiting = r->waiting = 0;\t\t/* open never hangs */\n\n\tp->open = (sc->sc_open & AUOPEN_WRITE) != 0;\n\tr->open = (sc->sc_open & AUOPEN_READ) != 0;\n\n\tp->active = sc->sc_pbus;\n\tr->active = sc->sc_rbus;\n\n\tp->buffer_size = sc->sc_pr.bufsize;\n\tr->buffer_size = sc->sc_rr.bufsize;\n\n\tai->blocksize = sc->sc_pr.blksize;\n\tai->hiwat = sc->sc_pr.usedhigh / sc->sc_pr.blksize;\n\tai->lowat = sc->sc_pr.usedlow / sc->sc_pr.blksize;\n\tai->mode = sc->sc_mode;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_GETINFO\\n\")"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiosetinfo",
          "args": [
            "sc",
            "(struct audio_info *)addr"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "audiosetinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2334-2630",
          "snippet": "int\naudiosetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tint cleared;\n\tint s, setmode, modechange = 0;\n\tint error;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params pp, rp;\n\tint np, nr;\n\tunsigned int blks;\n\tint oldpblksize, oldrblksize;\n\tint rbus, pbus;\n\tu_int gain;\n\tu_char balance;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\n\trbus = sc->sc_rbus;\n\tpbus = sc->sc_pbus;\n\terror = 0;\n\tcleared = 0;\n\n\tpp = sc->sc_pparams;\t/* Temporary encoding storage in */\n\trp = sc->sc_rparams;\t/* case setting the modes fails. */\n\tnr = np = 0;\n\n\tif (p->sample_rate != ~0) {\n\t\tpp.sample_rate = p->sample_rate;\n\t\tnp++;\n\t}\n\tif (r->sample_rate != ~0) {\n\t\trp.sample_rate = r->sample_rate;\n\t\tnr++;\n\t}\n\tif (p->encoding != ~0) {\n\t\tpp.encoding = p->encoding;\n\t\tnp++;\n\t}\t\n\tif (r->encoding != ~0) {\n\t\trp.encoding = r->encoding;\n\t\tnr++;\n\t}\n\tif (p->precision != ~0) {\n\t\tpp.precision = p->precision;\n\t\tnp++;\n\t}\n\tif (r->precision != ~0) {\n\t\trp.precision = r->precision;\n\t\tnr++;\n\t}\n\tif (p->channels != ~0) {\n\t\tpp.channels = p->channels;\n\t\tnp++;\n\t}\n\tif (r->channels != ~0) {\n\t\trp.channels = r->channels;\n\t\tnr++;\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug && nr)\n\t    audio_print_params(\"Setting record params\", &rp);\n\tif (audiodebug && np)\n\t    audio_print_params(\"Setting play params\", &pp);\n#endif\n\tif (nr && (error = audio_check_params(&rp)))\n\t\treturn error;\n\tif (np && (error = audio_check_params(&pp)))\n\t\treturn error;\n\tsetmode = 0;\n\tif (nr) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\trp.sw_code = 0;\n\t\trp.factor = 1;\n\t\tsetmode |= AUMODE_RECORD;\n\t}\n\tif (np) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tpp.sw_code = 0;\n\t\tpp.factor = 1;\n\t\tsetmode |= AUMODE_PLAY;\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tsc->sc_mode = ai->mode;\n\t\tif (sc->sc_mode & AUMODE_PLAY_ALL)\n\t\t\tsc->sc_mode |= AUMODE_PLAY;\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_full_duplex)\n\t\t\t/* Play takes precedence */\n\t\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\n\tif (modechange) {\n\t\tint indep = hw->get_props(sc->hw_hdl) & AUDIO_PROP_INDEPENDENT;\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD)\n\t\t\t\tpp = rp;\n\t\t\telse if (setmode == AUMODE_PLAY)\n\t\t\t\trp = pp;\n\t\t}\n\t\terror = hw->set_params(sc->hw_hdl, setmode,\n\t\t    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD), &pp, &rp);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD) {\n\t\t\t\tpp.sample_rate = rp.sample_rate;\n\t\t\t\tpp.encoding    = rp.encoding;\n\t\t\t\tpp.channels    = rp.channels;\n\t\t\t\tpp.precision   = rp.precision;\n\t\t\t} else if (setmode == AUMODE_PLAY) {\n\t\t\t\trp.sample_rate = pp.sample_rate;\n\t\t\t\trp.encoding    = pp.encoding;\n\t\t\t\trp.channels    = pp.channels;\n\t\t\t\trp.precision   = pp.precision;\n\t\t\t}\n\t\t}\n\t\tsc->sc_rparams = rp;\n\t\tsc->sc_pparams = pp;\n\t}\n\n\toldpblksize = sc->sc_pr.blksize;\n\toldrblksize = sc->sc_rr.blksize;\n\t/* Play params can affect the record params, so recalculate blksize. */\n\tif (nr || np) {\n\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug > 1 && nr)\n\t    audio_print_params(\"After setting record params\", &sc->sc_rparams);\n\tif (audiodebug > 1 && np)\n\t    audio_print_params(\"After setting play params\", &sc->sc_pparams);\n#endif\n\n\tif (p->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_outports, p->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_inports, r->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (p->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, p->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, r->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\t\n\tif (p->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, gain, p->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, gain, r->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (ai->monitor_gain != ~0 &&\n\t    sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = ai->monitor_gain;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (p->pause != (u_char)~0) {\n\t\tsc->sc_pr.pause = p->pause;\n\t\tif (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartp(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\tif (r->pause != (u_char)~0) {\n\t\tsc->sc_rr.pause = r->pause;\n\t\tif (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartr(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (ai->blocksize != ~0) {\n\t\t/* Block size specified explicitly. */\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\tif (ai->blocksize == 0) {\n\t\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t\t\tsc->sc_blkset = 0;\n\t\t} else {\n\t\t\tint bs = ai->blocksize;\n\t\t\tif (hw->round_blocksize)\n\t\t\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\t\t\tsc->sc_pr.blksize = sc->sc_rr.blksize = bs;\n\t\t\tsc->sc_blkset = 1;\n\t\t}\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (sc->sc_mode & AUMODE_PLAY)\n\t\t\taudio_init_play(sc);\n\t\tif (sc->sc_mode & AUMODE_RECORD)\n\t\t\taudio_init_record(sc);\n\t}\n\n\tif (hw->commit_settings) {\n\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\tif (cleared) {\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) goto err;\n\t\tif (sc->sc_pr.blksize != oldpblksize ||\n\t\t    sc->sc_rr.blksize != oldrblksize)\n\t\t\taudio_calcwater(sc);\n\t\tif ((sc->sc_mode & AUMODE_PLAY) &&\n\t\t    pbus && !sc->sc_pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error && \n\t\t    (sc->sc_mode & AUMODE_RECORD) &&\n\t\t    rbus && !sc->sc_rbus)\n\t\t\terror = audiostartr(sc);\n\terr:\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t\n\t/* Change water marks after initializing the buffers. */\n\tif (ai->hiwat != ~0) {\n\t\tblks = ai->hiwat;\n\t\tif (blks > sc->sc_pr.maxblks)\n\t\t\tblks = sc->sc_pr.maxblks;\n\t\tif (blks < 2)\n\t\t\tblks = 2;\n\t\tsc->sc_pr.usedhigh = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->lowat != ~0) {\n\t\tblks = ai->lowat;\n\t\tif (blks > sc->sc_pr.maxblks - 1)\n\t\t\tblks = sc->sc_pr.maxblks - 1;\n\t\tsc->sc_pr.usedlow = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->hiwat != ~0 || ai->lowat != ~0) {\n\t\tif (sc->sc_pr.usedlow > sc->sc_pr.usedhigh - sc->sc_pr.blksize)\n\t\t\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh - sc->sc_pr.blksize;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiosetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tint cleared;\n\tint s, setmode, modechange = 0;\n\tint error;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params pp, rp;\n\tint np, nr;\n\tunsigned int blks;\n\tint oldpblksize, oldrblksize;\n\tint rbus, pbus;\n\tu_int gain;\n\tu_char balance;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\n\trbus = sc->sc_rbus;\n\tpbus = sc->sc_pbus;\n\terror = 0;\n\tcleared = 0;\n\n\tpp = sc->sc_pparams;\t/* Temporary encoding storage in */\n\trp = sc->sc_rparams;\t/* case setting the modes fails. */\n\tnr = np = 0;\n\n\tif (p->sample_rate != ~0) {\n\t\tpp.sample_rate = p->sample_rate;\n\t\tnp++;\n\t}\n\tif (r->sample_rate != ~0) {\n\t\trp.sample_rate = r->sample_rate;\n\t\tnr++;\n\t}\n\tif (p->encoding != ~0) {\n\t\tpp.encoding = p->encoding;\n\t\tnp++;\n\t}\t\n\tif (r->encoding != ~0) {\n\t\trp.encoding = r->encoding;\n\t\tnr++;\n\t}\n\tif (p->precision != ~0) {\n\t\tpp.precision = p->precision;\n\t\tnp++;\n\t}\n\tif (r->precision != ~0) {\n\t\trp.precision = r->precision;\n\t\tnr++;\n\t}\n\tif (p->channels != ~0) {\n\t\tpp.channels = p->channels;\n\t\tnp++;\n\t}\n\tif (r->channels != ~0) {\n\t\trp.channels = r->channels;\n\t\tnr++;\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug && nr)\n\t    audio_print_params(\"Setting record params\", &rp);\n\tif (audiodebug && np)\n\t    audio_print_params(\"Setting play params\", &pp);\n#endif\n\tif (nr && (error = audio_check_params(&rp)))\n\t\treturn error;\n\tif (np && (error = audio_check_params(&pp)))\n\t\treturn error;\n\tsetmode = 0;\n\tif (nr) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\trp.sw_code = 0;\n\t\trp.factor = 1;\n\t\tsetmode |= AUMODE_RECORD;\n\t}\n\tif (np) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tpp.sw_code = 0;\n\t\tpp.factor = 1;\n\t\tsetmode |= AUMODE_PLAY;\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tsc->sc_mode = ai->mode;\n\t\tif (sc->sc_mode & AUMODE_PLAY_ALL)\n\t\t\tsc->sc_mode |= AUMODE_PLAY;\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_full_duplex)\n\t\t\t/* Play takes precedence */\n\t\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\n\tif (modechange) {\n\t\tint indep = hw->get_props(sc->hw_hdl) & AUDIO_PROP_INDEPENDENT;\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD)\n\t\t\t\tpp = rp;\n\t\t\telse if (setmode == AUMODE_PLAY)\n\t\t\t\trp = pp;\n\t\t}\n\t\terror = hw->set_params(sc->hw_hdl, setmode,\n\t\t    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD), &pp, &rp);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD) {\n\t\t\t\tpp.sample_rate = rp.sample_rate;\n\t\t\t\tpp.encoding    = rp.encoding;\n\t\t\t\tpp.channels    = rp.channels;\n\t\t\t\tpp.precision   = rp.precision;\n\t\t\t} else if (setmode == AUMODE_PLAY) {\n\t\t\t\trp.sample_rate = pp.sample_rate;\n\t\t\t\trp.encoding    = pp.encoding;\n\t\t\t\trp.channels    = pp.channels;\n\t\t\t\trp.precision   = pp.precision;\n\t\t\t}\n\t\t}\n\t\tsc->sc_rparams = rp;\n\t\tsc->sc_pparams = pp;\n\t}\n\n\toldpblksize = sc->sc_pr.blksize;\n\toldrblksize = sc->sc_rr.blksize;\n\t/* Play params can affect the record params, so recalculate blksize. */\n\tif (nr || np) {\n\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug > 1 && nr)\n\t    audio_print_params(\"After setting record params\", &sc->sc_rparams);\n\tif (audiodebug > 1 && np)\n\t    audio_print_params(\"After setting play params\", &sc->sc_pparams);\n#endif\n\n\tif (p->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_outports, p->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_inports, r->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (p->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, p->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, r->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\t\n\tif (p->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, gain, p->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, gain, r->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (ai->monitor_gain != ~0 &&\n\t    sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = ai->monitor_gain;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (p->pause != (u_char)~0) {\n\t\tsc->sc_pr.pause = p->pause;\n\t\tif (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartp(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\tif (r->pause != (u_char)~0) {\n\t\tsc->sc_rr.pause = r->pause;\n\t\tif (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartr(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (ai->blocksize != ~0) {\n\t\t/* Block size specified explicitly. */\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\tif (ai->blocksize == 0) {\n\t\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t\t\tsc->sc_blkset = 0;\n\t\t} else {\n\t\t\tint bs = ai->blocksize;\n\t\t\tif (hw->round_blocksize)\n\t\t\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\t\t\tsc->sc_pr.blksize = sc->sc_rr.blksize = bs;\n\t\t\tsc->sc_blkset = 1;\n\t\t}\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (sc->sc_mode & AUMODE_PLAY)\n\t\t\taudio_init_play(sc);\n\t\tif (sc->sc_mode & AUMODE_RECORD)\n\t\t\taudio_init_record(sc);\n\t}\n\n\tif (hw->commit_settings) {\n\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\tif (cleared) {\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) goto err;\n\t\tif (sc->sc_pr.blksize != oldpblksize ||\n\t\t    sc->sc_rr.blksize != oldrblksize)\n\t\t\taudio_calcwater(sc);\n\t\tif ((sc->sc_mode & AUMODE_PLAY) &&\n\t\t    pbus && !sc->sc_pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error && \n\t\t    (sc->sc_mode & AUMODE_RECORD) &&\n\t\t    rbus && !sc->sc_rbus)\n\t\t\terror = audiostartr(sc);\n\terr:\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t\n\t/* Change water marks after initializing the buffers. */\n\tif (ai->hiwat != ~0) {\n\t\tblks = ai->hiwat;\n\t\tif (blks > sc->sc_pr.maxblks)\n\t\t\tblks = sc->sc_pr.maxblks;\n\t\tif (blks < 2)\n\t\t\tblks = 2;\n\t\tsc->sc_pr.usedhigh = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->lowat != ~0) {\n\t\tblks = ai->lowat;\n\t\tif (blks > sc->sc_pr.maxblks - 1)\n\t\t\tblks = sc->sc_pr.maxblks - 1;\n\t\tsc->sc_pr.usedlow = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->hiwat != ~0 || ai->lowat != ~0) {\n\t\tif (sc->sc_pr.usedlow > sc->sc_pr.usedhigh - sc->sc_pr.blksize)\n\t\t\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh - sc->sc_pr.blksize;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_SETINFO mode=0x%x\\n\", sc->sc_mode)"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiostartr",
          "args": [
            "sc"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1692-1715",
          "snippet": "int\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audiostartp",
          "args": [
            "sc"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1717-1743",
          "snippet": "int\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_initbufs",
          "args": [
            "sc"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "audio_initbufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "672-719",
          "snippet": "int\naudio_initbufs(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"audio_initbufs: mode=0x%x\\n\", sc->sc_mode));\n\taudio_init_ringbuffer(&sc->sc_rr);\n\tif (hw->init_input && (sc->sc_mode & AUMODE_RECORD)) {\n\t\terror = hw->init_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t\t\t       sc->sc_rr.end - sc->sc_rr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\taudio_init_ringbuffer(&sc->sc_pr);\n\tsc->sc_sil_count = 0;\n\tif (hw->init_output && (sc->sc_mode & AUMODE_PLAY)) {\n\t\terror = hw->init_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t\t\t\tsc->sc_pr.end - sc->sc_pr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n#define double u_long\n\tsc->sc_pnintr = 0;\n\tsc->sc_pblktime = (u_long)(\n\t    (double)sc->sc_pr.blksize * 100000 / \n\t    (double)(sc->sc_pparams.precision / NBBY * \n                     sc->sc_pparams.channels * \n\t\t     sc->sc_pparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: play blktime = %lu for %d\\n\", \n\t\t sc->sc_pblktime, sc->sc_pr.blksize));\n\tsc->sc_rnintr = 0;\n\tsc->sc_rblktime = (u_long)(\n\t    (double)sc->sc_rr.blksize * 100000 / \n\t    (double)(sc->sc_rparams.precision / NBBY * \n                     sc->sc_rparams.channels * \n\t\t     sc->sc_rparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: record blktime = %lu for %d\\n\", \n\t\t sc->sc_rblktime, sc->sc_rr.blksize));\n#undef double\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [
            "#define double u_long"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\n#define double u_long\n\nint\naudio_initbufs(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"audio_initbufs: mode=0x%x\\n\", sc->sc_mode));\n\taudio_init_ringbuffer(&sc->sc_rr);\n\tif (hw->init_input && (sc->sc_mode & AUMODE_RECORD)) {\n\t\terror = hw->init_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t\t\t       sc->sc_rr.end - sc->sc_rr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\taudio_init_ringbuffer(&sc->sc_pr);\n\tsc->sc_sil_count = 0;\n\tif (hw->init_output && (sc->sc_mode & AUMODE_PLAY)) {\n\t\terror = hw->init_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t\t\t\tsc->sc_pr.end - sc->sc_pr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n#define double u_long\n\tsc->sc_pnintr = 0;\n\tsc->sc_pblktime = (u_long)(\n\t    (double)sc->sc_pr.blksize * 100000 / \n\t    (double)(sc->sc_pparams.precision / NBBY * \n                     sc->sc_pparams.channels * \n\t\t     sc->sc_pparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: play blktime = %lu for %d\\n\", \n\t\t sc->sc_pblktime, sc->sc_pr.blksize));\n\tsc->sc_rnintr = 0;\n\tsc->sc_rblktime = (u_long)(\n\t    (double)sc->sc_rr.blksize * 100000 / \n\t    (double)(sc->sc_rparams.precision / NBBY * \n                     sc->sc_rparams.channels * \n\t\t     sc->sc_rparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: record blktime = %lu for %d\\n\", \n\t\t sc->sc_rblktime, sc->sc_rr.blksize));\n#undef double\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_clear",
          "args": [
            "sc"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "audio_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1139-1156",
          "snippet": "void\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_FLUSH\\n\")"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_ioctl: FIOASYNC %p\\n\", p)"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_ioctl(%d,'%c',%d)\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff)"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCGROUP",
          "args": [
            "cmd"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOCPARM_LEN",
          "args": [
            "cmd"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_offset *ao;\n\tint error = 0, s, offs, fd;\n        int rbus, pbus;\n\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d)\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async_audio)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async_audio = p;\n\t\t\tDPRINTF((\"audio_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async_audio = 0;\n\t\tbreak;\n\n\tcase AUDIO_FLUSH:\n\t\tDPRINTF((\"AUDIO_FLUSH\\n\"));\n                rbus = sc->sc_rbus;\n                pbus = sc->sc_pbus;\n\t\taudio_clear(sc);\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn error;\n\t\t}\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_pbus && pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error &&\n\t\t    (sc->sc_mode & AUMODE_RECORD) && !sc->sc_rbus && rbus)\n\t\t\terror = audiostartr(sc);\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * Number of read (write) samples dropped.  We don't know where or\n\t * when they were dropped.\n\t */\n\tcase AUDIO_RERROR:\n\t\t*(int *)addr = sc->sc_rr.drops;\n\t\tbreak;\n\n\tcase AUDIO_PERROR:\n\t\t*(int *)addr = sc->sc_pr.drops;\n\t\tbreak;\n\n\t/*\n\t * Offsets into buffer.\n\t */\n\tcase AUDIO_GETIOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\tao->samples = sc->sc_rr.stamp;\n\t\tao->deltablks = (sc->sc_rr.stamp - sc->sc_rr.stamp_last) / sc->sc_rr.blksize;\n\t\tsc->sc_rr.stamp_last = sc->sc_rr.stamp;\n\t\tao->offset = sc->sc_rr.inp - sc->sc_rr.start;\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase AUDIO_GETOOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\toffs = sc->sc_pr.outp - sc->sc_pr.start + sc->sc_pr.blksize;\n\t\tif (sc->sc_pr.start + offs >= sc->sc_pr.end)\n\t\t\toffs = 0;\n\t\tao->samples = sc->sc_pr.stamp;\n\t\tao->deltablks = (sc->sc_pr.stamp - sc->sc_pr.stamp_last) / sc->sc_pr.blksize;\n\t\tsc->sc_pr.stamp_last = sc->sc_pr.stamp;\n\t\tao->offset = offs;\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * How many bytes will elapse until mike hears the first\n\t * sample of what we write next?\n\t */\n\tcase AUDIO_WSEEK:\n\t\t*(u_long *)addr = sc->sc_rr.used;\n\t\tbreak;\n\n\tcase AUDIO_SETINFO:\n\t\tDPRINTF((\"AUDIO_SETINFO mode=0x%x\\n\", sc->sc_mode));\n\t\terror = audiosetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETINFO:\n\t\tDPRINTF((\"AUDIO_GETINFO\\n\"));\n\t\terror = audiogetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_DRAIN:\n\t\tDPRINTF((\"AUDIO_DRAIN\\n\"));\n\t\terror = audio_drain(sc);\n\t\tif (!error && hw->drain)\n\t\t    error = hw->drain(sc->hw_hdl);\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_GETENC:\n\t\tDPRINTF((\"AUDIO_GETENC\\n\"));\n\t\t/* Pass read/write info down to query_encoding */\n\t\t((struct audio_encoding *)addr)->flags = sc->sc_open;\n\t\terror = hw->query_encoding(sc->hw_hdl, (struct audio_encoding *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETFD:\n\t\tDPRINTF((\"AUDIO_GETFD\\n\"));\n\t\t*(int *)addr = sc->sc_full_duplex;\n\t\tbreak;\n\n\tcase AUDIO_SETFD:\n\t\tDPRINTF((\"AUDIO_SETFD\\n\"));\n\t\tfd = *(int *)addr;\n\t\tif (hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX) {\n\t\t\tif (hw->setfd)\n\t\t\t\terror = hw->setfd(sc->hw_hdl, fd);\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t\tif (!error)\n\t\t\t\tsc->sc_full_duplex = fd;\n\t\t} else {\n\t\t\tif (fd)\n\t\t\t\terror = ENOTTY;\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase AUDIO_GETPROPS:\n\t\tDPRINTF((\"AUDIO_GETPROPS\\n\"));\n\t\t*(int *)addr = hw->get_props(sc->hw_hdl);\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF((\"audio_ioctl: unknown ioctl\\n\"));\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d) result %d\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}"
  },
  {
    "function_name": "audio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1270-1427",
    "snippet": "int\naudio_write(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tu_char *inp, *einp;\n\tint saveerror, error, s, n, cc, used;\n\n\tDPRINTFN(2, (\"audio_write: sc=%p(unit=%d) count=%d used=%d(hi=%d)\\n\", sc, unit,\n\t\t uio->uio_resid, sc->sc_pr.used, sc->sc_pr.usedhigh));\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tif (uio->uio_resid == 0) {\n\t\tsc->sc_eof++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If half-duplex and currently recording, throw away data.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_RECORD)) {\n\t\tuio->uio_offset += uio->uio_resid;\n\t\tuio->uio_resid = 0;\n\t\tDPRINTF((\"audio_write: half-dpx read busy\\n\"));\n\t\treturn (0);\n\t}\n\n\tif (!(sc->sc_mode & AUMODE_PLAY_ALL) && sc->sc_playdrop > 0) {\n\t\tn = min(sc->sc_playdrop, uio->uio_resid);\n\t\tDPRINTF((\"audio_write: playdrop %d\\n\", n));\n\t\tuio->uio_offset += n;\n\t\tuio->uio_resid -= n;\n\t\tsc->sc_playdrop -= n;\n\t\tif (uio->uio_resid == 0)\n\t\t\treturn 0;\n\t}\n\n\tDPRINTFN(1, (\"audio_write: sr=%ld, enc=%d, prec=%d, chan=%d, sw=%p, fact=%d\\n\",\n                     sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,\n                     sc->sc_pparams.precision, sc->sc_pparams.channels,\n                     sc->sc_pparams.sw_code, sc->sc_pparams.factor));\n\n\terror = 0;\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used >= cb->usedhigh) {\n\t\t\tDPRINTFN(2, (\"audio_write: sleep used=%d lowat=%d hiwat=%d\\n\", \n\t\t\t\t cb->used, cb->usedlow, cb->usedhigh));\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = audio_sleep(&sc->sc_wchan, \"aud_wr\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\tinp = cb->inp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = cb->usedhigh - used; \t/* maximum to write */\n\t\tn = cb->end - inp;\n\t\tif (sc->sc_pparams.factor != 1) {\n\t\t\t/* Compensate for software coding expansion factor. */\n\t\t\tn /= sc->sc_pparams.factor;\n\t\t\tcc /= sc->sc_pparams.factor;\n\t\t}\n\t\tif (n < cc)\n\t\t\tcc = n;\t\t\t/* don't write beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; \t/* and no more than we have */\n\n#ifdef DIAGNOSTIC\n\t\t/* \n\t\t * This should never happen since the block size and and\n\t\t * block pointers are always nicely aligned. \n\t\t */\n\t\tif (cc == 0) {\n\t\t\tprintf(\"audio_write: cc == 0, swcode=%p, factor=%d\\n\",\n\t\t\t       sc->sc_pparams.sw_code, sc->sc_pparams.factor);\n\t\t\tcb->copying = 0;\n\t\t\treturn EINVAL;\n\t\t}\n#endif\n\t\tDPRINTFN(1, (\"audio_write: uiomove cc=%d inp=%p, left=%d\\n\", \n                             cc, inp, uio->uio_resid));\n\t\tn = uio->uio_resid;\n\t\terror = uiomove(inp, cc, uio);\n\t\tcc = n - uio->uio_resid; /* number of bytes actually moved */\n#ifdef AUDIO_DEBUG\n\t\tif (error)\n\t\t        printf(\"audio_write:(1) uiomove failed %d; cc=%d inp=%p\\n\",\n\t\t\t       error, cc, inp);\n#endif\n\t\t/* \n\t\t * Continue even if uiomove() failed because we may have\n\t\t * gotten a partial block.\n\t\t */\n\n\t\tif (sc->sc_pparams.sw_code) {\n\t\t\tsc->sc_pparams.sw_code(sc->hw_hdl, inp, cc);\n\t\t\t/* Adjust count after the expansion. */\n\t\t\tcc *= sc->sc_pparams.factor;\n\t\t\tDPRINTFN(1, (\"audio_write: expanded cc=%d\\n\", cc));\n\t\t}\n\n\t\teinp = cb->inp + cc;\n\t\tif (einp >= cb->end)\n\t\t\teinp = cb->start;\n\n\t\ts = splaudio();\n\t\t/*\n\t\t * This is a very suboptimal way of keeping track of\n\t\t * silence in the buffer, but it is simple.\n\t\t */\n\t\tsc->sc_sil_count = 0;\n\n\t\tcb->inp = einp;\n\t\tcb->used += cc;\n\t\t/* If the interrupt routine wants the last block filled AND\n\t\t * the copy did not fill the last block completely it needs to\n\t\t * be padded.\n\t\t */\n\t\tif (cb->needfill &&\n\t\t    (inp  - cb->start) / cb->blksize == \n\t\t    (einp - cb->start) / cb->blksize) {\n\t\t\t/* Figure out how many bytes there is to a block boundary. */\n\t\t\tcc = cb->blksize - (einp - cb->start) % cb->blksize;\n\t\t\tDPRINTF((\"audio_write: partial fill %d\\n\", cc));\n\t\t} else\n\t\t\tcc = 0;\n\t\tcb->needfill = 0;\n\t\tcb->copying = 0;\n\t\tif (!sc->sc_pbus && !cb->pause) {\n\t\t\tsaveerror = error;\n\t\t\terror = audiostartp(sc);\n\t\t\tif (saveerror != 0) {\n\t\t\t\t/* Report the first error that occured. */\n\t\t\t\terror = saveerror;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\t\tif (cc) {\n\t\t\tDPRINTFN(1, (\"audio_write: fill %d\\n\", cc));\n\t\t\taudio_fill_silence(&sc->sc_pparams, einp, cc);\n\t\t}\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_fill_silence",
          "args": [
            "&sc->sc_pparams",
            "einp",
            "cc"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "audio_fill_silence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1191-1247",
          "snippet": "void\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_write: fill %d\\n\", cc)"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiostartp",
          "args": [
            "sc"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1717-1743",
          "snippet": "int\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_write: partial fill %d\\n\", cc)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_write: expanded cc=%d\\n\", cc)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_pparams.sw_code",
          "args": [
            "sc->hw_hdl",
            "inp",
            "cc"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio_write:(1) uiomove failed %d; cc=%d inp=%p\\n\"",
            "error",
            "cc",
            "inp"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "inp",
            "cc",
            "uio"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_write: uiomove cc=%d inp=%p, left=%d\\n\", \n                             cc, inp, uio->uio_resid)"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_sleep",
          "args": [
            "&sc->sc_wchan",
            "\"aud_wr\""
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "audio_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "756-762",
          "snippet": "static __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"audio_write: sleep used=%d lowat=%d hiwat=%d\\n\", \n\t\t\t\t cb->used, cb->usedlow, cb->usedhigh)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_write: sr=%ld, enc=%d, prec=%d, chan=%d, sw=%p, fact=%d\\n\",\n                     sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,\n                     sc->sc_pparams.precision, sc->sc_pparams.channels,\n                     sc->sc_pparams.sw_code, sc->sc_pparams.factor)"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_write: playdrop %d\\n\", n)"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sc->sc_playdrop",
            "uio->uio_resid"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_write: half-dpx read busy\\n\")"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"audio_write: sc=%p(unit=%d) count=%d used=%d(hi=%d)\\n\", sc, unit,\n\t\t uio->uio_resid, sc->sc_pr.used, sc->sc_pr.usedhigh)"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_write(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tu_char *inp, *einp;\n\tint saveerror, error, s, n, cc, used;\n\n\tDPRINTFN(2, (\"audio_write: sc=%p(unit=%d) count=%d used=%d(hi=%d)\\n\", sc, unit,\n\t\t uio->uio_resid, sc->sc_pr.used, sc->sc_pr.usedhigh));\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tif (uio->uio_resid == 0) {\n\t\tsc->sc_eof++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If half-duplex and currently recording, throw away data.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_RECORD)) {\n\t\tuio->uio_offset += uio->uio_resid;\n\t\tuio->uio_resid = 0;\n\t\tDPRINTF((\"audio_write: half-dpx read busy\\n\"));\n\t\treturn (0);\n\t}\n\n\tif (!(sc->sc_mode & AUMODE_PLAY_ALL) && sc->sc_playdrop > 0) {\n\t\tn = min(sc->sc_playdrop, uio->uio_resid);\n\t\tDPRINTF((\"audio_write: playdrop %d\\n\", n));\n\t\tuio->uio_offset += n;\n\t\tuio->uio_resid -= n;\n\t\tsc->sc_playdrop -= n;\n\t\tif (uio->uio_resid == 0)\n\t\t\treturn 0;\n\t}\n\n\tDPRINTFN(1, (\"audio_write: sr=%ld, enc=%d, prec=%d, chan=%d, sw=%p, fact=%d\\n\",\n                     sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,\n                     sc->sc_pparams.precision, sc->sc_pparams.channels,\n                     sc->sc_pparams.sw_code, sc->sc_pparams.factor));\n\n\terror = 0;\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used >= cb->usedhigh) {\n\t\t\tDPRINTFN(2, (\"audio_write: sleep used=%d lowat=%d hiwat=%d\\n\", \n\t\t\t\t cb->used, cb->usedlow, cb->usedhigh));\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = audio_sleep(&sc->sc_wchan, \"aud_wr\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\tinp = cb->inp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = cb->usedhigh - used; \t/* maximum to write */\n\t\tn = cb->end - inp;\n\t\tif (sc->sc_pparams.factor != 1) {\n\t\t\t/* Compensate for software coding expansion factor. */\n\t\t\tn /= sc->sc_pparams.factor;\n\t\t\tcc /= sc->sc_pparams.factor;\n\t\t}\n\t\tif (n < cc)\n\t\t\tcc = n;\t\t\t/* don't write beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; \t/* and no more than we have */\n\n#ifdef DIAGNOSTIC\n\t\t/* \n\t\t * This should never happen since the block size and and\n\t\t * block pointers are always nicely aligned. \n\t\t */\n\t\tif (cc == 0) {\n\t\t\tprintf(\"audio_write: cc == 0, swcode=%p, factor=%d\\n\",\n\t\t\t       sc->sc_pparams.sw_code, sc->sc_pparams.factor);\n\t\t\tcb->copying = 0;\n\t\t\treturn EINVAL;\n\t\t}\n#endif\n\t\tDPRINTFN(1, (\"audio_write: uiomove cc=%d inp=%p, left=%d\\n\", \n                             cc, inp, uio->uio_resid));\n\t\tn = uio->uio_resid;\n\t\terror = uiomove(inp, cc, uio);\n\t\tcc = n - uio->uio_resid; /* number of bytes actually moved */\n#ifdef AUDIO_DEBUG\n\t\tif (error)\n\t\t        printf(\"audio_write:(1) uiomove failed %d; cc=%d inp=%p\\n\",\n\t\t\t       error, cc, inp);\n#endif\n\t\t/* \n\t\t * Continue even if uiomove() failed because we may have\n\t\t * gotten a partial block.\n\t\t */\n\n\t\tif (sc->sc_pparams.sw_code) {\n\t\t\tsc->sc_pparams.sw_code(sc->hw_hdl, inp, cc);\n\t\t\t/* Adjust count after the expansion. */\n\t\t\tcc *= sc->sc_pparams.factor;\n\t\t\tDPRINTFN(1, (\"audio_write: expanded cc=%d\\n\", cc));\n\t\t}\n\n\t\teinp = cb->inp + cc;\n\t\tif (einp >= cb->end)\n\t\t\teinp = cb->start;\n\n\t\ts = splaudio();\n\t\t/*\n\t\t * This is a very suboptimal way of keeping track of\n\t\t * silence in the buffer, but it is simple.\n\t\t */\n\t\tsc->sc_sil_count = 0;\n\n\t\tcb->inp = einp;\n\t\tcb->used += cc;\n\t\t/* If the interrupt routine wants the last block filled AND\n\t\t * the copy did not fill the last block completely it needs to\n\t\t * be padded.\n\t\t */\n\t\tif (cb->needfill &&\n\t\t    (inp  - cb->start) / cb->blksize == \n\t\t    (einp - cb->start) / cb->blksize) {\n\t\t\t/* Figure out how many bytes there is to a block boundary. */\n\t\t\tcc = cb->blksize - (einp - cb->start) % cb->blksize;\n\t\t\tDPRINTF((\"audio_write: partial fill %d\\n\", cc));\n\t\t} else\n\t\t\tcc = 0;\n\t\tcb->needfill = 0;\n\t\tcb->copying = 0;\n\t\tif (!sc->sc_pbus && !cb->pause) {\n\t\t\tsaveerror = error;\n\t\t\terror = audiostartp(sc);\n\t\t\tif (saveerror != 0) {\n\t\t\t\t/* Report the first error that occured. */\n\t\t\t\terror = saveerror;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\t\tif (cc) {\n\t\t\tDPRINTFN(1, (\"audio_write: fill %d\\n\", cc));\n\t\t\taudio_fill_silence(&sc->sc_pparams, einp, cc);\n\t\t}\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "audio_silence_copyout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1249-1268",
    "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "zerobuf",
            "k",
            "uio"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "n",
            "min(uio->uio_resid, sizeof zerobuf)"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_fill_silence",
          "args": [
            "&sc->sc_rparams",
            "zerobuf",
            "sizeof zerobuf"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "audio_fill_silence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1191-1247",
          "snippet": "void\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
  },
  {
    "function_name": "audio_fill_silence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1191-1247",
    "snippet": "void\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio: bad encoding %d\\n\", params->encoding)"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "audio_calc_blksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1158-1189",
    "snippet": "void\naudio_calc_blksize(sc, mode)\n\tstruct audio_softc *sc;\n\tint mode;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params *parm;\n\tstruct audio_ringbuffer *rb;\n    \tint bs;\n\n\tif (sc->sc_blkset)\n\t\treturn;\n\n\tif (mode == AUMODE_PLAY) {\n\t\tparm = &sc->sc_pparams;\n\t\trb = &sc->sc_pr;\n\t} else {\n\t\tparm = &sc->sc_rparams;\n\t\trb = &sc->sc_rr;\n\t}\n\t\n\tbs = parm->sample_rate * audio_blk_ms / 1000 *\n\t     parm->channels * parm->precision / NBBY *\n\t     parm->factor;\n\tROUNDSIZE(bs);\n\tif (hw->round_blocksize)\n\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\trb->blksize = bs;\n\n\tDPRINTF((\"audio_calc_blksize: %s blksize=%d\\n\", \n\t\t mode == AUMODE_PLAY ? \"play\" : \"record\", bs));\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_calc_blksize: %s blksize=%d\\n\", \n\t\t mode == AUMODE_PLAY ? \"play\" : \"record\", bs)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->round_blocksize",
          "args": [
            "sc->hw_hdl",
            "bs"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUNDSIZE",
          "args": [
            "bs"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_calc_blksize(sc, mode)\n\tstruct audio_softc *sc;\n\tint mode;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params *parm;\n\tstruct audio_ringbuffer *rb;\n    \tint bs;\n\n\tif (sc->sc_blkset)\n\t\treturn;\n\n\tif (mode == AUMODE_PLAY) {\n\t\tparm = &sc->sc_pparams;\n\t\trb = &sc->sc_pr;\n\t} else {\n\t\tparm = &sc->sc_rparams;\n\t\trb = &sc->sc_rr;\n\t}\n\t\n\tbs = parm->sample_rate * audio_blk_ms / 1000 *\n\t     parm->channels * parm->precision / NBBY *\n\t     parm->factor;\n\tROUNDSIZE(bs);\n\tif (hw->round_blocksize)\n\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\trb->blksize = bs;\n\n\tDPRINTF((\"audio_calc_blksize: %s blksize=%d\\n\", \n\t\t mode == AUMODE_PLAY ? \"play\" : \"record\", bs));\n}"
  },
  {
    "function_name": "audio_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1139-1156",
    "snippet": "void\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->halt_output",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_wakeup",
          "args": [
            "&sc->sc_wchan"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->hw_if->halt_input",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_clear(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->sc_rbus) {\n\t\taudio_wakeup(&sc->sc_rchan);\n\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\tif (sc->sc_pbus) {\n\t\taudio_wakeup(&sc->sc_wchan);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "audio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "1036-1137",
    "snippet": "int\naudio_read(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_rr;\n\tu_char *outp;\n\tint error, s, used, cc, n;\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tDPRINTFN(1,(\"audio_read: cc=%d mode=%d\\n\", \n                    uio->uio_resid, sc->sc_mode));\n\n\terror = 0;\n\t/*\n\t * If hardware is half-duplex and currently playing, return\n\t * silence blocks based on the number of blocks we have output.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_PLAY)) {\n\t\twhile (uio->uio_resid > 0 && !error) {\n\t\t\ts = splaudio();\n\t\t\tfor(;;) {\n\t\t\t\tcc = sc->sc_pr.stamp - sc->sc_wstamp;\n\t\t\t\tif (cc > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tDPRINTF((\"audio_read: stamp=%lu, wstamp=%lu\\n\", \n\t\t\t\t\t sc->sc_pr.stamp, sc->sc_wstamp));\n\t\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn EWOULDBLOCK;\n\t\t\t\t}\n\t\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_hr\");\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\n\t\t\tif (uio->uio_resid < cc)\n\t\t\t\tcc = uio->uio_resid;\n\t\t\tDPRINTFN(1, (\"audio_read: reading in write mode, cc=%d\\n\", cc));\n\t\t\terror = audio_silence_copyout(sc, cc, uio);\n\t\t\tsc->sc_wstamp += cc;\n\t\t} \n\t\treturn (error);\n\t}\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used <= 0) {\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn EWOULDBLOCK;\n\t\t\t}\n\t\t\tif (!sc->sc_rbus) {\n\t\t\t\terror = audiostartr(sc);\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDPRINTFN(2, (\"audio_read: sleep used=%d\\n\", cb->used));\n\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_rd\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\toutp = cb->outp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = used - cb->usedlow; /* maximum to read */\n\t\tn = cb->end - outp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t/* don't read beyond end of buffer */\n\t\t\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; /* and no more than we want */\n\n\t\tif (sc->sc_rparams.sw_code)\n\t\t\tsc->sc_rparams.sw_code(sc->hw_hdl, outp, cc);\n\t\tDPRINTFN(1,(\"audio_read: outp=%p, cc=%d\\n\", outp, cc));\n\t\terror = uiomove(outp, cc, uio);\n\t\tused -= cc;\n\t\toutp += cc;\n\t\tif (outp >= cb->end)\n\t\t\toutp = cb->start;\n\t\ts = splaudio();\n\t\tcb->outp = outp;\n\t\tcb->used = used;\n\t\tcb->copying = 0;\n\t\tsplx(s);\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "outp",
            "cc",
            "uio"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_read: outp=%p, cc=%d\\n\", outp, cc)"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_rparams.sw_code",
          "args": [
            "sc->hw_hdl",
            "outp",
            "cc"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_sleep",
          "args": [
            "&sc->sc_rchan",
            "\"aud_rd\""
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "audio_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "756-762",
          "snippet": "static __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"audio_read: sleep used=%d\\n\", cb->used)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiostartr",
          "args": [
            "sc"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1692-1715",
          "snippet": "int\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartr(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartr: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, \n\t\t sc->sc_rr.mmapped));\n\n\tif (sc->hw_if->trigger_input)\n\t\terror = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t    sc->sc_rr.end, sc->sc_rr.blksize,\n\t\t    audio_rint, (void *)sc, &sc->sc_rparams);\n\telse\n\t\terror = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, \n\t\t    sc->sc_rr.blksize, audio_rint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartr failed: %d\\n\", error));\n\t\treturn error;\n\t}\n\tsc->sc_rbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_silence_copyout",
          "args": [
            "sc",
            "cc",
            "uio"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_read: reading in write mode, cc=%d\\n\", cc)"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_read: stamp=%lu, wstamp=%lu\\n\", \n\t\t\t\t\t sc->sc_pr.stamp, sc->sc_wstamp)"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"audio_read: cc=%d mode=%d\\n\", \n                    uio->uio_resid, sc->sc_mode)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_read(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_rr;\n\tu_char *outp;\n\tint error, s, used, cc, n;\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tDPRINTFN(1,(\"audio_read: cc=%d mode=%d\\n\", \n                    uio->uio_resid, sc->sc_mode));\n\n\terror = 0;\n\t/*\n\t * If hardware is half-duplex and currently playing, return\n\t * silence blocks based on the number of blocks we have output.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_PLAY)) {\n\t\twhile (uio->uio_resid > 0 && !error) {\n\t\t\ts = splaudio();\n\t\t\tfor(;;) {\n\t\t\t\tcc = sc->sc_pr.stamp - sc->sc_wstamp;\n\t\t\t\tif (cc > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tDPRINTF((\"audio_read: stamp=%lu, wstamp=%lu\\n\", \n\t\t\t\t\t sc->sc_pr.stamp, sc->sc_wstamp));\n\t\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn EWOULDBLOCK;\n\t\t\t\t}\n\t\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_hr\");\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\n\t\t\tif (uio->uio_resid < cc)\n\t\t\t\tcc = uio->uio_resid;\n\t\t\tDPRINTFN(1, (\"audio_read: reading in write mode, cc=%d\\n\", cc));\n\t\t\terror = audio_silence_copyout(sc, cc, uio);\n\t\t\tsc->sc_wstamp += cc;\n\t\t} \n\t\treturn (error);\n\t}\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used <= 0) {\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn EWOULDBLOCK;\n\t\t\t}\n\t\t\tif (!sc->sc_rbus) {\n\t\t\t\terror = audiostartr(sc);\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDPRINTFN(2, (\"audio_read: sleep used=%d\\n\", cb->used));\n\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_rd\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\toutp = cb->outp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = used - cb->usedlow; /* maximum to read */\n\t\tn = cb->end - outp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t/* don't read beyond end of buffer */\n\t\t\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; /* and no more than we want */\n\n\t\tif (sc->sc_rparams.sw_code)\n\t\t\tsc->sc_rparams.sw_code(sc->hw_hdl, outp, cc);\n\t\tDPRINTFN(1,(\"audio_read: outp=%p, cc=%d\\n\", outp, cc));\n\t\terror = uiomove(outp, cc, uio);\n\t\tused -= cc;\n\t\toutp += cc;\n\t\tif (outp >= cb->end)\n\t\t\toutp = cb->start;\n\t\ts = splaudio();\n\t\tcb->outp = outp;\n\t\tcb->used = used;\n\t\tcb->copying = 0;\n\t\tsplx(s);\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "audio_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "977-1034",
    "snippet": "int\naudio_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint s;\n\n\tDPRINTF((\"audio_close: unit=%d\\n\", unit));\n\n\ts = splaudio();\n        /* Stop recording. */\n\tif ((flags & FREAD) && sc->sc_rbus) {\n\t\t/* \n\t\t * XXX Some drivers (e.g. SB) use the same routine\n\t\t * to halt input and output so don't halt input if\n\t\t * in full duplex mode.  These drivers should be fixed.\n\t\t */\n\t\tif (!sc->sc_full_duplex || sc->hw_if->halt_input != sc->hw_if->halt_output)\n\t\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\t/*\n\t * Block until output drains, but allow ^C interrupt.\n\t */\n\tsc->sc_pr.usedlow = sc->sc_pr.blksize;\t/* avoid excessive wakeups */\n\t/*\n\t * If there is pending output, let it drain (unless\n\t * the output is paused).\n\t */\n\tif ((flags & FWRITE) && sc->sc_pbus) {\n\t\tif (!sc->sc_pr.pause && !audio_drain(sc) && hw->drain)\n\t\t\t(void)hw->drain(sc->hw_hdl);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\t\n\thw->close(sc->hw_hdl);\n\t\n\tif (flags & FREAD) {\n\t\tsc->sc_open &= ~AUOPEN_READ;\n\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open &= ~AUOPEN_WRITE;\n\t\tsc->sc_mode &= ~(AUMODE_PLAY|AUMODE_PLAY_ALL);\n\t}\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_full_duplex = 0;\n\tsplx(s);\n\tDPRINTF((\"audio_close: done\\n\"));\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_close: done\\n\")"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->close",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->halt_output",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->drain",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_drain",
          "args": [
            "sc"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "audio_drain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "914-971",
          "snippet": "int\naudio_drain(sc)\n\tstruct audio_softc *sc;\n{\n\tint error, drops;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tint s;\n\n        DPRINTF((\"audio_drain: enter busy=%d used=%d\\n\", \n                 sc->sc_pbus, sc->sc_pr.used));\n\tif (sc->sc_pr.mmapped || sc->sc_pr.used <= 0)\n\t\treturn 0;\n\tif (!sc->sc_pbus) {\n\t\t/* We've never started playing, probably because the\n\t\t * block was too short.  Pad it and start now.\n\t\t */\n\t\tint cc;\n\t\tu_char *inp = cb->inp;\n\n\t\tcc = cb->blksize - (inp - cb->start) % cb->blksize;\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\tinp += cc;\n\t\tif (inp >= cb->end)\n\t\t\tinp = cb->start;\n\t\ts = splaudio();\n\t\tcb->used += cc;\n\t\tcb->inp = inp;\n\t\terror = audiostartp(sc);\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/* \n\t * Play until a silence block has been played, then we\n\t * know all has been drained.\n\t * XXX This should be done some other way to avoid\n\t * playing silence.\n\t */\n#ifdef DIAGNOSTIC\n\tif (cb->copying) {\n\t\tprintf(\"audio_drain: copying in progress!?!\\n\");\n\t\tcb->copying = 0;\n\t}\n#endif\n\tdrops = cb->drops;\n\terror = 0;\n\ts = splaudio();\n\twhile (cb->drops == drops && !error) {\n\t\tDPRINTF((\"audio_drain: used=%d, drops=%ld\\n\", sc->sc_pr.used, cb->drops));\n\t\t/*\n\t\t * When the process is exiting, it ignores all signals and\n\t\t * we can't interrupt this sleep, so we set a timeout just in case.\n\t\t */\n\t\terror = audio_sleep_timo(&sc->sc_wchan, \"aud_dr\", 30*hz);\n\t}\n\tsplx(s);\n\treturn error;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_drain(sc)\n\tstruct audio_softc *sc;\n{\n\tint error, drops;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tint s;\n\n        DPRINTF((\"audio_drain: enter busy=%d used=%d\\n\", \n                 sc->sc_pbus, sc->sc_pr.used));\n\tif (sc->sc_pr.mmapped || sc->sc_pr.used <= 0)\n\t\treturn 0;\n\tif (!sc->sc_pbus) {\n\t\t/* We've never started playing, probably because the\n\t\t * block was too short.  Pad it and start now.\n\t\t */\n\t\tint cc;\n\t\tu_char *inp = cb->inp;\n\n\t\tcc = cb->blksize - (inp - cb->start) % cb->blksize;\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\tinp += cc;\n\t\tif (inp >= cb->end)\n\t\t\tinp = cb->start;\n\t\ts = splaudio();\n\t\tcb->used += cc;\n\t\tcb->inp = inp;\n\t\terror = audiostartp(sc);\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/* \n\t * Play until a silence block has been played, then we\n\t * know all has been drained.\n\t * XXX This should be done some other way to avoid\n\t * playing silence.\n\t */\n#ifdef DIAGNOSTIC\n\tif (cb->copying) {\n\t\tprintf(\"audio_drain: copying in progress!?!\\n\");\n\t\tcb->copying = 0;\n\t}\n#endif\n\tdrops = cb->drops;\n\terror = 0;\n\ts = splaudio();\n\twhile (cb->drops == drops && !error) {\n\t\tDPRINTF((\"audio_drain: used=%d, drops=%ld\\n\", sc->sc_pr.used, cb->drops));\n\t\t/*\n\t\t * When the process is exiting, it ignores all signals and\n\t\t * we can't interrupt this sleep, so we set a timeout just in case.\n\t\t */\n\t\terror = audio_sleep_timo(&sc->sc_wchan, \"aud_dr\", 30*hz);\n\t}\n\tsplx(s);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->hw_if->halt_input",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_close: unit=%d\\n\", unit)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint s;\n\n\tDPRINTF((\"audio_close: unit=%d\\n\", unit));\n\n\ts = splaudio();\n        /* Stop recording. */\n\tif ((flags & FREAD) && sc->sc_rbus) {\n\t\t/* \n\t\t * XXX Some drivers (e.g. SB) use the same routine\n\t\t * to halt input and output so don't halt input if\n\t\t * in full duplex mode.  These drivers should be fixed.\n\t\t */\n\t\tif (!sc->sc_full_duplex || sc->hw_if->halt_input != sc->hw_if->halt_output)\n\t\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\t/*\n\t * Block until output drains, but allow ^C interrupt.\n\t */\n\tsc->sc_pr.usedlow = sc->sc_pr.blksize;\t/* avoid excessive wakeups */\n\t/*\n\t * If there is pending output, let it drain (unless\n\t * the output is paused).\n\t */\n\tif ((flags & FWRITE) && sc->sc_pbus) {\n\t\tif (!sc->sc_pr.pause && !audio_drain(sc) && hw->drain)\n\t\t\t(void)hw->drain(sc->hw_hdl);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\t\n\thw->close(sc->hw_hdl);\n\t\n\tif (flags & FREAD) {\n\t\tsc->sc_open &= ~AUOPEN_READ;\n\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open &= ~AUOPEN_WRITE;\n\t\tsc->sc_mode &= ~(AUMODE_PLAY|AUMODE_PLAY_ALL);\n\t}\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_full_duplex = 0;\n\tsplx(s);\n\tDPRINTF((\"audio_close: done\\n\"));\n\n\treturn (0);\n}"
  },
  {
    "function_name": "audio_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "914-971",
    "snippet": "int\naudio_drain(sc)\n\tstruct audio_softc *sc;\n{\n\tint error, drops;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tint s;\n\n        DPRINTF((\"audio_drain: enter busy=%d used=%d\\n\", \n                 sc->sc_pbus, sc->sc_pr.used));\n\tif (sc->sc_pr.mmapped || sc->sc_pr.used <= 0)\n\t\treturn 0;\n\tif (!sc->sc_pbus) {\n\t\t/* We've never started playing, probably because the\n\t\t * block was too short.  Pad it and start now.\n\t\t */\n\t\tint cc;\n\t\tu_char *inp = cb->inp;\n\n\t\tcc = cb->blksize - (inp - cb->start) % cb->blksize;\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\tinp += cc;\n\t\tif (inp >= cb->end)\n\t\t\tinp = cb->start;\n\t\ts = splaudio();\n\t\tcb->used += cc;\n\t\tcb->inp = inp;\n\t\terror = audiostartp(sc);\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/* \n\t * Play until a silence block has been played, then we\n\t * know all has been drained.\n\t * XXX This should be done some other way to avoid\n\t * playing silence.\n\t */\n#ifdef DIAGNOSTIC\n\tif (cb->copying) {\n\t\tprintf(\"audio_drain: copying in progress!?!\\n\");\n\t\tcb->copying = 0;\n\t}\n#endif\n\tdrops = cb->drops;\n\terror = 0;\n\ts = splaudio();\n\twhile (cb->drops == drops && !error) {\n\t\tDPRINTF((\"audio_drain: used=%d, drops=%ld\\n\", sc->sc_pr.used, cb->drops));\n\t\t/*\n\t\t * When the process is exiting, it ignores all signals and\n\t\t * we can't interrupt this sleep, so we set a timeout just in case.\n\t\t */\n\t\terror = audio_sleep_timo(&sc->sc_wchan, \"aud_dr\", 30*hz);\n\t}\n\tsplx(s);\n\treturn error;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_sleep_timo",
          "args": [
            "&sc->sc_wchan",
            "\"aud_dr\"",
            "30*hz"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "audio_sleep_timo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "733-754",
          "snippet": "static __inline int\naudio_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"audio\";\n\n        DPRINTFN(3, (\"audio_sleep_timo: chan=%p, label=%s, timo=%d\\n\", \n                    chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef AUDIO_DEBUG\n\tif (st != 0)\n\t    printf(\"audio_sleep: woke up st=%d\\n\", st);\n#endif\n\treturn (st);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline int\naudio_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"audio\";\n\n        DPRINTFN(3, (\"audio_sleep_timo: chan=%p, label=%s, timo=%d\\n\", \n                    chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef AUDIO_DEBUG\n\tif (st != 0)\n\t    printf(\"audio_sleep: woke up st=%d\\n\", st);\n#endif\n\treturn (st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_drain: used=%d, drops=%ld\\n\", sc->sc_pr.used, cb->drops)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio_drain: copying in progress!?!\\n\""
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiostartp",
          "args": [
            "sc"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "audiostartp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1717-1743",
          "snippet": "int\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiostartp(sc)\n\tstruct audio_softc *sc;\n{\n\tint error;\n    \n    \tDPRINTF((\"audiostartp: start=%p used=%d(hi=%d) mmapped=%d\\n\", \n\t\t sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,\n\t\t sc->sc_pr.mmapped));\n    \n\tif (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)\n\t\treturn 0;\n\n\tif (sc->hw_if->trigger_output)\n\t\terror = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t    sc->sc_pr.end, sc->sc_pr.blksize,\n\t\t    audio_pint, (void *)sc, &sc->sc_pparams);\n\telse\n\t\terror = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,\n\t\t    sc->sc_pr.blksize, audio_pint, (void *)sc);\n\tif (error) {\n\t\tDPRINTF((\"audiostartp failed: %d\\n\", error));\n\t    \treturn error;\n\t}\n\tsc->sc_pbus = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_fill_silence",
          "args": [
            "&sc->sc_pparams",
            "inp",
            "cc"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "audio_fill_silence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1191-1247",
          "snippet": "void\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_fill_silence(params, p, n)\n\tstruct audio_params *params;\n        u_char *p;\n        int n;\n{\n\tu_char auzero0, auzero1 = 0; /* initialize to please gcc */\n\tint nfill = 1;\n\n\tswitch (params->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t    \tauzero0 = 0x7f; \n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tauzero0 = 0x55;\n\t\tbreak;\n\tcase AUDIO_ENCODING_MPEG_L1_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L1_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L1_SYSTEM:\n\tcase AUDIO_ENCODING_MPEG_L2_STREAM:\n\tcase AUDIO_ENCODING_MPEG_L2_PACKETS:\n\tcase AUDIO_ENCODING_MPEG_L2_SYSTEM:\n\tcase AUDIO_ENCODING_ADPCM: /* is this right XXX */\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tauzero0 = 0;\t/* fortunately this works for both 8 and 16 bits */\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tif (params->precision == 16) {\n\t\t\tnfill = 2;\n\t\t\tif (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {\n\t\t\t\tauzero0 = 0;\n\t\t\t\tauzero1 = 0x80;\n\t\t\t} else {\n\t\t\t\tauzero0 = 0x80;\n\t\t\t\tauzero1 = 0;\n\t\t\t}\n\t\t} else\n\t\t\tauzero0 = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"audio: bad encoding %d\\n\", params->encoding));\n\t\tauzero0 = 0;\n\t\tbreak;\n\t}\n\tif (nfill == 1) {\n\t\twhile (--n >= 0)\n\t\t\t*p++ = auzero0; /* XXX memset */\n\t} else /* nfill must be 2 */ {\n\t\twhile (n > 1) {\n\t\t\t*p++ = auzero0;\n\t\t\t*p++ = auzero1;\n\t\t\tn -= 2;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_drain: enter busy=%d used=%d\\n\", \n                 sc->sc_pbus, sc->sc_pr.used)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_drain(sc)\n\tstruct audio_softc *sc;\n{\n\tint error, drops;\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tint s;\n\n        DPRINTF((\"audio_drain: enter busy=%d used=%d\\n\", \n                 sc->sc_pbus, sc->sc_pr.used));\n\tif (sc->sc_pr.mmapped || sc->sc_pr.used <= 0)\n\t\treturn 0;\n\tif (!sc->sc_pbus) {\n\t\t/* We've never started playing, probably because the\n\t\t * block was too short.  Pad it and start now.\n\t\t */\n\t\tint cc;\n\t\tu_char *inp = cb->inp;\n\n\t\tcc = cb->blksize - (inp - cb->start) % cb->blksize;\n\t\taudio_fill_silence(&sc->sc_pparams, inp, cc);\n\t\tinp += cc;\n\t\tif (inp >= cb->end)\n\t\t\tinp = cb->start;\n\t\ts = splaudio();\n\t\tcb->used += cc;\n\t\tcb->inp = inp;\n\t\terror = audiostartp(sc);\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/* \n\t * Play until a silence block has been played, then we\n\t * know all has been drained.\n\t * XXX This should be done some other way to avoid\n\t * playing silence.\n\t */\n#ifdef DIAGNOSTIC\n\tif (cb->copying) {\n\t\tprintf(\"audio_drain: copying in progress!?!\\n\");\n\t\tcb->copying = 0;\n\t}\n#endif\n\tdrops = cb->drops;\n\terror = 0;\n\ts = splaudio();\n\twhile (cb->drops == drops && !error) {\n\t\tDPRINTF((\"audio_drain: used=%d, drops=%ld\\n\", sc->sc_pr.used, cb->drops));\n\t\t/*\n\t\t * When the process is exiting, it ignores all signals and\n\t\t * we can't interrupt this sleep, so we set a timeout just in case.\n\t\t */\n\t\terror = audio_sleep_timo(&sc->sc_wchan, \"aud_dr\", 30*hz);\n\t}\n\tsplx(s);\n\treturn error;\n}"
  },
  {
    "function_name": "audio_init_play",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "902-912",
    "snippet": "void\naudio_init_play(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tsc->sc_wstamp = sc->sc_pr.stamp;\n\tif (sc->hw_if->speaker_ctl)\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_ON);\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->speaker_ctl",
          "args": [
            "sc->hw_hdl",
            "SPKR_ON"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_init_play(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tsc->sc_wstamp = sc->sc_pr.stamp;\n\tif (sc->hw_if->speaker_ctl)\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_ON);\n\tsplx(s);\n}"
  },
  {
    "function_name": "audio_init_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "887-897",
    "snippet": "void\naudio_init_record(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->hw_if->speaker_ctl &&\n\t    (!sc->sc_full_duplex || (sc->sc_mode & AUMODE_PLAY) == 0))\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_OFF);\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->speaker_ctl",
          "args": [
            "sc->hw_hdl",
            "SPKR_OFF"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_init_record(sc)\n\tstruct audio_softc *sc;\n{\n\tint s = splaudio();\n\n\tif (sc->hw_if->speaker_ctl &&\n\t    (!sc->sc_full_duplex || (sc->sc_mode & AUMODE_PLAY) == 0))\n\t\tsc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_OFF);\n\tsplx(s);\n}"
  },
  {
    "function_name": "audio_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "776-882",
    "snippet": "int\naudio_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\tint error;\n\tint mode;\n\tstruct audio_hw_if *hw;\n\tstruct audio_info ai;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\thw = sc->hw_if;\n\tif (!hw)\n\t\treturn ENXIO;\n\n\tDPRINTF((\"audio_open: dev=0x%x flags=0x%x sc=%p hdl=%p\\n\", dev, flags, sc, sc->hw_hdl));\n\n\tif (ISDEVAUDIOCTL(dev))\n\t\treturn 0;\n\n\tif ((sc->sc_open & (AUOPEN_READ|AUOPEN_WRITE)) != 0)\n\t\treturn (EBUSY);\n\n\terror = hw->open(sc->hw_hdl, flags);\n\tif (error)\n\t\treturn (error);\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_rchan = 0;\n\tsc->sc_wchan = 0;\n\tsc->sc_blkset = 0; /* Block sizes not set yet */\n\tsc->sc_sil_count = 0;\n\tsc->sc_rbus = 0;\n\tsc->sc_pbus = 0;\n\tsc->sc_eof = 0;\n\tsc->sc_playdrop = 0;\n\n\tsc->sc_full_duplex = 0;\n/* doesn't always work right on SB.\n\t\t(flags & (FWRITE|FREAD)) == (FWRITE|FREAD) &&\n\t\t(hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX);\n*/\n\n\tmode = 0;\n\tif (flags & FREAD) {\n\t\tsc->sc_open |= AUOPEN_READ;\n\t\tmode |= AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open |= AUOPEN_WRITE;\n\t\tmode |= AUMODE_PLAY | AUMODE_PLAY_ALL;\n\t}\n\n\t/*\n\t * Multiplex device: /dev/audio (MU-Law) and /dev/sound (linear)\n\t * The /dev/audio is always (re)set to 8-bit MU-Law mono\n\t * For the other devices, you get what they were last set to.\n\t */\n\tif (ISDEVAUDIO(dev)) {\n\t\t/* /dev/audio */\n\t\tsc->sc_rparams = audio_default;\n\t\tsc->sc_pparams = audio_default;\n\t}\n#ifdef DIAGNOSTIC\n\t/*\n\t * Sample rate and precision are supposed to be set to proper\n\t * default values by the hardware driver, so that it may give\n\t * us these values.\n\t */\n\tif (sc->sc_rparams.precision == 0 || sc->sc_pparams.precision == 0) {\n\t\tprintf(\"audio_open: 0 precision\\n\");\n\t\treturn EINVAL;\n\t}\n#endif\n\n\tAUDIO_INITINFO(&ai);\n\tai.record.sample_rate = sc->sc_rparams.sample_rate;\n\tai.record.encoding    = sc->sc_rparams.encoding;\n\tai.record.channels    = sc->sc_rparams.channels;\n\tai.record.precision   = sc->sc_rparams.precision;\n\tai.play.sample_rate   = sc->sc_pparams.sample_rate;\n\tai.play.encoding      = sc->sc_pparams.encoding;\n\tai.play.channels      = sc->sc_pparams.channels;\n\tai.play.precision     = sc->sc_pparams.precision;\n\tai.mode\t\t      = mode;\n\tsc->sc_pr.blksize = sc->sc_rr.blksize = 0; /* force recalculation */\n\terror = audiosetinfo(sc, &ai);\n\tif (error)\n\t\tgoto bad;\n\n\tDPRINTF((\"audio_open: done sc_mode = 0x%x\\n\", sc->sc_mode));\n\t\n\treturn 0;\n\nbad:\n\thw->close(sc->hw_hdl);\n\tsc->sc_open = 0;\n\tsc->sc_mode = 0;\n\tsc->sc_full_duplex = 0;\n\treturn error;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw->close",
          "args": [
            "sc->hw_hdl"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_open: done sc_mode = 0x%x\\n\", sc->sc_mode)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audiosetinfo",
          "args": [
            "sc",
            "&ai"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "audiosetinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2334-2630",
          "snippet": "int\naudiosetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tint cleared;\n\tint s, setmode, modechange = 0;\n\tint error;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params pp, rp;\n\tint np, nr;\n\tunsigned int blks;\n\tint oldpblksize, oldrblksize;\n\tint rbus, pbus;\n\tu_int gain;\n\tu_char balance;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\n\trbus = sc->sc_rbus;\n\tpbus = sc->sc_pbus;\n\terror = 0;\n\tcleared = 0;\n\n\tpp = sc->sc_pparams;\t/* Temporary encoding storage in */\n\trp = sc->sc_rparams;\t/* case setting the modes fails. */\n\tnr = np = 0;\n\n\tif (p->sample_rate != ~0) {\n\t\tpp.sample_rate = p->sample_rate;\n\t\tnp++;\n\t}\n\tif (r->sample_rate != ~0) {\n\t\trp.sample_rate = r->sample_rate;\n\t\tnr++;\n\t}\n\tif (p->encoding != ~0) {\n\t\tpp.encoding = p->encoding;\n\t\tnp++;\n\t}\t\n\tif (r->encoding != ~0) {\n\t\trp.encoding = r->encoding;\n\t\tnr++;\n\t}\n\tif (p->precision != ~0) {\n\t\tpp.precision = p->precision;\n\t\tnp++;\n\t}\n\tif (r->precision != ~0) {\n\t\trp.precision = r->precision;\n\t\tnr++;\n\t}\n\tif (p->channels != ~0) {\n\t\tpp.channels = p->channels;\n\t\tnp++;\n\t}\n\tif (r->channels != ~0) {\n\t\trp.channels = r->channels;\n\t\tnr++;\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug && nr)\n\t    audio_print_params(\"Setting record params\", &rp);\n\tif (audiodebug && np)\n\t    audio_print_params(\"Setting play params\", &pp);\n#endif\n\tif (nr && (error = audio_check_params(&rp)))\n\t\treturn error;\n\tif (np && (error = audio_check_params(&pp)))\n\t\treturn error;\n\tsetmode = 0;\n\tif (nr) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\trp.sw_code = 0;\n\t\trp.factor = 1;\n\t\tsetmode |= AUMODE_RECORD;\n\t}\n\tif (np) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tpp.sw_code = 0;\n\t\tpp.factor = 1;\n\t\tsetmode |= AUMODE_PLAY;\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tsc->sc_mode = ai->mode;\n\t\tif (sc->sc_mode & AUMODE_PLAY_ALL)\n\t\t\tsc->sc_mode |= AUMODE_PLAY;\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_full_duplex)\n\t\t\t/* Play takes precedence */\n\t\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\n\tif (modechange) {\n\t\tint indep = hw->get_props(sc->hw_hdl) & AUDIO_PROP_INDEPENDENT;\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD)\n\t\t\t\tpp = rp;\n\t\t\telse if (setmode == AUMODE_PLAY)\n\t\t\t\trp = pp;\n\t\t}\n\t\terror = hw->set_params(sc->hw_hdl, setmode,\n\t\t    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD), &pp, &rp);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD) {\n\t\t\t\tpp.sample_rate = rp.sample_rate;\n\t\t\t\tpp.encoding    = rp.encoding;\n\t\t\t\tpp.channels    = rp.channels;\n\t\t\t\tpp.precision   = rp.precision;\n\t\t\t} else if (setmode == AUMODE_PLAY) {\n\t\t\t\trp.sample_rate = pp.sample_rate;\n\t\t\t\trp.encoding    = pp.encoding;\n\t\t\t\trp.channels    = pp.channels;\n\t\t\t\trp.precision   = pp.precision;\n\t\t\t}\n\t\t}\n\t\tsc->sc_rparams = rp;\n\t\tsc->sc_pparams = pp;\n\t}\n\n\toldpblksize = sc->sc_pr.blksize;\n\toldrblksize = sc->sc_rr.blksize;\n\t/* Play params can affect the record params, so recalculate blksize. */\n\tif (nr || np) {\n\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug > 1 && nr)\n\t    audio_print_params(\"After setting record params\", &sc->sc_rparams);\n\tif (audiodebug > 1 && np)\n\t    audio_print_params(\"After setting play params\", &sc->sc_pparams);\n#endif\n\n\tif (p->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_outports, p->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_inports, r->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (p->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, p->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, r->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\t\n\tif (p->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, gain, p->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, gain, r->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (ai->monitor_gain != ~0 &&\n\t    sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = ai->monitor_gain;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (p->pause != (u_char)~0) {\n\t\tsc->sc_pr.pause = p->pause;\n\t\tif (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartp(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\tif (r->pause != (u_char)~0) {\n\t\tsc->sc_rr.pause = r->pause;\n\t\tif (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartr(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (ai->blocksize != ~0) {\n\t\t/* Block size specified explicitly. */\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\tif (ai->blocksize == 0) {\n\t\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t\t\tsc->sc_blkset = 0;\n\t\t} else {\n\t\t\tint bs = ai->blocksize;\n\t\t\tif (hw->round_blocksize)\n\t\t\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\t\t\tsc->sc_pr.blksize = sc->sc_rr.blksize = bs;\n\t\t\tsc->sc_blkset = 1;\n\t\t}\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (sc->sc_mode & AUMODE_PLAY)\n\t\t\taudio_init_play(sc);\n\t\tif (sc->sc_mode & AUMODE_RECORD)\n\t\t\taudio_init_record(sc);\n\t}\n\n\tif (hw->commit_settings) {\n\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\tif (cleared) {\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) goto err;\n\t\tif (sc->sc_pr.blksize != oldpblksize ||\n\t\t    sc->sc_rr.blksize != oldrblksize)\n\t\t\taudio_calcwater(sc);\n\t\tif ((sc->sc_mode & AUMODE_PLAY) &&\n\t\t    pbus && !sc->sc_pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error && \n\t\t    (sc->sc_mode & AUMODE_RECORD) &&\n\t\t    rbus && !sc->sc_rbus)\n\t\t\terror = audiostartr(sc);\n\terr:\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t\n\t/* Change water marks after initializing the buffers. */\n\tif (ai->hiwat != ~0) {\n\t\tblks = ai->hiwat;\n\t\tif (blks > sc->sc_pr.maxblks)\n\t\t\tblks = sc->sc_pr.maxblks;\n\t\tif (blks < 2)\n\t\t\tblks = 2;\n\t\tsc->sc_pr.usedhigh = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->lowat != ~0) {\n\t\tblks = ai->lowat;\n\t\tif (blks > sc->sc_pr.maxblks - 1)\n\t\t\tblks = sc->sc_pr.maxblks - 1;\n\t\tsc->sc_pr.usedlow = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->hiwat != ~0 || ai->lowat != ~0) {\n\t\tif (sc->sc_pr.usedlow > sc->sc_pr.usedhigh - sc->sc_pr.blksize)\n\t\t\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh - sc->sc_pr.blksize;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiosetinfo(sc, ai)\n\tstruct audio_softc *sc;\n\tstruct audio_info *ai;\n{\n\tstruct audio_prinfo *r = &ai->record, *p = &ai->play;\n\tint cleared;\n\tint s, setmode, modechange = 0;\n\tint error;\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params pp, rp;\n\tint np, nr;\n\tunsigned int blks;\n\tint oldpblksize, oldrblksize;\n\tint rbus, pbus;\n\tu_int gain;\n\tu_char balance;\n\t\n\tif (hw == 0)\t\t/* HW has not attached */\n\t\treturn(ENXIO);\n\n\trbus = sc->sc_rbus;\n\tpbus = sc->sc_pbus;\n\terror = 0;\n\tcleared = 0;\n\n\tpp = sc->sc_pparams;\t/* Temporary encoding storage in */\n\trp = sc->sc_rparams;\t/* case setting the modes fails. */\n\tnr = np = 0;\n\n\tif (p->sample_rate != ~0) {\n\t\tpp.sample_rate = p->sample_rate;\n\t\tnp++;\n\t}\n\tif (r->sample_rate != ~0) {\n\t\trp.sample_rate = r->sample_rate;\n\t\tnr++;\n\t}\n\tif (p->encoding != ~0) {\n\t\tpp.encoding = p->encoding;\n\t\tnp++;\n\t}\t\n\tif (r->encoding != ~0) {\n\t\trp.encoding = r->encoding;\n\t\tnr++;\n\t}\n\tif (p->precision != ~0) {\n\t\tpp.precision = p->precision;\n\t\tnp++;\n\t}\n\tif (r->precision != ~0) {\n\t\trp.precision = r->precision;\n\t\tnr++;\n\t}\n\tif (p->channels != ~0) {\n\t\tpp.channels = p->channels;\n\t\tnp++;\n\t}\n\tif (r->channels != ~0) {\n\t\trp.channels = r->channels;\n\t\tnr++;\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug && nr)\n\t    audio_print_params(\"Setting record params\", &rp);\n\tif (audiodebug && np)\n\t    audio_print_params(\"Setting play params\", &pp);\n#endif\n\tif (nr && (error = audio_check_params(&rp)))\n\t\treturn error;\n\tif (np && (error = audio_check_params(&pp)))\n\t\treturn error;\n\tsetmode = 0;\n\tif (nr) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\trp.sw_code = 0;\n\t\trp.factor = 1;\n\t\tsetmode |= AUMODE_RECORD;\n\t}\n\tif (np) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tpp.sw_code = 0;\n\t\tpp.factor = 1;\n\t\tsetmode |= AUMODE_PLAY;\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tmodechange = cleared = 1;\n\t\tsc->sc_mode = ai->mode;\n\t\tif (sc->sc_mode & AUMODE_PLAY_ALL)\n\t\t\tsc->sc_mode |= AUMODE_PLAY;\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_full_duplex)\n\t\t\t/* Play takes precedence */\n\t\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\n\tif (modechange) {\n\t\tint indep = hw->get_props(sc->hw_hdl) & AUDIO_PROP_INDEPENDENT;\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD)\n\t\t\t\tpp = rp;\n\t\t\telse if (setmode == AUMODE_PLAY)\n\t\t\t\trp = pp;\n\t\t}\n\t\terror = hw->set_params(sc->hw_hdl, setmode,\n\t\t    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD), &pp, &rp);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tif (!indep) {\n\t\t\tif (setmode == AUMODE_RECORD) {\n\t\t\t\tpp.sample_rate = rp.sample_rate;\n\t\t\t\tpp.encoding    = rp.encoding;\n\t\t\t\tpp.channels    = rp.channels;\n\t\t\t\tpp.precision   = rp.precision;\n\t\t\t} else if (setmode == AUMODE_PLAY) {\n\t\t\t\trp.sample_rate = pp.sample_rate;\n\t\t\t\trp.encoding    = pp.encoding;\n\t\t\t\trp.channels    = pp.channels;\n\t\t\t\trp.precision   = pp.precision;\n\t\t\t}\n\t\t}\n\t\tsc->sc_rparams = rp;\n\t\tsc->sc_pparams = pp;\n\t}\n\n\toldpblksize = sc->sc_pr.blksize;\n\toldrblksize = sc->sc_rr.blksize;\n\t/* Play params can affect the record params, so recalculate blksize. */\n\tif (nr || np) {\n\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t}\n#ifdef AUDIO_DEBUG\n\tif (audiodebug > 1 && nr)\n\t    audio_print_params(\"After setting record params\", &sc->sc_rparams);\n\tif (audiodebug > 1 && np)\n\t    audio_print_params(\"After setting play params\", &sc->sc_pparams);\n#endif\n\n\tif (p->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_outports, p->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->port != ~0) {\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\terror = au_set_port(sc, &sc->sc_inports, r->port);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (p->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, p->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->gain != ~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, r->gain, balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\t\n\tif (p->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_outports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_outports, gain, p->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\tif (r->balance != (u_char)~0) {\n\t\tau_get_gain(sc, &sc->sc_inports, &gain, &balance);\n\t\terror = au_set_gain(sc, &sc->sc_inports, gain, r->balance);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (ai->monitor_gain != ~0 &&\n\t    sc->sc_monitor_port != -1) {\n\t\tmixer_ctrl_t ct;\n\t\t\n\t\tct.dev = sc->sc_monitor_port;\n\t\tct.type = AUDIO_MIXER_VALUE;\n\t\tct.un.value.num_channels = 1;\n\t\tct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = ai->monitor_gain;\n\t\terror = sc->hw_if->get_port(sc->hw_hdl, &ct);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\tif (p->pause != (u_char)~0) {\n\t\tsc->sc_pr.pause = p->pause;\n\t\tif (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartp(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\tif (r->pause != (u_char)~0) {\n\t\tsc->sc_rr.pause = r->pause;\n\t\tif (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {\n\t\t\ts = splaudio();\n\t\t\terror = audiostartr(sc);\n\t\t\tsplx(s);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (ai->blocksize != ~0) {\n\t\t/* Block size specified explicitly. */\n\t\tif (!cleared)\n\t\t\taudio_clear(sc);\n\t\tcleared = 1;\n\n\t\tif (ai->blocksize == 0) {\n\t\t\taudio_calc_blksize(sc, AUMODE_RECORD);\n\t\t\taudio_calc_blksize(sc, AUMODE_PLAY);\n\t\t\tsc->sc_blkset = 0;\n\t\t} else {\n\t\t\tint bs = ai->blocksize;\n\t\t\tif (hw->round_blocksize)\n\t\t\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\t\t\tsc->sc_pr.blksize = sc->sc_rr.blksize = bs;\n\t\t\tsc->sc_blkset = 1;\n\t\t}\n\t}\n\n\tif (ai->mode != ~0) {\n\t\tif (sc->sc_mode & AUMODE_PLAY)\n\t\t\taudio_init_play(sc);\n\t\tif (sc->sc_mode & AUMODE_RECORD)\n\t\t\taudio_init_record(sc);\n\t}\n\n\tif (hw->commit_settings) {\n\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\tif (cleared) {\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) goto err;\n\t\tif (sc->sc_pr.blksize != oldpblksize ||\n\t\t    sc->sc_rr.blksize != oldrblksize)\n\t\t\taudio_calcwater(sc);\n\t\tif ((sc->sc_mode & AUMODE_PLAY) &&\n\t\t    pbus && !sc->sc_pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error && \n\t\t    (sc->sc_mode & AUMODE_RECORD) &&\n\t\t    rbus && !sc->sc_rbus)\n\t\t\terror = audiostartr(sc);\n\terr:\n\t\tsplx(s);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t\n\t/* Change water marks after initializing the buffers. */\n\tif (ai->hiwat != ~0) {\n\t\tblks = ai->hiwat;\n\t\tif (blks > sc->sc_pr.maxblks)\n\t\t\tblks = sc->sc_pr.maxblks;\n\t\tif (blks < 2)\n\t\t\tblks = 2;\n\t\tsc->sc_pr.usedhigh = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->lowat != ~0) {\n\t\tblks = ai->lowat;\n\t\tif (blks > sc->sc_pr.maxblks - 1)\n\t\t\tblks = sc->sc_pr.maxblks - 1;\n\t\tsc->sc_pr.usedlow = blks * sc->sc_pr.blksize;\n\t}\n\tif (ai->hiwat != ~0 || ai->lowat != ~0) {\n\t\tif (sc->sc_pr.usedlow > sc->sc_pr.usedhigh - sc->sc_pr.blksize)\n\t\t\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh - sc->sc_pr.blksize;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIO_INITINFO",
          "args": [
            "&ai"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio_open: 0 precision\\n\""
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISDEVAUDIO",
          "args": [
            "dev"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->open",
          "args": [
            "sc->hw_hdl",
            "flags"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISDEVAUDIOCTL",
          "args": [
            "dev"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_open: dev=0x%x flags=0x%x sc=%p hdl=%p\\n\", dev, flags, sc, sc->hw_hdl)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIOUNIT",
          "args": [
            "dev"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\tint error;\n\tint mode;\n\tstruct audio_hw_if *hw;\n\tstruct audio_info ai;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\thw = sc->hw_if;\n\tif (!hw)\n\t\treturn ENXIO;\n\n\tDPRINTF((\"audio_open: dev=0x%x flags=0x%x sc=%p hdl=%p\\n\", dev, flags, sc, sc->hw_hdl));\n\n\tif (ISDEVAUDIOCTL(dev))\n\t\treturn 0;\n\n\tif ((sc->sc_open & (AUOPEN_READ|AUOPEN_WRITE)) != 0)\n\t\treturn (EBUSY);\n\n\terror = hw->open(sc->hw_hdl, flags);\n\tif (error)\n\t\treturn (error);\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_rchan = 0;\n\tsc->sc_wchan = 0;\n\tsc->sc_blkset = 0; /* Block sizes not set yet */\n\tsc->sc_sil_count = 0;\n\tsc->sc_rbus = 0;\n\tsc->sc_pbus = 0;\n\tsc->sc_eof = 0;\n\tsc->sc_playdrop = 0;\n\n\tsc->sc_full_duplex = 0;\n/* doesn't always work right on SB.\n\t\t(flags & (FWRITE|FREAD)) == (FWRITE|FREAD) &&\n\t\t(hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX);\n*/\n\n\tmode = 0;\n\tif (flags & FREAD) {\n\t\tsc->sc_open |= AUOPEN_READ;\n\t\tmode |= AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open |= AUOPEN_WRITE;\n\t\tmode |= AUMODE_PLAY | AUMODE_PLAY_ALL;\n\t}\n\n\t/*\n\t * Multiplex device: /dev/audio (MU-Law) and /dev/sound (linear)\n\t * The /dev/audio is always (re)set to 8-bit MU-Law mono\n\t * For the other devices, you get what they were last set to.\n\t */\n\tif (ISDEVAUDIO(dev)) {\n\t\t/* /dev/audio */\n\t\tsc->sc_rparams = audio_default;\n\t\tsc->sc_pparams = audio_default;\n\t}\n#ifdef DIAGNOSTIC\n\t/*\n\t * Sample rate and precision are supposed to be set to proper\n\t * default values by the hardware driver, so that it may give\n\t * us these values.\n\t */\n\tif (sc->sc_rparams.precision == 0 || sc->sc_pparams.precision == 0) {\n\t\tprintf(\"audio_open: 0 precision\\n\");\n\t\treturn EINVAL;\n\t}\n#endif\n\n\tAUDIO_INITINFO(&ai);\n\tai.record.sample_rate = sc->sc_rparams.sample_rate;\n\tai.record.encoding    = sc->sc_rparams.encoding;\n\tai.record.channels    = sc->sc_rparams.channels;\n\tai.record.precision   = sc->sc_rparams.precision;\n\tai.play.sample_rate   = sc->sc_pparams.sample_rate;\n\tai.play.encoding      = sc->sc_pparams.encoding;\n\tai.play.channels      = sc->sc_pparams.channels;\n\tai.play.precision     = sc->sc_pparams.precision;\n\tai.mode\t\t      = mode;\n\tsc->sc_pr.blksize = sc->sc_rr.blksize = 0; /* force recalculation */\n\terror = audiosetinfo(sc, &ai);\n\tif (error)\n\t\tgoto bad;\n\n\tDPRINTF((\"audio_open: done sc_mode = 0x%x\\n\", sc->sc_mode));\n\t\n\treturn 0;\n\nbad:\n\thw->close(sc->hw_hdl);\n\tsc->sc_open = 0;\n\tsc->sc_mode = 0;\n\tsc->sc_full_duplex = 0;\n\treturn error;\n}"
  },
  {
    "function_name": "audio_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "765-774",
    "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "chan"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
  },
  {
    "function_name": "audio_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "756-762",
    "snippet": "static __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_sleep_timo",
          "args": [
            "chan",
            "label",
            "0"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "audio_sleep_timo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "733-754",
          "snippet": "static __inline int\naudio_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"audio\";\n\n        DPRINTFN(3, (\"audio_sleep_timo: chan=%p, label=%s, timo=%d\\n\", \n                    chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef AUDIO_DEBUG\n\tif (st != 0)\n\t    printf(\"audio_sleep: woke up st=%d\\n\", st);\n#endif\n\treturn (st);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline int\naudio_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"audio\";\n\n        DPRINTFN(3, (\"audio_sleep_timo: chan=%p, label=%s, timo=%d\\n\", \n                    chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef AUDIO_DEBUG\n\tif (st != 0)\n\t    printf(\"audio_sleep: woke up st=%d\\n\", st);\n#endif\n\treturn (st);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}"
  },
  {
    "function_name": "audio_sleep_timo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "733-754",
    "snippet": "static __inline int\naudio_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"audio\";\n\n        DPRINTFN(3, (\"audio_sleep_timo: chan=%p, label=%s, timo=%d\\n\", \n                    chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef AUDIO_DEBUG\n\tif (st != 0)\n\t    printf(\"audio_sleep: woke up st=%d\\n\", st);\n#endif\n\treturn (st);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio_sleep: woke up st=%d\\n\"",
            "st"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "chan",
            "PWAIT | PCATCH",
            "label",
            "timo"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"audio_sleep_timo: chan=%p, label=%s, timo=%d\\n\", \n                    chan, label, timo)"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline int\naudio_sleep_timo(chan, label, timo)\n\tint *chan;\n\tchar *label;\n\tint timo;\n{\n\tint st;\n\n\tif (!label)\n\t\tlabel = \"audio\";\n\n        DPRINTFN(3, (\"audio_sleep_timo: chan=%p, label=%s, timo=%d\\n\", \n                    chan, label, timo));\n\t*chan = 1;\n\tst = tsleep(chan, PWAIT | PCATCH, label, timo);\n\t*chan = 0;\n#ifdef AUDIO_DEBUG\n\tif (st != 0)\n\t    printf(\"audio_sleep: woke up st=%d\\n\", st);\n#endif\n\treturn (st);\n}"
  },
  {
    "function_name": "audio_calcwater",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "721-731",
    "snippet": "void\naudio_calcwater(sc)\n\tstruct audio_softc *sc;\n{\n\tsc->sc_pr.usedhigh = sc->sc_pr.end - sc->sc_pr.start;\n\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh * 3 / 4;\t/* set lowater at 75% */\n\tif (sc->sc_pr.usedlow == sc->sc_pr.usedhigh)\n\t\tsc->sc_pr.usedlow -= sc->sc_pr.blksize;\n\tsc->sc_rr.usedhigh = sc->sc_pr.end - sc->sc_pr.start - sc->sc_pr.blksize;\n\tsc->sc_rr.usedlow = 0;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_calcwater(sc)\n\tstruct audio_softc *sc;\n{\n\tsc->sc_pr.usedhigh = sc->sc_pr.end - sc->sc_pr.start;\n\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh * 3 / 4;\t/* set lowater at 75% */\n\tif (sc->sc_pr.usedlow == sc->sc_pr.usedhigh)\n\t\tsc->sc_pr.usedlow -= sc->sc_pr.blksize;\n\tsc->sc_rr.usedhigh = sc->sc_pr.end - sc->sc_pr.start - sc->sc_pr.blksize;\n\tsc->sc_rr.usedlow = 0;\n}"
  },
  {
    "function_name": "audio_initbufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "672-719",
    "snippet": "int\naudio_initbufs(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"audio_initbufs: mode=0x%x\\n\", sc->sc_mode));\n\taudio_init_ringbuffer(&sc->sc_rr);\n\tif (hw->init_input && (sc->sc_mode & AUMODE_RECORD)) {\n\t\terror = hw->init_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t\t\t       sc->sc_rr.end - sc->sc_rr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\taudio_init_ringbuffer(&sc->sc_pr);\n\tsc->sc_sil_count = 0;\n\tif (hw->init_output && (sc->sc_mode & AUMODE_PLAY)) {\n\t\terror = hw->init_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t\t\t\tsc->sc_pr.end - sc->sc_pr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n#define double u_long\n\tsc->sc_pnintr = 0;\n\tsc->sc_pblktime = (u_long)(\n\t    (double)sc->sc_pr.blksize * 100000 / \n\t    (double)(sc->sc_pparams.precision / NBBY * \n                     sc->sc_pparams.channels * \n\t\t     sc->sc_pparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: play blktime = %lu for %d\\n\", \n\t\t sc->sc_pblktime, sc->sc_pr.blksize));\n\tsc->sc_rnintr = 0;\n\tsc->sc_rblktime = (u_long)(\n\t    (double)sc->sc_rr.blksize * 100000 / \n\t    (double)(sc->sc_rparams.precision / NBBY * \n                     sc->sc_rparams.channels * \n\t\t     sc->sc_rparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: record blktime = %lu for %d\\n\", \n\t\t sc->sc_rblktime, sc->sc_rr.blksize));\n#undef double\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [
      "#define double u_long"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio: record blktime = %lu for %d\\n\", \n\t\t sc->sc_rblktime, sc->sc_rr.blksize)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(double)sc->sc_rr.blksize * 100000 / \n\t    (double)(sc->sc_rparams.precision / NBBY * \n                     sc->sc_rparams.channels * \n\t\t     sc->sc_rparams.sample_rate)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio: play blktime = %lu for %d\\n\", \n\t\t sc->sc_pblktime, sc->sc_pr.blksize)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(double)sc->sc_pr.blksize * 100000 / \n\t    (double)(sc->sc_pparams.precision / NBBY * \n                     sc->sc_pparams.channels * \n\t\t     sc->sc_pparams.sample_rate)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->init_output",
          "args": [
            "sc->hw_hdl",
            "sc->sc_pr.start",
            "sc->sc_pr.end - sc->sc_pr.start"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_init_ringbuffer",
          "args": [
            "&sc->sc_pr"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "audio_init_ringbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "643-670",
          "snippet": "void\naudio_init_ringbuffer(rp)\n\tstruct audio_ringbuffer *rp;\n{\n\tint nblks;\n\tint blksize = rp->blksize;\n\n\tif (blksize < AUMINBLK)\n\t\tblksize = AUMINBLK;\n\tnblks = rp->bufsize / blksize;\n\tif (nblks < AUMINNOBLK) {\n\t\tnblks = AUMINNOBLK;\n\t\tblksize = rp->bufsize / nblks;\n\t\tROUNDSIZE(blksize);\n\t}\n\tDPRINTF((\"audio_init_ringbuffer: blksize=%d\\n\", blksize));\n\trp->blksize = blksize;\n\trp->maxblks = nblks;\n\trp->used = 0;\n\trp->end = rp->start + nblks * blksize;\n\trp->inp = rp->outp = rp->start;\n\trp->stamp = 0;\n\trp->drops = 0;\n\trp->pause = 0;\n\trp->copying = 0;\n\trp->needfill = 0;\n\trp->mmapped = 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_init_ringbuffer(rp)\n\tstruct audio_ringbuffer *rp;\n{\n\tint nblks;\n\tint blksize = rp->blksize;\n\n\tif (blksize < AUMINBLK)\n\t\tblksize = AUMINBLK;\n\tnblks = rp->bufsize / blksize;\n\tif (nblks < AUMINNOBLK) {\n\t\tnblks = AUMINNOBLK;\n\t\tblksize = rp->bufsize / nblks;\n\t\tROUNDSIZE(blksize);\n\t}\n\tDPRINTF((\"audio_init_ringbuffer: blksize=%d\\n\", blksize));\n\trp->blksize = blksize;\n\trp->maxblks = nblks;\n\trp->used = 0;\n\trp->end = rp->start + nblks * blksize;\n\trp->inp = rp->outp = rp->start;\n\trp->stamp = 0;\n\trp->drops = 0;\n\trp->pause = 0;\n\trp->copying = 0;\n\trp->needfill = 0;\n\trp->mmapped = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw->init_input",
          "args": [
            "sc->hw_hdl",
            "sc->sc_rr.start",
            "sc->sc_rr.end - sc->sc_rr.start"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_initbufs: mode=0x%x\\n\", sc->sc_mode)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\n#define double u_long\n\nint\naudio_initbufs(sc)\n\tstruct audio_softc *sc;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error;\n\n\tDPRINTF((\"audio_initbufs: mode=0x%x\\n\", sc->sc_mode));\n\taudio_init_ringbuffer(&sc->sc_rr);\n\tif (hw->init_input && (sc->sc_mode & AUMODE_RECORD)) {\n\t\terror = hw->init_input(sc->hw_hdl, sc->sc_rr.start,\n\t\t\t\t       sc->sc_rr.end - sc->sc_rr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\taudio_init_ringbuffer(&sc->sc_pr);\n\tsc->sc_sil_count = 0;\n\tif (hw->init_output && (sc->sc_mode & AUMODE_PLAY)) {\n\t\terror = hw->init_output(sc->hw_hdl, sc->sc_pr.start,\n\t\t\t\t\tsc->sc_pr.end - sc->sc_pr.start);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n#ifdef AUDIO_INTR_TIME\n#define double u_long\n\tsc->sc_pnintr = 0;\n\tsc->sc_pblktime = (u_long)(\n\t    (double)sc->sc_pr.blksize * 100000 / \n\t    (double)(sc->sc_pparams.precision / NBBY * \n                     sc->sc_pparams.channels * \n\t\t     sc->sc_pparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: play blktime = %lu for %d\\n\", \n\t\t sc->sc_pblktime, sc->sc_pr.blksize));\n\tsc->sc_rnintr = 0;\n\tsc->sc_rblktime = (u_long)(\n\t    (double)sc->sc_rr.blksize * 100000 / \n\t    (double)(sc->sc_rparams.precision / NBBY * \n                     sc->sc_rparams.channels * \n\t\t     sc->sc_rparams.sample_rate)) * 10;\n\tDPRINTF((\"audio: record blktime = %lu for %d\\n\", \n\t\t sc->sc_rblktime, sc->sc_rr.blksize));\n#undef double\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audio_init_ringbuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "643-670",
    "snippet": "void\naudio_init_ringbuffer(rp)\n\tstruct audio_ringbuffer *rp;\n{\n\tint nblks;\n\tint blksize = rp->blksize;\n\n\tif (blksize < AUMINBLK)\n\t\tblksize = AUMINBLK;\n\tnblks = rp->bufsize / blksize;\n\tif (nblks < AUMINNOBLK) {\n\t\tnblks = AUMINNOBLK;\n\t\tblksize = rp->bufsize / nblks;\n\t\tROUNDSIZE(blksize);\n\t}\n\tDPRINTF((\"audio_init_ringbuffer: blksize=%d\\n\", blksize));\n\trp->blksize = blksize;\n\trp->maxblks = nblks;\n\trp->used = 0;\n\trp->end = rp->start + nblks * blksize;\n\trp->inp = rp->outp = rp->start;\n\trp->stamp = 0;\n\trp->drops = 0;\n\trp->pause = 0;\n\trp->copying = 0;\n\trp->needfill = 0;\n\trp->mmapped = 0;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_init_ringbuffer: blksize=%d\\n\", blksize)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUNDSIZE",
          "args": [
            "blksize"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_init_ringbuffer(rp)\n\tstruct audio_ringbuffer *rp;\n{\n\tint nblks;\n\tint blksize = rp->blksize;\n\n\tif (blksize < AUMINBLK)\n\t\tblksize = AUMINBLK;\n\tnblks = rp->bufsize / blksize;\n\tif (nblks < AUMINNOBLK) {\n\t\tnblks = AUMINNOBLK;\n\t\tblksize = rp->bufsize / nblks;\n\t\tROUNDSIZE(blksize);\n\t}\n\tDPRINTF((\"audio_init_ringbuffer: blksize=%d\\n\", blksize));\n\trp->blksize = blksize;\n\trp->maxblks = nblks;\n\trp->used = 0;\n\trp->end = rp->start + nblks * blksize;\n\trp->inp = rp->outp = rp->start;\n\trp->stamp = 0;\n\trp->drops = 0;\n\trp->pause = 0;\n\trp->copying = 0;\n\trp->needfill = 0;\n\trp->mmapped = 0;\n}"
  },
  {
    "function_name": "audiommap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "622-638",
    "snippet": "int\naudiommap(dev, off, prot)\n\tdev_t dev;\n\tint off, prot;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_mmap(dev, off, prot));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_mmap",
          "args": [
            "dev",
            "off",
            "prot"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "audio_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1632-1690",
          "snippet": "int\naudio_mmap(dev, off, prot)\n\tdev_t dev;\n\tint off, prot;\n{\n\tint s;\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb;\n\n\tDPRINTF((\"audio_mmap: off=%d, prot=%d\\n\", off, prot));\n\n\tif (!(hw->get_props(sc->hw_hdl) & AUDIO_PROP_MMAP) || !hw->mappage)\n\t\treturn -1;\n#if 0\n/* XXX\n * The idea here was to use the protection to determine if\n * we are mapping the read or write buffer, but it fails.\n * The VM system is broken in (at least) two ways.\n * 1) If you map memory VM_PROT_WRITE you SIGSEGV\n *    when writing to it, so VM_PROT_READ|VM_PROT_WRITE\n *    has to be used for mmapping the play buffer.\n * 2) Even if calling mmap() with VM_PROT_READ|VM_PROT_WRITE\n *    audio_mmap will get called at some point with VM_PROT_READ\n *    only.\n * So, alas, we always map the play buffer for now.\n */\n\tif (prot == (VM_PROT_READ|VM_PROT_WRITE) ||\n\t    prot == VM_PROT_WRITE)\n\t\tcb = &sc->sc_pr;\n\telse if (prot == VM_PROT_READ)\n\t\tcb = &sc->sc_rr;\n\telse\n\t\treturn -1;\n#else\n\tcb = &sc->sc_pr;\n#endif\n\n\tif ((u_int)off >= cb->bufsize)\n\t\treturn -1;\n\tif (!cb->mmapped) {\n\t\tcb->mmapped = 1;\n\t\tif (cb == &sc->sc_pr) {\n\t\t\taudio_fill_silence(&sc->sc_pparams, cb->start, cb->bufsize);\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_pbus)\n\t\t\t\t(void)audiostartp(sc);\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_rbus)\n\t\t\t\t(void)audiostartr(sc);\n\t\t\tsplx(s);\n\t\t}\n\t}\n\n\treturn hw->mappage(sc->hw_hdl, cb->start, off, prot);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_mmap(dev, off, prot)\n\tdev_t dev;\n\tint off, prot;\n{\n\tint s;\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_ringbuffer *cb;\n\n\tDPRINTF((\"audio_mmap: off=%d, prot=%d\\n\", off, prot));\n\n\tif (!(hw->get_props(sc->hw_hdl) & AUDIO_PROP_MMAP) || !hw->mappage)\n\t\treturn -1;\n#if 0\n/* XXX\n * The idea here was to use the protection to determine if\n * we are mapping the read or write buffer, but it fails.\n * The VM system is broken in (at least) two ways.\n * 1) If you map memory VM_PROT_WRITE you SIGSEGV\n *    when writing to it, so VM_PROT_READ|VM_PROT_WRITE\n *    has to be used for mmapping the play buffer.\n * 2) Even if calling mmap() with VM_PROT_READ|VM_PROT_WRITE\n *    audio_mmap will get called at some point with VM_PROT_READ\n *    only.\n * So, alas, we always map the play buffer for now.\n */\n\tif (prot == (VM_PROT_READ|VM_PROT_WRITE) ||\n\t    prot == VM_PROT_WRITE)\n\t\tcb = &sc->sc_pr;\n\telse if (prot == VM_PROT_READ)\n\t\tcb = &sc->sc_rr;\n\telse\n\t\treturn -1;\n#else\n\tcb = &sc->sc_pr;\n#endif\n\n\tif ((u_int)off >= cb->bufsize)\n\t\treturn -1;\n\tif (!cb->mmapped) {\n\t\tcb->mmapped = 1;\n\t\tif (cb == &sc->sc_pr) {\n\t\t\taudio_fill_silence(&sc->sc_pparams, cb->start, cb->bufsize);\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_pbus)\n\t\t\t\t(void)audiostartp(sc);\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = splaudio();\n\t\t\tif (!sc->sc_rbus)\n\t\t\t\t(void)audiostartr(sc);\n\t\t\tsplx(s);\n\t\t}\n\t}\n\n\treturn hw->mappage(sc->hw_hdl, cb->start, off, prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIODEV",
          "args": [
            "dev"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiommap(dev, off, prot)\n\tdev_t dev;\n\tint off, prot;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_mmap(dev, off, prot));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "audioselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "603-620",
    "snippet": "int\naudioselect(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_select(dev, events, p));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn (0);\n\tdefault:\n\t\treturn (0);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_select",
          "args": [
            "dev",
            "events",
            "p"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "audio_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1595-1630",
          "snippet": "int\naudio_select(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tint s = splaudio();\n\n\tDPRINTF((\"audio_select: rw=0x%x mode=%d\\n\", rw, sc->sc_mode));\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\tif ((sc->sc_mode & AUMODE_PLAY) ?\n\t\t    sc->sc_pr.stamp > sc->sc_wstamp : \n\t\t    sc->sc_rr.used > sc->sc_rr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_rsel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tif (sc->sc_mode & AUMODE_RECORD ||\n\t\t    sc->sc_pr.used <= sc->sc_pr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_wsel);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_select(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tint s = splaudio();\n\n\tDPRINTF((\"audio_select: rw=0x%x mode=%d\\n\", rw, sc->sc_mode));\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\tif ((sc->sc_mode & AUMODE_PLAY) ?\n\t\t    sc->sc_pr.stamp > sc->sc_wstamp : \n\t\t    sc->sc_rr.used > sc->sc_rr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_rsel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tif (sc->sc_mode & AUMODE_RECORD ||\n\t\t    sc->sc_pr.used <= sc->sc_pr.usedlow) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &sc->sc_wsel);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIODEV",
          "args": [
            "dev"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudioselect(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_select(dev, events, p));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn (0);\n\tdefault:\n\t\treturn (0);\n\t}\n}"
  },
  {
    "function_name": "audioioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "582-601",
    "snippet": "int\naudioioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\tcase AUDIOCTL_DEVICE:\n\t\treturn (audio_ioctl(dev, cmd, addr, flag, p));\n\tcase MIXER_DEVICE:\n\t\treturn (mixer_ioctl(dev, cmd, addr, flag, p));\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mixer_ioctl",
          "args": [
            "dev",
            "cmd",
            "addr",
            "flag",
            "p"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2786-2847",
          "snippet": "int\nmixer_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error = EINVAL;\n\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d)\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\n\tswitch (cmd) {\n\tcase FIOASYNC:\n\t\tmixer_remove(sc, p); /* remove old entry */\n\t\tif (*(int *)addr) {\n\t\t\tstruct mixer_asyncs *ma;\n\t\t\tma = malloc(sizeof (struct mixer_asyncs),\n                                    M_DEVBUF, M_WAITOK);\n\t\t\tma->next = sc->sc_async_mixer;\n\t\t\tma->proc = p;\n\t\t\tsc->sc_async_mixer = ma;\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_MIXER_DEVINFO:\n\t\tDPRINTF((\"AUDIO_MIXER_DEVINFO\\n\"));\n\t\terror = hw->query_devinfo(sc->hw_hdl, (mixer_devinfo_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_READ:\n\t\tDPRINTF((\"AUDIO_MIXER_READ\\n\"));\n\t\terror = hw->get_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_WRITE:\n\t\tDPRINTF((\"AUDIO_MIXER_WRITE\\n\"));\n\t\terror = hw->set_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tif (!error && hw->commit_settings)\n\t\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (!error)\n\t\t\tmixer_signal(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d) result %d\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nmixer_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint error = EINVAL;\n\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d)\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\n\tswitch (cmd) {\n\tcase FIOASYNC:\n\t\tmixer_remove(sc, p); /* remove old entry */\n\t\tif (*(int *)addr) {\n\t\t\tstruct mixer_asyncs *ma;\n\t\t\tma = malloc(sizeof (struct mixer_asyncs),\n                                    M_DEVBUF, M_WAITOK);\n\t\t\tma->next = sc->sc_async_mixer;\n\t\t\tma->proc = p;\n\t\t\tsc->sc_async_mixer = ma;\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_MIXER_DEVINFO:\n\t\tDPRINTF((\"AUDIO_MIXER_DEVINFO\\n\"));\n\t\terror = hw->query_devinfo(sc->hw_hdl, (mixer_devinfo_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_READ:\n\t\tDPRINTF((\"AUDIO_MIXER_READ\\n\"));\n\t\terror = hw->get_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tbreak;\n\n\tcase AUDIO_MIXER_WRITE:\n\t\tDPRINTF((\"AUDIO_MIXER_WRITE\\n\"));\n\t\terror = hw->set_port(sc->hw_hdl, (mixer_ctrl_t *)addr);\n\t\tif (!error && hw->commit_settings)\n\t\t\terror = hw->commit_settings(sc->hw_hdl);\n\t\tif (!error)\n\t\t\tmixer_signal(sc);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"mixer_ioctl(%d,'%c',%d) result %d\\n\",\n\t\t IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_ioctl",
          "args": [
            "dev",
            "cmd",
            "addr",
            "flag",
            "p"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "audio_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1429-1593",
          "snippet": "int\naudio_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_offset *ao;\n\tint error = 0, s, offs, fd;\n        int rbus, pbus;\n\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d)\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async_audio)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async_audio = p;\n\t\t\tDPRINTF((\"audio_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async_audio = 0;\n\t\tbreak;\n\n\tcase AUDIO_FLUSH:\n\t\tDPRINTF((\"AUDIO_FLUSH\\n\"));\n                rbus = sc->sc_rbus;\n                pbus = sc->sc_pbus;\n\t\taudio_clear(sc);\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn error;\n\t\t}\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_pbus && pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error &&\n\t\t    (sc->sc_mode & AUMODE_RECORD) && !sc->sc_rbus && rbus)\n\t\t\terror = audiostartr(sc);\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * Number of read (write) samples dropped.  We don't know where or\n\t * when they were dropped.\n\t */\n\tcase AUDIO_RERROR:\n\t\t*(int *)addr = sc->sc_rr.drops;\n\t\tbreak;\n\n\tcase AUDIO_PERROR:\n\t\t*(int *)addr = sc->sc_pr.drops;\n\t\tbreak;\n\n\t/*\n\t * Offsets into buffer.\n\t */\n\tcase AUDIO_GETIOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\tao->samples = sc->sc_rr.stamp;\n\t\tao->deltablks = (sc->sc_rr.stamp - sc->sc_rr.stamp_last) / sc->sc_rr.blksize;\n\t\tsc->sc_rr.stamp_last = sc->sc_rr.stamp;\n\t\tao->offset = sc->sc_rr.inp - sc->sc_rr.start;\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase AUDIO_GETOOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\toffs = sc->sc_pr.outp - sc->sc_pr.start + sc->sc_pr.blksize;\n\t\tif (sc->sc_pr.start + offs >= sc->sc_pr.end)\n\t\t\toffs = 0;\n\t\tao->samples = sc->sc_pr.stamp;\n\t\tao->deltablks = (sc->sc_pr.stamp - sc->sc_pr.stamp_last) / sc->sc_pr.blksize;\n\t\tsc->sc_pr.stamp_last = sc->sc_pr.stamp;\n\t\tao->offset = offs;\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * How many bytes will elapse until mike hears the first\n\t * sample of what we write next?\n\t */\n\tcase AUDIO_WSEEK:\n\t\t*(u_long *)addr = sc->sc_rr.used;\n\t\tbreak;\n\n\tcase AUDIO_SETINFO:\n\t\tDPRINTF((\"AUDIO_SETINFO mode=0x%x\\n\", sc->sc_mode));\n\t\terror = audiosetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETINFO:\n\t\tDPRINTF((\"AUDIO_GETINFO\\n\"));\n\t\terror = audiogetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_DRAIN:\n\t\tDPRINTF((\"AUDIO_DRAIN\\n\"));\n\t\terror = audio_drain(sc);\n\t\tif (!error && hw->drain)\n\t\t    error = hw->drain(sc->hw_hdl);\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_GETENC:\n\t\tDPRINTF((\"AUDIO_GETENC\\n\"));\n\t\t/* Pass read/write info down to query_encoding */\n\t\t((struct audio_encoding *)addr)->flags = sc->sc_open;\n\t\terror = hw->query_encoding(sc->hw_hdl, (struct audio_encoding *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETFD:\n\t\tDPRINTF((\"AUDIO_GETFD\\n\"));\n\t\t*(int *)addr = sc->sc_full_duplex;\n\t\tbreak;\n\n\tcase AUDIO_SETFD:\n\t\tDPRINTF((\"AUDIO_SETFD\\n\"));\n\t\tfd = *(int *)addr;\n\t\tif (hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX) {\n\t\t\tif (hw->setfd)\n\t\t\t\terror = hw->setfd(sc->hw_hdl, fd);\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t\tif (!error)\n\t\t\t\tsc->sc_full_duplex = fd;\n\t\t} else {\n\t\t\tif (fd)\n\t\t\t\terror = ENOTTY;\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase AUDIO_GETPROPS:\n\t\tDPRINTF((\"AUDIO_GETPROPS\\n\"));\n\t\t*(int *)addr = hw->get_props(sc->hw_hdl);\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF((\"audio_ioctl: unknown ioctl\\n\"));\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d) result %d\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_ioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_offset *ao;\n\tint error = 0, s, offs, fd;\n        int rbus, pbus;\n\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d)\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async_audio)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async_audio = p;\n\t\t\tDPRINTF((\"audio_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async_audio = 0;\n\t\tbreak;\n\n\tcase AUDIO_FLUSH:\n\t\tDPRINTF((\"AUDIO_FLUSH\\n\"));\n                rbus = sc->sc_rbus;\n                pbus = sc->sc_pbus;\n\t\taudio_clear(sc);\n\t\ts = splaudio();\n\t\terror = audio_initbufs(sc);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn error;\n\t\t}\n\t\tif ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_pbus && pbus)\n\t\t\terror = audiostartp(sc);\n\t\tif (!error &&\n\t\t    (sc->sc_mode & AUMODE_RECORD) && !sc->sc_rbus && rbus)\n\t\t\terror = audiostartr(sc);\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * Number of read (write) samples dropped.  We don't know where or\n\t * when they were dropped.\n\t */\n\tcase AUDIO_RERROR:\n\t\t*(int *)addr = sc->sc_rr.drops;\n\t\tbreak;\n\n\tcase AUDIO_PERROR:\n\t\t*(int *)addr = sc->sc_pr.drops;\n\t\tbreak;\n\n\t/*\n\t * Offsets into buffer.\n\t */\n\tcase AUDIO_GETIOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\tao->samples = sc->sc_rr.stamp;\n\t\tao->deltablks = (sc->sc_rr.stamp - sc->sc_rr.stamp_last) / sc->sc_rr.blksize;\n\t\tsc->sc_rr.stamp_last = sc->sc_rr.stamp;\n\t\tao->offset = sc->sc_rr.inp - sc->sc_rr.start;\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase AUDIO_GETOOFFS:\n\t\ts = splaudio();\n\t\t/* figure out where next DMA will start */\n\t\tao = (struct audio_offset *)addr;\n\t\toffs = sc->sc_pr.outp - sc->sc_pr.start + sc->sc_pr.blksize;\n\t\tif (sc->sc_pr.start + offs >= sc->sc_pr.end)\n\t\t\toffs = 0;\n\t\tao->samples = sc->sc_pr.stamp;\n\t\tao->deltablks = (sc->sc_pr.stamp - sc->sc_pr.stamp_last) / sc->sc_pr.blksize;\n\t\tsc->sc_pr.stamp_last = sc->sc_pr.stamp;\n\t\tao->offset = offs;\n\t\tsplx(s);\n\t\tbreak;\n\n\t/*\n\t * How many bytes will elapse until mike hears the first\n\t * sample of what we write next?\n\t */\n\tcase AUDIO_WSEEK:\n\t\t*(u_long *)addr = sc->sc_rr.used;\n\t\tbreak;\n\n\tcase AUDIO_SETINFO:\n\t\tDPRINTF((\"AUDIO_SETINFO mode=0x%x\\n\", sc->sc_mode));\n\t\terror = audiosetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETINFO:\n\t\tDPRINTF((\"AUDIO_GETINFO\\n\"));\n\t\terror = audiogetinfo(sc, (struct audio_info *)addr);\n\t\tbreak;\n\n\tcase AUDIO_DRAIN:\n\t\tDPRINTF((\"AUDIO_DRAIN\\n\"));\n\t\terror = audio_drain(sc);\n\t\tif (!error && hw->drain)\n\t\t    error = hw->drain(sc->hw_hdl);\n\t\tbreak;\n\n\tcase AUDIO_GETDEV:\n\t\tDPRINTF((\"AUDIO_GETDEV\\n\"));\n\t\terror = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);\n\t\tbreak;\n\t\t\n\tcase AUDIO_GETENC:\n\t\tDPRINTF((\"AUDIO_GETENC\\n\"));\n\t\t/* Pass read/write info down to query_encoding */\n\t\t((struct audio_encoding *)addr)->flags = sc->sc_open;\n\t\terror = hw->query_encoding(sc->hw_hdl, (struct audio_encoding *)addr);\n\t\tbreak;\n\n\tcase AUDIO_GETFD:\n\t\tDPRINTF((\"AUDIO_GETFD\\n\"));\n\t\t*(int *)addr = sc->sc_full_duplex;\n\t\tbreak;\n\n\tcase AUDIO_SETFD:\n\t\tDPRINTF((\"AUDIO_SETFD\\n\"));\n\t\tfd = *(int *)addr;\n\t\tif (hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX) {\n\t\t\tif (hw->setfd)\n\t\t\t\terror = hw->setfd(sc->hw_hdl, fd);\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t\tif (!error)\n\t\t\t\tsc->sc_full_duplex = fd;\n\t\t} else {\n\t\t\tif (fd)\n\t\t\t\terror = ENOTTY;\n\t\t\telse\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase AUDIO_GETPROPS:\n\t\tDPRINTF((\"AUDIO_GETPROPS\\n\"));\n\t\t*(int *)addr = hw->get_props(sc->hw_hdl);\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF((\"audio_ioctl: unknown ioctl\\n\"));\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tDPRINTF((\"audio_ioctl(%d,'%c',%d) result %d\\n\",\n\t          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIODEV",
          "args": [
            "dev"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudioioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\tcase AUDIOCTL_DEVICE:\n\t\treturn (audio_ioctl(dev, cmd, addr, flag, p));\n\tcase MIXER_DEVICE:\n\t\treturn (mixer_ioctl(dev, cmd, addr, flag, p));\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}"
  },
  {
    "function_name": "audiowrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "563-580",
    "snippet": "int\naudiowrite(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_write(dev, uio, ioflag));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn (ENODEV);\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_write",
          "args": [
            "dev",
            "uio",
            "ioflag"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "audio_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1270-1427",
          "snippet": "int\naudio_write(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tu_char *inp, *einp;\n\tint saveerror, error, s, n, cc, used;\n\n\tDPRINTFN(2, (\"audio_write: sc=%p(unit=%d) count=%d used=%d(hi=%d)\\n\", sc, unit,\n\t\t uio->uio_resid, sc->sc_pr.used, sc->sc_pr.usedhigh));\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tif (uio->uio_resid == 0) {\n\t\tsc->sc_eof++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If half-duplex and currently recording, throw away data.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_RECORD)) {\n\t\tuio->uio_offset += uio->uio_resid;\n\t\tuio->uio_resid = 0;\n\t\tDPRINTF((\"audio_write: half-dpx read busy\\n\"));\n\t\treturn (0);\n\t}\n\n\tif (!(sc->sc_mode & AUMODE_PLAY_ALL) && sc->sc_playdrop > 0) {\n\t\tn = min(sc->sc_playdrop, uio->uio_resid);\n\t\tDPRINTF((\"audio_write: playdrop %d\\n\", n));\n\t\tuio->uio_offset += n;\n\t\tuio->uio_resid -= n;\n\t\tsc->sc_playdrop -= n;\n\t\tif (uio->uio_resid == 0)\n\t\t\treturn 0;\n\t}\n\n\tDPRINTFN(1, (\"audio_write: sr=%ld, enc=%d, prec=%d, chan=%d, sw=%p, fact=%d\\n\",\n                     sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,\n                     sc->sc_pparams.precision, sc->sc_pparams.channels,\n                     sc->sc_pparams.sw_code, sc->sc_pparams.factor));\n\n\terror = 0;\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used >= cb->usedhigh) {\n\t\t\tDPRINTFN(2, (\"audio_write: sleep used=%d lowat=%d hiwat=%d\\n\", \n\t\t\t\t cb->used, cb->usedlow, cb->usedhigh));\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = audio_sleep(&sc->sc_wchan, \"aud_wr\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\tinp = cb->inp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = cb->usedhigh - used; \t/* maximum to write */\n\t\tn = cb->end - inp;\n\t\tif (sc->sc_pparams.factor != 1) {\n\t\t\t/* Compensate for software coding expansion factor. */\n\t\t\tn /= sc->sc_pparams.factor;\n\t\t\tcc /= sc->sc_pparams.factor;\n\t\t}\n\t\tif (n < cc)\n\t\t\tcc = n;\t\t\t/* don't write beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; \t/* and no more than we have */\n\n#ifdef DIAGNOSTIC\n\t\t/* \n\t\t * This should never happen since the block size and and\n\t\t * block pointers are always nicely aligned. \n\t\t */\n\t\tif (cc == 0) {\n\t\t\tprintf(\"audio_write: cc == 0, swcode=%p, factor=%d\\n\",\n\t\t\t       sc->sc_pparams.sw_code, sc->sc_pparams.factor);\n\t\t\tcb->copying = 0;\n\t\t\treturn EINVAL;\n\t\t}\n#endif\n\t\tDPRINTFN(1, (\"audio_write: uiomove cc=%d inp=%p, left=%d\\n\", \n                             cc, inp, uio->uio_resid));\n\t\tn = uio->uio_resid;\n\t\terror = uiomove(inp, cc, uio);\n\t\tcc = n - uio->uio_resid; /* number of bytes actually moved */\n#ifdef AUDIO_DEBUG\n\t\tif (error)\n\t\t        printf(\"audio_write:(1) uiomove failed %d; cc=%d inp=%p\\n\",\n\t\t\t       error, cc, inp);\n#endif\n\t\t/* \n\t\t * Continue even if uiomove() failed because we may have\n\t\t * gotten a partial block.\n\t\t */\n\n\t\tif (sc->sc_pparams.sw_code) {\n\t\t\tsc->sc_pparams.sw_code(sc->hw_hdl, inp, cc);\n\t\t\t/* Adjust count after the expansion. */\n\t\t\tcc *= sc->sc_pparams.factor;\n\t\t\tDPRINTFN(1, (\"audio_write: expanded cc=%d\\n\", cc));\n\t\t}\n\n\t\teinp = cb->inp + cc;\n\t\tif (einp >= cb->end)\n\t\t\teinp = cb->start;\n\n\t\ts = splaudio();\n\t\t/*\n\t\t * This is a very suboptimal way of keeping track of\n\t\t * silence in the buffer, but it is simple.\n\t\t */\n\t\tsc->sc_sil_count = 0;\n\n\t\tcb->inp = einp;\n\t\tcb->used += cc;\n\t\t/* If the interrupt routine wants the last block filled AND\n\t\t * the copy did not fill the last block completely it needs to\n\t\t * be padded.\n\t\t */\n\t\tif (cb->needfill &&\n\t\t    (inp  - cb->start) / cb->blksize == \n\t\t    (einp - cb->start) / cb->blksize) {\n\t\t\t/* Figure out how many bytes there is to a block boundary. */\n\t\t\tcc = cb->blksize - (einp - cb->start) % cb->blksize;\n\t\t\tDPRINTF((\"audio_write: partial fill %d\\n\", cc));\n\t\t} else\n\t\t\tcc = 0;\n\t\tcb->needfill = 0;\n\t\tcb->copying = 0;\n\t\tif (!sc->sc_pbus && !cb->pause) {\n\t\t\tsaveerror = error;\n\t\t\terror = audiostartp(sc);\n\t\t\tif (saveerror != 0) {\n\t\t\t\t/* Report the first error that occured. */\n\t\t\t\terror = saveerror;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\t\tif (cc) {\n\t\t\tDPRINTFN(1, (\"audio_write: fill %d\\n\", cc));\n\t\t\taudio_fill_silence(&sc->sc_pparams, einp, cc);\n\t\t}\n\t}\n\treturn (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_write(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_pr;\n\tu_char *inp, *einp;\n\tint saveerror, error, s, n, cc, used;\n\n\tDPRINTFN(2, (\"audio_write: sc=%p(unit=%d) count=%d used=%d(hi=%d)\\n\", sc, unit,\n\t\t uio->uio_resid, sc->sc_pr.used, sc->sc_pr.usedhigh));\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tif (uio->uio_resid == 0) {\n\t\tsc->sc_eof++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If half-duplex and currently recording, throw away data.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_RECORD)) {\n\t\tuio->uio_offset += uio->uio_resid;\n\t\tuio->uio_resid = 0;\n\t\tDPRINTF((\"audio_write: half-dpx read busy\\n\"));\n\t\treturn (0);\n\t}\n\n\tif (!(sc->sc_mode & AUMODE_PLAY_ALL) && sc->sc_playdrop > 0) {\n\t\tn = min(sc->sc_playdrop, uio->uio_resid);\n\t\tDPRINTF((\"audio_write: playdrop %d\\n\", n));\n\t\tuio->uio_offset += n;\n\t\tuio->uio_resid -= n;\n\t\tsc->sc_playdrop -= n;\n\t\tif (uio->uio_resid == 0)\n\t\t\treturn 0;\n\t}\n\n\tDPRINTFN(1, (\"audio_write: sr=%ld, enc=%d, prec=%d, chan=%d, sw=%p, fact=%d\\n\",\n                     sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,\n                     sc->sc_pparams.precision, sc->sc_pparams.channels,\n                     sc->sc_pparams.sw_code, sc->sc_pparams.factor));\n\n\terror = 0;\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used >= cb->usedhigh) {\n\t\t\tDPRINTFN(2, (\"audio_write: sleep used=%d lowat=%d hiwat=%d\\n\", \n\t\t\t\t cb->used, cb->usedlow, cb->usedhigh));\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\terror = audio_sleep(&sc->sc_wchan, \"aud_wr\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\tinp = cb->inp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = cb->usedhigh - used; \t/* maximum to write */\n\t\tn = cb->end - inp;\n\t\tif (sc->sc_pparams.factor != 1) {\n\t\t\t/* Compensate for software coding expansion factor. */\n\t\t\tn /= sc->sc_pparams.factor;\n\t\t\tcc /= sc->sc_pparams.factor;\n\t\t}\n\t\tif (n < cc)\n\t\t\tcc = n;\t\t\t/* don't write beyond end of buffer */\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; \t/* and no more than we have */\n\n#ifdef DIAGNOSTIC\n\t\t/* \n\t\t * This should never happen since the block size and and\n\t\t * block pointers are always nicely aligned. \n\t\t */\n\t\tif (cc == 0) {\n\t\t\tprintf(\"audio_write: cc == 0, swcode=%p, factor=%d\\n\",\n\t\t\t       sc->sc_pparams.sw_code, sc->sc_pparams.factor);\n\t\t\tcb->copying = 0;\n\t\t\treturn EINVAL;\n\t\t}\n#endif\n\t\tDPRINTFN(1, (\"audio_write: uiomove cc=%d inp=%p, left=%d\\n\", \n                             cc, inp, uio->uio_resid));\n\t\tn = uio->uio_resid;\n\t\terror = uiomove(inp, cc, uio);\n\t\tcc = n - uio->uio_resid; /* number of bytes actually moved */\n#ifdef AUDIO_DEBUG\n\t\tif (error)\n\t\t        printf(\"audio_write:(1) uiomove failed %d; cc=%d inp=%p\\n\",\n\t\t\t       error, cc, inp);\n#endif\n\t\t/* \n\t\t * Continue even if uiomove() failed because we may have\n\t\t * gotten a partial block.\n\t\t */\n\n\t\tif (sc->sc_pparams.sw_code) {\n\t\t\tsc->sc_pparams.sw_code(sc->hw_hdl, inp, cc);\n\t\t\t/* Adjust count after the expansion. */\n\t\t\tcc *= sc->sc_pparams.factor;\n\t\t\tDPRINTFN(1, (\"audio_write: expanded cc=%d\\n\", cc));\n\t\t}\n\n\t\teinp = cb->inp + cc;\n\t\tif (einp >= cb->end)\n\t\t\teinp = cb->start;\n\n\t\ts = splaudio();\n\t\t/*\n\t\t * This is a very suboptimal way of keeping track of\n\t\t * silence in the buffer, but it is simple.\n\t\t */\n\t\tsc->sc_sil_count = 0;\n\n\t\tcb->inp = einp;\n\t\tcb->used += cc;\n\t\t/* If the interrupt routine wants the last block filled AND\n\t\t * the copy did not fill the last block completely it needs to\n\t\t * be padded.\n\t\t */\n\t\tif (cb->needfill &&\n\t\t    (inp  - cb->start) / cb->blksize == \n\t\t    (einp - cb->start) / cb->blksize) {\n\t\t\t/* Figure out how many bytes there is to a block boundary. */\n\t\t\tcc = cb->blksize - (einp - cb->start) % cb->blksize;\n\t\t\tDPRINTF((\"audio_write: partial fill %d\\n\", cc));\n\t\t} else\n\t\t\tcc = 0;\n\t\tcb->needfill = 0;\n\t\tcb->copying = 0;\n\t\tif (!sc->sc_pbus && !cb->pause) {\n\t\t\tsaveerror = error;\n\t\t\terror = audiostartp(sc);\n\t\t\tif (saveerror != 0) {\n\t\t\t\t/* Report the first error that occured. */\n\t\t\t\terror = saveerror;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\t\tif (cc) {\n\t\t\tDPRINTFN(1, (\"audio_write: fill %d\\n\", cc));\n\t\t\taudio_fill_silence(&sc->sc_pparams, einp, cc);\n\t\t}\n\t}\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIODEV",
          "args": [
            "dev"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudiowrite(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_write(dev, uio, ioflag));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn (ENODEV);\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}"
  },
  {
    "function_name": "audioread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "544-561",
    "snippet": "int\naudioread(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_read(dev, uio, ioflag));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn (ENODEV);\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_read",
          "args": [
            "dev",
            "uio",
            "ioflag"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "audio_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1036-1137",
          "snippet": "int\naudio_read(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_rr;\n\tu_char *outp;\n\tint error, s, used, cc, n;\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tDPRINTFN(1,(\"audio_read: cc=%d mode=%d\\n\", \n                    uio->uio_resid, sc->sc_mode));\n\n\terror = 0;\n\t/*\n\t * If hardware is half-duplex and currently playing, return\n\t * silence blocks based on the number of blocks we have output.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_PLAY)) {\n\t\twhile (uio->uio_resid > 0 && !error) {\n\t\t\ts = splaudio();\n\t\t\tfor(;;) {\n\t\t\t\tcc = sc->sc_pr.stamp - sc->sc_wstamp;\n\t\t\t\tif (cc > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tDPRINTF((\"audio_read: stamp=%lu, wstamp=%lu\\n\", \n\t\t\t\t\t sc->sc_pr.stamp, sc->sc_wstamp));\n\t\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn EWOULDBLOCK;\n\t\t\t\t}\n\t\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_hr\");\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\n\t\t\tif (uio->uio_resid < cc)\n\t\t\t\tcc = uio->uio_resid;\n\t\t\tDPRINTFN(1, (\"audio_read: reading in write mode, cc=%d\\n\", cc));\n\t\t\terror = audio_silence_copyout(sc, cc, uio);\n\t\t\tsc->sc_wstamp += cc;\n\t\t} \n\t\treturn (error);\n\t}\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used <= 0) {\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn EWOULDBLOCK;\n\t\t\t}\n\t\t\tif (!sc->sc_rbus) {\n\t\t\t\terror = audiostartr(sc);\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDPRINTFN(2, (\"audio_read: sleep used=%d\\n\", cb->used));\n\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_rd\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\toutp = cb->outp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = used - cb->usedlow; /* maximum to read */\n\t\tn = cb->end - outp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t/* don't read beyond end of buffer */\n\t\t\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; /* and no more than we want */\n\n\t\tif (sc->sc_rparams.sw_code)\n\t\t\tsc->sc_rparams.sw_code(sc->hw_hdl, outp, cc);\n\t\tDPRINTFN(1,(\"audio_read: outp=%p, cc=%d\\n\", outp, cc));\n\t\terror = uiomove(outp, cc, uio);\n\t\tused -= cc;\n\t\toutp += cc;\n\t\tif (outp >= cb->end)\n\t\t\toutp = cb->start;\n\t\ts = splaudio();\n\t\tcb->outp = outp;\n\t\tcb->used = used;\n\t\tcb->copying = 0;\n\t\tsplx(s);\n\t}\n\treturn (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_read(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_ringbuffer *cb = &sc->sc_rr;\n\tu_char *outp;\n\tint error, s, used, cc, n;\n\n\tif (cb->mmapped)\n\t\treturn EINVAL;\n\n\tDPRINTFN(1,(\"audio_read: cc=%d mode=%d\\n\", \n                    uio->uio_resid, sc->sc_mode));\n\n\terror = 0;\n\t/*\n\t * If hardware is half-duplex and currently playing, return\n\t * silence blocks based on the number of blocks we have output.\n\t */\n\tif (!sc->sc_full_duplex &&\n\t    (sc->sc_mode & AUMODE_PLAY)) {\n\t\twhile (uio->uio_resid > 0 && !error) {\n\t\t\ts = splaudio();\n\t\t\tfor(;;) {\n\t\t\t\tcc = sc->sc_pr.stamp - sc->sc_wstamp;\n\t\t\t\tif (cc > 0)\n\t\t\t\t\tbreak;\n\t\t\t\tDPRINTF((\"audio_read: stamp=%lu, wstamp=%lu\\n\", \n\t\t\t\t\t sc->sc_pr.stamp, sc->sc_wstamp));\n\t\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn EWOULDBLOCK;\n\t\t\t\t}\n\t\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_hr\");\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\n\t\t\tif (uio->uio_resid < cc)\n\t\t\t\tcc = uio->uio_resid;\n\t\t\tDPRINTFN(1, (\"audio_read: reading in write mode, cc=%d\\n\", cc));\n\t\t\terror = audio_silence_copyout(sc, cc, uio);\n\t\t\tsc->sc_wstamp += cc;\n\t\t} \n\t\treturn (error);\n\t}\n\twhile (uio->uio_resid > 0 && !error) {\n\t\ts = splaudio();\n\t\twhile (cb->used <= 0) {\n\t\t\tif (ioflag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn EWOULDBLOCK;\n\t\t\t}\n\t\t\tif (!sc->sc_rbus) {\n\t\t\t\terror = audiostartr(sc);\n\t\t\t\tif (error) {\n\t\t\t\t\tsplx(s);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDPRINTFN(2, (\"audio_read: sleep used=%d\\n\", cb->used));\n\t\t\terror = audio_sleep(&sc->sc_rchan, \"aud_rd\");\n\t\t\tif (error) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tused = cb->used;\n\t\toutp = cb->outp;\n\t\tcb->copying = 1;\n\t\tsplx(s);\n\t\tcc = used - cb->usedlow; /* maximum to read */\n\t\tn = cb->end - outp;\n\t\tif (n < cc)\n\t\t\tcc = n;\t/* don't read beyond end of buffer */\n\t\t\n\t\tif (uio->uio_resid < cc)\n\t\t\tcc = uio->uio_resid; /* and no more than we want */\n\n\t\tif (sc->sc_rparams.sw_code)\n\t\t\tsc->sc_rparams.sw_code(sc->hw_hdl, outp, cc);\n\t\tDPRINTFN(1,(\"audio_read: outp=%p, cc=%d\\n\", outp, cc));\n\t\terror = uiomove(outp, cc, uio);\n\t\tused -= cc;\n\t\toutp += cc;\n\t\tif (outp >= cb->end)\n\t\t\toutp = cb->start;\n\t\ts = splaudio();\n\t\tcb->outp = outp;\n\t\tcb->used = used;\n\t\tcb->copying = 0;\n\t\tsplx(s);\n\t}\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIODEV",
          "args": [
            "dev"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudioread(dev, uio, ioflag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint ioflag;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_read(dev, uio, ioflag));\n\tcase AUDIOCTL_DEVICE:\n\tcase MIXER_DEVICE:\n\t\treturn (ENODEV);\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}"
  },
  {
    "function_name": "audioclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "524-542",
    "snippet": "int\naudioclose(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_close(dev, flags, ifmt, p));\n\tcase MIXER_DEVICE:\n\t\treturn (mixer_close(dev, flags, ifmt, p));\n\tcase AUDIOCTL_DEVICE:\n\t\treturn 0;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mixer_close",
          "args": [
            "dev",
            "flags",
            "ifmt",
            "p"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2770-2784",
          "snippet": "int\nmixer_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\n\tDPRINTF((\"mixer_close: unit %d\\n\", AUDIOUNIT(dev)));\n\t\n\tmixer_remove(sc, p);\n\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nmixer_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\n\tDPRINTF((\"mixer_close: unit %d\\n\", AUDIOUNIT(dev)));\n\t\n\tmixer_remove(sc, p);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_close",
          "args": [
            "dev",
            "flags",
            "ifmt",
            "p"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "audio_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "977-1034",
          "snippet": "int\naudio_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint s;\n\n\tDPRINTF((\"audio_close: unit=%d\\n\", unit));\n\n\ts = splaudio();\n        /* Stop recording. */\n\tif ((flags & FREAD) && sc->sc_rbus) {\n\t\t/* \n\t\t * XXX Some drivers (e.g. SB) use the same routine\n\t\t * to halt input and output so don't halt input if\n\t\t * in full duplex mode.  These drivers should be fixed.\n\t\t */\n\t\tif (!sc->sc_full_duplex || sc->hw_if->halt_input != sc->hw_if->halt_output)\n\t\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\t/*\n\t * Block until output drains, but allow ^C interrupt.\n\t */\n\tsc->sc_pr.usedlow = sc->sc_pr.blksize;\t/* avoid excessive wakeups */\n\t/*\n\t * If there is pending output, let it drain (unless\n\t * the output is paused).\n\t */\n\tif ((flags & FWRITE) && sc->sc_pbus) {\n\t\tif (!sc->sc_pr.pause && !audio_drain(sc) && hw->drain)\n\t\t\t(void)hw->drain(sc->hw_hdl);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\t\n\thw->close(sc->hw_hdl);\n\t\n\tif (flags & FREAD) {\n\t\tsc->sc_open &= ~AUOPEN_READ;\n\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open &= ~AUOPEN_WRITE;\n\t\tsc->sc_mode &= ~(AUMODE_PLAY|AUMODE_PLAY_ALL);\n\t}\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_full_duplex = 0;\n\tsplx(s);\n\tDPRINTF((\"audio_close: done\\n\"));\n\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_close(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc = audio_cd.cd_devs[unit];\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tint s;\n\n\tDPRINTF((\"audio_close: unit=%d\\n\", unit));\n\n\ts = splaudio();\n        /* Stop recording. */\n\tif ((flags & FREAD) && sc->sc_rbus) {\n\t\t/* \n\t\t * XXX Some drivers (e.g. SB) use the same routine\n\t\t * to halt input and output so don't halt input if\n\t\t * in full duplex mode.  These drivers should be fixed.\n\t\t */\n\t\tif (!sc->sc_full_duplex || sc->hw_if->halt_input != sc->hw_if->halt_output)\n\t\t\tsc->hw_if->halt_input(sc->hw_hdl);\n\t\tsc->sc_rbus = 0;\n\t}\n\t/*\n\t * Block until output drains, but allow ^C interrupt.\n\t */\n\tsc->sc_pr.usedlow = sc->sc_pr.blksize;\t/* avoid excessive wakeups */\n\t/*\n\t * If there is pending output, let it drain (unless\n\t * the output is paused).\n\t */\n\tif ((flags & FWRITE) && sc->sc_pbus) {\n\t\tif (!sc->sc_pr.pause && !audio_drain(sc) && hw->drain)\n\t\t\t(void)hw->drain(sc->hw_hdl);\n\t\tsc->hw_if->halt_output(sc->hw_hdl);\n\t\tsc->sc_pbus = 0;\n\t}\n\t\n\thw->close(sc->hw_hdl);\n\t\n\tif (flags & FREAD) {\n\t\tsc->sc_open &= ~AUOPEN_READ;\n\t\tsc->sc_mode &= ~AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open &= ~AUOPEN_WRITE;\n\t\tsc->sc_mode &= ~(AUMODE_PLAY|AUMODE_PLAY_ALL);\n\t}\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_full_duplex = 0;\n\tsplx(s);\n\tDPRINTF((\"audio_close: done\\n\"));\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIODEV",
          "args": [
            "dev"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudioclose(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\t\treturn (audio_close(dev, flags, ifmt, p));\n\tcase MIXER_DEVICE:\n\t\treturn (mixer_close(dev, flags, ifmt, p));\n\tcase AUDIOCTL_DEVICE:\n\t\treturn 0;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}"
  },
  {
    "function_name": "audioopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "505-522",
    "snippet": "int\naudioopen(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\tcase AUDIOCTL_DEVICE:\n\t\treturn (audio_open(dev, flags, ifmt, p));\n\tcase MIXER_DEVICE:\n\t\treturn (mixer_open(dev, flags, ifmt, p));\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mixer_open",
          "args": [
            "dev",
            "flags",
            "ifmt",
            "p"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "mixer_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "2712-2731",
          "snippet": "int\nmixer_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\tif (!sc->hw_if)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"mixer_open: dev=0x%x flags=0x%x sc=%p\\n\", dev, flags, sc));\n\n\treturn (0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nmixer_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\tif (!sc->hw_if)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"mixer_open: dev=0x%x flags=0x%x sc=%p\\n\", dev, flags, sc));\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_open",
          "args": [
            "dev",
            "flags",
            "ifmt",
            "p"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "audio_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "776-882",
          "snippet": "int\naudio_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\tint error;\n\tint mode;\n\tstruct audio_hw_if *hw;\n\tstruct audio_info ai;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\thw = sc->hw_if;\n\tif (!hw)\n\t\treturn ENXIO;\n\n\tDPRINTF((\"audio_open: dev=0x%x flags=0x%x sc=%p hdl=%p\\n\", dev, flags, sc, sc->hw_hdl));\n\n\tif (ISDEVAUDIOCTL(dev))\n\t\treturn 0;\n\n\tif ((sc->sc_open & (AUOPEN_READ|AUOPEN_WRITE)) != 0)\n\t\treturn (EBUSY);\n\n\terror = hw->open(sc->hw_hdl, flags);\n\tif (error)\n\t\treturn (error);\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_rchan = 0;\n\tsc->sc_wchan = 0;\n\tsc->sc_blkset = 0; /* Block sizes not set yet */\n\tsc->sc_sil_count = 0;\n\tsc->sc_rbus = 0;\n\tsc->sc_pbus = 0;\n\tsc->sc_eof = 0;\n\tsc->sc_playdrop = 0;\n\n\tsc->sc_full_duplex = 0;\n/* doesn't always work right on SB.\n\t\t(flags & (FWRITE|FREAD)) == (FWRITE|FREAD) &&\n\t\t(hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX);\n*/\n\n\tmode = 0;\n\tif (flags & FREAD) {\n\t\tsc->sc_open |= AUOPEN_READ;\n\t\tmode |= AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open |= AUOPEN_WRITE;\n\t\tmode |= AUMODE_PLAY | AUMODE_PLAY_ALL;\n\t}\n\n\t/*\n\t * Multiplex device: /dev/audio (MU-Law) and /dev/sound (linear)\n\t * The /dev/audio is always (re)set to 8-bit MU-Law mono\n\t * For the other devices, you get what they were last set to.\n\t */\n\tif (ISDEVAUDIO(dev)) {\n\t\t/* /dev/audio */\n\t\tsc->sc_rparams = audio_default;\n\t\tsc->sc_pparams = audio_default;\n\t}\n#ifdef DIAGNOSTIC\n\t/*\n\t * Sample rate and precision are supposed to be set to proper\n\t * default values by the hardware driver, so that it may give\n\t * us these values.\n\t */\n\tif (sc->sc_rparams.precision == 0 || sc->sc_pparams.precision == 0) {\n\t\tprintf(\"audio_open: 0 precision\\n\");\n\t\treturn EINVAL;\n\t}\n#endif\n\n\tAUDIO_INITINFO(&ai);\n\tai.record.sample_rate = sc->sc_rparams.sample_rate;\n\tai.record.encoding    = sc->sc_rparams.encoding;\n\tai.record.channels    = sc->sc_rparams.channels;\n\tai.record.precision   = sc->sc_rparams.precision;\n\tai.play.sample_rate   = sc->sc_pparams.sample_rate;\n\tai.play.encoding      = sc->sc_pparams.encoding;\n\tai.play.channels      = sc->sc_pparams.channels;\n\tai.play.precision     = sc->sc_pparams.precision;\n\tai.mode\t\t      = mode;\n\tsc->sc_pr.blksize = sc->sc_rr.blksize = 0; /* force recalculation */\n\terror = audiosetinfo(sc, &ai);\n\tif (error)\n\t\tgoto bad;\n\n\tDPRINTF((\"audio_open: done sc_mode = 0x%x\\n\", sc->sc_mode));\n\t\n\treturn 0;\n\nbad:\n\thw->close(sc->hw_hdl);\n\tsc->sc_open = 0;\n\tsc->sc_mode = 0;\n\tsc->sc_full_duplex = 0;\n\treturn error;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_open(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\tint unit = AUDIOUNIT(dev);\n\tstruct audio_softc *sc;\n\tint error;\n\tint mode;\n\tstruct audio_hw_if *hw;\n\tstruct audio_info ai;\n\n\tif (unit >= audio_cd.cd_ndevs ||\n\t    (sc = audio_cd.cd_devs[unit]) == NULL)\n\t\treturn ENXIO;\n\n\thw = sc->hw_if;\n\tif (!hw)\n\t\treturn ENXIO;\n\n\tDPRINTF((\"audio_open: dev=0x%x flags=0x%x sc=%p hdl=%p\\n\", dev, flags, sc, sc->hw_hdl));\n\n\tif (ISDEVAUDIOCTL(dev))\n\t\treturn 0;\n\n\tif ((sc->sc_open & (AUOPEN_READ|AUOPEN_WRITE)) != 0)\n\t\treturn (EBUSY);\n\n\terror = hw->open(sc->hw_hdl, flags);\n\tif (error)\n\t\treturn (error);\n\n\tsc->sc_async_audio = 0;\n\tsc->sc_rchan = 0;\n\tsc->sc_wchan = 0;\n\tsc->sc_blkset = 0; /* Block sizes not set yet */\n\tsc->sc_sil_count = 0;\n\tsc->sc_rbus = 0;\n\tsc->sc_pbus = 0;\n\tsc->sc_eof = 0;\n\tsc->sc_playdrop = 0;\n\n\tsc->sc_full_duplex = 0;\n/* doesn't always work right on SB.\n\t\t(flags & (FWRITE|FREAD)) == (FWRITE|FREAD) &&\n\t\t(hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX);\n*/\n\n\tmode = 0;\n\tif (flags & FREAD) {\n\t\tsc->sc_open |= AUOPEN_READ;\n\t\tmode |= AUMODE_RECORD;\n\t}\n\tif (flags & FWRITE) {\n\t\tsc->sc_open |= AUOPEN_WRITE;\n\t\tmode |= AUMODE_PLAY | AUMODE_PLAY_ALL;\n\t}\n\n\t/*\n\t * Multiplex device: /dev/audio (MU-Law) and /dev/sound (linear)\n\t * The /dev/audio is always (re)set to 8-bit MU-Law mono\n\t * For the other devices, you get what they were last set to.\n\t */\n\tif (ISDEVAUDIO(dev)) {\n\t\t/* /dev/audio */\n\t\tsc->sc_rparams = audio_default;\n\t\tsc->sc_pparams = audio_default;\n\t}\n#ifdef DIAGNOSTIC\n\t/*\n\t * Sample rate and precision are supposed to be set to proper\n\t * default values by the hardware driver, so that it may give\n\t * us these values.\n\t */\n\tif (sc->sc_rparams.precision == 0 || sc->sc_pparams.precision == 0) {\n\t\tprintf(\"audio_open: 0 precision\\n\");\n\t\treturn EINVAL;\n\t}\n#endif\n\n\tAUDIO_INITINFO(&ai);\n\tai.record.sample_rate = sc->sc_rparams.sample_rate;\n\tai.record.encoding    = sc->sc_rparams.encoding;\n\tai.record.channels    = sc->sc_rparams.channels;\n\tai.record.precision   = sc->sc_rparams.precision;\n\tai.play.sample_rate   = sc->sc_pparams.sample_rate;\n\tai.play.encoding      = sc->sc_pparams.encoding;\n\tai.play.channels      = sc->sc_pparams.channels;\n\tai.play.precision     = sc->sc_pparams.precision;\n\tai.mode\t\t      = mode;\n\tsc->sc_pr.blksize = sc->sc_rr.blksize = 0; /* force recalculation */\n\terror = audiosetinfo(sc, &ai);\n\tif (error)\n\t\tgoto bad;\n\n\tDPRINTF((\"audio_open: done sc_mode = 0x%x\\n\", sc->sc_mode));\n\t\n\treturn 0;\n\nbad:\n\thw->close(sc->hw_hdl);\n\tsc->sc_open = 0;\n\tsc->sc_mode = 0;\n\tsc->sc_full_duplex = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIODEV",
          "args": [
            "dev"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudioopen(dev, flags, ifmt, p)\n\tdev_t dev;\n\tint flags, ifmt;\n\tstruct proc *p;\n{\n\n\tswitch (AUDIODEV(dev)) {\n\tcase SOUND_DEVICE:\n\tcase AUDIO_DEVICE:\n\tcase AUDIOCTL_DEVICE:\n\t\treturn (audio_open(dev, flags, ifmt, p));\n\tcase MIXER_DEVICE:\n\t\treturn (mixer_open(dev, flags, ifmt, p));\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n}"
  },
  {
    "function_name": "audio_free_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "493-503",
    "snippet": "void\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "r->start",
            "M_DEVBUF"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "audio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "493-503",
          "snippet": "void\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sc->hw_if->freem",
          "args": [
            "sc->hw_hdl",
            "r->start",
            "M_DEVBUF"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}"
  },
  {
    "function_name": "audio_alloc_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "467-491",
    "snippet": "int\naudio_alloc_ring(sc, r, bufsize)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n\tint bufsize;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tvoid *hdl = sc->hw_hdl;\n\t/*\n\t * Alloc DMA play and record buffers\n\t */\n\tROUNDSIZE(bufsize);\n\tif (bufsize < AUMINBUF)\n\t\tbufsize = AUMINBUF;\n\tif (hw->round_buffersize)\n\t\tbufsize = hw->round_buffersize(hdl, bufsize);\n\tr->bufsize = bufsize;\n\tif (hw->allocm)\n\t    r->start = hw->allocm(hdl, r->bufsize, M_DEVBUF, M_WAITOK);\n\telse\n\t    r->start = malloc(bufsize, M_DEVBUF, M_WAITOK);\n\tif (r->start == 0)\n\t\treturn ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "bufsize",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw->allocm",
          "args": [
            "hdl",
            "r->bufsize",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw->round_buffersize",
          "args": [
            "hdl",
            "bufsize"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUNDSIZE",
          "args": [
            "bufsize"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_alloc_ring(sc, r, bufsize)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n\tint bufsize;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tvoid *hdl = sc->hw_hdl;\n\t/*\n\t * Alloc DMA play and record buffers\n\t */\n\tROUNDSIZE(bufsize);\n\tif (bufsize < AUMINBUF)\n\t\tbufsize = AUMINBUF;\n\tif (hw->round_buffersize)\n\t\tbufsize = hw->round_buffersize(hdl, bufsize);\n\tr->bufsize = bufsize;\n\tif (hw->allocm)\n\t    r->start = hw->allocm(hdl, r->bufsize, M_DEVBUF, M_WAITOK);\n\telse\n\t    r->start = malloc(bufsize, M_DEVBUF, M_WAITOK);\n\tif (r->start == 0)\n\t\treturn ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "audio_print_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "457-464",
    "snippet": "void\naudio_print_params(s, p)\n\tchar *s;\n\tstruct audio_params *p;\n{\n\tprintf(\"audio: %s sr=%ld, enc=%d, chan=%d, prec=%d\\n\", s,\n\t       p->sample_rate, p->encoding, p->channels, p->precision);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio: %s sr=%ld, enc=%d, chan=%d, prec=%d\\n\"",
            "s",
            "p->sample_rate",
            "p->encoding",
            "p->channels",
            "p->precision"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_print_params(s, p)\n\tchar *s;\n\tstruct audio_params *p;\n{\n\tprintf(\"audio: %s sr=%ld, enc=%d, chan=%d, prec=%d\\n\", s,\n\t       p->sample_rate, p->encoding, p->channels, p->precision);\n}"
  },
  {
    "function_name": "audio_printsc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "444-455",
    "snippet": "void\naudio_printsc(sc)\n\tstruct audio_softc *sc;\n{\n\tprintf(\"hwhandle %p hw_if %p \", sc->hw_hdl, sc->hw_if);\n\tprintf(\"open 0x%x mode 0x%x\\n\", sc->sc_open, sc->sc_mode);\n\tprintf(\"rchan 0x%x wchan 0x%x \", sc->sc_rchan, sc->sc_wchan);\n\tprintf(\"rring used 0x%x pring used=%d\\n\", sc->sc_rr.used, sc->sc_pr.used);\n\tprintf(\"rbus 0x%x pbus 0x%x \", sc->sc_rbus, sc->sc_pbus);\n\tprintf(\"blksize %d\", sc->sc_pr.blksize);\n\tprintf(\"hiwat %d lowat %d\\n\", sc->sc_pr.usedhigh, sc->sc_pr.usedlow);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"hiwat %d lowat %d\\n\"",
            "sc->sc_pr.usedhigh",
            "sc->sc_pr.usedlow"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_printsc(sc)\n\tstruct audio_softc *sc;\n{\n\tprintf(\"hwhandle %p hw_if %p \", sc->hw_hdl, sc->hw_if);\n\tprintf(\"open 0x%x mode 0x%x\\n\", sc->sc_open, sc->sc_mode);\n\tprintf(\"rchan 0x%x wchan 0x%x \", sc->sc_rchan, sc->sc_wchan);\n\tprintf(\"rring used 0x%x pring used=%d\\n\", sc->sc_rr.used, sc->sc_pr.used);\n\tprintf(\"rbus 0x%x pbus 0x%x \", sc->sc_rbus, sc->sc_pbus);\n\tprintf(\"blksize %d\", sc->sc_pr.blksize);\n\tprintf(\"hiwat %d lowat %d\\n\", sc->sc_pr.usedhigh, sc->sc_pr.usedlow);\n}"
  },
  {
    "function_name": "audioprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "411-436",
    "snippet": "int\naudioprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct audio_attach_args *arg = aux;\n\tconst char *type;\n \n\tif (pnp != NULL) {\n\t\tswitch (arg->type) {\n\t\tcase AUDIODEV_TYPE_AUDIO:\n\t\t\ttype = \"audio\";\n\t\t\tbreak;\n\t\tcase AUDIODEV_TYPE_OPL:\n\t\t\ttype = \"opl\";\n\t\t\tbreak;\n\t\tcase AUDIODEV_TYPE_MPU:\n\t\t\ttype = \"mpu\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"audioprint: unknown type %d\", arg->type);\n\t\t}\n\t\tprintf(\"%s at %s\", type, pnp);\n\t}\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s at %s\"",
            "type",
            "pnp"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"audioprint: unknown type %d\"",
            "arg->type"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudioprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct audio_attach_args *arg = aux;\n\tconst char *type;\n \n\tif (pnp != NULL) {\n\t\tswitch (arg->type) {\n\t\tcase AUDIODEV_TYPE_AUDIO:\n\t\t\ttype = \"audio\";\n\t\t\tbreak;\n\t\tcase AUDIODEV_TYPE_OPL:\n\t\t\ttype = \"opl\";\n\t\t\tbreak;\n\t\tcase AUDIODEV_TYPE_MPU:\n\t\t\ttype = \"mpu\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"audioprint: unknown type %d\", arg->type);\n\t\t}\n\t\tprintf(\"%s at %s\", type, pnp);\n\t}\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "audio_attach_mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "394-408",
    "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "dev",
            "&arg",
            "audioprint"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
  },
  {
    "function_name": "au_check_ports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "338-388",
    "snippet": "void\nau_check_ports(sc, ports, mi, cls, name, mname, tbl)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tmixer_devinfo_t *mi;\n\tint\tcls;\n\tchar\t*name;\n\tchar\t*mname;\n\tstruct\tportname *tbl;\n{\n\tint i, j;\n\n\tif (mi->mixer_class != cls)\n\t\treturn;\n\tif (strcmp(mi->label.name, mname) == 0) {\n\t\tports->master = mi->index;\n\t\treturn;\n\t}\n\tif (strcmp(mi->label.name, name) != 0)\n\t\treturn;\n\tif (mi->type == AUDIO_MIXER_ENUM) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.e.num_mem; j++) {\n\t\t    if (strcmp(mi->un.e.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.e.member[j].ord;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.e.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t    ports->isenum = 1;\n\t} else if (mi->type == AUDIO_MIXER_SET) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.s.num_mem; j++) {\n\t\t    if (strcmp(mi->un.s.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.s.member[j].mask;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.s.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t}\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "au_portof",
          "args": [
            "sc",
            "mi->un.s.member[j].label.name"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "au_portof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "323-336",
          "snippet": "int\nau_portof(sc, name)\n\tstruct\taudio_softc *sc;\n\tchar\t*name;\n{\n\tmixer_devinfo_t mi;\n\n\tfor(mi.index = 0; \n\t    sc->hw_if->query_devinfo(sc->hw_hdl, &mi) == 0;\n\t    mi.index++)\n\t\tif (strcmp(mi.label.name, name) == 0)\n\t\t\treturn mi.index;\n\treturn -1;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_portof(sc, name)\n\tstruct\taudio_softc *sc;\n\tchar\t*name;\n{\n\tmixer_devinfo_t mi;\n\n\tfor(mi.index = 0; \n\t    sc->hw_if->query_devinfo(sc->hw_hdl, &mi) == 0;\n\t    mi.index++)\n\t\tif (strcmp(mi.label.name, name) == 0)\n\t\t\treturn mi.index;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi->un.s.member[j].label.name",
            "tbl[i].name"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi->un.e.member[j].label.name",
            "tbl[i].name"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi->label.name",
            "name"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi->label.name",
            "mname"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\nau_check_ports(sc, ports, mi, cls, name, mname, tbl)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tmixer_devinfo_t *mi;\n\tint\tcls;\n\tchar\t*name;\n\tchar\t*mname;\n\tstruct\tportname *tbl;\n{\n\tint i, j;\n\n\tif (mi->mixer_class != cls)\n\t\treturn;\n\tif (strcmp(mi->label.name, mname) == 0) {\n\t\tports->master = mi->index;\n\t\treturn;\n\t}\n\tif (strcmp(mi->label.name, name) != 0)\n\t\treturn;\n\tif (mi->type == AUDIO_MIXER_ENUM) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.e.num_mem; j++) {\n\t\t    if (strcmp(mi->un.e.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.e.member[j].ord;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.e.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t    ports->isenum = 1;\n\t} else if (mi->type == AUDIO_MIXER_SET) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.s.num_mem; j++) {\n\t\t    if (strcmp(mi->un.s.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.s.member[j].mask;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.s.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t}\n}"
  },
  {
    "function_name": "au_portof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "323-336",
    "snippet": "int\nau_portof(sc, name)\n\tstruct\taudio_softc *sc;\n\tchar\t*name;\n{\n\tmixer_devinfo_t mi;\n\n\tfor(mi.index = 0; \n\t    sc->hw_if->query_devinfo(sc->hw_hdl, &mi) == 0;\n\t    mi.index++)\n\t\tif (strcmp(mi.label.name, name) == 0)\n\t\t\treturn mi.index;\n\treturn -1;\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi.label.name",
            "name"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->hw_if->query_devinfo",
          "args": [
            "sc->hw_hdl",
            "&mi"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\nau_portof(sc, name)\n\tstruct\taudio_softc *sc;\n\tchar\t*name;\n{\n\tmixer_devinfo_t mi;\n\n\tfor(mi.index = 0; \n\t    sc->hw_if->query_devinfo(sc->hw_hdl, &mi) == 0;\n\t    mi.index++)\n\t\tif (strcmp(mi.label.name, name) == 0)\n\t\t\treturn mi.index;\n\treturn -1;\n}"
  },
  {
    "function_name": "audioattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
    "lines": "220-321",
    "snippet": "void\naudioattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct audio_softc *sc = (void *)self;\n\tstruct audio_attach_args *sa = aux;\n\tstruct audio_hw_if *hwp = sa->hwif;\n\tvoid *hdlp = sa->hdl;\n\tint error;\n\tmixer_devinfo_t mi;\n\tint iclass, oclass;\n\n\tprintf(\"\\n\");\n\n#ifdef DIAGNOSTIC\n\tif (hwp == 0 ||\n\t    hwp->open == 0 ||\n\t    hwp->close == 0 ||\n\t    hwp->query_encoding == 0 ||\n\t    hwp->set_params == 0 ||\n\t    (hwp->start_output == 0 && hwp->trigger_output == 0) ||\n\t    (hwp->start_input == 0 && hwp->trigger_input == 0) ||\n\t    hwp->halt_output == 0 ||\n\t    hwp->halt_input == 0 ||\n\t    hwp->getdev == 0 ||\n\t    hwp->set_port == 0 ||\n\t    hwp->get_port == 0 ||\n\t    hwp->query_devinfo == 0 ||\n\t    hwp->get_props == 0) {\n\t\tprintf(\"audio: missing method\\n\");\n\t\tsc->hw_if = 0;\n\t\treturn;\n        }\n#endif\n\n\tsc->hw_if = hwp;\n\tsc->hw_hdl = hdlp;\n\tsc->sc_dev = parent;\n\n\terror = audio_alloc_ring(sc, &sc->sc_pr, AU_RING_SIZE);\n\tif (error) {\n\t\tsc->hw_if = 0;\n\t\tprintf(\"audio: could not allocate play buffer\\n\");\n\t\treturn;\n\t}\n\terror = audio_alloc_ring(sc, &sc->sc_rr, AU_RING_SIZE);\n\tif (error) {\n\t\taudio_free_ring(sc, &sc->sc_pr);\n\t\tsc->hw_if = 0;\n\t\tprintf(\"audio: could not allocate record buffer\\n\");\n\t\treturn;\n\t}\n\t\n\t/*\n\t * Set default softc params\n\t */\n\tsc->sc_pparams = audio_default;\n\tsc->sc_rparams = audio_default;\n\n\t/* Set up some default values */\n\tsc->sc_blkset = 0;\n\taudio_calc_blksize(sc, AUMODE_RECORD);\n\taudio_calc_blksize(sc, AUMODE_PLAY);\n\taudio_init_ringbuffer(&sc->sc_rr);\n\taudio_init_ringbuffer(&sc->sc_pr);\n\taudio_calcwater(sc);\n\n\ticlass = oclass = -1;\n\tsc->sc_inports.index = -1;\n\tsc->sc_inports.nports = 0;\n\tsc->sc_inports.isenum = 0;\n\tsc->sc_inports.allports = 0;\n\tsc->sc_outports.index = -1;\n\tsc->sc_outports.nports = 0;\n\tsc->sc_outports.isenum = 0;\n\tsc->sc_outports.allports = 0;\n\tsc->sc_monitor_port = -1;\n\tfor(mi.index = 0; ; mi.index++) {\n\t\tif (hwp->query_devinfo(hdlp, &mi) != 0)\n\t\t\tbreak;\n\t\tif (mi.type == AUDIO_MIXER_CLASS &&\n\t\t    strcmp(mi.label.name, AudioCrecord) == 0)\n\t\t\ticlass = mi.index;\n\t\tif (mi.type == AUDIO_MIXER_CLASS &&\n\t\t    strcmp(mi.label.name, AudioCmonitor) == 0)\n\t\t\toclass = mi.index;\n\t}\n\tfor(mi.index = 0; ; mi.index++) {\n\t\tif (hwp->query_devinfo(hdlp, &mi) != 0)\n\t\t\tbreak;\n\t\tau_check_ports(sc, &sc->sc_inports,  &mi, iclass, \n\t\t\t       AudioNsource, AudioNrecord, itable);\n\t\tau_check_ports(sc, &sc->sc_outports, &mi, oclass, \n\t\t\t       AudioNoutput, AudioNmaster, otable);\n\t\tif (mi.mixer_class == oclass && \n\t\t    strcmp(mi.label.name, AudioNmonitor))\n\t\t\tsc->sc_monitor_port = mi.index;\n\t}\n\tDPRINTF((\"audio_attach: inputs ports=0x%x, output ports=0x%x\\n\",\n\t\t sc->sc_inports.allports, sc->sc_outports.allports));\n}",
    "includes": [
      "#include <machine/endian.h>",
      "#include <vm/vm_prot.h>",
      "#include <vm/vm.h>",
      "#include <dev/rndvar.h>",
      "#include <dev/audiovar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/device.h>",
      "#include <sys/audioio.h>",
      "#include <sys/conf.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/syslog.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include \"audio.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"audio_attach: inputs ports=0x%x, output ports=0x%x\\n\",\n\t\t sc->sc_inports.allports, sc->sc_outports.allports)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi.label.name",
            "AudioNmonitor"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_check_ports",
          "args": [
            "sc",
            "&sc->sc_outports",
            "&mi",
            "oclass",
            "AudioNoutput",
            "AudioNmaster",
            "otable"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "au_check_ports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "338-388",
          "snippet": "void\nau_check_ports(sc, ports, mi, cls, name, mname, tbl)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tmixer_devinfo_t *mi;\n\tint\tcls;\n\tchar\t*name;\n\tchar\t*mname;\n\tstruct\tportname *tbl;\n{\n\tint i, j;\n\n\tif (mi->mixer_class != cls)\n\t\treturn;\n\tif (strcmp(mi->label.name, mname) == 0) {\n\t\tports->master = mi->index;\n\t\treturn;\n\t}\n\tif (strcmp(mi->label.name, name) != 0)\n\t\treturn;\n\tif (mi->type == AUDIO_MIXER_ENUM) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.e.num_mem; j++) {\n\t\t    if (strcmp(mi->un.e.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.e.member[j].ord;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.e.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t    ports->isenum = 1;\n\t} else if (mi->type == AUDIO_MIXER_SET) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.s.num_mem; j++) {\n\t\t    if (strcmp(mi->un.s.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.s.member[j].mask;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.s.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\nau_check_ports(sc, ports, mi, cls, name, mname, tbl)\n\tstruct\taudio_softc *sc;\n\tstruct\tau_mixer_ports *ports;\n\tmixer_devinfo_t *mi;\n\tint\tcls;\n\tchar\t*name;\n\tchar\t*mname;\n\tstruct\tportname *tbl;\n{\n\tint i, j;\n\n\tif (mi->mixer_class != cls)\n\t\treturn;\n\tif (strcmp(mi->label.name, mname) == 0) {\n\t\tports->master = mi->index;\n\t\treturn;\n\t}\n\tif (strcmp(mi->label.name, name) != 0)\n\t\treturn;\n\tif (mi->type == AUDIO_MIXER_ENUM) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.e.num_mem; j++) {\n\t\t    if (strcmp(mi->un.e.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.e.member[j].ord;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.e.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t    ports->isenum = 1;\n\t} else if (mi->type == AUDIO_MIXER_SET) {\n\t    ports->index = mi->index;\n\t    for(i = 0; tbl[i].name; i++) {\n\t\tfor(j = 0; j < mi->un.s.num_mem; j++) {\n\t\t    if (strcmp(mi->un.s.member[j].label.name,\n\t\t\t       tbl[i].name) == 0) {\n\t\t\tports->aumask[ports->nports] = tbl[i].mask;\n\t\t\tports->misel [ports->nports] = mi->un.s.member[j].mask;\n\t\t\tports->miport[ports->nports++] = \n\t\t\t\tau_portof(sc, mi->un.s.member[j].label.name);\n\t\t\tports->allports |= tbl[i].mask;\n\t\t    }\n\t\t}\n\t    }\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwp->query_devinfo",
          "args": [
            "hdlp",
            "&mi"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi.label.name",
            "AudioCmonitor"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mi.label.name",
            "AudioCrecord"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwp->query_devinfo",
          "args": [
            "hdlp",
            "&mi"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audio_calcwater",
          "args": [
            "sc"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "audio_calcwater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "721-731",
          "snippet": "void\naudio_calcwater(sc)\n\tstruct audio_softc *sc;\n{\n\tsc->sc_pr.usedhigh = sc->sc_pr.end - sc->sc_pr.start;\n\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh * 3 / 4;\t/* set lowater at 75% */\n\tif (sc->sc_pr.usedlow == sc->sc_pr.usedhigh)\n\t\tsc->sc_pr.usedlow -= sc->sc_pr.blksize;\n\tsc->sc_rr.usedhigh = sc->sc_pr.end - sc->sc_pr.start - sc->sc_pr.blksize;\n\tsc->sc_rr.usedlow = 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_calcwater(sc)\n\tstruct audio_softc *sc;\n{\n\tsc->sc_pr.usedhigh = sc->sc_pr.end - sc->sc_pr.start;\n\tsc->sc_pr.usedlow = sc->sc_pr.usedhigh * 3 / 4;\t/* set lowater at 75% */\n\tif (sc->sc_pr.usedlow == sc->sc_pr.usedhigh)\n\t\tsc->sc_pr.usedlow -= sc->sc_pr.blksize;\n\tsc->sc_rr.usedhigh = sc->sc_pr.end - sc->sc_pr.start - sc->sc_pr.blksize;\n\tsc->sc_rr.usedlow = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_init_ringbuffer",
          "args": [
            "&sc->sc_pr"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "audio_init_ringbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "643-670",
          "snippet": "void\naudio_init_ringbuffer(rp)\n\tstruct audio_ringbuffer *rp;\n{\n\tint nblks;\n\tint blksize = rp->blksize;\n\n\tif (blksize < AUMINBLK)\n\t\tblksize = AUMINBLK;\n\tnblks = rp->bufsize / blksize;\n\tif (nblks < AUMINNOBLK) {\n\t\tnblks = AUMINNOBLK;\n\t\tblksize = rp->bufsize / nblks;\n\t\tROUNDSIZE(blksize);\n\t}\n\tDPRINTF((\"audio_init_ringbuffer: blksize=%d\\n\", blksize));\n\trp->blksize = blksize;\n\trp->maxblks = nblks;\n\trp->used = 0;\n\trp->end = rp->start + nblks * blksize;\n\trp->inp = rp->outp = rp->start;\n\trp->stamp = 0;\n\trp->drops = 0;\n\trp->pause = 0;\n\trp->copying = 0;\n\trp->needfill = 0;\n\trp->mmapped = 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_init_ringbuffer(rp)\n\tstruct audio_ringbuffer *rp;\n{\n\tint nblks;\n\tint blksize = rp->blksize;\n\n\tif (blksize < AUMINBLK)\n\t\tblksize = AUMINBLK;\n\tnblks = rp->bufsize / blksize;\n\tif (nblks < AUMINNOBLK) {\n\t\tnblks = AUMINNOBLK;\n\t\tblksize = rp->bufsize / nblks;\n\t\tROUNDSIZE(blksize);\n\t}\n\tDPRINTF((\"audio_init_ringbuffer: blksize=%d\\n\", blksize));\n\trp->blksize = blksize;\n\trp->maxblks = nblks;\n\trp->used = 0;\n\trp->end = rp->start + nblks * blksize;\n\trp->inp = rp->outp = rp->start;\n\trp->stamp = 0;\n\trp->drops = 0;\n\trp->pause = 0;\n\trp->copying = 0;\n\trp->needfill = 0;\n\trp->mmapped = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_calc_blksize",
          "args": [
            "sc",
            "AUMODE_PLAY"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "audio_calc_blksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1158-1189",
          "snippet": "void\naudio_calc_blksize(sc, mode)\n\tstruct audio_softc *sc;\n\tint mode;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params *parm;\n\tstruct audio_ringbuffer *rb;\n    \tint bs;\n\n\tif (sc->sc_blkset)\n\t\treturn;\n\n\tif (mode == AUMODE_PLAY) {\n\t\tparm = &sc->sc_pparams;\n\t\trb = &sc->sc_pr;\n\t} else {\n\t\tparm = &sc->sc_rparams;\n\t\trb = &sc->sc_rr;\n\t}\n\t\n\tbs = parm->sample_rate * audio_blk_ms / 1000 *\n\t     parm->channels * parm->precision / NBBY *\n\t     parm->factor;\n\tROUNDSIZE(bs);\n\tif (hw->round_blocksize)\n\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\trb->blksize = bs;\n\n\tDPRINTF((\"audio_calc_blksize: %s blksize=%d\\n\", \n\t\t mode == AUMODE_PLAY ? \"play\" : \"record\", bs));\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_calc_blksize(sc, mode)\n\tstruct audio_softc *sc;\n\tint mode;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tstruct audio_params *parm;\n\tstruct audio_ringbuffer *rb;\n    \tint bs;\n\n\tif (sc->sc_blkset)\n\t\treturn;\n\n\tif (mode == AUMODE_PLAY) {\n\t\tparm = &sc->sc_pparams;\n\t\trb = &sc->sc_pr;\n\t} else {\n\t\tparm = &sc->sc_rparams;\n\t\trb = &sc->sc_rr;\n\t}\n\t\n\tbs = parm->sample_rate * audio_blk_ms / 1000 *\n\t     parm->channels * parm->precision / NBBY *\n\t     parm->factor;\n\tROUNDSIZE(bs);\n\tif (hw->round_blocksize)\n\t\tbs = hw->round_blocksize(sc->hw_hdl, bs);\n\trb->blksize = bs;\n\n\tDPRINTF((\"audio_calc_blksize: %s blksize=%d\\n\", \n\t\t mode == AUMODE_PLAY ? \"play\" : \"record\", bs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"audio: could not allocate record buffer\\n\""
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_free_ring",
          "args": [
            "sc",
            "&sc->sc_pr"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "audio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "493-503",
          "snippet": "void\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audio_alloc_ring",
          "args": [
            "sc",
            "&sc->sc_rr",
            "AU_RING_SIZE"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "audio_alloc_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "467-491",
          "snippet": "int\naudio_alloc_ring(sc, r, bufsize)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n\tint bufsize;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tvoid *hdl = sc->hw_hdl;\n\t/*\n\t * Alloc DMA play and record buffers\n\t */\n\tROUNDSIZE(bufsize);\n\tif (bufsize < AUMINBUF)\n\t\tbufsize = AUMINBUF;\n\tif (hw->round_buffersize)\n\t\tbufsize = hw->round_buffersize(hdl, bufsize);\n\tr->bufsize = bufsize;\n\tif (hw->allocm)\n\t    r->start = hw->allocm(hdl, r->bufsize, M_DEVBUF, M_WAITOK);\n\telse\n\t    r->start = malloc(bufsize, M_DEVBUF, M_WAITOK);\n\tif (r->start == 0)\n\t\treturn ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_alloc_ring(sc, r, bufsize)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n\tint bufsize;\n{\n\tstruct audio_hw_if *hw = sc->hw_if;\n\tvoid *hdl = sc->hw_hdl;\n\t/*\n\t * Alloc DMA play and record buffers\n\t */\n\tROUNDSIZE(bufsize);\n\tif (bufsize < AUMINBUF)\n\t\tbufsize = AUMINBUF;\n\tif (hw->round_buffersize)\n\t\tbufsize = hw->round_buffersize(hdl, bufsize);\n\tr->bufsize = bufsize;\n\tif (hw->allocm)\n\t    r->start = hw->allocm(hdl, r->bufsize, M_DEVBUF, M_WAITOK);\n\telse\n\t    r->start = malloc(bufsize, M_DEVBUF, M_WAITOK);\n\tif (r->start == 0)\n\t\treturn ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudioattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct audio_softc *sc = (void *)self;\n\tstruct audio_attach_args *sa = aux;\n\tstruct audio_hw_if *hwp = sa->hwif;\n\tvoid *hdlp = sa->hdl;\n\tint error;\n\tmixer_devinfo_t mi;\n\tint iclass, oclass;\n\n\tprintf(\"\\n\");\n\n#ifdef DIAGNOSTIC\n\tif (hwp == 0 ||\n\t    hwp->open == 0 ||\n\t    hwp->close == 0 ||\n\t    hwp->query_encoding == 0 ||\n\t    hwp->set_params == 0 ||\n\t    (hwp->start_output == 0 && hwp->trigger_output == 0) ||\n\t    (hwp->start_input == 0 && hwp->trigger_input == 0) ||\n\t    hwp->halt_output == 0 ||\n\t    hwp->halt_input == 0 ||\n\t    hwp->getdev == 0 ||\n\t    hwp->set_port == 0 ||\n\t    hwp->get_port == 0 ||\n\t    hwp->query_devinfo == 0 ||\n\t    hwp->get_props == 0) {\n\t\tprintf(\"audio: missing method\\n\");\n\t\tsc->hw_if = 0;\n\t\treturn;\n        }\n#endif\n\n\tsc->hw_if = hwp;\n\tsc->hw_hdl = hdlp;\n\tsc->sc_dev = parent;\n\n\terror = audio_alloc_ring(sc, &sc->sc_pr, AU_RING_SIZE);\n\tif (error) {\n\t\tsc->hw_if = 0;\n\t\tprintf(\"audio: could not allocate play buffer\\n\");\n\t\treturn;\n\t}\n\terror = audio_alloc_ring(sc, &sc->sc_rr, AU_RING_SIZE);\n\tif (error) {\n\t\taudio_free_ring(sc, &sc->sc_pr);\n\t\tsc->hw_if = 0;\n\t\tprintf(\"audio: could not allocate record buffer\\n\");\n\t\treturn;\n\t}\n\t\n\t/*\n\t * Set default softc params\n\t */\n\tsc->sc_pparams = audio_default;\n\tsc->sc_rparams = audio_default;\n\n\t/* Set up some default values */\n\tsc->sc_blkset = 0;\n\taudio_calc_blksize(sc, AUMODE_RECORD);\n\taudio_calc_blksize(sc, AUMODE_PLAY);\n\taudio_init_ringbuffer(&sc->sc_rr);\n\taudio_init_ringbuffer(&sc->sc_pr);\n\taudio_calcwater(sc);\n\n\ticlass = oclass = -1;\n\tsc->sc_inports.index = -1;\n\tsc->sc_inports.nports = 0;\n\tsc->sc_inports.isenum = 0;\n\tsc->sc_inports.allports = 0;\n\tsc->sc_outports.index = -1;\n\tsc->sc_outports.nports = 0;\n\tsc->sc_outports.isenum = 0;\n\tsc->sc_outports.allports = 0;\n\tsc->sc_monitor_port = -1;\n\tfor(mi.index = 0; ; mi.index++) {\n\t\tif (hwp->query_devinfo(hdlp, &mi) != 0)\n\t\t\tbreak;\n\t\tif (mi.type == AUDIO_MIXER_CLASS &&\n\t\t    strcmp(mi.label.name, AudioCrecord) == 0)\n\t\t\ticlass = mi.index;\n\t\tif (mi.type == AUDIO_MIXER_CLASS &&\n\t\t    strcmp(mi.label.name, AudioCmonitor) == 0)\n\t\t\toclass = mi.index;\n\t}\n\tfor(mi.index = 0; ; mi.index++) {\n\t\tif (hwp->query_devinfo(hdlp, &mi) != 0)\n\t\t\tbreak;\n\t\tau_check_ports(sc, &sc->sc_inports,  &mi, iclass, \n\t\t\t       AudioNsource, AudioNrecord, itable);\n\t\tau_check_ports(sc, &sc->sc_outports, &mi, oclass, \n\t\t\t       AudioNoutput, AudioNmaster, otable);\n\t\tif (mi.mixer_class == oclass && \n\t\t    strcmp(mi.label.name, AudioNmonitor))\n\t\t\tsc->sc_monitor_port = mi.index;\n\t}\n\tDPRINTF((\"audio_attach: inputs ports=0x%x, output ports=0x%x\\n\",\n\t\t sc->sc_inports.allports, sc->sc_outports.allports));\n}"
  }
]