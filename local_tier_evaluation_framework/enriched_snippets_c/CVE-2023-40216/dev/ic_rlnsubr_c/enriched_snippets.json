[
  {
    "function_name": "rln_mbox_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "918-943",
    "snippet": "void\nrln_mbox_unlock(sc, seq, actlen)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tsize_t\t\t\tactlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <unlock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox unlock seq\");\n\tif (mb->mb_state != RLNMBOX_FILLING)\n\t\tpanic(\"mbox unlock\");\n#endif\n\tmb->mb_state = RLNMBOX_FILLED;\n\tdprintf(\" filled>\");\n\tmb->mb_actlen = actlen;\n#if defined(RLN_TSLEEP)\n\twakeup(mb);\n#endif\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "mb"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" filled>\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"mbox unlock\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"mbox unlock seq\""
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" <unlock %d\"",
            "seq"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_mbox_unlock(sc, seq, actlen)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tsize_t\t\t\tactlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <unlock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox unlock seq\");\n\tif (mb->mb_state != RLNMBOX_FILLING)\n\t\tpanic(\"mbox unlock\");\n#endif\n\tmb->mb_state = RLNMBOX_FILLED;\n\tdprintf(\" filled>\");\n\tmb->mb_actlen = actlen;\n#if defined(RLN_TSLEEP)\n\twakeup(mb);\n#endif\n\tsplx(s);\n}"
  },
  {
    "function_name": "rln_mbox_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "885-915",
    "snippet": "int\nrln_mbox_lock(sc, seq, bufp, lenp)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid **\t\t\tbufp;\n\tsize_t *\t\tlenp;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <lock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox lock\");\n#endif\n\tif (mb->mb_state != RLNMBOX_EMPTY) {\n\t\tsplx(s);\n\t\tdprintf(\" ?>\");\n\t\treturn (-1);\n\t}\n\n\tmb->mb_state = RLNMBOX_FILLING;\n\tdprintf(\" filling>\");\n\t*bufp = mb->mb_buf;\n\t*lenp = mb->mb_len;\n\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" filling>\""
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" ?>\""
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"mbox lock\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" <lock %d\"",
            "seq"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_mbox_lock(sc, seq, bufp, lenp)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid **\t\t\tbufp;\n\tsize_t *\t\tlenp;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <lock %d\", seq);\n\n\ts = splhigh();\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox lock\");\n#endif\n\tif (mb->mb_state != RLNMBOX_EMPTY) {\n\t\tsplx(s);\n\t\tdprintf(\" ?>\");\n\t\treturn (-1);\n\t}\n\n\tmb->mb_state = RLNMBOX_FILLING;\n\tdprintf(\" filling>\");\n\t*bufp = mb->mb_buf;\n\t*lenp = mb->mb_len;\n\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_mbox_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "786-818",
    "snippet": "int\nrln_mbox_create(sc, seq, buf, len)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid *\t\t\tbuf;\n\tsize_t\t\t\tlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <create %d\", seq);\n\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox create\");\n#endif\n\n\ts = splhigh();\n\tif (mb->mb_state != RLNMBOX_VOID) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"mbox collision\");\n#endif\n\t\tsplx(s);\n\t\treturn (-1);\n\t}\n\tmb->mb_buf = buf;\n\tmb->mb_len = len;\n\tmb->mb_actlen = 0;\n\tmb->mb_state = RLNMBOX_EMPTY;\n\tdprintf(\" empty>\");\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" empty>\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"mbox collision\""
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"mbox create\""
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" <create %d\"",
            "seq"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_mbox_create(sc, seq, buf, len)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid *\t\t\tbuf;\n\tsize_t\t\t\tlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <create %d\", seq);\n\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox create\");\n#endif\n\n\ts = splhigh();\n\tif (mb->mb_state != RLNMBOX_VOID) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"mbox collision\");\n#endif\n\t\tsplx(s);\n\t\treturn (-1);\n\t}\n\tmb->mb_buf = buf;\n\tmb->mb_len = len;\n\tmb->mb_actlen = 0;\n\tmb->mb_state = RLNMBOX_EMPTY;\n\tdprintf(\" empty>\");\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_msg_txrx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "686-774",
    "snippet": "int\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: command error 0x%02x command %c%d\\n\"",
            "sc->sc_dev.dv_xname",
            "rxc->cmd_error & ~0x80",
            "rxc->cmd_letter",
            "rxc->cmd_fn"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "((char *)rx) + sizeof *rxc",
            "rxlen - sizeof *rxc"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "rxc",
            "sizeof *rxc"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "ien"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_mbox_wait",
          "args": [
            "sc",
            "txc->cmd_seq",
            "4000"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_mbox_wait",
          "args": [
            "sc",
            "txc->cmd_seq",
            "-1"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_msg_tx_end",
          "args": [
            "sc",
            "&state"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_tx_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "638-659",
          "snippet": "int\nrln_msg_tx_end(sc, state)\n\tstruct rln_softc *\tsc;\n\tstruct rln_msg_tx_state * state;\n{\n\tint\t\t\tret;\n\n\t/* Flush the tx buffer. */\n\tif (state->pd.p_nremain)\n\t\trln_msg_tx_data(sc, NULL, 0, state);\n\n#ifdef DIAGNOSTIC\n\tif (state->pd.p_nremain)\n\t\tpanic(\"rln_msg_tx_end remain %d\", state->pd.p_nremain);\n#endif\n\tret = rln_tx_end(sc);\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE)\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, state->w);\n\trln_enable(sc, state->ien);\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trln_tx_end"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_end;\n\nint\nrln_msg_tx_end(sc, state)\n\tstruct rln_softc *\tsc;\n\tstruct rln_msg_tx_state * state;\n{\n\tint\t\t\tret;\n\n\t/* Flush the tx buffer. */\n\tif (state->pd.p_nremain)\n\t\trln_msg_tx_data(sc, NULL, 0, state);\n\n#ifdef DIAGNOSTIC\n\tif (state->pd.p_nremain)\n\t\tpanic(\"rln_msg_tx_end remain %d\", state->pd.p_nremain);\n#endif\n\tret = rln_tx_end(sc);\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE)\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, state->w);\n\trln_enable(sc, state->ien);\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_msg_tx_data",
          "args": [
            "sc",
            "tx",
            "(txlen + 1) & ~1",
            "&state"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_tx_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "587-635",
          "snippet": "void\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_mbox_wait",
          "args": [
            "sc",
            "txc->cmd_seq",
            "-1"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_msg_tx_start",
          "args": [
            "sc",
            "tx",
            "txlen",
            "&state"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_tx_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "554-585",
          "snippet": "int\nrln_msg_tx_start(sc, buf, pktlen, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tpktlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tstruct rln_mm_cmd *\tcmd = (struct rln_mm_cmd *)buf;\n\tint\t\t\tret;\n\n\tstate->ien = rln_enable(sc, 0);\n\tstate->pd.p_nremain = 0;\n\n\tif (!(cmd->cmd_letter == 'A' && cmd->cmd_fn == 6)) \t/* Standby. */\n\t\tstate->w = rln_wakeup(sc, RLN_WAKEUP_SET); \n\telse\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\n\tret = rln_tx_request(sc, pktlen);\n\tif (ret == 2) {\n\t\trln_clear_nak(sc);\n\t\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\t\trln_need_reset(sc);\n\t\tret = 2;\n\t}\n\telse if (ret == 1) {\n\t\t/* Timeout. */\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_XFR);\n\t\tret = -1;\n\t}\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trln_tx_request"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_request;\n\nint\nrln_msg_tx_start(sc, buf, pktlen, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tpktlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tstruct rln_mm_cmd *\tcmd = (struct rln_mm_cmd *)buf;\n\tint\t\t\tret;\n\n\tstate->ien = rln_enable(sc, 0);\n\tstate->pd.p_nremain = 0;\n\n\tif (!(cmd->cmd_letter == 'A' && cmd->cmd_fn == 6)) \t/* Standby. */\n\t\tstate->w = rln_wakeup(sc, RLN_WAKEUP_SET); \n\telse\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\n\tret = rln_tx_request(sc, pktlen);\n\tif (ret == 2) {\n\t\trln_clear_nak(sc);\n\t\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\t\trln_need_reset(sc);\n\t\tret = 2;\n\t}\n\telse if (ret == 1) {\n\t\t/* Timeout. */\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_XFR);\n\t\tret = -1;\n\t}\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_mbox_create",
          "args": [
            "sc",
            "txc->cmd_seq",
            "rx",
            "rxlen"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "rln_mbox_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "786-818",
          "snippet": "int\nrln_mbox_create(sc, seq, buf, len)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid *\t\t\tbuf;\n\tsize_t\t\t\tlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <create %d\", seq);\n\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox create\");\n#endif\n\n\ts = splhigh();\n\tif (mb->mb_state != RLNMBOX_VOID) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"mbox collision\");\n#endif\n\t\tsplx(s);\n\t\treturn (-1);\n\t}\n\tmb->mb_buf = buf;\n\tmb->mb_len = len;\n\tmb->mb_actlen = 0;\n\tmb->mb_state = RLNMBOX_EMPTY;\n\tdprintf(\" empty>\");\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_mbox_create(sc, seq, buf, len)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\tseq;\n\tvoid *\t\t\tbuf;\n\tsize_t\t\t\tlen;\n{\n\tint\t\t\ts;\n\tstruct rln_mbox *\tmb = &sc->sc_mbox[seq];\n\n\tdprintf(\" <create %d\", seq);\n\n#ifdef DIAGNOSTIC\n\tif (seq > RLN_NMBOX)\n\t\tpanic(\"mbox create\");\n#endif\n\n\ts = splhigh();\n\tif (mb->mb_state != RLNMBOX_VOID) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"mbox collision\");\n#endif\n\t\tsplx(s);\n\t\treturn (-1);\n\t}\n\tmb->mb_buf = buf;\n\tmb->mb_len = len;\n\tmb->mb_actlen = 0;\n\tmb->mb_state = RLNMBOX_EMPTY;\n\tdprintf(\" empty>\");\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "(char *)tx + sizeof *txc",
            "txlen - sizeof *txc"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RLNDUMPHEX",
          "args": [
            "txc",
            "sizeof *txc"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_newseq",
          "args": [
            "sc"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "rln_newseq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "662-675",
          "snippet": "u_int8_t\nrln_newseq(sc)\n\tstruct rln_softc * sc;\n{\n\tint s;\n\tu_int8_t seq;\n\n\ts = splhigh();\n\tseq = sc->sc_pktseq++;\n\tif (sc->sc_pktseq > RLN_MAXSEQ)\n\t\tsc->sc_pktseq = 0;\n\tsplx(s);\n\treturn (seq);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_newseq(sc)\n\tstruct rln_softc * sc;\n{\n\tint s;\n\tu_int8_t seq;\n\n\ts = splhigh();\n\tseq = sc->sc_pktseq++;\n\tif (sc->sc_pktseq > RLN_MAXSEQ)\n\t\tsc->sc_pktseq = 0;\n\tsplx(s);\n\treturn (seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_msg_txrx\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_msg_txrx(sc, tx, txlen, rx, rxlen)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\ttx;\n\tint \t\t\ttxlen;\n\tvoid *\t\t\trx;\n\tint\t\t\trxlen;\n{\n\tstruct rln_mm_cmd *\ttxc = (struct rln_mm_cmd *)tx;\n\tstruct rln_mm_cmd *\trxc = (struct rln_mm_cmd *)rx;\n\tstruct rln_msg_tx_state state;\n\tint\t\t\tien;\n\tint\t\t\tret;\n\n#ifdef DIAGNOSTIC\n\tif (rx != NULL && rxlen < sizeof *rxc)\n\t\tpanic(\"rln_msg_txrx\");\n#endif\n\n\ttxc->cmd_seq = rln_newseq(sc);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: send %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    txc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\tRLNDUMPHEX(txc, sizeof *txc);\n\tprintf(\":\");\n\tRLNDUMPHEX((char *)tx + sizeof *txc, txlen - sizeof *txc);\n\tprintf(\"\\n\");\n#endif\n\n\tif (rx != NULL)\n\t\tif (rln_mbox_create(sc, txc->cmd_seq, rx, rxlen) < 0)\n\t\t\t/* Mailbox collision. */\n\t\t\treturn (-1);\n\n\t/* Start the transfer. */\n\tif ((ret = rln_msg_tx_start(sc, tx, txlen, &state))) {\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Always send an even number of octets. */\n\trln_msg_tx_data(sc, tx, (txlen + 1) & ~1, &state);\n\n\t/* End the transmission. */\n\tif ((ret = rln_msg_tx_end(sc, &state))) {\n\t\t/* Destroy mailbox. */\n\t\tif (rx != NULL)\n\t\t\trln_mbox_wait(sc, txc->cmd_seq, -1);\n\t\treturn (ret);\n\t}\n\n\t/* Don't wait for reply if there is nowhere to put it. */\n\tif (rx == NULL)\n\t\treturn (0);\n\n\t/* Enable interrupts if not already. */\n\tien = rln_enable(sc, 1);\n\n\t/* Wait for the reply message. */\n\tif (rln_mbox_wait(sc, txc->cmd_seq, 4000) <= 0) {\n\t\tprintf(\"%s: lost message %c%d seq %d\\n\", sc->sc_dev.dv_xname,\n\t\t\ttxc->cmd_letter, txc->cmd_fn, txc->cmd_seq);\n\t\trln_enable(sc, ien);\n\t\treturn (-1);\n\t}\n\trln_enable(sc, ien);\n\n#ifdef RLNDUMP\n\tprintf(\"%s: recv %c%d seq %d data \", sc->sc_dev.dv_xname, \n\t    rxc->cmd_letter, rxc->cmd_fn, rxc->cmd_seq);\n\tRLNDUMPHEX(rxc, sizeof *rxc);\n\tprintf(\":\");\n\tRLNDUMPHEX(((char *)rx) + sizeof *rxc, rxlen - sizeof *rxc);\n\tprintf(\"\\n\");\n#endif\n\n\t/* Check for errors in the received message. */\n\tif (rxc->cmd_error & 0x80) {\n\t\tprintf(\"%s: command error 0x%02x command %c%d\\n\",\n\t\t\tsc->sc_dev.dv_xname,\n\t\t\trxc->cmd_error & ~0x80,\n\t\t\trxc->cmd_letter, rxc->cmd_fn);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_newseq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "662-675",
    "snippet": "u_int8_t\nrln_newseq(sc)\n\tstruct rln_softc * sc;\n{\n\tint s;\n\tu_int8_t seq;\n\n\ts = splhigh();\n\tseq = sc->sc_pktseq++;\n\tif (sc->sc_pktseq > RLN_MAXSEQ)\n\t\tsc->sc_pktseq = 0;\n\tsplx(s);\n\treturn (seq);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_newseq(sc)\n\tstruct rln_softc * sc;\n{\n\tint s;\n\tu_int8_t seq;\n\n\ts = splhigh();\n\tseq = sc->sc_pktseq++;\n\tif (sc->sc_pktseq > RLN_MAXSEQ)\n\t\tsc->sc_pktseq = 0;\n\tsplx(s);\n\treturn (seq);\n}"
  },
  {
    "function_name": "rln_msg_tx_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "638-659",
    "snippet": "int\nrln_msg_tx_end(sc, state)\n\tstruct rln_softc *\tsc;\n\tstruct rln_msg_tx_state * state;\n{\n\tint\t\t\tret;\n\n\t/* Flush the tx buffer. */\n\tif (state->pd.p_nremain)\n\t\trln_msg_tx_data(sc, NULL, 0, state);\n\n#ifdef DIAGNOSTIC\n\tif (state->pd.p_nremain)\n\t\tpanic(\"rln_msg_tx_end remain %d\", state->pd.p_nremain);\n#endif\n\tret = rln_tx_end(sc);\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE)\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, state->w);\n\trln_enable(sc, state->ien);\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\trln_tx_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "state->ien"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_wakeup",
          "args": [
            "sc",
            "state->w"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_tx_end",
          "args": [
            "sc"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "rln_tx_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "318-347",
          "snippet": "static int\nrln_tx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfTx() */\n\tint\t\ti;\n\tint\t\ts;\n\tu_int8_t\tstatus;\n\n\tdprintf(\" Te[\");\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_tx_read(sc);\n\t\tif (status == RLN_STATUS_TX_XFR_COMPLETE)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status == RLN_STATUS_TX_XFR_COMPLETE) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_IDLE);\n\t\tdprintf(\"]=0\");\n\t\treturn (0);\n\t} else {\n\t\tprintf(\"%s: tx cmd failed (%02x)\\n\", sc->sc_dev.dv_xname,\n\t\t    status);\n\t\trln_need_reset(sc);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trln_tx_end"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_end;\n\nstatic int\nrln_tx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfTx() */\n\tint\t\ti;\n\tint\t\ts;\n\tu_int8_t\tstatus;\n\n\tdprintf(\" Te[\");\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_tx_read(sc);\n\t\tif (status == RLN_STATUS_TX_XFR_COMPLETE)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status == RLN_STATUS_TX_XFR_COMPLETE) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_IDLE);\n\t\tdprintf(\"]=0\");\n\t\treturn (0);\n\t} else {\n\t\tprintf(\"%s: tx cmd failed (%02x)\\n\", sc->sc_dev.dv_xname,\n\t\t    status);\n\t\trln_need_reset(sc);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_msg_tx_end remain %d\"",
            "state->pd.p_nremain"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_msg_tx_data",
          "args": [
            "sc",
            "NULL",
            "0",
            "state"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "rln_msg_tx_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "587-635",
          "snippet": "void\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_end;\n\nint\nrln_msg_tx_end(sc, state)\n\tstruct rln_softc *\tsc;\n\tstruct rln_msg_tx_state * state;\n{\n\tint\t\t\tret;\n\n\t/* Flush the tx buffer. */\n\tif (state->pd.p_nremain)\n\t\trln_msg_tx_data(sc, NULL, 0, state);\n\n#ifdef DIAGNOSTIC\n\tif (state->pd.p_nremain)\n\t\tpanic(\"rln_msg_tx_end remain %d\", state->pd.p_nremain);\n#endif\n\tret = rln_tx_end(sc);\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE)\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\trln_wakeup(sc, state->w);\n\trln_enable(sc, state->ien);\n\treturn (ret);\n}"
  },
  {
    "function_name": "rln_msg_tx_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "587-635",
    "snippet": "void\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprinthex",
          "args": [
            "data",
            "len"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" D<\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_multi_1",
          "args": [
            "sc",
            "buf",
            "len"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_multi_2",
          "args": [
            "sc",
            "buf",
            "len / 2"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_2",
          "args": [
            "sc",
            "u.w"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" D<%02x%02x\"",
            "u.b[0]",
            "u.b[1]"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_msg_tx_data(sc, buf, len, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tu_int16_t\t\tlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (sc->sc_width == 16 && state->pd.p_nremain) {\n\t\t/* XXX htons() needed? */\n\t\tunion {\n\t\t\tu_int8_t  b[2];\n\t\t\tu_int16_t w;\n\t\t} u;\n\n\t\tu.b[0] = state->pd.p_data;\n\t\tif (len) {\n\t\t\tu.b[1] = *data++;\n\t\t\tlen--;\n\t\t} else\n\t\t\tu.b[1] = '\\0';\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<%02x%02x\", u.b[0], u.b[1]);\n#endif\n\t\trln_data_write_2(sc, u.w);\n\t\tstate->pd.p_nremain = 0;\n\t} \n\n\tif (len) {\n\t\tif (sc->sc_width == 16) {\n\t\t\tif (len >= 2)\n\t\t\t\trln_data_write_multi_2(sc, buf, len / 2);\n\t\t\tif (len & 1) {\n\t\t\t\tstate->pd.p_nremain = 1;\n\t\t\t\tstate->pd.p_data = data[len - 1];\n\t\t\t}\n\t\t} else if (sc->sc_width == 8)\n\t\t\trln_data_write_multi_1(sc, buf, len);\n#ifdef DIAGNOSTIC\n\t\telse\n\t\t\tpanic(\"rln_msg_tx_data width %d\", sc->sc_width);\n#endif\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D<\"); \n\t\tdprinthex(data, len);\n#endif\n\t}\n}"
  },
  {
    "function_name": "rln_msg_tx_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "554-585",
    "snippet": "int\nrln_msg_tx_start(sc, buf, pktlen, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tpktlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tstruct rln_mm_cmd *\tcmd = (struct rln_mm_cmd *)buf;\n\tint\t\t\tret;\n\n\tstate->ien = rln_enable(sc, 0);\n\tstate->pd.p_nremain = 0;\n\n\tif (!(cmd->cmd_letter == 'A' && cmd->cmd_fn == 6)) \t/* Standby. */\n\t\tstate->w = rln_wakeup(sc, RLN_WAKEUP_SET); \n\telse\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\n\tret = rln_tx_request(sc, pktlen);\n\tif (ret == 2) {\n\t\trln_clear_nak(sc);\n\t\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\t\trln_need_reset(sc);\n\t\tret = 2;\n\t}\n\telse if (ret == 1) {\n\t\t/* Timeout. */\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_XFR);\n\t\tret = -1;\n\t}\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\trln_tx_request"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_status_tx_write",
          "args": [
            "sc",
            "RLN_STATUS_TX_XFR"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_need_reset",
          "args": [
            "sc"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_clear_nak",
          "args": [
            "sc"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "rln_clear_nak",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "538-546",
          "snippet": "void\nrln_clear_nak(sc)\n\tstruct rln_softc * sc;\n{\n\t/* ClearNAK() */\n\n\trln_status_tx_write(sc, RLN_STATUS_CLRNAK);\n\trln_status_tx_int(sc);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_clear_nak(sc)\n\tstruct rln_softc * sc;\n{\n\t/* ClearNAK() */\n\n\trln_status_tx_write(sc, RLN_STATUS_CLRNAK);\n\trln_status_tx_int(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_tx_request",
          "args": [
            "sc",
            "pktlen"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "rln_tx_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "223-310",
          "snippet": "static int\nrln_tx_request(sc, len)\n\tstruct rln_softc *\tsc;\n\tu_int16_t\t\tlen;\n{\n\t/* TxRequest() */\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\t/* u_int8_t w; */\n\t/* w = rln_wakeup(sc, RLN_WAKEUP_SET); */\n\n\tdprintf(\" Tr[\");\n\tif (sc->sc_width == 16) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\trln_data_write_2(sc, len);\n\t\trln_status_tx_int(sc);\n\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\tgoto success;\n\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\tgoto error;\n\t} else if (sc->sc_width == 8) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_LOLEN_AVAIL);\n\t\trln_data_write_1(sc, len & 0xff);\n\t\trln_status_tx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 6800; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT) {\n\t\t\trln_data_write_1(sc, (len >> 8) & 0xff);\n\t\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\t\ts = spl0();\n\t\t\tfor (i = 0; i < 600; i++) {\n\t\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\t\tbreak;\n\t\t\t\tDELAY(1000);\n\t\t\t}\n\t\t\tsplx(s);\n\t\t\tdprintf(\" %dms\", i);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\t\tgoto success;\n\t\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width\");\n#endif\n\n\tprintf(\"%s: tx_request timed out, status 0x%02x\", \n\t    sc->sc_dev.dv_xname, status);\n\tdprintf(\"]=(1)\");\n\treturn (1);\n\nerror:\n\t/* Will need to clear nak within 100 ms. */\n\tdprintf(\"]=2\");\n#ifdef DIAGNOSTIC\n\tprintf(\"%s: tx protocol fault (nak)\\n\", sc->sc_dev.dv_xname);\n#endif\n\treturn (2);\n\nsuccess:\n\t/* rln_wakeup(sc, w); */\n\tdprintf(\"]=0\");\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trln_tx_request"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_request;\n\nstatic int\nrln_tx_request(sc, len)\n\tstruct rln_softc *\tsc;\n\tu_int16_t\t\tlen;\n{\n\t/* TxRequest() */\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\t/* u_int8_t w; */\n\t/* w = rln_wakeup(sc, RLN_WAKEUP_SET); */\n\n\tdprintf(\" Tr[\");\n\tif (sc->sc_width == 16) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\trln_data_write_2(sc, len);\n\t\trln_status_tx_int(sc);\n\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\tgoto success;\n\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\tgoto error;\n\t} else if (sc->sc_width == 8) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_LOLEN_AVAIL);\n\t\trln_data_write_1(sc, len & 0xff);\n\t\trln_status_tx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 6800; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT) {\n\t\t\trln_data_write_1(sc, (len >> 8) & 0xff);\n\t\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\t\ts = spl0();\n\t\t\tfor (i = 0; i < 600; i++) {\n\t\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\t\tbreak;\n\t\t\t\tDELAY(1000);\n\t\t\t}\n\t\t\tsplx(s);\n\t\t\tdprintf(\" %dms\", i);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\t\tgoto success;\n\t\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width\");\n#endif\n\n\tprintf(\"%s: tx_request timed out, status 0x%02x\", \n\t    sc->sc_dev.dv_xname, status);\n\tdprintf(\"]=(1)\");\n\treturn (1);\n\nerror:\n\t/* Will need to clear nak within 100 ms. */\n\tdprintf(\"]=2\");\n#ifdef DIAGNOSTIC\n\tprintf(\"%s: tx protocol fault (nak)\\n\", sc->sc_dev.dv_xname);\n#endif\n\treturn (2);\n\nsuccess:\n\t/* rln_wakeup(sc, w); */\n\tdprintf(\"]=0\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_wakeup",
          "args": [
            "sc",
            "RLN_WAKEUP_SET"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rln_enable",
          "args": [
            "sc",
            "0"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "rln_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "48-67",
          "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_request;\n\nint\nrln_msg_tx_start(sc, buf, pktlen, state)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tpktlen;\n\tstruct rln_msg_tx_state * state;\n{\n\tstruct rln_mm_cmd *\tcmd = (struct rln_mm_cmd *)buf;\n\tint\t\t\tret;\n\n\tstate->ien = rln_enable(sc, 0);\n\tstate->pd.p_nremain = 0;\n\n\tif (!(cmd->cmd_letter == 'A' && cmd->cmd_fn == 6)) \t/* Standby. */\n\t\tstate->w = rln_wakeup(sc, RLN_WAKEUP_SET); \n\telse\n\t\tstate->w = RLN_WAKEUP_NOCHANGE;\n\n\tret = rln_tx_request(sc, pktlen);\n\tif (ret == 2) {\n\t\trln_clear_nak(sc);\n\t\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\t\trln_need_reset(sc);\n\t\tret = 2;\n\t}\n\telse if (ret == 1) {\n\t\t/* Timeout. */\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_XFR);\n\t\tret = -1;\n\t}\n\treturn (ret);\n}"
  },
  {
    "function_name": "rln_clear_nak",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "538-546",
    "snippet": "void\nrln_clear_nak(sc)\n\tstruct rln_softc * sc;\n{\n\t/* ClearNAK() */\n\n\trln_status_tx_write(sc, RLN_STATUS_CLRNAK);\n\trln_status_tx_int(sc);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rln_status_tx_int",
          "args": [
            "sc"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_write",
          "args": [
            "sc",
            "RLN_STATUS_CLRNAK"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_clear_nak(sc)\n\tstruct rln_softc * sc;\n{\n\t/* ClearNAK() */\n\n\trln_status_tx_write(sc, RLN_STATUS_CLRNAK);\n\trln_status_tx_int(sc);\n}"
  },
  {
    "function_name": "rln_rx_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "524-535",
    "snippet": "void\nrln_rx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfRx() */\n\n\tdprintf(\" Re[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_XFR_COMPLETE);\n\trln_status_rx_int(sc);\n\t/* rln_wakeup(sc, 0); */\n\tdprintf(\"]\");\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_int",
          "args": [
            "sc"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_write",
          "args": [
            "sc",
            "RLN_STATUS_RX_XFR_COMPLETE"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" Re[\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_rx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfRx() */\n\n\tdprintf(\" Re[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_XFR_COMPLETE);\n\trln_status_rx_int(sc);\n\t/* rln_wakeup(sc, 0); */\n\tdprintf(\"]\");\n}"
  },
  {
    "function_name": "rln_rx_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "485-522",
    "snippet": "int\nrln_rx_data(sc, buf, len)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\t/* RxData() */\n\tstruct rln_pdata\tpd = { 0, 0 };\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\tdprintf(\" Rd[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_HILEN_ACCEPT);\n\trln_status_rx_int(sc);\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_rx_read(sc);\n\t\tif (status == RLN_STATUS_RX_XFR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status != RLN_STATUS_RX_XFR) {\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\n\trln_rx_pdata(sc, buf, len, &pd);\n#ifdef DIAGNOSTIC\n\t/* We should have nothing left over. */\n\tif (pd.p_nremain || len & 1)\n\t\tpanic(\"rln_rx_data: leftover\");\n#endif\n\n\tdprintf(\"]=0\");\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=0\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_rx_data: leftover\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_rx_pdata",
          "args": [
            "sc",
            "buf",
            "len",
            "&pd"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "rln_rx_pdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "428-483",
          "snippet": "void\nrln_rx_pdata(sc, buf, len, pd)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n\tstruct rln_pdata *\tpd;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (pd->p_nremain) {\n\t\t*data++ = pd->p_data;\n\t\tif (--len == 0)\n\t\t\treturn;\n\t}\n\n\tpd->p_nremain = 0;\n\n\tif (sc->sc_width == 16) {\n\t\t/* Round down to the closest even multiple. */\n\t\trln_data_read_multi_2(sc, data, len / 2);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Read the last octet plus a bit extra. */\n\t\t\tunion {\n\t\t\t\tu_int16_t w;\n\t\t\t\tu_int8_t  b[2];\n\t\t\t} u;\n\n\t\t\tu.w = rln_data_read_2(sc);\n\t\t\tdata[len - 1] = u.b[0];\n\t\t\tpd->p_data = u.b[1];\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x%02x}\", u.b[0], u.b[1]); \n#endif\n\t\t}\n\t} else if (sc->sc_width == 8) {\n\t\trln_data_read_multi_1(sc, data, len);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Must read multiples of two. */\n\t\t\tpd->p_data = rln_data_read_1(sc);\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x}\", pd->p_data); \n#endif\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_rx_pdata(sc, buf, len, pd)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n\tstruct rln_pdata *\tpd;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (pd->p_nremain) {\n\t\t*data++ = pd->p_data;\n\t\tif (--len == 0)\n\t\t\treturn;\n\t}\n\n\tpd->p_nremain = 0;\n\n\tif (sc->sc_width == 16) {\n\t\t/* Round down to the closest even multiple. */\n\t\trln_data_read_multi_2(sc, data, len / 2);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Read the last octet plus a bit extra. */\n\t\t\tunion {\n\t\t\t\tu_int16_t w;\n\t\t\t\tu_int8_t  b[2];\n\t\t\t} u;\n\n\t\t\tu.w = rln_data_read_2(sc);\n\t\t\tdata[len - 1] = u.b[0];\n\t\t\tpd->p_data = u.b[1];\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x%02x}\", u.b[0], u.b[1]); \n#endif\n\t\t}\n\t} else if (sc->sc_width == 8) {\n\t\trln_data_read_multi_1(sc, data, len);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Must read multiples of two. */\n\t\t\tpd->p_data = rln_data_read_1(sc);\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x}\", pd->p_data); \n#endif\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=-1\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_read",
          "args": [
            "sc"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "rln_status_rx_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnreg.h",
          "lines": "204-214",
          "snippet": "static inline int\nrln_status_rx_ready(sc)\n\tstruct rln_softc *sc;\n{\n\tu_int8_t status;\n\n\tstatus = rln_status_rx_read(sc);\n\treturn (status == RLN_STATUS_RX_LOLEN_AVAIL ||\n\t    status == RLN_STATUS_RX_HILEN_AVAIL ||\n\t    status == RLN_STATUS_RX_ERROR);\n}",
          "includes": [],
          "macros_used": [
            "#define RLN_STATUS_RX_LOLEN_AVAIL\t0x60",
            "#define RLN_STATUS_RX_ERROR\t\t0x50",
            "#define RLN_STATUS_RX_HILEN_AVAIL\t0x10"
          ],
          "globals_used": [
            "static int\trln_status_rx_ready"
          ],
          "called_functions": [],
          "contextual_snippet": "#define RLN_STATUS_RX_LOLEN_AVAIL\t0x60\n#define RLN_STATUS_RX_ERROR\t\t0x50\n#define RLN_STATUS_RX_HILEN_AVAIL\t0x10\n\nstatic int\trln_status_rx_ready;\n\nstatic inline int\nrln_status_rx_ready(sc)\n\tstruct rln_softc *sc;\n{\n\tu_int8_t status;\n\n\tstatus = rln_status_rx_read(sc);\n\treturn (status == RLN_STATUS_RX_LOLEN_AVAIL ||\n\t    status == RLN_STATUS_RX_HILEN_AVAIL ||\n\t    status == RLN_STATUS_RX_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spl0",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_int",
          "args": [
            "sc"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_write",
          "args": [
            "sc",
            "RLN_STATUS_RX_HILEN_ACCEPT"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" Rd[\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_rx_data(sc, buf, len)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\t/* RxData() */\n\tstruct rln_pdata\tpd = { 0, 0 };\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\tdprintf(\" Rd[\");\n\trln_status_rx_write(sc, RLN_STATUS_RX_HILEN_ACCEPT);\n\trln_status_rx_int(sc);\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_rx_read(sc);\n\t\tif (status == RLN_STATUS_RX_XFR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status != RLN_STATUS_RX_XFR) {\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\n\trln_rx_pdata(sc, buf, len, &pd);\n#ifdef DIAGNOSTIC\n\t/* We should have nothing left over. */\n\tif (pd.p_nremain || len & 1)\n\t\tpanic(\"rln_rx_data: leftover\");\n#endif\n\n\tdprintf(\"]=0\");\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_rx_pdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "428-483",
    "snippet": "void\nrln_rx_pdata(sc, buf, len, pd)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n\tstruct rln_pdata *\tpd;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (pd->p_nremain) {\n\t\t*data++ = pd->p_data;\n\t\tif (--len == 0)\n\t\t\treturn;\n\t}\n\n\tpd->p_nremain = 0;\n\n\tif (sc->sc_width == 16) {\n\t\t/* Round down to the closest even multiple. */\n\t\trln_data_read_multi_2(sc, data, len / 2);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Read the last octet plus a bit extra. */\n\t\t\tunion {\n\t\t\t\tu_int16_t w;\n\t\t\t\tu_int8_t  b[2];\n\t\t\t} u;\n\n\t\t\tu.w = rln_data_read_2(sc);\n\t\t\tdata[len - 1] = u.b[0];\n\t\t\tpd->p_data = u.b[1];\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x%02x}\", u.b[0], u.b[1]); \n#endif\n\t\t}\n\t} else if (sc->sc_width == 8) {\n\t\trln_data_read_multi_1(sc, data, len);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Must read multiples of two. */\n\t\t\tpd->p_data = rln_data_read_1(sc);\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x}\", pd->p_data); \n#endif\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" D>{%02x}\"",
            "pd->p_data"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_1",
          "args": [
            "sc"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprinthex",
          "args": [
            "data",
            "len"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" D>\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_multi_1",
          "args": [
            "sc",
            "data",
            "len"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" D>{%02x%02x}\"",
            "u.b[0]",
            "u.b[1]"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_2",
          "args": [
            "sc"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprinthex",
          "args": [
            "data",
            "len"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" D>\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_multi_2",
          "args": [
            "sc",
            "data",
            "len / 2"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nrln_rx_pdata(sc, buf, len, pd)\n\tstruct rln_softc *\tsc;\n\tvoid *\t\t\tbuf;\n\tint\t\t\tlen;\n\tstruct rln_pdata *\tpd;\n{\n\tchar *\t\t\tdata = (char *)buf;\n\n\tif (pd->p_nremain) {\n\t\t*data++ = pd->p_data;\n\t\tif (--len == 0)\n\t\t\treturn;\n\t}\n\n\tpd->p_nremain = 0;\n\n\tif (sc->sc_width == 16) {\n\t\t/* Round down to the closest even multiple. */\n\t\trln_data_read_multi_2(sc, data, len / 2);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Read the last octet plus a bit extra. */\n\t\t\tunion {\n\t\t\t\tu_int16_t w;\n\t\t\t\tu_int8_t  b[2];\n\t\t\t} u;\n\n\t\t\tu.w = rln_data_read_2(sc);\n\t\t\tdata[len - 1] = u.b[0];\n\t\t\tpd->p_data = u.b[1];\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x%02x}\", u.b[0], u.b[1]); \n#endif\n\t\t}\n\t} else if (sc->sc_width == 8) {\n\t\trln_data_read_multi_1(sc, data, len);\n#ifdef RLNDEBUG_REG\n\t\tdprintf(\" D>\"); \n\t\tdprinthex(data, len);\n#endif\n\t\tif (len & 1) {\n\t\t\t/* Must read multiples of two. */\n\t\t\tpd->p_data = rln_data_read_1(sc);\n\t\t\tpd->p_nremain = 1;\n#ifdef RLNDEBUG_REG\n\t\t\tdprintf(\" D>{%02x}\", pd->p_data); \n#endif\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "rln_rx_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "355-425",
    "snippet": "int\nrln_rx_request(sc, timeo)\n\tstruct rln_softc *\tsc;\n\tint \t\t\ttimeo;\t/* milliseconds */\n{\n\t/* RxRequest */\n\tint\t\t\ts;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\tu_int8_t\t\thi, lo;\n\n\tdprintf(\" Rr[\");\n\tstatus = rln_status_rx_read(sc);\n\n\t/* Short wait for states 1|5|6. */\n\ts = spl0();\n\tfor (i = 0; i < timeo; i++) {\n\t\tif (status == RLN_STATUS_RX_LOLEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_HILEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_ERROR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t\tstatus = rln_status_rx_read(sc);\n\t}\n\tsplx(s);\n\tdprintf(\" (%dms)\",i);\n\n\tif (sc->sc_width == 16) {\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read 2 octets. */\n\t\tlen = rln_data_read_2(sc);\n\t} else if (sc->sc_width == 8) {\n\t\tif (status != RLN_STATUS_RX_LOLEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read low octet. */\n\t\tlo = rln_data_read_1(sc);\n\t\trln_status_rx_write(sc, RLN_STATUS_RX_LOLEN_ACCEPT);\n\t\trln_status_rx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_rx_read(sc);\n\t\t\tif (status == RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus;\n\t\t/* Read high octet. */\n\t\thi = rln_data_read_1(sc);\n\t\tlen = lo | (hi << 8);\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width %d\", sc->sc_width);\n#endif\n\n\tdprintf(\" len=%d]\", len);\n\treturn (len);\n\nbadstatus:\n\tprintf(\"%s: rx_request timed out, status %02x\\n\", \n\t    sc->sc_dev.dv_xname, status);\nbadstatus_quiet:\n\tif (status == RLN_STATUS_RX_ERROR)\n\t\tprintf(\"%s: rx protocol error (nak)\\n\", sc->sc_dev.dv_xname);\n\tdprintf(\"]\");\n\treturn (-1);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx protocol error (nak)\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" len=%d]\"",
            "len"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_1",
          "args": [
            "sc"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_read",
          "args": [
            "sc"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "rln_status_rx_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnreg.h",
          "lines": "204-214",
          "snippet": "static inline int\nrln_status_rx_ready(sc)\n\tstruct rln_softc *sc;\n{\n\tu_int8_t status;\n\n\tstatus = rln_status_rx_read(sc);\n\treturn (status == RLN_STATUS_RX_LOLEN_AVAIL ||\n\t    status == RLN_STATUS_RX_HILEN_AVAIL ||\n\t    status == RLN_STATUS_RX_ERROR);\n}",
          "includes": [],
          "macros_used": [
            "#define RLN_STATUS_RX_LOLEN_AVAIL\t0x60",
            "#define RLN_STATUS_RX_ERROR\t\t0x50",
            "#define RLN_STATUS_RX_HILEN_AVAIL\t0x10"
          ],
          "globals_used": [
            "static int\trln_status_rx_ready"
          ],
          "called_functions": [],
          "contextual_snippet": "#define RLN_STATUS_RX_LOLEN_AVAIL\t0x60\n#define RLN_STATUS_RX_ERROR\t\t0x50\n#define RLN_STATUS_RX_HILEN_AVAIL\t0x10\n\nstatic int\trln_status_rx_ready;\n\nstatic inline int\nrln_status_rx_ready(sc)\n\tstruct rln_softc *sc;\n{\n\tu_int8_t status;\n\n\tstatus = rln_status_rx_read(sc);\n\treturn (status == RLN_STATUS_RX_LOLEN_AVAIL ||\n\t    status == RLN_STATUS_RX_HILEN_AVAIL ||\n\t    status == RLN_STATUS_RX_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spl0",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_int",
          "args": [
            "sc"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_rx_write",
          "args": [
            "sc",
            "RLN_STATUS_RX_LOLEN_ACCEPT"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_1",
          "args": [
            "sc"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_2",
          "args": [
            "sc"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" (%dms)\"",
            "i"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl0",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" Rr[\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_rx_request(sc, timeo)\n\tstruct rln_softc *\tsc;\n\tint \t\t\ttimeo;\t/* milliseconds */\n{\n\t/* RxRequest */\n\tint\t\t\ts;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\tu_int8_t\t\thi, lo;\n\n\tdprintf(\" Rr[\");\n\tstatus = rln_status_rx_read(sc);\n\n\t/* Short wait for states 1|5|6. */\n\ts = spl0();\n\tfor (i = 0; i < timeo; i++) {\n\t\tif (status == RLN_STATUS_RX_LOLEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_HILEN_AVAIL || \n\t\t    status == RLN_STATUS_RX_ERROR)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t\tstatus = rln_status_rx_read(sc);\n\t}\n\tsplx(s);\n\tdprintf(\" (%dms)\",i);\n\n\tif (sc->sc_width == 16) {\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read 2 octets. */\n\t\tlen = rln_data_read_2(sc);\n\t} else if (sc->sc_width == 8) {\n\t\tif (status != RLN_STATUS_RX_LOLEN_AVAIL)\n\t\t\tgoto badstatus_quiet;\n\t\t/* Read low octet. */\n\t\tlo = rln_data_read_1(sc);\n\t\trln_status_rx_write(sc, RLN_STATUS_RX_LOLEN_ACCEPT);\n\t\trln_status_rx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_rx_read(sc);\n\t\t\tif (status == RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tif (status != RLN_STATUS_RX_HILEN_AVAIL)\n\t\t\tgoto badstatus;\n\t\t/* Read high octet. */\n\t\thi = rln_data_read_1(sc);\n\t\tlen = lo | (hi << 8);\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width %d\", sc->sc_width);\n#endif\n\n\tdprintf(\" len=%d]\", len);\n\treturn (len);\n\nbadstatus:\n\tprintf(\"%s: rx_request timed out, status %02x\\n\", \n\t    sc->sc_dev.dv_xname, status);\nbadstatus_quiet:\n\tif (status == RLN_STATUS_RX_ERROR)\n\t\tprintf(\"%s: rx protocol error (nak)\\n\", sc->sc_dev.dv_xname);\n\tdprintf(\"]\");\n\treturn (-1);\n}"
  },
  {
    "function_name": "rln_tx_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "318-347",
    "snippet": "static int\nrln_tx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfTx() */\n\tint\t\ti;\n\tint\t\ts;\n\tu_int8_t\tstatus;\n\n\tdprintf(\" Te[\");\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_tx_read(sc);\n\t\tif (status == RLN_STATUS_TX_XFR_COMPLETE)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status == RLN_STATUS_TX_XFR_COMPLETE) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_IDLE);\n\t\tdprintf(\"]=0\");\n\t\treturn (0);\n\t} else {\n\t\tprintf(\"%s: tx cmd failed (%02x)\\n\", sc->sc_dev.dv_xname,\n\t\t    status);\n\t\trln_need_reset(sc);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\trln_tx_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=-1\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_need_reset",
          "args": [
            "sc"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: tx cmd failed (%02x)\\n\"",
            "sc->sc_dev.dv_xname",
            "status"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=0\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_write",
          "args": [
            "sc",
            "RLN_STATUS_TX_IDLE"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_read",
          "args": [
            "sc"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl0",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" Te[\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_end;\n\nstatic int\nrln_tx_end(sc)\n\tstruct rln_softc * sc;\n{\n\t/* EndOfTx() */\n\tint\t\ti;\n\tint\t\ts;\n\tu_int8_t\tstatus;\n\n\tdprintf(\" Te[\");\n\ts = spl0();\n\tfor (i = 0; i < 600; i++) {\n\t\tstatus = rln_status_tx_read(sc);\n\t\tif (status == RLN_STATUS_TX_XFR_COMPLETE)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tsplx(s);\n\tif (status == RLN_STATUS_TX_XFR_COMPLETE) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_IDLE);\n\t\tdprintf(\"]=0\");\n\t\treturn (0);\n\t} else {\n\t\tprintf(\"%s: tx cmd failed (%02x)\\n\", sc->sc_dev.dv_xname,\n\t\t    status);\n\t\trln_need_reset(sc);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n}"
  },
  {
    "function_name": "rln_tx_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "223-310",
    "snippet": "static int\nrln_tx_request(sc, len)\n\tstruct rln_softc *\tsc;\n\tu_int16_t\t\tlen;\n{\n\t/* TxRequest() */\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\t/* u_int8_t w; */\n\t/* w = rln_wakeup(sc, RLN_WAKEUP_SET); */\n\n\tdprintf(\" Tr[\");\n\tif (sc->sc_width == 16) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\trln_data_write_2(sc, len);\n\t\trln_status_tx_int(sc);\n\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\tgoto success;\n\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\tgoto error;\n\t} else if (sc->sc_width == 8) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_LOLEN_AVAIL);\n\t\trln_data_write_1(sc, len & 0xff);\n\t\trln_status_tx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 6800; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT) {\n\t\t\trln_data_write_1(sc, (len >> 8) & 0xff);\n\t\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\t\ts = spl0();\n\t\t\tfor (i = 0; i < 600; i++) {\n\t\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\t\tbreak;\n\t\t\t\tDELAY(1000);\n\t\t\t}\n\t\t\tsplx(s);\n\t\t\tdprintf(\" %dms\", i);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\t\tgoto success;\n\t\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width\");\n#endif\n\n\tprintf(\"%s: tx_request timed out, status 0x%02x\", \n\t    sc->sc_dev.dv_xname, status);\n\tdprintf(\"]=(1)\");\n\treturn (1);\n\nerror:\n\t/* Will need to clear nak within 100 ms. */\n\tdprintf(\"]=2\");\n#ifdef DIAGNOSTIC\n\tprintf(\"%s: tx protocol fault (nak)\\n\", sc->sc_dev.dv_xname);\n#endif\n\treturn (2);\n\nsuccess:\n\t/* rln_wakeup(sc, w); */\n\tdprintf(\"]=0\");\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\trln_tx_request"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=0\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: tx protocol fault (nak)\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=2\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=(1)\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" %dms\"",
            "i"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_read",
          "args": [
            "sc"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl0",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_write",
          "args": [
            "sc",
            "RLN_STATUS_TX_HILEN_AVAIL"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_1",
          "args": [
            "sc",
            "(len >> 8) & 0xff"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" %dms\"",
            "i"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_read",
          "args": [
            "sc"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl0",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_int",
          "args": [
            "sc"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_1",
          "args": [
            "sc",
            "len & 0xff"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_write",
          "args": [
            "sc",
            "RLN_STATUS_TX_LOLEN_AVAIL"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" %dms\"",
            "i"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_read",
          "args": [
            "sc"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spl0",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_int",
          "args": [
            "sc"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_2",
          "args": [
            "sc",
            "len"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_tx_write",
          "args": [
            "sc",
            "RLN_STATUS_TX_HILEN_AVAIL"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" Tr[\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\trln_tx_request;\n\nstatic int\nrln_tx_request(sc, len)\n\tstruct rln_softc *\tsc;\n\tu_int16_t\t\tlen;\n{\n\t/* TxRequest() */\n\tint\t\t\ts;\n\tint\t\t\ti;\n\tu_int8_t\t\tstatus;\n\n\t/* u_int8_t w; */\n\t/* w = rln_wakeup(sc, RLN_WAKEUP_SET); */\n\n\tdprintf(\" Tr[\");\n\tif (sc->sc_width == 16) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\trln_data_write_2(sc, len);\n\t\trln_status_tx_int(sc);\n\n\t\ts = spl0();\n\t\tfor (i = 0; i < 600; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\tgoto success;\n\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\tgoto error;\n\t} else if (sc->sc_width == 8) {\n\t\trln_status_tx_write(sc, RLN_STATUS_TX_LOLEN_AVAIL);\n\t\trln_data_write_1(sc, len & 0xff);\n\t\trln_status_tx_int(sc);\n\t\ts = spl0();\n\t\tfor (i = 0; i < 6800; i++) {\n\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT)\n\t\t\t\tbreak;\n\t\t\tDELAY(1000);\n\t\t}\n\t\tsplx(s);\n\t\tdprintf(\" %dms\", i);\n\t\tif (status == RLN_STATUS_TX_LOLEN_ACCEPT) {\n\t\t\trln_data_write_1(sc, (len >> 8) & 0xff);\n\t\t\trln_status_tx_write(sc, RLN_STATUS_TX_HILEN_AVAIL);\n\t\t\ts = spl0();\n\t\t\tfor (i = 0; i < 600; i++) {\n\t\t\t\tstatus = rln_status_tx_read(sc);\n\t\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT || \n\t\t\t\t    status == RLN_STATUS_TX_ERROR)\n\t\t\t\t\tbreak;\n\t\t\t\tDELAY(1000);\n\t\t\t}\n\t\t\tsplx(s);\n\t\t\tdprintf(\" %dms\", i);\n\t\t\tif (status == RLN_STATUS_TX_HILEN_ACCEPT)\n\t\t\t\tgoto success;\n\t\t\tif (status == RLN_STATUS_TX_ERROR)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n#ifdef DIAGNOSTIC\n\telse\n\t\tpanic(\"rln: bus width\");\n#endif\n\n\tprintf(\"%s: tx_request timed out, status 0x%02x\", \n\t    sc->sc_dev.dv_xname, status);\n\tdprintf(\"]=(1)\");\n\treturn (1);\n\nerror:\n\t/* Will need to clear nak within 100 ms. */\n\tdprintf(\"]=2\");\n#ifdef DIAGNOSTIC\n\tprintf(\"%s: tx protocol fault (nak)\\n\", sc->sc_dev.dv_xname);\n#endif\n\treturn (2);\n\nsuccess:\n\t/* rln_wakeup(sc, w); */\n\tdprintf(\"]=0\");\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "171-214",
    "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_clear",
          "args": [
            "sc",
            "RLN_CONTROL_RESET"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_clear",
          "args": [
            "sc",
            "RLN_STATUS_WAKEUP"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" Wc[\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_set",
          "args": [
            "sc",
            "RLN_STATUS_WAKEUP"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2000"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" 2ms\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_set",
          "args": [
            "sc",
            "RLN_CONTROL_RESET"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_read",
          "args": [
            "sc"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" .1ms\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "167000"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" 167ms\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_set",
          "args": [
            "sc",
            "RLN_STATUS_WAKEUP"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" Ws[\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
  },
  {
    "function_name": "rln_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "77-163",
    "snippet": "int\nrln_reset(sc)\n\tstruct rln_softc * sc;\n{\n\tint\t\ts;\n\tint\t\ti;\n\tint\t\tstatus;\n\tu_int8_t\top = 0x00;\n\n\ts = splhigh();\n\tdprintf(\" R[\");\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\top = 0x04;\n\tif (rln_status_read(sc) & RLN_STATUS_WAKEUP) {\n\t\trln_control_write(sc, op);\n\t\trln_control_write(sc, op | RLN_CONTROL_RESET);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t\trln_control_write(sc, op);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t}\n\trln_control_write(sc, op);\n\trln_control_write(sc, op);\n\trln_control_write(sc, op | RLN_CONTROL_BIT3);\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_status_write(sc, 0x00);\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\trln_control_write(sc, 0x38); \n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_RESET | RLN_CONTROL_16BIT */\n\telse\n\t\trln_control_write(sc, 0x2c);\n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_BIT2  | RLN_CONTROL_16BIT */\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_data_write_2(sc, 0xaa55);\n\trln_status_write(sc, 0x5a);\n\tsplx(s);\n\tfor (i = 0; i < 200 * 10; i++) {\t/* Proxim says 200. */\n\t\tif ((status = rln_status_read(sc)) == 0x5a)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tdprintf(\" (%dms)\", i);\n\ts = splhigh();\n\tif (status != 0x5a) {\n\t\tsplx(s);\n\t\t/* Only winge if bus width not yet probed */\n\t\tif (sc->sc_width != 0)\n\t\t\tprintf(\"%s: reset timeout\\n\", sc->sc_dev.dv_xname);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\tif (sc->sc_width == 8) {\n\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\telse\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t    RLN_CONTROL_BIT2);\n\t\trln_data_write_1(sc, 0x20);\n\t} else if (sc->sc_width == 16) {\n\t\trln_data_write_2(sc, 0x0000);\n\t} else {\n\t\tif (rln_data_read_2(sc) == 0x55aa) {\n\t\t\trln_data_write_2(sc, 0x0000);\n\t\t\tsc->sc_width = 16;\n\t\t} else {\n\t\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | \n\t\t\t    RLN_CTYPE_ONE_PIECE))\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\t\telse\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t\t    RLN_CONTROL_BIT2);\n\t\t\trln_data_write_1(sc, 0x20);\n\t\t\tsc->sc_width = 8;\n\t\t}\n\t\t/* printf(\"%s: %d bit bus\\n\", sc->sc_dev.dv_xname, \n\t\t   sc->sc_width); */\n\t}\n\trln_status_write(sc, 0x00);\n\tsc->sc_intsel = 0;\n\trln_intsel_write(sc, sc->sc_irq);\n\tsplx(s);\n\tdprintf(\"]\");\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_intsel_write",
          "args": [
            "sc",
            "sc->sc_irq"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_write",
          "args": [
            "sc",
            "0x00"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_1",
          "args": [
            "sc",
            "0x20"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "RLN_CONTROL_BIT3 | \n\t\t\t\t    RLN_CONTROL_BIT2"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "RLN_CONTROL_BIT3"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_2",
          "args": [
            "sc",
            "0x0000"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_read_2",
          "args": [
            "sc"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_2",
          "args": [
            "sc",
            "0x0000"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_1",
          "args": [
            "sc",
            "0x20"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "RLN_CONTROL_BIT3 | \n\t\t\t    RLN_CONTROL_BIT2"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "RLN_CONTROL_BIT3"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"]=-1\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" (%dms)\"",
            "i"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_read",
          "args": [
            "sc"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_write",
          "args": [
            "sc",
            "0x5a"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_data_write_2",
          "args": [
            "sc",
            "0xaa55"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "67000"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" 67ms\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "0x2c"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "0x38"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_write",
          "args": [
            "sc",
            "0x00"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "67000"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" 67ms\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "op | RLN_CONTROL_BIT3"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "op"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "op"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "7000"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" 7ms\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "op"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "7000"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" 7ms\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "op | RLN_CONTROL_RESET"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_control_write",
          "args": [
            "sc",
            "op"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_status_read",
          "args": [
            "sc"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\" R[\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_reset(sc)\n\tstruct rln_softc * sc;\n{\n\tint\t\ts;\n\tint\t\ti;\n\tint\t\tstatus;\n\tu_int8_t\top = 0x00;\n\n\ts = splhigh();\n\tdprintf(\" R[\");\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\top = 0x04;\n\tif (rln_status_read(sc) & RLN_STATUS_WAKEUP) {\n\t\trln_control_write(sc, op);\n\t\trln_control_write(sc, op | RLN_CONTROL_RESET);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t\trln_control_write(sc, op);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t}\n\trln_control_write(sc, op);\n\trln_control_write(sc, op);\n\trln_control_write(sc, op | RLN_CONTROL_BIT3);\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_status_write(sc, 0x00);\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\trln_control_write(sc, 0x38); \n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_RESET | RLN_CONTROL_16BIT */\n\telse\n\t\trln_control_write(sc, 0x2c);\n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_BIT2  | RLN_CONTROL_16BIT */\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_data_write_2(sc, 0xaa55);\n\trln_status_write(sc, 0x5a);\n\tsplx(s);\n\tfor (i = 0; i < 200 * 10; i++) {\t/* Proxim says 200. */\n\t\tif ((status = rln_status_read(sc)) == 0x5a)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tdprintf(\" (%dms)\", i);\n\ts = splhigh();\n\tif (status != 0x5a) {\n\t\tsplx(s);\n\t\t/* Only winge if bus width not yet probed */\n\t\tif (sc->sc_width != 0)\n\t\t\tprintf(\"%s: reset timeout\\n\", sc->sc_dev.dv_xname);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\tif (sc->sc_width == 8) {\n\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\telse\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t    RLN_CONTROL_BIT2);\n\t\trln_data_write_1(sc, 0x20);\n\t} else if (sc->sc_width == 16) {\n\t\trln_data_write_2(sc, 0x0000);\n\t} else {\n\t\tif (rln_data_read_2(sc) == 0x55aa) {\n\t\t\trln_data_write_2(sc, 0x0000);\n\t\t\tsc->sc_width = 16;\n\t\t} else {\n\t\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | \n\t\t\t    RLN_CTYPE_ONE_PIECE))\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\t\telse\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t\t    RLN_CONTROL_BIT2);\n\t\t\trln_data_write_1(sc, 0x20);\n\t\t\tsc->sc_width = 8;\n\t\t}\n\t\t/* printf(\"%s: %d bit bus\\n\", sc->sc_dev.dv_xname, \n\t\t   sc->sc_width); */\n\t}\n\trln_status_write(sc, 0x00);\n\tsc->sc_intsel = 0;\n\trln_intsel_write(sc, sc->sc_irq);\n\tsplx(s);\n\tdprintf(\"]\");\n\treturn (0);\n}"
  },
  {
    "function_name": "rln_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
    "lines": "48-67",
    "snippet": "int\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}",
    "includes": [
      "#include <dev/ic/rlncmd.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rln_register_write_1",
          "args": [
            "sc",
            "RLN_REG_INTSEL",
            "sc->sc_intsel"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "_rln_register_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnreg.h",
          "lines": "65-77",
          "snippet": "static inline void\n_rln_register_write_1(sc, regoff, value)\n\tstruct rln_softc *sc;\n\tu_int8_t regoff;\n\tu_int8_t value;\n{\n\n#ifdef RLNDEBUG_REG\n\tprintf(\" %c<%02x\", \"DDS3CEI7\"[regoff], value);\n#endif\n\tbus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, (regoff), (value));\n\t_rln_regacc_delay();\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static void\t_rln_register_write_1"
          ],
          "called_functions": [],
          "contextual_snippet": "static void\t_rln_register_write_1;\n\nstatic inline void\n_rln_register_write_1(sc, regoff, value)\n\tstruct rln_softc *sc;\n\tu_int8_t regoff;\n\tu_int8_t value;\n{\n\n#ifdef RLNDEBUG_REG\n\tprintf(\" %c<%02x\", \"DDS3CEI7\"[regoff], value);\n#endif\n\tbus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, (regoff), (value));\n\t_rln_regacc_delay();\n}"
        }
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_enable(sc, enable)\n\tstruct rln_softc * sc;\n\tint\t\tenable;\n{\n\tint\t\ts;\n\tint\t\twas_enabled;\n\n\ts = splhigh();\n\twas_enabled = (sc->sc_intsel & RLN_INTSEL_ENABLE) ? 1 : 0;\n\tif (enable != was_enabled) {\n\t\tif (enable)\n\t\t\tsc->sc_intsel |= RLN_INTSEL_ENABLE;\n\t\telse\n\t\t\tsc->sc_intsel &=~RLN_INTSEL_ENABLE;\n\t\t_rln_register_write_1(sc, RLN_REG_INTSEL, sc->sc_intsel);\n\t}\n\tsplx(s);\n\treturn (was_enabled);\n}"
  }
]