[
  {
    "function_name": "zstty_softint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "1118-1230",
    "snippet": "static void\nzstty_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct linesw *line;\n\tregister struct tty *tp;\n\tregister int get, c, s;\n\tint ringmask, overrun;\n\tregister u_short ring_data;\n\tregister u_char rr0, delta;\n\n\tzst  = cs->cs_private;\n\ttp   = zst->zst_tty;\n\tline = &linesw[tp->t_line];\n\tringmask = zst->zst_ringmask;\n\toverrun = 0;\n\n\t/*\n\t * Raise to tty priority while servicing the ring.\n\t */\n\ts = spltty();\n\n\tif (zst->zst_rx_overrun) {\n\t\tzst->zst_rx_overrun = 0;\n\t\tzsoverrun(zst, &zst->zst_rotime, \"ring\");\n\t}\n\n\t/*\n\t * Copy data from the receive ring into the tty layer.\n\t */\n\tget = zst->zst_rbget;\n\twhile (get != zst->zst_rbput) {\n\t\tring_data = zst->zst_rbuf[get];\n\t\tget = (get + 1) & ringmask;\n\n\t\tif (ring_data & ZSRR1_DO)\n\t\t\toverrun++;\n\t\t/* low byte of ring_data is rr1 */\n\t\tc = (ring_data >> 8) & 0xff;\n\t\tif (ring_data & ZSRR1_FE)\n\t\t\tc |= TTY_FE;\n\t\tif (ring_data & ZSRR1_PE)\n\t\t\tc |= TTY_PE;\n\n\t\tline->l_rint(c, tp);\n\t}\n\tzst->zst_rbget = get;\n\n\t/*\n\t * If the overrun flag is set now, it was set while\n\t * copying char/status pairs from the ring, which\n\t * means this was a hardware (fifo) overrun.\n\t */\n\tif (overrun) {\n\t\tzsoverrun(zst, &zst->zst_fotime, \"fifo\");\n\t}\n\n\t/*\n\t * We have emptied the input ring.  Maybe unblock input.\n\t * Note: an \"input blockage\" condition is assumed to exist\n\t * when EITHER zst_rx_blocked or the TS_TBLOCK flag is set,\n\t * so unblock here ONLY if TS_TBLOCK has not been set.\n\t */\n\tif (zst->zst_rx_blocked && ((tp->t_state & TS_TBLOCK) == 0)) {\n\t\t(void) splzs();\n\t\tzst->zst_rx_blocked = 0;\n\t\tzs_hwiflow(zst, 0);\t/* unblock input */\n\t\t(void) spltty();\n\t}\n\n\t/*\n\t * Do any deferred work for status interrupts.\n\t * The rr0 was saved in the h/w interrupt to\n\t * avoid another splzs in here.\n\t */\n\tif (zst->zst_st_check) {\n\t\tzst->zst_st_check = 0;\n\n\t\trr0 = cs->cs_rr0;\n\t\tdelta = cs->cs_rr0_delta;\n\t\tcs->cs_rr0_delta = 0;\n\t\tif (delta & ZSRR0_DCD) {\n\t\t\tc = ((rr0 & ZSRR0_DCD) != 0);\n\t\t\tif (line->l_modem(tp, c) == 0)\n\t\t\t\tzs_modem(zst, c);\n\t\t}\n\t\tif ((delta & ZSRR0_CTS) && (tp->t_cflag & CRTSCTS)) {\n\t\t\t/*\n\t\t\t * Only do restart here.  Stop is handled\n\t\t\t * at the h/w interrupt level.\n\t\t\t */\n\t\t\tif (rr0 & ZSRR0_CTS) {\n\t\t\t\tzst->zst_tx_stopped = 0;\n\t\t\t\ttp->t_state &= ~TS_TTSTOP;\n\t\t\t\t(*line->l_start)(tp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zst->zst_tx_done) {\n\t\tzst->zst_tx_done = 0;\n\t\ttp->t_state &= ~TS_BUSY;\n\t\tif (tp->t_state & TS_FLUSH)\n\t\t\ttp->t_state &= ~TS_FLUSH;\n\t\telse\n\t\t\tndflush(&tp->t_outq, zst->zst_tba -\n\t\t\t\t(caddr_t) tp->t_outq.c_cf);\n\t\tline->l_start(tp);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tzs_modem",
      "static void\tzs_hwiflow",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "static void\tzstty_softint",
      "static void\tzsoverrun"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line->l_start",
          "args": [
            "tp"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndflush",
          "args": [
            "&tp->t_outq",
            "zst->zst_tba -\n\t\t\t\t(caddr_t) tp->t_outq.c_cf"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_modem",
          "args": [
            "zst",
            "c"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "zs_modem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "796-828",
          "snippet": "static void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "line->l_modem",
          "args": [
            "tp",
            "c"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_hwiflow",
          "args": [
            "zst",
            "0"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "zs_hwiflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "872-905",
          "snippet": "static void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_hwiflow",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_hwiflow;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zsoverrun",
          "args": [
            "zst",
            "&zst->zst_fotime",
            "\"fifo\""
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "zsoverrun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "1092-1104",
          "snippet": "static void\nzsoverrun(zst, ptime, what)\n\tstruct zstty_softc *zst;\n\tlong *ptime;\n\tchar *what;\n{\n\n\tif (*ptime != time.tv_sec) {\n\t\t*ptime = time.tv_sec;\n\t\tlog(LOG_WARNING, \"%s: %s overrun\\n\",\n\t\t\tzst->zst_dev.dv_xname, what);\n\t}\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzsoverrun"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzsoverrun;\n\nstatic void\nzsoverrun(zst, ptime, what)\n\tstruct zstty_softc *zst;\n\tlong *ptime;\n\tchar *what;\n{\n\n\tif (*ptime != time.tv_sec) {\n\t\t*ptime = time.tv_sec;\n\t\tlog(LOG_WARNING, \"%s: %s overrun\\n\",\n\t\t\tzst->zst_dev.dv_xname, what);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "line->l_rint",
          "args": [
            "c",
            "tp"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\nstatic void\tzs_hwiflow;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\nstatic void\tzstty_softint;\nstatic void\tzsoverrun;\n\nstatic void\nzstty_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct linesw *line;\n\tregister struct tty *tp;\n\tregister int get, c, s;\n\tint ringmask, overrun;\n\tregister u_short ring_data;\n\tregister u_char rr0, delta;\n\n\tzst  = cs->cs_private;\n\ttp   = zst->zst_tty;\n\tline = &linesw[tp->t_line];\n\tringmask = zst->zst_ringmask;\n\toverrun = 0;\n\n\t/*\n\t * Raise to tty priority while servicing the ring.\n\t */\n\ts = spltty();\n\n\tif (zst->zst_rx_overrun) {\n\t\tzst->zst_rx_overrun = 0;\n\t\tzsoverrun(zst, &zst->zst_rotime, \"ring\");\n\t}\n\n\t/*\n\t * Copy data from the receive ring into the tty layer.\n\t */\n\tget = zst->zst_rbget;\n\twhile (get != zst->zst_rbput) {\n\t\tring_data = zst->zst_rbuf[get];\n\t\tget = (get + 1) & ringmask;\n\n\t\tif (ring_data & ZSRR1_DO)\n\t\t\toverrun++;\n\t\t/* low byte of ring_data is rr1 */\n\t\tc = (ring_data >> 8) & 0xff;\n\t\tif (ring_data & ZSRR1_FE)\n\t\t\tc |= TTY_FE;\n\t\tif (ring_data & ZSRR1_PE)\n\t\t\tc |= TTY_PE;\n\n\t\tline->l_rint(c, tp);\n\t}\n\tzst->zst_rbget = get;\n\n\t/*\n\t * If the overrun flag is set now, it was set while\n\t * copying char/status pairs from the ring, which\n\t * means this was a hardware (fifo) overrun.\n\t */\n\tif (overrun) {\n\t\tzsoverrun(zst, &zst->zst_fotime, \"fifo\");\n\t}\n\n\t/*\n\t * We have emptied the input ring.  Maybe unblock input.\n\t * Note: an \"input blockage\" condition is assumed to exist\n\t * when EITHER zst_rx_blocked or the TS_TBLOCK flag is set,\n\t * so unblock here ONLY if TS_TBLOCK has not been set.\n\t */\n\tif (zst->zst_rx_blocked && ((tp->t_state & TS_TBLOCK) == 0)) {\n\t\t(void) splzs();\n\t\tzst->zst_rx_blocked = 0;\n\t\tzs_hwiflow(zst, 0);\t/* unblock input */\n\t\t(void) spltty();\n\t}\n\n\t/*\n\t * Do any deferred work for status interrupts.\n\t * The rr0 was saved in the h/w interrupt to\n\t * avoid another splzs in here.\n\t */\n\tif (zst->zst_st_check) {\n\t\tzst->zst_st_check = 0;\n\n\t\trr0 = cs->cs_rr0;\n\t\tdelta = cs->cs_rr0_delta;\n\t\tcs->cs_rr0_delta = 0;\n\t\tif (delta & ZSRR0_DCD) {\n\t\t\tc = ((rr0 & ZSRR0_DCD) != 0);\n\t\t\tif (line->l_modem(tp, c) == 0)\n\t\t\t\tzs_modem(zst, c);\n\t\t}\n\t\tif ((delta & ZSRR0_CTS) && (tp->t_cflag & CRTSCTS)) {\n\t\t\t/*\n\t\t\t * Only do restart here.  Stop is handled\n\t\t\t * at the h/w interrupt level.\n\t\t\t */\n\t\t\tif (rr0 & ZSRR0_CTS) {\n\t\t\t\tzst->zst_tx_stopped = 0;\n\t\t\t\ttp->t_state &= ~TS_TTSTOP;\n\t\t\t\t(*line->l_start)(tp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zst->zst_tx_done) {\n\t\tzst->zst_tx_done = 0;\n\t\ttp->t_state &= ~TS_BUSY;\n\t\tif (tp->t_state & TS_FLUSH)\n\t\t\ttp->t_state &= ~TS_FLUSH;\n\t\telse\n\t\t\tndflush(&tp->t_outq, zst->zst_tba -\n\t\t\t\t(caddr_t) tp->t_outq.c_cf);\n\t\tline->l_start(tp);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "zsoverrun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "1092-1104",
    "snippet": "static void\nzsoverrun(zst, ptime, what)\n\tstruct zstty_softc *zst;\n\tlong *ptime;\n\tchar *what;\n{\n\n\tif (*ptime != time.tv_sec) {\n\t\t*ptime = time.tv_sec;\n\t\tlog(LOG_WARNING, \"%s: %s overrun\\n\",\n\t\t\tzst->zst_dev.dv_xname, what);\n\t}\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tzsoverrun"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: %s overrun\\n\"",
            "zst->zst_dev.dv_xname",
            "what"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzsoverrun;\n\nstatic void\nzsoverrun(zst, ptime, what)\n\tstruct zstty_softc *zst;\n\tlong *ptime;\n\tchar *what;\n{\n\n\tif (*ptime != time.tv_sec) {\n\t\t*ptime = time.tv_sec;\n\t\tlog(LOG_WARNING, \"%s: %s overrun\\n\",\n\t\t\tzst->zst_dev.dv_xname, what);\n\t}\n}"
  },
  {
    "function_name": "zstty_stint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "1036-1087",
    "snippet": "static void\nzstty_stint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct tty *tp;\n\tregister u_char rr0;\n\n\tzst = cs->cs_private;\n\ttp  = zst->zst_tty;\n\n\trr0 = zs_read_csr(cs);\n\tzs_write_csr(cs, ZSWR0_RESET_STATUS);\n\n\t/*\n\t * Check here for console break, so that we can abort\n\t * even when interrupts are locking up the machine.\n\t */\n\tif ((rr0 & ZSRR0_BREAK) &&\n\t\t(zst->zst_hwflags & ZS_HWFLAG_CONSOLE))\n\t{\n\t\tzs_abort();\n\t\treturn;\n\t}\n\n\t/*\n\t * Need to handle CTS output flow control here.\n\t * Output remains stopped as long as either the\n\t * zst_tx_stopped or TS_TTSTOP flag is set.\n\t * Never restart here; the softint routine will\n\t * do that after things are ready to move.\n\t */\n\tif (((rr0 & ZSRR0_CTS) == 0) && (tp->t_cflag & CRTSCTS)) {\n\t\tzst->zst_tbc = 0;\n\t\tzst->zst_heldtbc = 0;\n\t\tzst->zst_tx_stopped = 1;\n\t}\n\n\t/*\n\t * We have to accumulate status line changes here.\n\t * Otherwise, if we get multiple status interrupts\n\t * before the softint runs, we could fail to notice\n\t * some status line changes in the softint routine.\n\t * Fix from Bill Studenmund, October 1996.\n\t */\n\tcs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);\n\tcs->cs_rr0 = rr0;\n\tzst->zst_st_check = 1;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "static void\tzstty_stint",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_abort",
          "args": [],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_STATUS"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_csr",
          "args": [
            "cs"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\nstatic void\tzstty_stint;\n__P((register struct zs_chanstate *));\n\nstatic void\nzstty_stint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct tty *tp;\n\tregister u_char rr0;\n\n\tzst = cs->cs_private;\n\ttp  = zst->zst_tty;\n\n\trr0 = zs_read_csr(cs);\n\tzs_write_csr(cs, ZSWR0_RESET_STATUS);\n\n\t/*\n\t * Check here for console break, so that we can abort\n\t * even when interrupts are locking up the machine.\n\t */\n\tif ((rr0 & ZSRR0_BREAK) &&\n\t\t(zst->zst_hwflags & ZS_HWFLAG_CONSOLE))\n\t{\n\t\tzs_abort();\n\t\treturn;\n\t}\n\n\t/*\n\t * Need to handle CTS output flow control here.\n\t * Output remains stopped as long as either the\n\t * zst_tx_stopped or TS_TTSTOP flag is set.\n\t * Never restart here; the softint routine will\n\t * do that after things are ready to move.\n\t */\n\tif (((rr0 & ZSRR0_CTS) == 0) && (tp->t_cflag & CRTSCTS)) {\n\t\tzst->zst_tbc = 0;\n\t\tzst->zst_heldtbc = 0;\n\t\tzst->zst_tx_stopped = 1;\n\t}\n\n\t/*\n\t * We have to accumulate status line changes here.\n\t * Otherwise, if we get multiple status interrupts\n\t * before the softint runs, we could fail to notice\n\t * some status line changes in the softint routine.\n\t * Fix from Bill Studenmund, October 1996.\n\t */\n\tcs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);\n\tcs->cs_rr0 = rr0;\n\tzst->zst_st_check = 1;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "zstty_txint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "984-1031",
    "snippet": "static void\nzstty_txint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister int count;\n\n\tzst = cs->cs_private;\n\n\t/*\n\t * If we suspended output for a \"held\" change,\n\t * then handle that now and resume.\n\t * Do flow-control changes ASAP.\n\t * When the only change is for flow control,\n\t * avoid hitting other registers, because that\n\t * often makes the stupid zs drop input...\n\t */\n\tif (cs->cs_heldchange) {\n\t\tif (cs->cs_heldchange == (1<<5)) {\n\t\t\t/* Avoid whacking the chip... */\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t} else\n\t\t\tzs_loadchannelregs(cs);\n\t\tcs->cs_heldchange = 0;\n\t\tcount = zst->zst_heldtbc;\n\t} else\n\t\tcount = zst->zst_tbc;\n\n\t/*\n\t * If our transmit buffer still has data,\n\t * just send the next character.\n\t */\n\tif (count > 0) {\n\t\t/* Send the next char. */\n\t\tzst->zst_tbc = --count;\n\t\tzs_write_data(cs, *zst->zst_tba);\n\t\tzst->zst_tba++;\n\t\treturn;\n\t}\n\n\tzs_write_csr(cs, ZSWR0_RESET_TXINT);\n\n\t/* Ask the softint routine for more output. */\n\tzst->zst_tx_busy = 0;\n\tzst->zst_tx_done = 1;\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__P((register struct zs_chanstate *));",
      "static void\tzstty_txint",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_TXINT"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_data",
          "args": [
            "cs",
            "*zst->zst_tba"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_loadchannelregs",
          "args": [
            "cs"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "zs_loadchannelregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "144-207",
          "snippet": "void\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "5",
            "cs->cs_creg[5]"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((register struct zs_chanstate *));\nstatic void\tzstty_txint;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzstty_txint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister int count;\n\n\tzst = cs->cs_private;\n\n\t/*\n\t * If we suspended output for a \"held\" change,\n\t * then handle that now and resume.\n\t * Do flow-control changes ASAP.\n\t * When the only change is for flow control,\n\t * avoid hitting other registers, because that\n\t * often makes the stupid zs drop input...\n\t */\n\tif (cs->cs_heldchange) {\n\t\tif (cs->cs_heldchange == (1<<5)) {\n\t\t\t/* Avoid whacking the chip... */\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t} else\n\t\t\tzs_loadchannelregs(cs);\n\t\tcs->cs_heldchange = 0;\n\t\tcount = zst->zst_heldtbc;\n\t} else\n\t\tcount = zst->zst_tbc;\n\n\t/*\n\t * If our transmit buffer still has data,\n\t * just send the next character.\n\t */\n\tif (count > 0) {\n\t\t/* Send the next char. */\n\t\tzst->zst_tbc = --count;\n\t\tzs_write_data(cs, *zst->zst_tba);\n\t\tzst->zst_tba++;\n\t\treturn;\n\t}\n\n\tzs_write_csr(cs, ZSWR0_RESET_TXINT);\n\n\t/* Ask the softint routine for more output. */\n\tzst->zst_tx_busy = 0;\n\tzst->zst_tx_done = 1;\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "zstty_rxint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "917-979",
    "snippet": "static void\nzstty_rxint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister int cc, put, put_next, ringmask;\n\tregister u_char c, rr0, rr1;\n\tregister u_short ch_rr1;\n\n\tzst = cs->cs_private;\n\tput = zst->zst_rbput;\n\tringmask = zst->zst_ringmask;\n\nnextchar:\n\n\t/*\n\t * First read the status, because reading the received char\n\t * destroys the status of this char.\n\t */\n\trr1 = zs_read_reg(cs, 1);\n\tc = zs_read_data(cs);\n\tch_rr1 = (c << 8) | rr1;\n\n\tif (ch_rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t/* Clear the receive error. */\n\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t}\n\n\t/* XXX: Check for the stop character? */\n\n\tzst->zst_rbuf[put] = ch_rr1;\n\tput_next = (put + 1) & ringmask;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put_next == zst->zst_rbget) {\n\t\tzst->zst_rx_overrun = 1;\n\t} else {\n\t\t/* OK, really increment. */\n\t\tput = put_next;\n\t}\n\n\t/* Keep reading until the FIFO is empty. */\n\trr0 = zs_read_csr(cs);\n\tif (rr0 & ZSRR0_RX_READY)\n\t\tgoto nextchar;\n\n\t/* Done reading. */\n\tzst->zst_rbput = put;\n\n\t/*\n\t * If ring is getting too full, try to block input.\n\t */\n\tcc = put - zst->zst_rbget;\n\tif (cc < 0)\n\t\tcc += zstty_rbuf_size;\n\tif ((cc > zst->zst_rbhiwat) && (zst->zst_rx_blocked == 0)) {\n\t\tzst->zst_rx_blocked = 1;\n\t\tzs_hwiflow(zst, 1);\n\t}\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int zstty_rbuf_size = ZSTTY_RING_SIZE;",
      "static void\tzs_hwiflow",
      "static void\tzstty_rxint",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_hwiflow",
          "args": [
            "zst",
            "1"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "zs_hwiflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "872-905",
          "snippet": "static void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_hwiflow",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_hwiflow;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zs_read_csr",
          "args": [
            "cs"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_ERRORS"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_data",
          "args": [
            "cs"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_reg",
          "args": [
            "cs",
            "1"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint zstty_rbuf_size = ZSTTY_RING_SIZE;\nstatic void\tzs_hwiflow;\nstatic void\tzstty_rxint;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzstty_rxint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct zstty_softc *zst;\n\tregister int cc, put, put_next, ringmask;\n\tregister u_char c, rr0, rr1;\n\tregister u_short ch_rr1;\n\n\tzst = cs->cs_private;\n\tput = zst->zst_rbput;\n\tringmask = zst->zst_ringmask;\n\nnextchar:\n\n\t/*\n\t * First read the status, because reading the received char\n\t * destroys the status of this char.\n\t */\n\trr1 = zs_read_reg(cs, 1);\n\tc = zs_read_data(cs);\n\tch_rr1 = (c << 8) | rr1;\n\n\tif (ch_rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t/* Clear the receive error. */\n\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t}\n\n\t/* XXX: Check for the stop character? */\n\n\tzst->zst_rbuf[put] = ch_rr1;\n\tput_next = (put + 1) & ringmask;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put_next == zst->zst_rbget) {\n\t\tzst->zst_rx_overrun = 1;\n\t} else {\n\t\t/* OK, really increment. */\n\t\tput = put_next;\n\t}\n\n\t/* Keep reading until the FIFO is empty. */\n\trr0 = zs_read_csr(cs);\n\tif (rr0 & ZSRR0_RX_READY)\n\t\tgoto nextchar;\n\n\t/* Done reading. */\n\tzst->zst_rbput = put;\n\n\t/*\n\t * If ring is getting too full, try to block input.\n\t */\n\tcc = put - zst->zst_rbget;\n\tif (cc < 0)\n\t\tcc += zstty_rbuf_size;\n\tif ((cc > zst->zst_rbhiwat) && (zst->zst_rx_blocked == 0)) {\n\t\tzst->zst_rx_blocked = 1;\n\t\tzs_hwiflow(zst, 1);\n\t}\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "zs_hwiflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "872-905",
    "snippet": "static void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tzs_hwiflow",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "5",
            "cs->cs_creg[5]"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_hwiflow;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "zshwiflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "836-866",
    "snippet": "int\nzshwiflow(tp, stop)\n\tstruct tty *tp;\n\tint stop;\n{\n\tregister struct zstty_softc *zst;\n\tint s;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\n\ts = splzs();\n\tif (stop) {\n\t\t/*\n\t\t * The tty layer is asking us to block input.\n\t\t * If we already did it, just return TRUE.\n\t\t */\n\t\tif (zst->zst_rx_blocked)\n\t\t\tgoto out;\n\t\tzst->zst_rx_blocked = 1;\n\t} else {\n\t\t/*\n\t\t * The tty layer is asking us to resume input.\n\t\t * The input ring is always empty by now.\n\t\t */\n\t\tzst->zst_rx_blocked = 0;\n\t}\n\tzs_hwiflow(zst, stop);\n out:\n\tsplx(s);\n\treturn 1;\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "static int\tzshwiflow",
      "static void\tzs_hwiflow"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_hwiflow",
          "args": [
            "zst",
            "stop"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "zs_hwiflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "872-905",
          "snippet": "static void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_hwiflow",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_hwiflow;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_hwiflow(zst, stop)\n\tregister struct zstty_softc *zst;\n\tint stop;\n{\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (stop) {\n\t\t/* Block input (Lower RTS) */\n\t\tbis = 0;\n\t\tand = ~ZSWR5_RTS;\n\t} else {\n\t\t/* Unblock input (Raise RTS) */\n\t\tbis = ZSWR5_RTS;\n\t\tand = ~0;\n\t}\n\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "tp->t_dev"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic int\tzshwiflow;\nstatic void\tzs_hwiflow;\n\nint\nzshwiflow(tp, stop)\n\tstruct tty *tp;\n\tint stop;\n{\n\tregister struct zstty_softc *zst;\n\tint s;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\n\ts = splzs();\n\tif (stop) {\n\t\t/*\n\t\t * The tty layer is asking us to block input.\n\t\t * If we already did it, just return TRUE.\n\t\t */\n\t\tif (zst->zst_rx_blocked)\n\t\t\tgoto out;\n\t\tzst->zst_rx_blocked = 1;\n\t} else {\n\t\t/*\n\t\t * The tty layer is asking us to resume input.\n\t\t * The input ring is always empty by now.\n\t\t */\n\t\tzst->zst_rx_blocked = 0;\n\t}\n\tzs_hwiflow(zst, stop);\n out:\n\tsplx(s);\n\treturn 1;\n}"
  },
  {
    "function_name": "zs_modem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "796-828",
    "snippet": "static void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tzs_modem",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "5",
            "cs->cs_creg[5]"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "zsparam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "681-790",
    "snippet": "static int\nzsparam(tp, t)\n\tregister struct tty *tp;\n\tregister struct termios *t;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, bps, cflag, tconst;\n\tu_char tmp3, tmp4, tmp5;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\t/* XXX: Need to use an MD function for this. */\n\tbps = t->c_ospeed;\n\tif (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))\n\t\treturn (EINVAL);\n\tif (bps == 0) {\n\t\t/* stty 0 => drop DTR and RTS */\n\t\tzs_modem(zst, 0);\n\t\treturn (0);\n\t}\n\ttconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);\n\tif (tconst < 0)\n\t\treturn (EINVAL);\n\n\t/* Convert back to make sure we can do it. */\n\tbps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);\n\tif (bps != t->c_ospeed)\n\t\treturn (EINVAL);\n\ttp->t_ispeed = tp->t_ospeed = bps;\n\n\tcflag = t->c_cflag;\n\ttp->t_cflag = cflag;\n\n\t/*\n\t * Block interrupts so that state will not\n\t * be altered until we are done setting it up.\n\t */\n\ts = splzs();\n\n\t/*\n\t * Initial values in cs_preg are set before\n\t * our attach routine is called.  The master\n\t * interrupt enable is handled by zsc.c\n\t */\n\n\tcs->cs_preg[12] = tconst;\n\tcs->cs_preg[13] = tconst >> 8;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\ttmp3 = ZSWR3_RX_5;\n\t\ttmp5 = ZSWR5_TX_5;\n\t\tbreak;\n\tcase CS6:\n\t\ttmp3 = ZSWR3_RX_6;\n\t\ttmp5 = ZSWR5_TX_6;\n\t\tbreak;\n\tcase CS7:\n\t\ttmp3 = ZSWR3_RX_7;\n\t\ttmp5 = ZSWR5_TX_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\ttmp3 = ZSWR3_RX_8;\n\t\ttmp5 = ZSWR5_TX_8;\n\t\tbreak;\n\t}\n\n\tcs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;\n\tcs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;\n\n\ttmp4 = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);\n\tif ((cflag & PARODD) == 0)\n\t\ttmp4 |= ZSWR4_EVENP;\n\tif (cflag & PARENB)\n\t\ttmp4 |= ZSWR4_PARENB;\n\tcs->cs_preg[4] = tmp4;\n\n\t/*\n\t * Output hardware flow control on the chip is horrendous:\n\t * if carrier detect drops, the receiver is disabled.\n\t * Therefore, NEVER set the HFC bit, and instead use\n\t * the status interrupts to detect CTS changes.\n\t */\n\tif (cflag & CRTSCTS) {\n\t\tzst->zst_rbhiwat = zstty_rbuf_hiwat;\n\t\tcs->cs_preg[15] |= ZSWR15_CTS_IE;\n\t} else {\n\t\tzst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */\n\t\tcs->cs_preg[15] &= ~ZSWR15_CTS_IE;\n\t}\n\n\t/*\n\t * If nothing is being transmitted, set up new current values,\n\t * else mark them as pending.\n\t */\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = 0xFF; /* XXX */\n\t\t} else {\n\t\t\tzs_loadchannelregs(cs);\n\t\t}\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int zstty_rbuf_size = ZSTTY_RING_SIZE;",
      "int zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));",
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "static int\tzsparam",
      "static void\tzs_modem",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_loadchannelregs",
          "args": [
            "cs"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "zs_loadchannelregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "144-207",
          "snippet": "void\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TCONST_TO_BPS",
          "args": [
            "cs->cs_brg_clk",
            "tconst"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPS_TO_TCONST",
          "args": [
            "cs->cs_brg_clk",
            "bps"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_modem",
          "args": [
            "zst",
            "0"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "zs_modem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "796-828",
          "snippet": "static void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "tp->t_dev"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint zstty_rbuf_size = ZSTTY_RING_SIZE;\nint zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic int\tzsparam;\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic int\nzsparam(tp, t)\n\tregister struct tty *tp;\n\tregister struct termios *t;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, bps, cflag, tconst;\n\tu_char tmp3, tmp4, tmp5;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\t/* XXX: Need to use an MD function for this. */\n\tbps = t->c_ospeed;\n\tif (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))\n\t\treturn (EINVAL);\n\tif (bps == 0) {\n\t\t/* stty 0 => drop DTR and RTS */\n\t\tzs_modem(zst, 0);\n\t\treturn (0);\n\t}\n\ttconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);\n\tif (tconst < 0)\n\t\treturn (EINVAL);\n\n\t/* Convert back to make sure we can do it. */\n\tbps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);\n\tif (bps != t->c_ospeed)\n\t\treturn (EINVAL);\n\ttp->t_ispeed = tp->t_ospeed = bps;\n\n\tcflag = t->c_cflag;\n\ttp->t_cflag = cflag;\n\n\t/*\n\t * Block interrupts so that state will not\n\t * be altered until we are done setting it up.\n\t */\n\ts = splzs();\n\n\t/*\n\t * Initial values in cs_preg are set before\n\t * our attach routine is called.  The master\n\t * interrupt enable is handled by zsc.c\n\t */\n\n\tcs->cs_preg[12] = tconst;\n\tcs->cs_preg[13] = tconst >> 8;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\ttmp3 = ZSWR3_RX_5;\n\t\ttmp5 = ZSWR5_TX_5;\n\t\tbreak;\n\tcase CS6:\n\t\ttmp3 = ZSWR3_RX_6;\n\t\ttmp5 = ZSWR5_TX_6;\n\t\tbreak;\n\tcase CS7:\n\t\ttmp3 = ZSWR3_RX_7;\n\t\ttmp5 = ZSWR5_TX_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\ttmp3 = ZSWR3_RX_8;\n\t\ttmp5 = ZSWR5_TX_8;\n\t\tbreak;\n\t}\n\n\tcs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;\n\tcs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;\n\n\ttmp4 = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);\n\tif ((cflag & PARODD) == 0)\n\t\ttmp4 |= ZSWR4_EVENP;\n\tif (cflag & PARENB)\n\t\ttmp4 |= ZSWR4_PARENB;\n\tcs->cs_preg[4] = tmp4;\n\n\t/*\n\t * Output hardware flow control on the chip is horrendous:\n\t * if carrier detect drops, the receiver is disabled.\n\t * Therefore, NEVER set the HFC bit, and instead use\n\t * the status interrupts to detect CTS changes.\n\t */\n\tif (cflag & CRTSCTS) {\n\t\tzst->zst_rbhiwat = zstty_rbuf_hiwat;\n\t\tcs->cs_preg[15] |= ZSWR15_CTS_IE;\n\t} else {\n\t\tzst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */\n\t\tcs->cs_preg[15] &= ~ZSWR15_CTS_IE;\n\t}\n\n\t/*\n\t * If nothing is being transmitted, set up new current values,\n\t * else mark them as pending.\n\t */\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = 0xFF; /* XXX */\n\t\t} else {\n\t\t\tzs_loadchannelregs(cs);\n\t\t}\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "zsstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "647-673",
    "snippet": "int\nzsstop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\ts = splzs();\n\tif (tp->t_state & TS_BUSY) {\n\t\t/*\n\t\t * Device is transmitting; must stop it.\n\t\t * Also clear _heldtbc to prevent any\n\t\t * flow-control event from resuming.\n\t\t */\n\t\tzst->zst_tbc = 0;\n\t\tzst->zst_heldtbc = 0;\n\t\tif ((tp->t_state & TS_TTSTOP) == 0)\n\t\t\ttp->t_state |= TS_FLUSH;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "tp->t_dev"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nint\nzsstop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\ts = splzs();\n\tif (tp->t_state & TS_BUSY) {\n\t\t/*\n\t\t * Device is transmitting; must stop it.\n\t\t * Also clear _heldtbc to prevent any\n\t\t * flow-control event from resuming.\n\t\t */\n\t\tzst->zst_tbc = 0;\n\t\tzst->zst_heldtbc = 0;\n\t\tif ((tp->t_state & TS_TTSTOP) == 0)\n\t\t\ttp->t_state |= TS_FLUSH;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "zsstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "578-642",
    "snippet": "static void\nzsstart(tp)\n\tregister struct tty *tp;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, nch;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\ts = spltty();\n\n\t/*\n\t * If currently active or delaying, no need to do anything.\n\t */\n\tif (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))\n\t\tgoto out;\n\n\t/*\n\t * If under CRTSCTS hfc and halted, do nothing\n\t */\n\tif (tp->t_cflag & CRTSCTS)\n\t\tif (zst->zst_tx_stopped)\n\t\t\tgoto out;\n\n\t/*\n\t * If there are sleepers, and output has drained below low\n\t * water mark, awaken.\n\t */\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (tp->t_state & TS_ASLEEP) {\n\t\t\ttp->t_state &= ~TS_ASLEEP;\n\t\t\twakeup((caddr_t)&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t}\n\n\tnch = ndqb(&tp->t_outq, 0);\t/* XXX */\n\t(void) splzs();\n\n\tif (nch) {\n\t\tregister char *p = tp->t_outq.c_cf;\n\n\t\t/* mark busy, enable tx done interrupts, & send first byte */\n\t\ttp->t_state |= TS_BUSY;\n\t\tzst->zst_tx_busy = 1;\n\t\tcs->cs_preg[1] |= ZSWR1_TIE;\n\t\tcs->cs_creg[1] = cs->cs_preg[1];\n\t\tzs_write_reg(cs, 1, cs->cs_creg[1]);\n\t\tzs_write_data(cs, *p);\n\t\tzst->zst_tba = p + 1;\n\t\tzst->zst_tbc = nch - 1;\n\t} else {\n\t\t/*\n\t\t * Nothing to send, turn off transmit done interrupts.\n\t\t * This is useful if something is doing polled output.\n\t\t */\n\t\tcs->cs_preg[1] &= ~ZSWR1_TIE;\n\t\tcs->cs_creg[1] = cs->cs_preg[1];\n\t\tzs_write_reg(cs, 1, cs->cs_creg[1]);\n\t}\nout:\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "static void\tzsstart",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "1",
            "cs->cs_creg[1]"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_data",
          "args": [
            "cs",
            "*p"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "1",
            "cs->cs_creg[1]"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndqb",
          "args": [
            "&tp->t_outq",
            "0"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&tp->t_wsel"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)&tp->t_outq"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "tp->t_dev"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic void\tzsstart;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzsstart(tp)\n\tregister struct tty *tp;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, nch;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\ts = spltty();\n\n\t/*\n\t * If currently active or delaying, no need to do anything.\n\t */\n\tif (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))\n\t\tgoto out;\n\n\t/*\n\t * If under CRTSCTS hfc and halted, do nothing\n\t */\n\tif (tp->t_cflag & CRTSCTS)\n\t\tif (zst->zst_tx_stopped)\n\t\t\tgoto out;\n\n\t/*\n\t * If there are sleepers, and output has drained below low\n\t * water mark, awaken.\n\t */\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (tp->t_state & TS_ASLEEP) {\n\t\t\ttp->t_state &= ~TS_ASLEEP;\n\t\t\twakeup((caddr_t)&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t}\n\n\tnch = ndqb(&tp->t_outq, 0);\t/* XXX */\n\t(void) splzs();\n\n\tif (nch) {\n\t\tregister char *p = tp->t_outq.c_cf;\n\n\t\t/* mark busy, enable tx done interrupts, & send first byte */\n\t\ttp->t_state |= TS_BUSY;\n\t\tzst->zst_tx_busy = 1;\n\t\tcs->cs_preg[1] |= ZSWR1_TIE;\n\t\tcs->cs_creg[1] = cs->cs_preg[1];\n\t\tzs_write_reg(cs, 1, cs->cs_creg[1]);\n\t\tzs_write_data(cs, *p);\n\t\tzst->zst_tba = p + 1;\n\t\tzst->zst_tbc = nch - 1;\n\t} else {\n\t\t/*\n\t\t * Nothing to send, turn off transmit done interrupts.\n\t\t * This is useful if something is doing polled output.\n\t\t */\n\t\tcs->cs_preg[1] &= ~ZSWR1_TIE;\n\t\tcs->cs_creg[1] = cs->cs_preg[1];\n\t\tzs_write_reg(cs, 1, cs->cs_creg[1]);\n\t}\nout:\n\tsplx(s);\n}"
  },
  {
    "function_name": "zsioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "504-573",
    "snippet": "int\nzsioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int error, tmp;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\terror = ttioctl(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\tswitch (cmd) {\n\n\tcase TIOCSBRK:\n\t\tzs_break(cs, 1);\n\t\tbreak;\n\n\tcase TIOCCBRK:\n\t\tzs_break(cs, 0);\n\t\tbreak;\n\n\tcase TIOCGFLAGS:\n\t\t*(int *)data = zst->zst_swflags;\n\t\tbreak;\n\n\tcase TIOCSFLAGS:\n\t\terror = suser(p->p_ucred, &p->p_acflag);\n\t\tif (error != 0)\n\t\t\treturn (EPERM);\n\t\ttmp = *(int *)data;\n\t\t/* Check for random bits... */\n\t\tif (tmp & ~TIOCFLAG_ALL)\n\t\t\treturn(EINVAL);\n\t\t/* Silently enforce softcar on the console. */\n\t\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)\n\t\t\ttmp |= TIOCFLAG_SOFTCAR;\n\t\t/* These flags take effect during open. */\n\t\tzst->zst_swflags = tmp;\n\t\tbreak;\n\n\tcase TIOCSDTR:\n\t\tzs_modem(zst, 1);\n\t\tbreak;\n\n\tcase TIOCCDTR:\n\t\tzs_modem(zst, 0);\n\t\tbreak;\n\n\tcase TIOCMSET:\n\tcase TIOCMBIS:\n\tcase TIOCMBIC:\n\tcase TIOCMGET:\n\tdefault:\n\t\treturn (ENOTTY);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TIOCFLAG_ALL (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | \\\n                      TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF )"
    ],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "static void\tzs_modem",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "struct tty *\nzstty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_modem",
          "args": [
            "zst",
            "0"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "zs_modem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "796-828",
          "snippet": "static void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_break",
          "args": [
            "cs",
            "0"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "zs_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "74-91",
          "snippet": "void\nzs_break(cs, set)\n\tstruct zs_chanstate *cs;\n\tint set;\n{\n\tint s;\n\n\ts = splzs();\n\tif (set) {\n\t\tcs->cs_preg[5] |= ZSWR5_BREAK;\n\t\tcs->cs_creg[5] |= ZSWR5_BREAK;\n\t} else {\n\t\tcs->cs_preg[5] &= ~ZSWR5_BREAK;\n\t\tcs->cs_creg[5] &= ~ZSWR5_BREAK;\n\t}\n\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_break(cs, set)\n\tstruct zs_chanstate *cs;\n\tint set;\n{\n\tint s;\n\n\ts = splzs();\n\tif (set) {\n\t\tcs->cs_preg[5] |= ZSWR5_BREAK;\n\t\tcs->cs_creg[5] |= ZSWR5_BREAK;\n\t} else {\n\t\tcs->cs_preg[5] &= ~ZSWR5_BREAK;\n\t\tcs->cs_creg[5] &= ~ZSWR5_BREAK;\n\t}\n\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttioctl",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TIOCFLAG_ALL (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | \\\n                      TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF )\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\nstruct tty *\nzstty(dev)\n\tdev_t dev;\n\nint\nzsioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tregister int error, tmp;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\terror = ttioctl(tp, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n\n\tswitch (cmd) {\n\n\tcase TIOCSBRK:\n\t\tzs_break(cs, 1);\n\t\tbreak;\n\n\tcase TIOCCBRK:\n\t\tzs_break(cs, 0);\n\t\tbreak;\n\n\tcase TIOCGFLAGS:\n\t\t*(int *)data = zst->zst_swflags;\n\t\tbreak;\n\n\tcase TIOCSFLAGS:\n\t\terror = suser(p->p_ucred, &p->p_acflag);\n\t\tif (error != 0)\n\t\t\treturn (EPERM);\n\t\ttmp = *(int *)data;\n\t\t/* Check for random bits... */\n\t\tif (tmp & ~TIOCFLAG_ALL)\n\t\t\treturn(EINVAL);\n\t\t/* Silently enforce softcar on the console. */\n\t\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)\n\t\t\ttmp |= TIOCFLAG_SOFTCAR;\n\t\t/* These flags take effect during open. */\n\t\tzst->zst_swflags = tmp;\n\t\tbreak;\n\n\tcase TIOCSDTR:\n\t\tzs_modem(zst, 1);\n\t\tbreak;\n\n\tcase TIOCCDTR:\n\t\tzs_modem(zst, 0);\n\t\tbreak;\n\n\tcase TIOCMSET:\n\tcase TIOCMBIS:\n\tcase TIOCMBIC:\n\tcase TIOCMGET:\n\tdefault:\n\t\treturn (ENOTTY);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "zswrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "487-499",
    "snippet": "int\nzswrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct tty *tp;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\ttp = zst->zst_tty;\n\treturn (linesw[tp->t_line].l_write(tp, uio, flags));\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "struct tty *\nzstty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "linesw[tp->t_line].l_write",
          "args": [
            "tp",
            "uio",
            "flags"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstruct tty *\nzstty(dev)\n\tdev_t dev;\n\nint\nzswrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct tty *tp;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\ttp = zst->zst_tty;\n\treturn (linesw[tp->t_line].l_write(tp, uio, flags));\n}"
  },
  {
    "function_name": "zsread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "473-485",
    "snippet": "int\nzsread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct tty *tp;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\ttp = zst->zst_tty;\n\treturn (linesw[tp->t_line].l_read(tp, uio, flags));\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "struct tty *\nzstty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "linesw[tp->t_line].l_read",
          "args": [
            "tp",
            "uio",
            "flags"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstruct tty *\nzstty(dev)\n\tdev_t dev;\n\nint\nzsread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct tty *tp;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\ttp = zst->zst_tty;\n\treturn (linesw[tp->t_line].l_read(tp, uio, flags));\n}"
  },
  {
    "function_name": "zsclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "432-468",
    "snippet": "int\nzsclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tint hup;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\t/* XXX This is for cons.c. */\n\tif ((tp->t_state & TS_ISOPEN) == 0)\n\t\treturn 0;\n\n\t(*linesw[tp->t_line].l_close)(tp, flags);\n\thup = tp->t_cflag & HUPCL;\n\tif (zst->zst_swflags & TIOCFLAG_SOFTCAR)\n\t\thup = 0;\n\tif (hup) {\n\t\tzs_modem(zst, 0);\n\t\t/* hold low for 1 second */\n\t\t(void) tsleep((caddr_t)cs, TTIPRI, ttclos, hz);\n\t}\n\tif (cs->cs_creg[5] & ZSWR5_BREAK) {\n\t\tzs_break(cs, 0);\n\t}\n\t/* XXX - turn off interrupts? */\n\n\tttyclose(tp);\n\treturn (0);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "static void\tzs_modem",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "struct tty *\nzstty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ttyclose",
          "args": [
            "tp"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_break",
          "args": [
            "cs",
            "0"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "zs_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "74-91",
          "snippet": "void\nzs_break(cs, set)\n\tstruct zs_chanstate *cs;\n\tint set;\n{\n\tint s;\n\n\ts = splzs();\n\tif (set) {\n\t\tcs->cs_preg[5] |= ZSWR5_BREAK;\n\t\tcs->cs_creg[5] |= ZSWR5_BREAK;\n\t} else {\n\t\tcs->cs_preg[5] &= ~ZSWR5_BREAK;\n\t\tcs->cs_creg[5] &= ~ZSWR5_BREAK;\n\t}\n\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_break(cs, set)\n\tstruct zs_chanstate *cs;\n\tint set;\n{\n\tint s;\n\n\ts = splzs();\n\tif (set) {\n\t\tcs->cs_preg[5] |= ZSWR5_BREAK;\n\t\tcs->cs_creg[5] |= ZSWR5_BREAK;\n\t} else {\n\t\tcs->cs_preg[5] &= ~ZSWR5_BREAK;\n\t\tcs->cs_creg[5] &= ~ZSWR5_BREAK;\n\t}\n\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)cs",
            "TTIPRI",
            "ttclos",
            "hz"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_modem",
          "args": [
            "zst",
            "0"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "zs_modem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "796-828",
          "snippet": "static void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "flags"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\nstruct tty *\nzstty(dev)\n\tdev_t dev;\n\nint\nzsclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister struct tty *tp;\n\tint hup;\n\n\tzst = zstty_cd.cd_devs[minor(dev)];\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\t/* XXX This is for cons.c. */\n\tif ((tp->t_state & TS_ISOPEN) == 0)\n\t\treturn 0;\n\n\t(*linesw[tp->t_line].l_close)(tp, flags);\n\thup = tp->t_cflag & HUPCL;\n\tif (zst->zst_swflags & TIOCFLAG_SOFTCAR)\n\t\thup = 0;\n\tif (hup) {\n\t\tzs_modem(zst, 0);\n\t\t/* hold low for 1 second */\n\t\t(void) tsleep((caddr_t)cs, TTIPRI, ttclos, hz);\n\t}\n\tif (cs->cs_creg[5] & ZSWR5_BREAK) {\n\t\tzs_break(cs, 0);\n\t}\n\t/* XXX - turn off interrupts? */\n\n\tttyclose(tp);\n\treturn (0);\n}"
  },
  {
    "function_name": "zsopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "328-427",
    "snippet": "int\nzsopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tregister struct tty *tp;\n\tregister struct zs_chanstate *cs;\n\tstruct zstty_softc *zst;\n\tint error, s, unit;\n\n\tunit = minor(dev);\n\tif (unit >= zstty_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tzst = zstty_cd.cd_devs[unit];\n\tif (zst == NULL)\n\t\treturn (ENXIO);\n\ttp = zst->zst_tty;\n\tcs = zst->zst_cs;\n\n\t/* If KGDB took the line, then tp==NULL */\n\tif (tp == NULL)\n\t\treturn (EBUSY);\n\n\t/* It's simpler to do this up here. */\n\tif (((tp->t_state & (TS_ISOPEN | TS_XCLUDE))\n\t     ==             (TS_ISOPEN | TS_XCLUDE))\n\t    && (p->p_ucred->cr_uid != 0) )\n\t{\n\t\treturn (EBUSY);\n\t}\n\n\ts = spltty();\n\n\tif ((tp->t_state & TS_ISOPEN) == 0) {\n\t\t/* First open. */\n\t\tttychars(tp);\n\t\ttp->t_iflag = TTYDEF_IFLAG;\n\t\ttp->t_oflag = TTYDEF_OFLAG;\n\t\ttp->t_cflag = ZSTTY_DEF_CFLAG;\n\t\tif (zst->zst_swflags & TIOCFLAG_CLOCAL)\n\t\t\ttp->t_cflag |= CLOCAL;\n\t\tif (zst->zst_swflags & TIOCFLAG_CRTSCTS)\n\t\t\ttp->t_cflag |= CRTSCTS;\n\t\tif (zst->zst_swflags & TIOCFLAG_MDMBUF)\n\t\t\ttp->t_cflag |= MDMBUF;\n\t\ttp->t_lflag = TTYDEF_LFLAG;\n\t\ttp->t_ispeed = tp->t_ospeed = cs->cs_defspeed;\n\t\t(void) zsparam(tp, &tp->t_termios);\n\t\tttsetwater(tp);\n\t\t/* Flush any pending input. */\n\t\tzst->zst_rbget = zst->zst_rbput;\n\t\tzs_iflush(cs);\t/* XXX */\n\t\t/* Turn on DTR */\n\t\tzs_modem(zst, 1);\n\t\tif (zst->zst_swflags & TIOCFLAG_SOFTCAR) {\n\t\t\ttp->t_state |= TS_CARR_ON;\n\t\t}\n\t}\n\terror = 0;\n\n\t/* Wait for carrier. */\n\tfor (;;) {\n\n\t\t/* Might never get status intr if carrier already on. */\n\t\tcs->cs_rr0 = zs_read_csr(cs);\n\t\tif (cs->cs_rr0 & ZSRR0_DCD) {\n\t\t\ttp->t_state |= TS_CARR_ON;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((tp->t_state & TS_CARR_ON) ||\n\t\t    (tp->t_cflag & CLOCAL) ||\n\t\t    (flags & O_NONBLOCK) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ttp->t_state |= TS_WOPEN;\n\t\terror = ttysleep(tp, (caddr_t)&tp->t_rawq,\n\t\t\tTTIPRI | PCATCH, ttopen, 0);\n\t\tif (error) {\n\t\t\tif ((tp->t_state & TS_ISOPEN) == 0) {\n\t\t\t\t/* Never get here with softcar */\n\t\t\t\tzs_modem(zst, 0);\n\t\t\t\ttp->t_state &= ~TS_WOPEN;\n\t\t\t\tttwakeup(tp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tif (error == 0)\n\t\terror = linesw[tp->t_line].l_open(dev, tp);\n\n\treturn (error);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tZSTTY_DEF_CFLAG\tTTYDEF_CFLAG"
    ],
    "globals_used": [
      "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
      "static int\tzsparam",
      "static void\tzs_modem",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "struct tty *\nzstty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "linesw[tp->t_line].l_open",
          "args": [
            "dev",
            "tp"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttwakeup",
          "args": [
            "tp"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_modem",
          "args": [
            "zst",
            "0"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "zs_modem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "796-828",
          "snippet": "static void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttysleep",
          "args": [
            "tp",
            "(caddr_t)&tp->t_rawq",
            "TTIPRI | PCATCH",
            "ttopen",
            "0"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_csr",
          "args": [
            "cs"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_iflush",
          "args": [
            "cs"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "zs_iflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "111-135",
          "snippet": "void\nzs_iflush(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char c, rr0, rr1;\n\n\tfor (;;) {\n\t\t/* Is there input available? */\n\t\trr0 = zs_read_csr(cs);\n\t\tif ((rr0 & ZSRR0_RX_READY) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * First read the status, because reading the data\n\t\t * destroys the status of this char.\n\t\t */\n\t\trr1 = zs_read_reg(cs, 1);\n\t\tc = zs_read_data(cs);\n\n\t\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t\t/* Clear the receive error. */\n\t\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_iflush(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char c, rr0, rr1;\n\n\tfor (;;) {\n\t\t/* Is there input available? */\n\t\trr0 = zs_read_csr(cs);\n\t\tif ((rr0 & ZSRR0_RX_READY) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * First read the status, because reading the data\n\t\t * destroys the status of this char.\n\t\t */\n\t\trr1 = zs_read_reg(cs, 1);\n\t\tc = zs_read_data(cs);\n\n\t\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t\t/* Clear the receive error. */\n\t\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttsetwater",
          "args": [
            "tp"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zsparam",
          "args": [
            "tp",
            "&tp->t_termios"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "zsparam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "681-790",
          "snippet": "static int\nzsparam(tp, t)\n\tregister struct tty *tp;\n\tregister struct termios *t;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, bps, cflag, tconst;\n\tu_char tmp3, tmp4, tmp5;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\t/* XXX: Need to use an MD function for this. */\n\tbps = t->c_ospeed;\n\tif (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))\n\t\treturn (EINVAL);\n\tif (bps == 0) {\n\t\t/* stty 0 => drop DTR and RTS */\n\t\tzs_modem(zst, 0);\n\t\treturn (0);\n\t}\n\ttconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);\n\tif (tconst < 0)\n\t\treturn (EINVAL);\n\n\t/* Convert back to make sure we can do it. */\n\tbps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);\n\tif (bps != t->c_ospeed)\n\t\treturn (EINVAL);\n\ttp->t_ispeed = tp->t_ospeed = bps;\n\n\tcflag = t->c_cflag;\n\ttp->t_cflag = cflag;\n\n\t/*\n\t * Block interrupts so that state will not\n\t * be altered until we are done setting it up.\n\t */\n\ts = splzs();\n\n\t/*\n\t * Initial values in cs_preg are set before\n\t * our attach routine is called.  The master\n\t * interrupt enable is handled by zsc.c\n\t */\n\n\tcs->cs_preg[12] = tconst;\n\tcs->cs_preg[13] = tconst >> 8;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\ttmp3 = ZSWR3_RX_5;\n\t\ttmp5 = ZSWR5_TX_5;\n\t\tbreak;\n\tcase CS6:\n\t\ttmp3 = ZSWR3_RX_6;\n\t\ttmp5 = ZSWR5_TX_6;\n\t\tbreak;\n\tcase CS7:\n\t\ttmp3 = ZSWR3_RX_7;\n\t\ttmp5 = ZSWR5_TX_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\ttmp3 = ZSWR3_RX_8;\n\t\ttmp5 = ZSWR5_TX_8;\n\t\tbreak;\n\t}\n\n\tcs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;\n\tcs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;\n\n\ttmp4 = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);\n\tif ((cflag & PARODD) == 0)\n\t\ttmp4 |= ZSWR4_EVENP;\n\tif (cflag & PARENB)\n\t\ttmp4 |= ZSWR4_PARENB;\n\tcs->cs_preg[4] = tmp4;\n\n\t/*\n\t * Output hardware flow control on the chip is horrendous:\n\t * if carrier detect drops, the receiver is disabled.\n\t * Therefore, NEVER set the HFC bit, and instead use\n\t * the status interrupts to detect CTS changes.\n\t */\n\tif (cflag & CRTSCTS) {\n\t\tzst->zst_rbhiwat = zstty_rbuf_hiwat;\n\t\tcs->cs_preg[15] |= ZSWR15_CTS_IE;\n\t} else {\n\t\tzst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */\n\t\tcs->cs_preg[15] &= ~ZSWR15_CTS_IE;\n\t}\n\n\t/*\n\t * If nothing is being transmitted, set up new current values,\n\t * else mark them as pending.\n\t */\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = 0xFF; /* XXX */\n\t\t} else {\n\t\t\tzs_loadchannelregs(cs);\n\t\t}\n\t}\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int zstty_rbuf_size = ZSTTY_RING_SIZE;",
            "int zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));",
            "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
            "static int\tzsparam",
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint zstty_rbuf_size = ZSTTY_RING_SIZE;\nint zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic int\tzsparam;\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic int\nzsparam(tp, t)\n\tregister struct tty *tp;\n\tregister struct termios *t;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, bps, cflag, tconst;\n\tu_char tmp3, tmp4, tmp5;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\t/* XXX: Need to use an MD function for this. */\n\tbps = t->c_ospeed;\n\tif (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))\n\t\treturn (EINVAL);\n\tif (bps == 0) {\n\t\t/* stty 0 => drop DTR and RTS */\n\t\tzs_modem(zst, 0);\n\t\treturn (0);\n\t}\n\ttconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);\n\tif (tconst < 0)\n\t\treturn (EINVAL);\n\n\t/* Convert back to make sure we can do it. */\n\tbps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);\n\tif (bps != t->c_ospeed)\n\t\treturn (EINVAL);\n\ttp->t_ispeed = tp->t_ospeed = bps;\n\n\tcflag = t->c_cflag;\n\ttp->t_cflag = cflag;\n\n\t/*\n\t * Block interrupts so that state will not\n\t * be altered until we are done setting it up.\n\t */\n\ts = splzs();\n\n\t/*\n\t * Initial values in cs_preg are set before\n\t * our attach routine is called.  The master\n\t * interrupt enable is handled by zsc.c\n\t */\n\n\tcs->cs_preg[12] = tconst;\n\tcs->cs_preg[13] = tconst >> 8;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\ttmp3 = ZSWR3_RX_5;\n\t\ttmp5 = ZSWR5_TX_5;\n\t\tbreak;\n\tcase CS6:\n\t\ttmp3 = ZSWR3_RX_6;\n\t\ttmp5 = ZSWR5_TX_6;\n\t\tbreak;\n\tcase CS7:\n\t\ttmp3 = ZSWR3_RX_7;\n\t\ttmp5 = ZSWR5_TX_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\ttmp3 = ZSWR3_RX_8;\n\t\ttmp5 = ZSWR5_TX_8;\n\t\tbreak;\n\t}\n\n\tcs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;\n\tcs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;\n\n\ttmp4 = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);\n\tif ((cflag & PARODD) == 0)\n\t\ttmp4 |= ZSWR4_EVENP;\n\tif (cflag & PARENB)\n\t\ttmp4 |= ZSWR4_PARENB;\n\tcs->cs_preg[4] = tmp4;\n\n\t/*\n\t * Output hardware flow control on the chip is horrendous:\n\t * if carrier detect drops, the receiver is disabled.\n\t * Therefore, NEVER set the HFC bit, and instead use\n\t * the status interrupts to detect CTS changes.\n\t */\n\tif (cflag & CRTSCTS) {\n\t\tzst->zst_rbhiwat = zstty_rbuf_hiwat;\n\t\tcs->cs_preg[15] |= ZSWR15_CTS_IE;\n\t} else {\n\t\tzst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */\n\t\tcs->cs_preg[15] &= ~ZSWR15_CTS_IE;\n\t}\n\n\t/*\n\t * If nothing is being transmitted, set up new current values,\n\t * else mark them as pending.\n\t */\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = 0xFF; /* XXX */\n\t\t} else {\n\t\t\tzs_loadchannelregs(cs);\n\t\t}\n\t}\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttychars",
          "args": [
            "tp"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tZSTTY_DEF_CFLAG\tTTYDEF_CFLAG\n\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic int\tzsparam;\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\nstruct tty *\nzstty(dev)\n\tdev_t dev;\n\nint\nzsopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tregister struct tty *tp;\n\tregister struct zs_chanstate *cs;\n\tstruct zstty_softc *zst;\n\tint error, s, unit;\n\n\tunit = minor(dev);\n\tif (unit >= zstty_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tzst = zstty_cd.cd_devs[unit];\n\tif (zst == NULL)\n\t\treturn (ENXIO);\n\ttp = zst->zst_tty;\n\tcs = zst->zst_cs;\n\n\t/* If KGDB took the line, then tp==NULL */\n\tif (tp == NULL)\n\t\treturn (EBUSY);\n\n\t/* It's simpler to do this up here. */\n\tif (((tp->t_state & (TS_ISOPEN | TS_XCLUDE))\n\t     ==             (TS_ISOPEN | TS_XCLUDE))\n\t    && (p->p_ucred->cr_uid != 0) )\n\t{\n\t\treturn (EBUSY);\n\t}\n\n\ts = spltty();\n\n\tif ((tp->t_state & TS_ISOPEN) == 0) {\n\t\t/* First open. */\n\t\tttychars(tp);\n\t\ttp->t_iflag = TTYDEF_IFLAG;\n\t\ttp->t_oflag = TTYDEF_OFLAG;\n\t\ttp->t_cflag = ZSTTY_DEF_CFLAG;\n\t\tif (zst->zst_swflags & TIOCFLAG_CLOCAL)\n\t\t\ttp->t_cflag |= CLOCAL;\n\t\tif (zst->zst_swflags & TIOCFLAG_CRTSCTS)\n\t\t\ttp->t_cflag |= CRTSCTS;\n\t\tif (zst->zst_swflags & TIOCFLAG_MDMBUF)\n\t\t\ttp->t_cflag |= MDMBUF;\n\t\ttp->t_lflag = TTYDEF_LFLAG;\n\t\ttp->t_ispeed = tp->t_ospeed = cs->cs_defspeed;\n\t\t(void) zsparam(tp, &tp->t_termios);\n\t\tttsetwater(tp);\n\t\t/* Flush any pending input. */\n\t\tzst->zst_rbget = zst->zst_rbput;\n\t\tzs_iflush(cs);\t/* XXX */\n\t\t/* Turn on DTR */\n\t\tzs_modem(zst, 1);\n\t\tif (zst->zst_swflags & TIOCFLAG_SOFTCAR) {\n\t\t\ttp->t_state |= TS_CARR_ON;\n\t\t}\n\t}\n\terror = 0;\n\n\t/* Wait for carrier. */\n\tfor (;;) {\n\n\t\t/* Might never get status intr if carrier already on. */\n\t\tcs->cs_rr0 = zs_read_csr(cs);\n\t\tif (cs->cs_rr0 & ZSRR0_DCD) {\n\t\t\ttp->t_state |= TS_CARR_ON;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((tp->t_state & TS_CARR_ON) ||\n\t\t    (tp->t_cflag & CLOCAL) ||\n\t\t    (flags & O_NONBLOCK) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ttp->t_state |= TS_WOPEN;\n\t\terror = ttysleep(tp, (caddr_t)&tp->t_rawq,\n\t\t\tTTIPRI | PCATCH, ttopen, 0);\n\t\tif (error) {\n\t\t\tif ((tp->t_state & TS_ISOPEN) == 0) {\n\t\t\t\t/* Never get here with softcar */\n\t\t\t\tzs_modem(zst, 0);\n\t\t\t\ttp->t_state &= ~TS_WOPEN;\n\t\t\t\tttwakeup(tp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tif (error == 0)\n\t\terror = linesw[tp->t_line].l_open(dev, tp);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "zstty_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "210-303",
    "snippet": "void \nzstty_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct zstty_softc *zst = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tstruct tty *tp;\n\tint channel, tty_unit;\n\tdev_t dev;\n\n\tcf = zst->zst_dev.dv_cfdata;\n\ttty_unit = zst->zst_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = &zsc->zsc_cs[channel];\n\tcs->cs_private = zst;\n\tcs->cs_ops = &zsops_tty;\n\n\tzst->zst_cs = cs;\n\tzst->zst_swflags = cf->cf_flags;\t/* softcar, etc. */\n\tzst->zst_hwflags = args->hwflags;\n\tdev = makedev(ZSTTY_MAJOR, tty_unit);\n\n\tif (zst->zst_swflags)\n\t\tprintf(\" flags 0x%x\", zst->zst_swflags);\n\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)\n\t\tprintf(\" (console)\");\n\telse {\n#ifdef KGDB\n\t\t/*\n\t\t * Allow kgdb to \"take over\" this port.  If this port is\n\t\t * NOT the kgdb port, zs_check_kgdb() will return zero.\n\t\t * If it IS the kgdb port, it will print \"kgdb,...\\n\"\n\t\t * and then return non-zero.\n\t\t */\n\t\tif (zs_check_kgdb(cs, dev)) {\n\t\t\t/*\n\t\t\t * This is the kgdb port (exclusive use)\n\t\t\t * so skip the normal attach code.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\tprintf(\"\\n\");\n\n\ttp = ttymalloc();\n\ttp->t_dev = dev;\n\ttp->t_oproc = zsstart;\n\ttp->t_param = zsparam;\n\ttp->t_hwiflow = zshwiflow;\n\ttty_attach(tp);\n\n\tzst->zst_tty = tp;\n\tzst->zst_rbhiwat =  zstty_rbuf_size;\t/* impossible value */\n\tzst->zst_ringmask = zstty_rbuf_size - 1;\n\tzst->zst_rbuf = malloc(zstty_rbuf_size * sizeof(zst->zst_rbuf[0]),\n\t\t\t      M_DEVBUF, M_WAITOK);\n\n\t/*\n\t * Hardware init\n\t */\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE) {\n\t\t/* This unit is the console. */\n\t\tzst->zst_swflags |= TIOCFLAG_SOFTCAR;\n\t\t/* Call _param so interrupts get enabled. */\n\t\tcs->cs_defspeed = zs_getspeed(cs);\n\t\ttp->t_ispeed = cs->cs_defspeed;\n\t\ttp->t_ospeed = cs->cs_defspeed;\n\t\ttp->t_cflag = ZSTTY_DEF_CFLAG;\n\t\t(void) zsparam(tp, &tp->t_termios);\n\t} else {\n\t\t/* Not the console; may need reset. */\n\t\tint reset, s;\n\t\treset = (channel == 0) ?\n\t\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\t\ts = splzs();\n\t\tzs_write_reg(cs, 9, reset);\n\t\tsplx(s);\n\t}\n\n\t/*\n\t * Initialize state of modem control lines (DTR).\n\t * If softcar is set, turn on DTR now and leave it.\n\t * otherwise, turn off DTR now, and raise in open.\n\t * (Keeps modem from answering too early.)\n\t */\n\tzs_modem(zst, (zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tZSTTY_DEF_CFLAG\tTTYDEF_CFLAG"
    ],
    "globals_used": [
      "int zstty_rbuf_size = ZSTTY_RING_SIZE;",
      "static int\tzstty_match(struct device *, void *, void *);",
      "static void\tzstty_attach(struct device *, struct device *, void *);",
      "struct zsops zsops_tty;",
      "static void\tzsstart",
      "static int\tzsparam",
      "static void\tzs_modem",
      "static int\tzshwiflow",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "__P((register struct zs_chanstate *));",
      "struct tty *\nzstty(dev)\n\tdev_t dev;",
      "struct zsops zsops_tty = {\n\tzstty_rxint,\t/* receive char available */\n\tzstty_stint,\t/* external/status */\n\tzstty_txint,\t/* xmit buffer empty */\n\tzstty_softint,\t/* process software interrupt */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_modem",
          "args": [
            "zst",
            "(zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "zs_modem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "796-828",
          "snippet": "static void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic void\nzs_modem(zst, onoff)\n\tstruct zstty_softc *zst;\n\tint onoff;\n{\n\tstruct zs_chanstate *cs;\n\tstruct tty *tp;\n\tint s, bis, and;\n\n\tcs = zst->zst_cs;\n\ttp = zst->zst_tty;\n\n\tif (onoff) {\n\t\tbis = ZSWR5_DTR | ZSWR5_RTS;\n\t\tand = ~0;\n\t} else {\n\t\tbis = 0;\n\t\tand = ~(ZSWR5_DTR | ZSWR5_RTS);\n\t}\n\ts = splzs();\n\tcs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = (1<<5);\n\t\t} else {\n\t\t\tcs->cs_creg[5] = cs->cs_preg[5];\n\t\t\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\t\t}\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "9",
            "reset"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zsparam",
          "args": [
            "tp",
            "&tp->t_termios"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "zsparam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "681-790",
          "snippet": "static int\nzsparam(tp, t)\n\tregister struct tty *tp;\n\tregister struct termios *t;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, bps, cflag, tconst;\n\tu_char tmp3, tmp4, tmp5;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\t/* XXX: Need to use an MD function for this. */\n\tbps = t->c_ospeed;\n\tif (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))\n\t\treturn (EINVAL);\n\tif (bps == 0) {\n\t\t/* stty 0 => drop DTR and RTS */\n\t\tzs_modem(zst, 0);\n\t\treturn (0);\n\t}\n\ttconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);\n\tif (tconst < 0)\n\t\treturn (EINVAL);\n\n\t/* Convert back to make sure we can do it. */\n\tbps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);\n\tif (bps != t->c_ospeed)\n\t\treturn (EINVAL);\n\ttp->t_ispeed = tp->t_ospeed = bps;\n\n\tcflag = t->c_cflag;\n\ttp->t_cflag = cflag;\n\n\t/*\n\t * Block interrupts so that state will not\n\t * be altered until we are done setting it up.\n\t */\n\ts = splzs();\n\n\t/*\n\t * Initial values in cs_preg are set before\n\t * our attach routine is called.  The master\n\t * interrupt enable is handled by zsc.c\n\t */\n\n\tcs->cs_preg[12] = tconst;\n\tcs->cs_preg[13] = tconst >> 8;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\ttmp3 = ZSWR3_RX_5;\n\t\ttmp5 = ZSWR5_TX_5;\n\t\tbreak;\n\tcase CS6:\n\t\ttmp3 = ZSWR3_RX_6;\n\t\ttmp5 = ZSWR5_TX_6;\n\t\tbreak;\n\tcase CS7:\n\t\ttmp3 = ZSWR3_RX_7;\n\t\ttmp5 = ZSWR5_TX_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\ttmp3 = ZSWR3_RX_8;\n\t\ttmp5 = ZSWR5_TX_8;\n\t\tbreak;\n\t}\n\n\tcs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;\n\tcs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;\n\n\ttmp4 = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);\n\tif ((cflag & PARODD) == 0)\n\t\ttmp4 |= ZSWR4_EVENP;\n\tif (cflag & PARENB)\n\t\ttmp4 |= ZSWR4_PARENB;\n\tcs->cs_preg[4] = tmp4;\n\n\t/*\n\t * Output hardware flow control on the chip is horrendous:\n\t * if carrier detect drops, the receiver is disabled.\n\t * Therefore, NEVER set the HFC bit, and instead use\n\t * the status interrupts to detect CTS changes.\n\t */\n\tif (cflag & CRTSCTS) {\n\t\tzst->zst_rbhiwat = zstty_rbuf_hiwat;\n\t\tcs->cs_preg[15] |= ZSWR15_CTS_IE;\n\t} else {\n\t\tzst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */\n\t\tcs->cs_preg[15] &= ~ZSWR15_CTS_IE;\n\t}\n\n\t/*\n\t * If nothing is being transmitted, set up new current values,\n\t * else mark them as pending.\n\t */\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = 0xFF; /* XXX */\n\t\t} else {\n\t\t\tzs_loadchannelregs(cs);\n\t\t}\n\t}\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int zstty_rbuf_size = ZSTTY_RING_SIZE;",
            "int zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));",
            "struct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};",
            "static int\tzsparam",
            "static void\tzs_modem",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint zstty_rbuf_size = ZSTTY_RING_SIZE;\nint zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));\nstruct cfdriver zstty_cd = {\n\tNULL, \"zstty\", DV_TTY\n};\nstatic int\tzsparam;\nstatic void\tzs_modem;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n\nstatic int\nzsparam(tp, t)\n\tregister struct tty *tp;\n\tregister struct termios *t;\n{\n\tregister struct zstty_softc *zst;\n\tregister struct zs_chanstate *cs;\n\tregister int s, bps, cflag, tconst;\n\tu_char tmp3, tmp4, tmp5;\n\n\tzst = zstty_cd.cd_devs[minor(tp->t_dev)];\n\tcs = zst->zst_cs;\n\n\t/* XXX: Need to use an MD function for this. */\n\tbps = t->c_ospeed;\n\tif (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))\n\t\treturn (EINVAL);\n\tif (bps == 0) {\n\t\t/* stty 0 => drop DTR and RTS */\n\t\tzs_modem(zst, 0);\n\t\treturn (0);\n\t}\n\ttconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);\n\tif (tconst < 0)\n\t\treturn (EINVAL);\n\n\t/* Convert back to make sure we can do it. */\n\tbps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);\n\tif (bps != t->c_ospeed)\n\t\treturn (EINVAL);\n\ttp->t_ispeed = tp->t_ospeed = bps;\n\n\tcflag = t->c_cflag;\n\ttp->t_cflag = cflag;\n\n\t/*\n\t * Block interrupts so that state will not\n\t * be altered until we are done setting it up.\n\t */\n\ts = splzs();\n\n\t/*\n\t * Initial values in cs_preg are set before\n\t * our attach routine is called.  The master\n\t * interrupt enable is handled by zsc.c\n\t */\n\n\tcs->cs_preg[12] = tconst;\n\tcs->cs_preg[13] = tconst >> 8;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\ttmp3 = ZSWR3_RX_5;\n\t\ttmp5 = ZSWR5_TX_5;\n\t\tbreak;\n\tcase CS6:\n\t\ttmp3 = ZSWR3_RX_6;\n\t\ttmp5 = ZSWR5_TX_6;\n\t\tbreak;\n\tcase CS7:\n\t\ttmp3 = ZSWR3_RX_7;\n\t\ttmp5 = ZSWR5_TX_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\ttmp3 = ZSWR3_RX_8;\n\t\ttmp5 = ZSWR5_TX_8;\n\t\tbreak;\n\t}\n\n\tcs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;\n\tcs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;\n\n\ttmp4 = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);\n\tif ((cflag & PARODD) == 0)\n\t\ttmp4 |= ZSWR4_EVENP;\n\tif (cflag & PARENB)\n\t\ttmp4 |= ZSWR4_PARENB;\n\tcs->cs_preg[4] = tmp4;\n\n\t/*\n\t * Output hardware flow control on the chip is horrendous:\n\t * if carrier detect drops, the receiver is disabled.\n\t * Therefore, NEVER set the HFC bit, and instead use\n\t * the status interrupts to detect CTS changes.\n\t */\n\tif (cflag & CRTSCTS) {\n\t\tzst->zst_rbhiwat = zstty_rbuf_hiwat;\n\t\tcs->cs_preg[15] |= ZSWR15_CTS_IE;\n\t} else {\n\t\tzst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */\n\t\tcs->cs_preg[15] &= ~ZSWR15_CTS_IE;\n\t}\n\n\t/*\n\t * If nothing is being transmitted, set up new current values,\n\t * else mark them as pending.\n\t */\n\tif (cs->cs_heldchange == 0) {\n\t\tif (zst->zst_tx_busy) {\n\t\t\tzst->zst_heldtbc = zst->zst_tbc;\n\t\t\tzst->zst_tbc = 0;\n\t\t\tcs->cs_heldchange = 0xFF; /* XXX */\n\t\t} else {\n\t\t\tzs_loadchannelregs(cs);\n\t\t}\n\t}\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zs_getspeed",
          "args": [
            "cs"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "zs_getspeed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "97-106",
          "snippet": "int\nzs_getspeed(cs)\n\tstruct zs_chanstate *cs;\n{\n\tint tconst;\n\n\ttconst = zs_read_reg(cs, 12);\n\ttconst |= zs_read_reg(cs, 13) << 8;\n\treturn (TCONST_TO_BPS(cs->cs_brg_clk, tconst));\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nzs_getspeed(cs)\n\tstruct zs_chanstate *cs;\n{\n\tint tconst;\n\n\ttconst = zs_read_reg(cs, 12);\n\ttconst |= zs_read_reg(cs, 13) << 8;\n\treturn (TCONST_TO_BPS(cs->cs_brg_clk, tconst));\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "zstty_rbuf_size * sizeof(zst->zst_rbuf[0])",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_attach",
          "args": [
            "tp"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "zstty_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "210-303",
          "snippet": "void \nzstty_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct zstty_softc *zst = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tstruct tty *tp;\n\tint channel, tty_unit;\n\tdev_t dev;\n\n\tcf = zst->zst_dev.dv_cfdata;\n\ttty_unit = zst->zst_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = &zsc->zsc_cs[channel];\n\tcs->cs_private = zst;\n\tcs->cs_ops = &zsops_tty;\n\n\tzst->zst_cs = cs;\n\tzst->zst_swflags = cf->cf_flags;\t/* softcar, etc. */\n\tzst->zst_hwflags = args->hwflags;\n\tdev = makedev(ZSTTY_MAJOR, tty_unit);\n\n\tif (zst->zst_swflags)\n\t\tprintf(\" flags 0x%x\", zst->zst_swflags);\n\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)\n\t\tprintf(\" (console)\");\n\telse {\n#ifdef KGDB\n\t\t/*\n\t\t * Allow kgdb to \"take over\" this port.  If this port is\n\t\t * NOT the kgdb port, zs_check_kgdb() will return zero.\n\t\t * If it IS the kgdb port, it will print \"kgdb,...\\n\"\n\t\t * and then return non-zero.\n\t\t */\n\t\tif (zs_check_kgdb(cs, dev)) {\n\t\t\t/*\n\t\t\t * This is the kgdb port (exclusive use)\n\t\t\t * so skip the normal attach code.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\tprintf(\"\\n\");\n\n\ttp = ttymalloc();\n\ttp->t_dev = dev;\n\ttp->t_oproc = zsstart;\n\ttp->t_param = zsparam;\n\ttp->t_hwiflow = zshwiflow;\n\ttty_attach(tp);\n\n\tzst->zst_tty = tp;\n\tzst->zst_rbhiwat =  zstty_rbuf_size;\t/* impossible value */\n\tzst->zst_ringmask = zstty_rbuf_size - 1;\n\tzst->zst_rbuf = malloc(zstty_rbuf_size * sizeof(zst->zst_rbuf[0]),\n\t\t\t      M_DEVBUF, M_WAITOK);\n\n\t/*\n\t * Hardware init\n\t */\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE) {\n\t\t/* This unit is the console. */\n\t\tzst->zst_swflags |= TIOCFLAG_SOFTCAR;\n\t\t/* Call _param so interrupts get enabled. */\n\t\tcs->cs_defspeed = zs_getspeed(cs);\n\t\ttp->t_ispeed = cs->cs_defspeed;\n\t\ttp->t_ospeed = cs->cs_defspeed;\n\t\ttp->t_cflag = ZSTTY_DEF_CFLAG;\n\t\t(void) zsparam(tp, &tp->t_termios);\n\t} else {\n\t\t/* Not the console; may need reset. */\n\t\tint reset, s;\n\t\treset = (channel == 0) ?\n\t\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\t\ts = splzs();\n\t\tzs_write_reg(cs, 9, reset);\n\t\tsplx(s);\n\t}\n\n\t/*\n\t * Initialize state of modem control lines (DTR).\n\t * If softcar is set, turn on DTR now and leave it.\n\t * otherwise, turn off DTR now, and raise in open.\n\t * (Keeps modem from answering too early.)\n\t */\n\tzs_modem(zst, (zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ttymalloc",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zs_check_kgdb",
          "args": [
            "cs",
            "dev"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makedev",
          "args": [
            "ZSTTY_MAJOR",
            "tty_unit"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tZSTTY_DEF_CFLAG\tTTYDEF_CFLAG\n\nint zstty_rbuf_size = ZSTTY_RING_SIZE;\nstatic int\tzstty_match(struct device *, void *, void *);\nstatic void\tzstty_attach(struct device *, struct device *, void *);\nstruct zsops zsops_tty;\nstatic void\tzsstart;\nstatic int\tzsparam;\nstatic void\tzs_modem;\nstatic int\tzshwiflow;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\nstruct tty *\nzstty(dev)\n\tdev_t dev;\nstruct zsops zsops_tty = {\n\tzstty_rxint,\t/* receive char available */\n\tzstty_stint,\t/* external/status */\n\tzstty_txint,\t/* xmit buffer empty */\n\tzstty_softint,\t/* process software interrupt */\n};\n\nvoid \nzstty_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct zstty_softc *zst = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tstruct tty *tp;\n\tint channel, tty_unit;\n\tdev_t dev;\n\n\tcf = zst->zst_dev.dv_cfdata;\n\ttty_unit = zst->zst_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = &zsc->zsc_cs[channel];\n\tcs->cs_private = zst;\n\tcs->cs_ops = &zsops_tty;\n\n\tzst->zst_cs = cs;\n\tzst->zst_swflags = cf->cf_flags;\t/* softcar, etc. */\n\tzst->zst_hwflags = args->hwflags;\n\tdev = makedev(ZSTTY_MAJOR, tty_unit);\n\n\tif (zst->zst_swflags)\n\t\tprintf(\" flags 0x%x\", zst->zst_swflags);\n\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)\n\t\tprintf(\" (console)\");\n\telse {\n#ifdef KGDB\n\t\t/*\n\t\t * Allow kgdb to \"take over\" this port.  If this port is\n\t\t * NOT the kgdb port, zs_check_kgdb() will return zero.\n\t\t * If it IS the kgdb port, it will print \"kgdb,...\\n\"\n\t\t * and then return non-zero.\n\t\t */\n\t\tif (zs_check_kgdb(cs, dev)) {\n\t\t\t/*\n\t\t\t * This is the kgdb port (exclusive use)\n\t\t\t * so skip the normal attach code.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\tprintf(\"\\n\");\n\n\ttp = ttymalloc();\n\ttp->t_dev = dev;\n\ttp->t_oproc = zsstart;\n\ttp->t_param = zsparam;\n\ttp->t_hwiflow = zshwiflow;\n\ttty_attach(tp);\n\n\tzst->zst_tty = tp;\n\tzst->zst_rbhiwat =  zstty_rbuf_size;\t/* impossible value */\n\tzst->zst_ringmask = zstty_rbuf_size - 1;\n\tzst->zst_rbuf = malloc(zstty_rbuf_size * sizeof(zst->zst_rbuf[0]),\n\t\t\t      M_DEVBUF, M_WAITOK);\n\n\t/*\n\t * Hardware init\n\t */\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE) {\n\t\t/* This unit is the console. */\n\t\tzst->zst_swflags |= TIOCFLAG_SOFTCAR;\n\t\t/* Call _param so interrupts get enabled. */\n\t\tcs->cs_defspeed = zs_getspeed(cs);\n\t\ttp->t_ispeed = cs->cs_defspeed;\n\t\ttp->t_ospeed = cs->cs_defspeed;\n\t\ttp->t_cflag = ZSTTY_DEF_CFLAG;\n\t\t(void) zsparam(tp, &tp->t_termios);\n\t} else {\n\t\t/* Not the console; may need reset. */\n\t\tint reset, s;\n\t\treset = (channel == 0) ?\n\t\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\t\ts = splzs();\n\t\tzs_write_reg(cs, 9, reset);\n\t\tsplx(s);\n\t}\n\n\t/*\n\t * Initialize state of modem control lines (DTR).\n\t * If softcar is set, turn on DTR now and leave it.\n\t * otherwise, turn off DTR now, and raise in open.\n\t * (Keeps modem from answering too early.)\n\t */\n\tzs_modem(zst, (zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0);\n}"
  },
  {
    "function_name": "zstty_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
    "lines": "191-208",
    "snippet": "int \nzstty_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid   *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct zsc_attach_args *args = aux;\n\n\t/* Exact match is better than wildcard. */\n\tif (cf->cf_loc[0] == args->channel)\n\t\treturn 2;\n\n\t/* This driver accepts wildcard. */\n\tif (cf->cf_loc[0] == -1)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tzstty_match(struct device *, void *, void *);",
      "static void\tzstty_attach(struct device *, struct device *, void *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\tzstty_match(struct device *, void *, void *);\nstatic void\tzstty_attach(struct device *, struct device *, void *);\n\nint \nzstty_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid   *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct zsc_attach_args *args = aux;\n\n\t/* Exact match is better than wildcard. */\n\tif (cf->cf_loc[0] == args->channel)\n\t\treturn 2;\n\n\t/* This driver accepts wildcard. */\n\tif (cf->cf_loc[0] == -1)\n\t\treturn 1;\n\n\treturn 0;\n}"
  }
]