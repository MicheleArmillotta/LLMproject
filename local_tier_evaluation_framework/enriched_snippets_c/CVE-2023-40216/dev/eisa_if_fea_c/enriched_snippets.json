[
  {
    "function_name": "pdq_eisa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/if_fea.c",
    "lines": "154-242",
    "snippet": "void\npdq_eisa_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tpdq_softc_t *sc = (pdq_softc_t *) self;\n\tstruct eisa_attach_args *ea = (struct eisa_attach_args *) aux;\n\tu_int32_t irq, maddr, msize;\n\teisa_intr_handle_t ih;\n\tconst char *intrstr;\n\n\tsc->sc_iotag = ea->ea_iot;\n\tbcopy(sc->sc_dev.dv_xname, sc->sc_if.if_xname, IFNAMSIZ);\n\tsc->sc_if.if_flags = 0;\n\tsc->sc_if.if_softc = sc;\n\n\t/*\n\t * NOTE: sc_bc is an alias for sc_csrtag and sc_membase is\n\t * an alias for sc_csrhandle.  sc_iobase is used here to\n\t * check the card's configuration.\n\t */\n\n\tif (bus_space_map(sc->sc_iotag, EISA_SLOT_ADDR(ea->ea_slot),\n\t    EISA_SLOT_SIZE, 0, &sc->sc_iobase)) {\n\t\tprintf(\"\\n%s: failed to map I/O!\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tpdq_eisa_subprobe(sc->sc_iotag, sc->sc_iobase, &maddr, &msize, &irq);\n\n#if defined(PDQ_IOMAPPED)\n\tsc->sc_csrtag = sc->sc_iotag;\n\tsc->sc_csrhandle = sc->sc_iobase;\n#else\n\tif (maddr == 0 || msize == 0) {\n\t\tprintf(\"\\n%s: error: memory not enabled! ECU reconfiguration\"\n\t\t    \" required\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (bus_space_map(sc->sc_csrtag, maddr, msize, 0, &sc->sc_csrhandle)) {\n\t\tbus_space_unmap(sc->sc_iotag, sc->sc_iobase, EISA_SLOT_SIZE);\n\t\tprintf(\"\\n%s: failed to map memory (0x%x-0x%x)!\\n\",\n\t\t    sc->sc_dev.dv_xname, maddr, maddr + msize - 1);\n\t\treturn;\n\t}\n#endif\n\tpdq_eisa_devinit(sc);\n\tsc->sc_pdq = pdq_initialize(sc->sc_bc, sc->sc_membase,\n\t    sc->sc_if.if_xname, 0, (void *) sc, PDQ_DEFEA);\n\tif (sc->sc_pdq == NULL) {\n\t\tprintf(\"%s: initialization failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (eisa_intr_map(ea->ea_ec, irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, irq);\n\t\treturn;\n\t}\n\tintrstr = eisa_intr_string(ea->ea_ec, ih);\n\tsc->sc_ih = eisa_intr_establish(ea->ea_ec, ih, IST_LEVEL, IPL_NET,\n\t    (int (*)(void *)) pdq_interrupt, sc->sc_pdq, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\", sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\": interrupting at %s\\n\", sc->sc_dev.dv_xname, intrstr);\n\n\tbcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes,\n\t    sc->sc_ac.ac_enaddr, 6);\n\n\tpdq_ifattach(sc, NULL);\n\n\tsc->sc_ats = shutdownhook_establish((void (*)(void *)) pdq_hwreset,\n\t    sc->sc_pdq);\n\tif (sc->sc_ats == NULL)\n\t\tprintf(\"%s: warning: couldn't establish shutdown hook\\n\",\n\t\t    self->dv_xname);\n#if !defined(PDQ_IOMAPPED)\n\tprintf(\"%s: using iomem 0x%x-0x%x\\n\", sc->sc_dev.dv_xname, maddr,\n\t    maddr + msize - 1);\n#endif\n}",
    "includes": [
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <dev/ic/pdqreg.h>",
      "#include <dev/ic/pdqvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pdq_eisa_subprobe",
      "void pdq_eisa_devinit",
      "void pdq_eisa_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: using iomem 0x%x-0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "maddr",
            "maddr + msize - 1"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "(void (*)(void *)) pdq_hwreset",
            "sc->sc_pdq"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_ifattach",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_ifattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "358-383",
          "snippet": "void\npdq_ifattach(\n    pdq_softc_t *sc,\n    ifnet_ret_t (*ifwatchdog)(int unit))\n{\n    struct ifnet *ifp = &sc->sc_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n\n#if (defined(__FreeBSD__) && BSD >= 199506) || defined(__NetBSD__) || \\\n\tdefined(__OpenBSD__)\n    ifp->if_watchdog = pdq_ifwatchdog;\n#else\n    ifp->if_watchdog = ifwatchdog;\n#endif\n\n    ifp->if_ioctl = pdq_ifioctl;\n    ifp->if_output = fddi_output;\n    ifp->if_start = pdq_ifstart;\n  \n    if_attach(ifp);\n    fddi_ifattach(ifp);\n#if NBPFILTER > 0\n    PDQ_BPFATTACH(sc, DLT_FDDI, sizeof(struct fddi_header));\n#endif\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tIFF_NOTRAILERS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define\tIFF_NOTRAILERS\t0\n\nvoid\npdq_ifattach(\n    pdq_softc_t *sc,\n    ifnet_ret_t (*ifwatchdog)(int unit))\n{\n    struct ifnet *ifp = &sc->sc_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n\n#if (defined(__FreeBSD__) && BSD >= 199506) || defined(__NetBSD__) || \\\n\tdefined(__OpenBSD__)\n    ifp->if_watchdog = pdq_ifwatchdog;\n#else\n    ifp->if_watchdog = ifwatchdog;\n#endif\n\n    ifp->if_ioctl = pdq_ifioctl;\n    ifp->if_output = fddi_output;\n    ifp->if_start = pdq_ifstart;\n  \n    if_attach(ifp);\n    fddi_ifattach(ifp);\n#if NBPFILTER > 0\n    PDQ_BPFATTACH(sc, DLT_FDDI, sizeof(struct fddi_header));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes",
            "sc->sc_ac.ac_enaddr",
            "6"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "eisa_intr_establish",
          "args": [
            "ea->ea_ec",
            "ih",
            "IST_LEVEL",
            "IPL_NET",
            "(int (*)(void *)) pdq_interrupt",
            "sc->sc_pdq",
            "sc->sc_dev.dv_xname"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_string",
          "args": [
            "ea->ea_ec",
            "ih"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_map",
          "args": [
            "ea->ea_ec",
            "irq",
            "&ih"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_initialize",
          "args": [
            "sc->sc_bc",
            "sc->sc_membase",
            "sc->sc_if.if_xname",
            "0",
            "(void *) sc",
            "PDQ_DEFEA"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "1327-1575",
          "snippet": "pdq_t *\npdq_initialize(\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    const char *name,\n    int unit,\n    void *ctx,\n    pdq_type_t type)\n{\n    pdq_t *pdq;\n    pdq_state_t state;\n    const pdq_uint32_t contig_bytes = (sizeof(pdq_descriptor_block_t) * 2) - PDQ_OS_PAGESIZE;\n    pdq_uint8_t *p;\n    int idx;\n\n    PDQ_ASSERT(sizeof(pdq_descriptor_block_t) == 8192);\n    PDQ_ASSERT(sizeof(pdq_consumer_block_t) == 64);\n    PDQ_ASSERT(sizeof(pdq_response_filter_get_t) == PDQ_SIZE_RESPONSE_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_cmd_addr_filter_set_t) == PDQ_SIZE_CMD_ADDR_FILTER_SET);\n    PDQ_ASSERT(sizeof(pdq_response_addr_filter_get_t) == PDQ_SIZE_RESPONSE_ADDR_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_response_status_chars_get_t) == PDQ_SIZE_RESPONSE_STATUS_CHARS_GET);\n    PDQ_ASSERT(sizeof(pdq_response_fddi_mib_get_t) == PDQ_SIZE_RESPONSE_FDDI_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_response_dec_ext_mib_get_t) == PDQ_SIZE_RESPONSE_DEC_EXT_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_unsolicited_event_t) == 512);\n\n    pdq = (pdq_t *) PDQ_OS_MEMALLOC(sizeof(pdq_t));\n    if (pdq == NULL) {\n\tPDQ_PRINTF((\"malloc(%d) failed\\n\", sizeof(*pdq)));\n\treturn NULL;\n    }\n    PDQ_OS_MEMZERO(pdq, sizeof(pdq_t));\n    pdq->pdq_type = type;\n    pdq->pdq_unit = unit;\n    pdq->pdq_os_ctx = (void *) ctx;\n    pdq->pdq_os_name = name;\n    pdq->pdq_flags = PDQ_PRINTCHARS;\n    /*\n     * Allocate the additional data structures required by\n     * the PDQ driver.  Allocate a contiguous region of memory\n     * for the descriptor block.  We need to allocated enough\n     * to guarantee that we will a get 8KB block of memory aligned\n     * on a 8KB boundary.  This turns to require that we allocate\n     * (N*2 - 1 page) pages of memory.  On machine with less than\n     * a 8KB page size, it mean we will allocate more memory than\n     * we need.  The extra will be used for the unsolicited event\n     * buffers (though on machines with 8KB pages we will to allocate\n     * them separately since there will be nothing left overs.)\n     */\n    p = (pdq_uint8_t *) PDQ_OS_MEMALLOC_CONTIG(contig_bytes);\n    if (p != NULL) {\n\tpdq_physaddr_t physaddr = PDQ_OS_VA_TO_PA(pdq, p);\n\t/*\n\t * Assert that we really got contiguous memory.  This isn't really\n\t * needed on systems that actually have physical contiguous allocation\n\t * routines, but on those systems that don't ...\n\t */\n\tfor (idx = PDQ_OS_PAGESIZE; idx < 0x2000; idx += PDQ_OS_PAGESIZE) {\n\t    if (PDQ_OS_VA_TO_PA(pdq, p + idx) - physaddr != idx)\n\t\tgoto cleanup_and_return;\n\t}\n\tphysaddr &= 0x1FFF;\n\tif (physaddr) {\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) p;\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) &p[0x2000 - physaddr];\n\t} else {\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) p;\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) &p[0x2000];\n\t}\n    }\n    if (contig_bytes == sizeof(pdq_descriptor_block_t)) {\n\tpdq->pdq_unsolicited_info.ui_events =\n\t    (pdq_unsolicited_event_t *) PDQ_OS_MEMALLOC(\n\t\tPDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n    }\n\n    /*\n     * Make sure everything got allocated.  If not, free what did\n     * get allocated and return.\n     */\n    if (pdq->pdq_dbp == NULL || pdq->pdq_unsolicited_info.ui_events == NULL) {\n      cleanup_and_return:\n\tif (p /* pdq->pdq_dbp */ != NULL)\n\t    PDQ_OS_MEMFREE_CONTIG(p /* pdq->pdq_dbp */, contig_bytes);\n\tif (contig_bytes == sizeof(pdq_descriptor_block_t) && pdq->pdq_unsolicited_info.ui_events != NULL)\n\t    PDQ_OS_MEMFREE(pdq->pdq_unsolicited_info.ui_events,\n\t\t\t   PDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n\tPDQ_OS_MEMFREE(pdq, sizeof(pdq_t));\n\treturn NULL;\n    }\n\n    pdq->pdq_cbp = (volatile pdq_consumer_block_t *) &pdq->pdq_dbp->pdqdb_consumer;\n    pdq->pdq_command_info.ci_bufstart = (pdq_uint8_t *) pdq->pdq_dbp->pdqdb_command_pool;\n    pdq->pdq_rx_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_receive_buffers;\n\n    pdq->pdq_host_smt_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_host_smt_buffers;\n\n    PDQ_PRINTF((\"\\nPDQ Descriptor Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp));\n    PDQ_PRINTF((\"    Recieve Queue          = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_receives));\n    PDQ_PRINTF((\"    Transmit Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_transmits));\n    PDQ_PRINTF((\"    Host SMT Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_host_smt));\n    PDQ_PRINTF((\"    Command Response Queue = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_responses));\n    PDQ_PRINTF((\"    Command Request Queue  = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_requests));\n    PDQ_PRINTF((\"PDQ Consumer Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_cbp));\n\n    /*\n     * Zero out the descriptor block.  Not really required but\n     * it pays to be neat.  This will also zero out the consumer\n     * block, command pool, and buffer pointers for the receive\n     * host_smt rings.\n     */\n    PDQ_OS_MEMZERO(pdq->pdq_dbp, sizeof(*pdq->pdq_dbp));\n\n    /*\n     * Initialize the CSR references.\n     * the DEFAA (FutureBus+) skips a longword between registers\n     */\n    pdq_init_csrs(&pdq->pdq_csrs, bus, csr_base, pdq->pdq_type == PDQ_DEFAA ? 2 : 1);\n    if (pdq->pdq_type == PDQ_DEFPA)\n\tpdq_init_pci_csrs(&pdq->pdq_pci_csrs, bus, csr_base, 1);\n\n    PDQ_PRINTF((\"PDQ CSRs: BASE = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_csrs.csr_base));\n    PDQ_PRINTF((\"    Port Reset                = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_reset, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_reset)));\n    PDQ_PRINTF((\"    Host Data                 = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_data, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_data)));\n    PDQ_PRINTF((\"    Port Control              = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_control, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_control)));\n    PDQ_PRINTF((\"    Port Data A               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_a, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_a)));\n    PDQ_PRINTF((\"    Port Data B               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_b, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_b)));\n    PDQ_PRINTF((\"    Port Status               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_status, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status)));\n    PDQ_PRINTF((\"    Host Int Type 0           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_type_0, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0)));\n    PDQ_PRINTF((\"    Host Int Enable           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_enable, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_enable)));\n    PDQ_PRINTF((\"    Type 2 Producer           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_type_2_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_type_2_producer)));\n    PDQ_PRINTF((\"    Command Response Producer = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_response_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_response_producer)));\n    PDQ_PRINTF((\"    Command Request Producer  = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_request_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_request_producer)));\n    PDQ_PRINTF((\"    Host SMT Producer         = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_smt_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_smt_producer)));\n    PDQ_PRINTF((\"    Unsolicited Producer      = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_unsolicited_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_unsolicited_producer)));\n\n    /*\n     * Initialize the command information block\n     */\n    pdq->pdq_command_info.ci_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_command_info.ci_bufstart);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_requests)/sizeof(pdq->pdq_dbp->pdqdb_command_requests[0]); idx++) {\n\tpdq_txdesc_t *txd = &pdq->pdq_dbp->pdqdb_command_requests[idx];\n\n\ttxd->txd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\ttxd->txd_eop = txd->txd_sop = 1;\n\ttxd->txd_pa_hi = 0;\n    }\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_responses)/sizeof(pdq->pdq_dbp->pdqdb_command_responses[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_command_responses[idx];\n\n\trxd->rxd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_lo = 0;\n    }\n\n    /*\n     * Initialize the unsolicited event information block\n     */\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_unsolicited_info.ui_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_unsolicited_info.ui_events);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events)/sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_unsolicited_events[idx];\n\tpdq_unsolicited_event_t *event = &pdq->pdq_unsolicited_info.ui_events[idx & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_hi = sizeof(pdq_unsolicited_event_t) / 16;\n\trxd->rxd_pa_lo = pdq->pdq_unsolicited_info.ui_pa_bufstart + (const pdq_uint8_t *) event\n\t    - (const pdq_uint8_t *) pdq->pdq_unsolicited_info.ui_events;\n\trxd->rxd_pa_hi = 0;\n    }\n    /*\n     * Initialize the receive information blocks (normal and SMT).\n     */\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    pdq->pdq_rx_info.rx_target = pdq->pdq_rx_info.rx_free - PDQ_RX_SEGCNT * 8;\n\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n    pdq->pdq_host_smt_info.rx_target = pdq->pdq_host_smt_info.rx_free - PDQ_RX_SEGCNT * 3;\n\n    /*\n     * Initialize the transmit information block.\n     */\n    pdq->pdq_tx_hdr[0] = PDQ_FDDI_PH0;\n    pdq->pdq_tx_hdr[1] = PDQ_FDDI_PH1;\n    pdq->pdq_tx_hdr[2] = PDQ_FDDI_PH2;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_seg_len = sizeof(pdq->pdq_tx_hdr);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_sop = 1;\n    pdq->pdq_tx_info.tx_hdrdesc.txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_tx_hdr);\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n\n    /*\n     * Stop the PDQ if it is running and put it into a known state.\n     */\n    state = pdq_stop(pdq);\n\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    /*\n     * If the adapter is not the state we expect, then the initialization\n     * failed.  Cleanup and exit.\n     */\n#if defined(PDQVERBOSE)\n    if (state == PDQS_HALTED) {\n\tpdq_halt_code_t halt_code = PDQ_PSTS_HALT_ID(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n\tprintf(\"Halt code = %d (%s)\\n\", halt_code, pdq_halt_codes[halt_code]);\n\tif (halt_code == PDQH_DMA_ERROR && pdq->pdq_type == PDQ_DEFPA)\n\t    PDQ_PRINTF((\"PFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t       PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0) & PDQ_HOST_INT_FATAL_ERROR));\n    }\n#endif\n    if (state == PDQS_RESET || state == PDQS_HALTED || state == PDQS_UPGRADE)\n\tgoto cleanup_and_return;\n\n    PDQ_PRINTF((\"PDQ Hardware Address = %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n\t   pdq->pdq_hwaddr.lanaddr_bytes[0], pdq->pdq_hwaddr.lanaddr_bytes[1],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[2], pdq->pdq_hwaddr.lanaddr_bytes[3],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[4], pdq->pdq_hwaddr.lanaddr_bytes[5]));\n    PDQ_PRINTF((\"PDQ Firmware Revision = %c%c%c%c\\n\",\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3]));\n    PDQ_PRINTF((\"PDQ Chip Revision = \"));\n    switch (pdq->pdq_chip_rev) {\n\tcase PDQ_CHIP_REV_A_B_OR_C: PDQ_PRINTF((\"Rev C or below\")); break;\n\tcase PDQ_CHIP_REV_D: PDQ_PRINTF((\"Rev D\")); break;\n\tcase PDQ_CHIP_REV_E: PDQ_PRINTF((\"Rev E\")); break;\n\tdefault: PDQ_PRINTF((\"Unknown Rev %d\", (int) pdq->pdq_chip_rev));\n    }\n    PDQ_PRINTF((\"\\n\"));\n\n    return pdq;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const pdq_halt_codes[] = {\n    \"Selftest Timeout\", \"Host Bus Parity Error\", \"Host Directed Fault\",\n    \"Software Fault\", \"Hardware Fault\", \"PC Trace Path Test\",\n    \"DMA Error\", \"Image CRC Error\", \"Adapter Processer Error\"\n};",
            "static const char * const pdq_adapter_states[] = {\n    \"Reset\", \"Upgrade\", \"DMA Unavailable\", \"DMA Available\",\n    \"Link Available\", \"Link Unavailable\", \"Halted\", \"Ring Member\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_halt_codes[] = {\n    \"Selftest Timeout\", \"Host Bus Parity Error\", \"Host Directed Fault\",\n    \"Software Fault\", \"Hardware Fault\", \"PC Trace Path Test\",\n    \"DMA Error\", \"Image CRC Error\", \"Adapter Processer Error\"\n};\nstatic const char * const pdq_adapter_states[] = {\n    \"Reset\", \"Upgrade\", \"DMA Unavailable\", \"DMA Available\",\n    \"Link Available\", \"Link Unavailable\", \"Halted\", \"Ring Member\"\n};\n\npdq_t *\npdq_initialize(\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    const char *name,\n    int unit,\n    void *ctx,\n    pdq_type_t type)\n{\n    pdq_t *pdq;\n    pdq_state_t state;\n    const pdq_uint32_t contig_bytes = (sizeof(pdq_descriptor_block_t) * 2) - PDQ_OS_PAGESIZE;\n    pdq_uint8_t *p;\n    int idx;\n\n    PDQ_ASSERT(sizeof(pdq_descriptor_block_t) == 8192);\n    PDQ_ASSERT(sizeof(pdq_consumer_block_t) == 64);\n    PDQ_ASSERT(sizeof(pdq_response_filter_get_t) == PDQ_SIZE_RESPONSE_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_cmd_addr_filter_set_t) == PDQ_SIZE_CMD_ADDR_FILTER_SET);\n    PDQ_ASSERT(sizeof(pdq_response_addr_filter_get_t) == PDQ_SIZE_RESPONSE_ADDR_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_response_status_chars_get_t) == PDQ_SIZE_RESPONSE_STATUS_CHARS_GET);\n    PDQ_ASSERT(sizeof(pdq_response_fddi_mib_get_t) == PDQ_SIZE_RESPONSE_FDDI_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_response_dec_ext_mib_get_t) == PDQ_SIZE_RESPONSE_DEC_EXT_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_unsolicited_event_t) == 512);\n\n    pdq = (pdq_t *) PDQ_OS_MEMALLOC(sizeof(pdq_t));\n    if (pdq == NULL) {\n\tPDQ_PRINTF((\"malloc(%d) failed\\n\", sizeof(*pdq)));\n\treturn NULL;\n    }\n    PDQ_OS_MEMZERO(pdq, sizeof(pdq_t));\n    pdq->pdq_type = type;\n    pdq->pdq_unit = unit;\n    pdq->pdq_os_ctx = (void *) ctx;\n    pdq->pdq_os_name = name;\n    pdq->pdq_flags = PDQ_PRINTCHARS;\n    /*\n     * Allocate the additional data structures required by\n     * the PDQ driver.  Allocate a contiguous region of memory\n     * for the descriptor block.  We need to allocated enough\n     * to guarantee that we will a get 8KB block of memory aligned\n     * on a 8KB boundary.  This turns to require that we allocate\n     * (N*2 - 1 page) pages of memory.  On machine with less than\n     * a 8KB page size, it mean we will allocate more memory than\n     * we need.  The extra will be used for the unsolicited event\n     * buffers (though on machines with 8KB pages we will to allocate\n     * them separately since there will be nothing left overs.)\n     */\n    p = (pdq_uint8_t *) PDQ_OS_MEMALLOC_CONTIG(contig_bytes);\n    if (p != NULL) {\n\tpdq_physaddr_t physaddr = PDQ_OS_VA_TO_PA(pdq, p);\n\t/*\n\t * Assert that we really got contiguous memory.  This isn't really\n\t * needed on systems that actually have physical contiguous allocation\n\t * routines, but on those systems that don't ...\n\t */\n\tfor (idx = PDQ_OS_PAGESIZE; idx < 0x2000; idx += PDQ_OS_PAGESIZE) {\n\t    if (PDQ_OS_VA_TO_PA(pdq, p + idx) - physaddr != idx)\n\t\tgoto cleanup_and_return;\n\t}\n\tphysaddr &= 0x1FFF;\n\tif (physaddr) {\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) p;\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) &p[0x2000 - physaddr];\n\t} else {\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) p;\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) &p[0x2000];\n\t}\n    }\n    if (contig_bytes == sizeof(pdq_descriptor_block_t)) {\n\tpdq->pdq_unsolicited_info.ui_events =\n\t    (pdq_unsolicited_event_t *) PDQ_OS_MEMALLOC(\n\t\tPDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n    }\n\n    /*\n     * Make sure everything got allocated.  If not, free what did\n     * get allocated and return.\n     */\n    if (pdq->pdq_dbp == NULL || pdq->pdq_unsolicited_info.ui_events == NULL) {\n      cleanup_and_return:\n\tif (p /* pdq->pdq_dbp */ != NULL)\n\t    PDQ_OS_MEMFREE_CONTIG(p /* pdq->pdq_dbp */, contig_bytes);\n\tif (contig_bytes == sizeof(pdq_descriptor_block_t) && pdq->pdq_unsolicited_info.ui_events != NULL)\n\t    PDQ_OS_MEMFREE(pdq->pdq_unsolicited_info.ui_events,\n\t\t\t   PDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n\tPDQ_OS_MEMFREE(pdq, sizeof(pdq_t));\n\treturn NULL;\n    }\n\n    pdq->pdq_cbp = (volatile pdq_consumer_block_t *) &pdq->pdq_dbp->pdqdb_consumer;\n    pdq->pdq_command_info.ci_bufstart = (pdq_uint8_t *) pdq->pdq_dbp->pdqdb_command_pool;\n    pdq->pdq_rx_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_receive_buffers;\n\n    pdq->pdq_host_smt_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_host_smt_buffers;\n\n    PDQ_PRINTF((\"\\nPDQ Descriptor Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp));\n    PDQ_PRINTF((\"    Recieve Queue          = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_receives));\n    PDQ_PRINTF((\"    Transmit Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_transmits));\n    PDQ_PRINTF((\"    Host SMT Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_host_smt));\n    PDQ_PRINTF((\"    Command Response Queue = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_responses));\n    PDQ_PRINTF((\"    Command Request Queue  = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_requests));\n    PDQ_PRINTF((\"PDQ Consumer Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_cbp));\n\n    /*\n     * Zero out the descriptor block.  Not really required but\n     * it pays to be neat.  This will also zero out the consumer\n     * block, command pool, and buffer pointers for the receive\n     * host_smt rings.\n     */\n    PDQ_OS_MEMZERO(pdq->pdq_dbp, sizeof(*pdq->pdq_dbp));\n\n    /*\n     * Initialize the CSR references.\n     * the DEFAA (FutureBus+) skips a longword between registers\n     */\n    pdq_init_csrs(&pdq->pdq_csrs, bus, csr_base, pdq->pdq_type == PDQ_DEFAA ? 2 : 1);\n    if (pdq->pdq_type == PDQ_DEFPA)\n\tpdq_init_pci_csrs(&pdq->pdq_pci_csrs, bus, csr_base, 1);\n\n    PDQ_PRINTF((\"PDQ CSRs: BASE = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_csrs.csr_base));\n    PDQ_PRINTF((\"    Port Reset                = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_reset, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_reset)));\n    PDQ_PRINTF((\"    Host Data                 = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_data, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_data)));\n    PDQ_PRINTF((\"    Port Control              = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_control, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_control)));\n    PDQ_PRINTF((\"    Port Data A               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_a, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_a)));\n    PDQ_PRINTF((\"    Port Data B               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_b, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_b)));\n    PDQ_PRINTF((\"    Port Status               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_status, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status)));\n    PDQ_PRINTF((\"    Host Int Type 0           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_type_0, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0)));\n    PDQ_PRINTF((\"    Host Int Enable           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_enable, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_enable)));\n    PDQ_PRINTF((\"    Type 2 Producer           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_type_2_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_type_2_producer)));\n    PDQ_PRINTF((\"    Command Response Producer = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_response_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_response_producer)));\n    PDQ_PRINTF((\"    Command Request Producer  = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_request_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_request_producer)));\n    PDQ_PRINTF((\"    Host SMT Producer         = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_smt_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_smt_producer)));\n    PDQ_PRINTF((\"    Unsolicited Producer      = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_unsolicited_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_unsolicited_producer)));\n\n    /*\n     * Initialize the command information block\n     */\n    pdq->pdq_command_info.ci_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_command_info.ci_bufstart);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_requests)/sizeof(pdq->pdq_dbp->pdqdb_command_requests[0]); idx++) {\n\tpdq_txdesc_t *txd = &pdq->pdq_dbp->pdqdb_command_requests[idx];\n\n\ttxd->txd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\ttxd->txd_eop = txd->txd_sop = 1;\n\ttxd->txd_pa_hi = 0;\n    }\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_responses)/sizeof(pdq->pdq_dbp->pdqdb_command_responses[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_command_responses[idx];\n\n\trxd->rxd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_lo = 0;\n    }\n\n    /*\n     * Initialize the unsolicited event information block\n     */\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_unsolicited_info.ui_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_unsolicited_info.ui_events);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events)/sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_unsolicited_events[idx];\n\tpdq_unsolicited_event_t *event = &pdq->pdq_unsolicited_info.ui_events[idx & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_hi = sizeof(pdq_unsolicited_event_t) / 16;\n\trxd->rxd_pa_lo = pdq->pdq_unsolicited_info.ui_pa_bufstart + (const pdq_uint8_t *) event\n\t    - (const pdq_uint8_t *) pdq->pdq_unsolicited_info.ui_events;\n\trxd->rxd_pa_hi = 0;\n    }\n    /*\n     * Initialize the receive information blocks (normal and SMT).\n     */\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    pdq->pdq_rx_info.rx_target = pdq->pdq_rx_info.rx_free - PDQ_RX_SEGCNT * 8;\n\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n    pdq->pdq_host_smt_info.rx_target = pdq->pdq_host_smt_info.rx_free - PDQ_RX_SEGCNT * 3;\n\n    /*\n     * Initialize the transmit information block.\n     */\n    pdq->pdq_tx_hdr[0] = PDQ_FDDI_PH0;\n    pdq->pdq_tx_hdr[1] = PDQ_FDDI_PH1;\n    pdq->pdq_tx_hdr[2] = PDQ_FDDI_PH2;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_seg_len = sizeof(pdq->pdq_tx_hdr);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_sop = 1;\n    pdq->pdq_tx_info.tx_hdrdesc.txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_tx_hdr);\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n\n    /*\n     * Stop the PDQ if it is running and put it into a known state.\n     */\n    state = pdq_stop(pdq);\n\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    /*\n     * If the adapter is not the state we expect, then the initialization\n     * failed.  Cleanup and exit.\n     */\n#if defined(PDQVERBOSE)\n    if (state == PDQS_HALTED) {\n\tpdq_halt_code_t halt_code = PDQ_PSTS_HALT_ID(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n\tprintf(\"Halt code = %d (%s)\\n\", halt_code, pdq_halt_codes[halt_code]);\n\tif (halt_code == PDQH_DMA_ERROR && pdq->pdq_type == PDQ_DEFPA)\n\t    PDQ_PRINTF((\"PFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t       PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0) & PDQ_HOST_INT_FATAL_ERROR));\n    }\n#endif\n    if (state == PDQS_RESET || state == PDQS_HALTED || state == PDQS_UPGRADE)\n\tgoto cleanup_and_return;\n\n    PDQ_PRINTF((\"PDQ Hardware Address = %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n\t   pdq->pdq_hwaddr.lanaddr_bytes[0], pdq->pdq_hwaddr.lanaddr_bytes[1],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[2], pdq->pdq_hwaddr.lanaddr_bytes[3],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[4], pdq->pdq_hwaddr.lanaddr_bytes[5]));\n    PDQ_PRINTF((\"PDQ Firmware Revision = %c%c%c%c\\n\",\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3]));\n    PDQ_PRINTF((\"PDQ Chip Revision = \"));\n    switch (pdq->pdq_chip_rev) {\n\tcase PDQ_CHIP_REV_A_B_OR_C: PDQ_PRINTF((\"Rev C or below\")); break;\n\tcase PDQ_CHIP_REV_D: PDQ_PRINTF((\"Rev D\")); break;\n\tcase PDQ_CHIP_REV_E: PDQ_PRINTF((\"Rev E\")); break;\n\tdefault: PDQ_PRINTF((\"Unknown Rev %d\", (int) pdq->pdq_chip_rev));\n    }\n    PDQ_PRINTF((\"\\n\"));\n\n    return pdq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_eisa_devinit",
          "args": [
            "sc"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_eisa_devinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/if_fea.c",
          "lines": "112-139",
          "snippet": "void\npdq_eisa_devinit(sc)\n\tpdq_softc_t *sc;\n{\n\tu_int8_t data;\n\tbus_space_tag_t tag;\n\n\ttag = sc->sc_bc;\n\n\t/*\n\t * Do the standard initialization for the DEFEA registers.\n\t */\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_FUNCTION_CTRL, 0x23);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_1_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_0_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_SLOT_CTRL, 0x01);\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF);\n#if defined(PDQ_IOMAPPED)\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data & ~1);\n#else\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data | 1);\n#endif\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0,\n\t    data | DEFEA_INTRENABLE);\n}",
          "includes": [
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <dev/ic/pdqreg.h>",
            "#include <dev/ic/pdqvar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tDEFEA_INTRENABLE\t\t0x8\t/* level interrupt */"
          ],
          "globals_used": [
            "void pdq_eisa_devinit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <dev/ic/pdqreg.h>\n#include <dev/ic/pdqvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <net/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define\tDEFEA_INTRENABLE\t\t0x8\t/* level interrupt */\n\nvoid pdq_eisa_devinit;\n\nvoid\npdq_eisa_devinit(sc)\n\tpdq_softc_t *sc;\n{\n\tu_int8_t data;\n\tbus_space_tag_t tag;\n\n\ttag = sc->sc_bc;\n\n\t/*\n\t * Do the standard initialization for the DEFEA registers.\n\t */\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_FUNCTION_CTRL, 0x23);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_1_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_0_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_SLOT_CTRL, 0x01);\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF);\n#if defined(PDQ_IOMAPPED)\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data & ~1);\n#else\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data | 1);\n#endif\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0,\n\t    data | DEFEA_INTRENABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iotag",
            "sc->sc_iobase",
            "EISA_SLOT_SIZE"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_csrtag",
            "maddr",
            "msize",
            "0",
            "&sc->sc_csrhandle"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_eisa_subprobe",
          "args": [
            "sc->sc_iotag",
            "sc->sc_iobase",
            "&maddr",
            "&msize",
            "&irq"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_eisa_subprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/if_fea.c",
          "lines": "95-110",
          "snippet": "void\npdq_eisa_subprobe(bc, iobase, maddr, msize, irq)\n\tbus_space_tag_t bc;\n\tbus_space_handle_t iobase;\n\tu_int32_t *maddr;\n\tu_int32_t *msize;\n\tu_int32_t *irq;\n{\n\tif (irq != NULL)\n\t\t*irq = pdq_eisa_irqs[PDQ_OS_IORD_8(bc, iobase,\n\t\t    PDQ_EISA_IO_CONFIG_STAT_0) & 3];\n\n\t*maddr = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_0) << 8)\n\t    | (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_1) << 16);\n\t*msize = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_MASK_0) + 4) << 8;\n}",
          "includes": [
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <dev/ic/pdqreg.h>",
            "#include <dev/ic/pdqvar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pdq_eisa_subprobe",
            "static int pdq_eisa_irqs[4] = { 9, 10, 11, 15 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <dev/ic/pdqreg.h>\n#include <dev/ic/pdqvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <net/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid pdq_eisa_subprobe;\nstatic int pdq_eisa_irqs[4] = { 9, 10, 11, 15 };\n\nvoid\npdq_eisa_subprobe(bc, iobase, maddr, msize, irq)\n\tbus_space_tag_t bc;\n\tbus_space_handle_t iobase;\n\tu_int32_t *maddr;\n\tu_int32_t *msize;\n\tu_int32_t *irq;\n{\n\tif (irq != NULL)\n\t\t*irq = pdq_eisa_irqs[PDQ_OS_IORD_8(bc, iobase,\n\t\t    PDQ_EISA_IO_CONFIG_STAT_0) & 3];\n\n\t*maddr = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_0) << 8)\n\t    | (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_1) << 16);\n\t*msize = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_MASK_0) + 4) << 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iotag",
            "EISA_SLOT_ADDR(ea->ea_slot)",
            "EISA_SLOT_SIZE",
            "0",
            "&sc->sc_iobase"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <dev/ic/pdqreg.h>\n#include <dev/ic/pdqvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <net/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid pdq_eisa_subprobe;\nvoid pdq_eisa_devinit;\nvoid pdq_eisa_attach;\n\nvoid\npdq_eisa_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tpdq_softc_t *sc = (pdq_softc_t *) self;\n\tstruct eisa_attach_args *ea = (struct eisa_attach_args *) aux;\n\tu_int32_t irq, maddr, msize;\n\teisa_intr_handle_t ih;\n\tconst char *intrstr;\n\n\tsc->sc_iotag = ea->ea_iot;\n\tbcopy(sc->sc_dev.dv_xname, sc->sc_if.if_xname, IFNAMSIZ);\n\tsc->sc_if.if_flags = 0;\n\tsc->sc_if.if_softc = sc;\n\n\t/*\n\t * NOTE: sc_bc is an alias for sc_csrtag and sc_membase is\n\t * an alias for sc_csrhandle.  sc_iobase is used here to\n\t * check the card's configuration.\n\t */\n\n\tif (bus_space_map(sc->sc_iotag, EISA_SLOT_ADDR(ea->ea_slot),\n\t    EISA_SLOT_SIZE, 0, &sc->sc_iobase)) {\n\t\tprintf(\"\\n%s: failed to map I/O!\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tpdq_eisa_subprobe(sc->sc_iotag, sc->sc_iobase, &maddr, &msize, &irq);\n\n#if defined(PDQ_IOMAPPED)\n\tsc->sc_csrtag = sc->sc_iotag;\n\tsc->sc_csrhandle = sc->sc_iobase;\n#else\n\tif (maddr == 0 || msize == 0) {\n\t\tprintf(\"\\n%s: error: memory not enabled! ECU reconfiguration\"\n\t\t    \" required\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (bus_space_map(sc->sc_csrtag, maddr, msize, 0, &sc->sc_csrhandle)) {\n\t\tbus_space_unmap(sc->sc_iotag, sc->sc_iobase, EISA_SLOT_SIZE);\n\t\tprintf(\"\\n%s: failed to map memory (0x%x-0x%x)!\\n\",\n\t\t    sc->sc_dev.dv_xname, maddr, maddr + msize - 1);\n\t\treturn;\n\t}\n#endif\n\tpdq_eisa_devinit(sc);\n\tsc->sc_pdq = pdq_initialize(sc->sc_bc, sc->sc_membase,\n\t    sc->sc_if.if_xname, 0, (void *) sc, PDQ_DEFEA);\n\tif (sc->sc_pdq == NULL) {\n\t\tprintf(\"%s: initialization failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (eisa_intr_map(ea->ea_ec, irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, irq);\n\t\treturn;\n\t}\n\tintrstr = eisa_intr_string(ea->ea_ec, ih);\n\tsc->sc_ih = eisa_intr_establish(ea->ea_ec, ih, IST_LEVEL, IPL_NET,\n\t    (int (*)(void *)) pdq_interrupt, sc->sc_pdq, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\", sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\": interrupting at %s\\n\", sc->sc_dev.dv_xname, intrstr);\n\n\tbcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes,\n\t    sc->sc_ac.ac_enaddr, 6);\n\n\tpdq_ifattach(sc, NULL);\n\n\tsc->sc_ats = shutdownhook_establish((void (*)(void *)) pdq_hwreset,\n\t    sc->sc_pdq);\n\tif (sc->sc_ats == NULL)\n\t\tprintf(\"%s: warning: couldn't establish shutdown hook\\n\",\n\t\t    self->dv_xname);\n#if !defined(PDQ_IOMAPPED)\n\tprintf(\"%s: using iomem 0x%x-0x%x\\n\", sc->sc_dev.dv_xname, maddr,\n\t    maddr + msize - 1);\n#endif\n}"
  },
  {
    "function_name": "pdq_eisa_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/if_fea.c",
    "lines": "141-152",
    "snippet": "int\npdq_eisa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea = (struct eisa_attach_args *) aux;\n\n\tif (strncmp(ea->ea_idstring, \"DEC300\", 6) == 0)\n\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <dev/ic/pdqreg.h>",
      "#include <dev/ic/pdqvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pdq_eisa_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ea->ea_idstring",
            "\"DEC300\"",
            "6"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <dev/ic/pdqreg.h>\n#include <dev/ic/pdqvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <net/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nint pdq_eisa_match;\n\nint\npdq_eisa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea = (struct eisa_attach_args *) aux;\n\n\tif (strncmp(ea->ea_idstring, \"DEC300\", 6) == 0)\n\t\treturn (1);\n\treturn (0);\n}"
  },
  {
    "function_name": "pdq_eisa_devinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/if_fea.c",
    "lines": "112-139",
    "snippet": "void\npdq_eisa_devinit(sc)\n\tpdq_softc_t *sc;\n{\n\tu_int8_t data;\n\tbus_space_tag_t tag;\n\n\ttag = sc->sc_bc;\n\n\t/*\n\t * Do the standard initialization for the DEFEA registers.\n\t */\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_FUNCTION_CTRL, 0x23);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_1_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_0_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_SLOT_CTRL, 0x01);\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF);\n#if defined(PDQ_IOMAPPED)\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data & ~1);\n#else\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data | 1);\n#endif\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0,\n\t    data | DEFEA_INTRENABLE);\n}",
    "includes": [
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <dev/ic/pdqreg.h>",
      "#include <dev/ic/pdqvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tDEFEA_INTRENABLE\t\t0x8\t/* level interrupt */"
    ],
    "globals_used": [
      "void pdq_eisa_devinit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_OS_IOWR_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_IO_CONFIG_STAT_0",
            "data | DEFEA_INTRENABLE"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IORD_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_IO_CONFIG_STAT_0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IOWR_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_BURST_HOLDOFF",
            "data | 1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IOWR_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_BURST_HOLDOFF",
            "data & ~1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IORD_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_BURST_HOLDOFF"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IOWR_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_SLOT_CTRL",
            "0x01"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IOWR_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_IO_CMP_0_1",
            "(sc->sc_iobase >> 8) & 0xF0"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IOWR_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_IO_CMP_1_1",
            "(sc->sc_iobase >> 8) & 0xF0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IOWR_8",
          "args": [
            "tag",
            "sc->sc_iobase",
            "PDQ_EISA_FUNCTION_CTRL",
            "0x23"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <dev/ic/pdqreg.h>\n#include <dev/ic/pdqvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <net/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define\tDEFEA_INTRENABLE\t\t0x8\t/* level interrupt */\n\nvoid pdq_eisa_devinit;\n\nvoid\npdq_eisa_devinit(sc)\n\tpdq_softc_t *sc;\n{\n\tu_int8_t data;\n\tbus_space_tag_t tag;\n\n\ttag = sc->sc_bc;\n\n\t/*\n\t * Do the standard initialization for the DEFEA registers.\n\t */\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_FUNCTION_CTRL, 0x23);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_1_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_0_1,\n\t    (sc->sc_iobase >> 8) & 0xF0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_SLOT_CTRL, 0x01);\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF);\n#if defined(PDQ_IOMAPPED)\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data & ~1);\n#else\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data | 1);\n#endif\n\tdata = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0);\n\tPDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0,\n\t    data | DEFEA_INTRENABLE);\n}"
  },
  {
    "function_name": "pdq_eisa_subprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/if_fea.c",
    "lines": "95-110",
    "snippet": "void\npdq_eisa_subprobe(bc, iobase, maddr, msize, irq)\n\tbus_space_tag_t bc;\n\tbus_space_handle_t iobase;\n\tu_int32_t *maddr;\n\tu_int32_t *msize;\n\tu_int32_t *irq;\n{\n\tif (irq != NULL)\n\t\t*irq = pdq_eisa_irqs[PDQ_OS_IORD_8(bc, iobase,\n\t\t    PDQ_EISA_IO_CONFIG_STAT_0) & 3];\n\n\t*maddr = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_0) << 8)\n\t    | (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_1) << 16);\n\t*msize = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_MASK_0) + 4) << 8;\n}",
    "includes": [
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <dev/ic/pdqreg.h>",
      "#include <dev/ic/pdqvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <net/if_fddi.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pdq_eisa_subprobe",
      "static int pdq_eisa_irqs[4] = { 9, 10, 11, 15 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_OS_IORD_8",
          "args": [
            "bc",
            "iobase",
            "PDQ_EISA_MEM_ADD_MASK_0"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IORD_8",
          "args": [
            "bc",
            "iobase",
            "PDQ_EISA_MEM_ADD_CMP_1"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IORD_8",
          "args": [
            "bc",
            "iobase",
            "PDQ_EISA_MEM_ADD_CMP_0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_IORD_8",
          "args": [
            "bc",
            "iobase",
            "PDQ_EISA_IO_CONFIG_STAT_0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <dev/ic/pdqreg.h>\n#include <dev/ic/pdqvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <net/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid pdq_eisa_subprobe;\nstatic int pdq_eisa_irqs[4] = { 9, 10, 11, 15 };\n\nvoid\npdq_eisa_subprobe(bc, iobase, maddr, msize, irq)\n\tbus_space_tag_t bc;\n\tbus_space_handle_t iobase;\n\tu_int32_t *maddr;\n\tu_int32_t *msize;\n\tu_int32_t *irq;\n{\n\tif (irq != NULL)\n\t\t*irq = pdq_eisa_irqs[PDQ_OS_IORD_8(bc, iobase,\n\t\t    PDQ_EISA_IO_CONFIG_STAT_0) & 3];\n\n\t*maddr = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_0) << 8)\n\t    | (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_1) << 16);\n\t*msize = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_MASK_0) + 4) << 8;\n}"
  }
]