[
  {
    "function_name": "epic_init_rings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "1841-1886",
    "snippet": "int\nepic_init_rings(epic_softc_t * sc){\n\tint i;\n\n\tsc->cur_rx = sc->cur_tx = sc->dirty_tx = sc->pending_txs = 0;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct epic_rx_buffer *buf = sc->rx_buffer + i;\n\t\tstruct epic_rx_desc *desc = sc->rx_desc + i;\n\n\t\tdesc->status = 0;\t\t/* Owned by driver */\n\t\tdesc->next = vtophys( sc->rx_desc + ((i+1) & RX_RING_MASK) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_rx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! rx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tEPIC_MGETCLUSTER( buf->mbuf );\n\t\tif( NULL == buf->mbuf ) {\n\t\t\tepic_free_rings(sc);\n\t\t\treturn -1;\n\t\t}\n\t\tdesc->bufaddr = vtophys( mtod(buf->mbuf,caddr_t) );\n\n\t\tdesc->buflength = ETHER_MAX_FRAME_LEN;\n\t\tdesc->status = 0x8000;\t\t\t/* Give to EPIC */\n\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct epic_tx_buffer *buf = sc->tx_buffer + i;\n\t\tstruct epic_tx_desc *desc = sc->tx_desc + i;\n\n\t\tdesc->status = 0;\n\t\tdesc->next = vtophys( sc->tx_desc + ( (i+1) & TX_RING_MASK ) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_tx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! tx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tbuf->mbuf = NULL;\n\t\tdesc->bufaddr = vtophys( sc->tx_flist + i );\n\t\tif( (desc->bufaddr & 3) || ((desc->bufaddr & 0xFFF) + sizeof(struct epic_frag_list) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! frag_list is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "EPIC_FORMAT \": WARNING! frag_list is misbound or misaligned\\n\"",
            "EPIC_ARGS(sc)"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->tx_flist + i"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->tx_desc + ( (i+1) & TX_RING_MASK )"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(buf->mbuf,caddr_t)"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "buf->mbuf",
            "caddr_t"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_free_rings",
          "args": [
            "sc"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_MGETCLUSTER",
          "args": [
            "buf->mbuf"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->rx_desc + ((i+1) & RX_RING_MASK)"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint\nepic_init_rings(epic_softc_t * sc){\n\tint i;\n\n\tsc->cur_rx = sc->cur_tx = sc->dirty_tx = sc->pending_txs = 0;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct epic_rx_buffer *buf = sc->rx_buffer + i;\n\t\tstruct epic_rx_desc *desc = sc->rx_desc + i;\n\n\t\tdesc->status = 0;\t\t/* Owned by driver */\n\t\tdesc->next = vtophys( sc->rx_desc + ((i+1) & RX_RING_MASK) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_rx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! rx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tEPIC_MGETCLUSTER( buf->mbuf );\n\t\tif( NULL == buf->mbuf ) {\n\t\t\tepic_free_rings(sc);\n\t\t\treturn -1;\n\t\t}\n\t\tdesc->bufaddr = vtophys( mtod(buf->mbuf,caddr_t) );\n\n\t\tdesc->buflength = ETHER_MAX_FRAME_LEN;\n\t\tdesc->status = 0x8000;\t\t\t/* Give to EPIC */\n\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct epic_tx_buffer *buf = sc->tx_buffer + i;\n\t\tstruct epic_tx_desc *desc = sc->tx_desc + i;\n\n\t\tdesc->status = 0;\n\t\tdesc->next = vtophys( sc->tx_desc + ( (i+1) & TX_RING_MASK ) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_tx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! tx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tbuf->mbuf = NULL;\n\t\tdesc->bufaddr = vtophys( sc->tx_flist + i );\n\t\tif( (desc->bufaddr & 3) || ((desc->bufaddr & 0xFFF) + sizeof(struct epic_frag_list) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! frag_list is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "epic_set_mc_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "1636-1650",
    "snippet": "void\nepic_set_mc_table (\n    epic_softc_t * sc)\n{\n\tstruct ifnet *ifp = &sc->sc_if;\n\n\tif( ifp->if_flags & IFF_MULTICAST ){\n\t\tCSR_WRITE_4( sc, MC0, 0xFFFF );\n\t\tCSR_WRITE_4( sc, MC1, 0xFFFF );\n\t\tCSR_WRITE_4( sc, MC2, 0xFFFF );\n\t\tCSR_WRITE_4( sc, MC3, 0xFFFF );\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "MC3",
            "0xFFFF"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "MC2",
            "0xFFFF"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "MC1",
            "0xFFFF"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "MC0",
            "0xFFFF"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_set_mc_table (\n    epic_softc_t * sc)\n{\n\tstruct ifnet *ifp = &sc->sc_if;\n\n\tif( ifp->if_flags & IFF_MULTICAST ){\n\t\tCSR_WRITE_4( sc, MC0, 0xFFFF );\n\t\tCSR_WRITE_4( sc, MC1, 0xFFFF );\n\t\tCSR_WRITE_4( sc, MC2, 0xFFFF );\n\t\tCSR_WRITE_4( sc, MC3, 0xFFFF );\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "epic_set_tx_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "1617-1626",
    "snippet": "void\nepic_set_tx_mode (\n    epic_softc_t *sc )\n{\n\n    if( sc->txcon & TXCON_EARLY_TRANSMIT_ENABLE )\n\tCSR_WRITE_4( sc, ETXTHR, sc->tx_threshold );\n\n    CSR_WRITE_4( sc, TXCON, sc->txcon );\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TXCON",
            "sc->txcon"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "ETXTHR",
            "sc->tx_threshold"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_set_tx_mode (\n    epic_softc_t *sc )\n{\n\n    if( sc->txcon & TXCON_EARLY_TRANSMIT_ENABLE )\n\tCSR_WRITE_4( sc, ETXTHR, sc->tx_threshold );\n\n    CSR_WRITE_4( sc, TXCON, sc->txcon );\n}"
  },
  {
    "function_name": "epic_autoneg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "1543-1613",
    "snippet": "int \nepic_autoneg(\n    epic_softc_t * sc)\n{\n\tu_int16_t media;\n\tu_int16_t i;\n\n        /* BMSR must be read twice to update the link status bit\n\t * since that bit is a latch bit\n         */\n\tPHY_READ_2( sc, DP83840_BMSR);\n\ti = PHY_READ_2( sc, DP83840_BMSR);\n        \n        if ((i & BMSR_LINK_STATUS) && (i & BMSR_AUTONEG_COMPLETE)){\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\n\t\tif ( i & (ANAR_100_TX_FD|ANAR_10_FD) )\n\t\t\treturn \tEPIC_FULL_DUPLEX;\n\t\telse\n\t\t\treturn EPIC_HALF_DUPLEX;\n        } else {   \n\t\t/*Auto-negotiation or link status is not 1\n\t\t  Thus the auto-negotiation failed and one\n\t\t  must take other means to fix it.\n\t\t */\n\n\t\t/* ANER must be read twice to get the correct reading for the \n\t\t * Multiple link fault bit -- it is a latched bit\n\t \t */\n \t\tPHY_READ_2( sc, DP83840_ANER );\n\t\ti = PHY_READ_2( sc, DP83840_ANER );\n\t\n\t\tif ( i & ANER_MULTIPLE_LINK_FAULT ) {\n\t\t\t/* it can be forced to 100Mb/s Half-Duplex */\n\t \t\tmedia = PHY_READ_2( sc, DP83840_BMCR );\n\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX);\n\t\t\tmedia |= BMCR_100MBPS;\n\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media );\n\t\t\n\t\t\t/* read BMSR again to determine link status */\n\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\ti=PHY_READ_2( sc, DP83840_BMSR );\n\t\t\n\t\t\tif (i & BMSR_LINK_STATUS){\n\t\t\t\t/* port is linked to the non Auto-Negotiation\n\t\t\t\t * 100Mbs partner.\n\t\t\t \t */\n\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmedia = PHY_READ_2( sc, DP83840_BMCR);\n\t\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX | BMCR_100MBPS);\n\t\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media);\n\t\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\t\ti = PHY_READ_2( sc, DP83840_BMSR );\n\n\t\t\t\tif (i & BMSR_LINK_STATUS) {\n\t\t\t\t\t/*port is linked to the non\n\t\t\t\t\t * Auto-Negotiation10Mbs partner\n\t\t\t \t \t */\n\t\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* If we get here we are most likely not connected\n\t\t * so lets default it to half duplex\n\t\t */\n\t\treturn EPIC_HALF_DUPLEX;\n\t}\n\t\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_WRITE_2",
          "args": [
            "sc",
            "DP83840_BMCR",
            "media"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMCR"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_WRITE_2",
          "args": [
            "sc",
            "DP83840_BMCR",
            "media"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMCR"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_ANER"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_ANER"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_LPAR"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint \nepic_autoneg(\n    epic_softc_t * sc)\n{\n\tu_int16_t media;\n\tu_int16_t i;\n\n        /* BMSR must be read twice to update the link status bit\n\t * since that bit is a latch bit\n         */\n\tPHY_READ_2( sc, DP83840_BMSR);\n\ti = PHY_READ_2( sc, DP83840_BMSR);\n        \n        if ((i & BMSR_LINK_STATUS) && (i & BMSR_AUTONEG_COMPLETE)){\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\n\t\tif ( i & (ANAR_100_TX_FD|ANAR_10_FD) )\n\t\t\treturn \tEPIC_FULL_DUPLEX;\n\t\telse\n\t\t\treturn EPIC_HALF_DUPLEX;\n        } else {   \n\t\t/*Auto-negotiation or link status is not 1\n\t\t  Thus the auto-negotiation failed and one\n\t\t  must take other means to fix it.\n\t\t */\n\n\t\t/* ANER must be read twice to get the correct reading for the \n\t\t * Multiple link fault bit -- it is a latched bit\n\t \t */\n \t\tPHY_READ_2( sc, DP83840_ANER );\n\t\ti = PHY_READ_2( sc, DP83840_ANER );\n\t\n\t\tif ( i & ANER_MULTIPLE_LINK_FAULT ) {\n\t\t\t/* it can be forced to 100Mb/s Half-Duplex */\n\t \t\tmedia = PHY_READ_2( sc, DP83840_BMCR );\n\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX);\n\t\t\tmedia |= BMCR_100MBPS;\n\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media );\n\t\t\n\t\t\t/* read BMSR again to determine link status */\n\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\ti=PHY_READ_2( sc, DP83840_BMSR );\n\t\t\n\t\t\tif (i & BMSR_LINK_STATUS){\n\t\t\t\t/* port is linked to the non Auto-Negotiation\n\t\t\t\t * 100Mbs partner.\n\t\t\t \t */\n\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmedia = PHY_READ_2( sc, DP83840_BMCR);\n\t\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX | BMCR_100MBPS);\n\t\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media);\n\t\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\t\ti = PHY_READ_2( sc, DP83840_BMSR );\n\n\t\t\t\tif (i & BMSR_LINK_STATUS) {\n\t\t\t\t\t/*port is linked to the non\n\t\t\t\t\t * Auto-Negotiation10Mbs partner\n\t\t\t \t \t */\n\t\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* If we get here we are most likely not connected\n\t\t * so lets default it to half duplex\n\t\t */\n\t\treturn EPIC_HALF_DUPLEX;\n\t}\n\t\n}"
  },
  {
    "function_name": "epic_dump_phy_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "1382-1395",
    "snippet": "void\nepic_dump_phy_regs(epic_softc_t *sc)\n{\n\n\tprintf(\"BMCR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_BMCR));\n\tprintf(\"BMSR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_BMSR));\n\tprintf(\"ANAR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_ANAR));\n\tprintf(\"LPAR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_LPAR));\n\tprintf(\"ANER: 0x%04x\\n\", PHY_READ_2(sc, DP83840_ANER));\n\tprintf(\"MCTL: 0x%04x\\n\", PHY_READ_2(sc, QS6612_MCTL));\n\tprintf(\"INTSTAT: 0x%04x\\n\", PHY_READ_2(sc, QS6612_INTSTAT));\n\tprintf(\"INTMASK: 0x%04x\\n\", PHY_READ_2(sc, QS6612_INTMASK));\n\tprintf(\"BPCR: 0x%04x\\n\", PHY_READ_2(sc, QS6612_BPCR));\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"BPCR: 0x%04x\\n\"",
            "PHY_READ_2(sc, QS6612_BPCR)"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "QS6612_BPCR"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "QS6612_INTMASK"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "QS6612_INTSTAT"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "QS6612_MCTL"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_ANER"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_LPAR"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_ANAR"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMCR"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_dump_phy_regs(epic_softc_t *sc)\n{\n\n\tprintf(\"BMCR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_BMCR));\n\tprintf(\"BMSR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_BMSR));\n\tprintf(\"ANAR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_ANAR));\n\tprintf(\"LPAR: 0x%04x\\n\", PHY_READ_2(sc, DP83840_LPAR));\n\tprintf(\"ANER: 0x%04x\\n\", PHY_READ_2(sc, DP83840_ANER));\n\tprintf(\"MCTL: 0x%04x\\n\", PHY_READ_2(sc, QS6612_MCTL));\n\tprintf(\"INTSTAT: 0x%04x\\n\", PHY_READ_2(sc, QS6612_INTSTAT));\n\tprintf(\"INTMASK: 0x%04x\\n\", PHY_READ_2(sc, QS6612_INTMASK));\n\tprintf(\"BPCR: 0x%04x\\n\", PHY_READ_2(sc, QS6612_BPCR));\n}"
  },
  {
    "function_name": "epic_set_rx_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "1367-1379",
    "snippet": "void\nepic_set_rx_mode(\n    epic_softc_t * sc)\n{\n\tu_int32_t flags = sc->sc_if.if_flags;\n        u_int32_t rxcon = RXCON_DEFAULT | RXCON_RECEIVE_MULTICAST_FRAMES | RXCON_RECEIVE_BROADCAST_FRAMES;\n\n\trxcon |= (flags & IFF_PROMISC)?RXCON_PROMISCUOUS_MODE:0;\n\n\tCSR_WRITE_4( sc, RXCON, rxcon );\n\n\treturn;\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "RXCON",
            "rxcon"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_set_rx_mode(\n    epic_softc_t * sc)\n{\n\tu_int32_t flags = sc->sc_if.if_flags;\n        u_int32_t rxcon = RXCON_DEFAULT | RXCON_RECEIVE_MULTICAST_FRAMES | RXCON_RECEIVE_BROADCAST_FRAMES;\n\n\trxcon |= (flags & IFF_PROMISC)?RXCON_PROMISCUOUS_MODE:0;\n\n\tCSR_WRITE_4( sc, RXCON, rxcon );\n\n\treturn;\n}"
  },
  {
    "function_name": "epic_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "1044-1177",
    "snippet": "EPIC_INTR_RET_TYPE\nepic_intr (\n    void *arg)\n{\n    epic_softc_t * sc = (epic_softc_t *) arg;\n    int status,i=4;\n#if defined(__OpenBSD__)\n    int claimed = 0;\n#endif\n\n\n    while( i-- && ((status = CSR_READ_4(sc, INTSTAT)) & INTSTAT_INT_ACTV) ){\n#if defined(__OpenBSD__)\n\tclaimed = 1;\n#endif\n\tCSR_WRITE_4( sc, INTSTAT, status );\n\n\tif( status & (INTSTAT_RQE|INTSTAT_RCC|INTSTAT_OVW) ) {\n            epic_rx_done( sc );\n            if( status & (INTSTAT_RQE|INTSTAT_OVW) ){\n#if defined(EPIC_DEBUG)\n                if( status & INTSTAT_OVW ) \n                    printf(EPIC_FORMAT \": RX buffer overflow\\n\",EPIC_ARGS(sc));\n                if( status & INTSTAT_RQE ) \n                    printf(EPIC_FORMAT \": RX FIFO overflow\\n\",EPIC_ARGS(sc));\n                if( sc->sc_if.if_flags & IFF_DEBUG ) \n                    epic_dump_state(sc);\n#endif\n                if( !(CSR_READ_4( sc, COMMAND ) & COMMAND_RXQUEUED) )\n                    CSR_WRITE_4( sc, COMMAND, COMMAND_RXQUEUED );\n                sc->sc_if.if_ierrors++;\n            }\n        }\n\n        if( status & (INTSTAT_TXC|INTSTAT_TCC|INTSTAT_TQE) ) {\n            epic_tx_done( sc );\n\t    if(!(sc->sc_if.if_flags & IFF_OACTIVE) &&\n\t\tsc->sc_if.if_snd.ifq_head )\n\t\t    epic_ifstart( &sc->sc_if );\n\t}\n\n        if( (status & INTSTAT_GP2) && (QS6612_OUI == sc->phyid) ) {\n\t    u_int32_t phystatus = PHY_READ_2( sc, QS6612_INTSTAT );\n\n\t    if( phystatus & INTSTAT_AN_COMPLETE ) {\n\t\tu_int32_t bmcr;\n\t\tif( epic_autoneg(sc) == EPIC_FULL_DUPLEX ) {\n\t\t    dprintf((EPIC_FORMAT \": going fullduplex\\n\",EPIC_ARGS(sc)));\n\t\t    bmcr = BMCR_FULL_DUPLEX | PHY_READ_2( sc, DP83840_BMCR );\n\t\t    sc->txcon |= TXCON_FULL_DUPLEX;\n\t\t} else {\n\t\t    /* Default to half-duplex */\n\t\t    dprintf((EPIC_FORMAT \": going halfduplex\\n\",EPIC_ARGS(sc)));\n\t\t    bmcr = ~BMCR_FULL_DUPLEX & PHY_READ_2( sc, DP83840_BMCR );\n\t\t    sc->txcon &= ~TXCON_FULL_DUPLEX;\n\t\t}\n\n\t\t/* There is apparently QS6612 chip bug: */\n\t\t/* BMCR_FULL_DUPLEX flag is not updated by */\n\t\t/* autonegotiation process, so update it by hands */\n\t\t/* so we can rely on it in epic_ifmedia_status() */\n\t\tPHY_WRITE_2( sc, DP83840_BMCR, bmcr );\n\n\t\tepic_stop_activity(sc);\n\t\tepic_set_tx_mode(sc);\n\t\tepic_start_activity(sc);\n\t    }\n\n\t    PHY_READ_2(sc, DP83840_BMSR);\n\t    if( !(PHY_READ_2(sc, DP83840_BMSR) & BMSR_LINK_STATUS) ) {\n\t\tdprintf((EPIC_FORMAT \": WARNING! link down\\n\",EPIC_ARGS(sc)));\n\t\tsc->flags |= EPIC_LINK_DOWN;\n\t    } else {\n    \t\tdprintf((EPIC_FORMAT \": link up\\n\",EPIC_ARGS(sc)));\n\t\tsc->flags &= ~EPIC_LINK_DOWN;\n\t    }\n\n\t    /* We should clear GP2 int again after we clear it on PHY */\n\t    CSR_WRITE_4( sc, INTSTAT, INTSTAT_GP2 ); \n\t}\n\n\t/* Check for errors */\n\tif( status & (INTSTAT_FATAL|INTSTAT_PMA|INTSTAT_PTA|\n\t\t      INTSTAT_APE|INTSTAT_DPE|INTSTAT_TXU|INTSTAT_RXE) ){\n    \t    if( status & (INTSTAT_FATAL|INTSTAT_PMA|INTSTAT_PTA|\n\t\t\t  INTSTAT_APE|INTSTAT_DPE) ){\n\t\tprintf(EPIC_FORMAT \": PCI fatal error occured (%s%s%s%s)\\n\",\n    \t\t    EPIC_ARGS(sc),\n\t\t    (status&INTSTAT_PMA)?\"PMA\":\"\",\n\t\t    (status&INTSTAT_PTA)?\" PTA\":\"\",\n\t\t    (status&INTSTAT_APE)?\" APE\":\"\",\n\t\t    (status&INTSTAT_DPE)?\" DPE\":\"\"\n\t\t);\n\n\t\tepic_dump_state(sc);\n\n\t\tepic_stop(sc);\n\t\tepic_init(sc);\n\t\t\n\t    \tbreak;\n\t    }\n\n\t    if (status & INTSTAT_RXE) {\n\t\tdprintf((EPIC_FORMAT \": CRC/Alignment error\\n\",EPIC_ARGS(sc)));\n\t\tsc->sc_if.if_ierrors++;\n\t    }\n\n\t    /* Tx FIFO underflow. Increase tx threshold, */\n\t    /* if it grown above 2048, disable EARLY_TX */\n\t    if (status & INTSTAT_TXU) {\n\t\tif( sc->tx_threshold > 0x800 ) {\n\t\t    sc->txcon &= ~TXCON_EARLY_TRANSMIT_ENABLE;\n    \t\t    dprintf((EPIC_FORMAT \": TX underrun error, early tx disabled\\n\",EPIC_ARGS(sc)));\n\t\t} else {\n\t\t    sc->tx_threshold += 0x40;\n    \t\t    dprintf((EPIC_FORMAT \": TX underrun error, tx threshold increased to %d\\n\",EPIC_ARGS(sc),sc->tx_threshold));\n\t\t}\n\n\t\tCSR_WRITE_4(sc, COMMAND, COMMAND_TXUGO | COMMAND_TXQUEUED);\n\t\tepic_stop_activity(sc);\n\t\tepic_set_tx_mode(sc);\n\t\tepic_start_activity(sc);\n\t\tsc->sc_if.if_oerrors++;\n\t    }\n\t}\n    }\n\n    /* If no packets are pending, thus no timeouts */\n    if( sc->pending_txs == 0 ) sc->sc_if.if_timer = 0;\n\n#if defined(__OpenBSD__)\n    return claimed;\n#endif\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define EPIC_INTR_RET_TYPE int",
      "#define EPIC_INTR_RET_TYPE void"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "epic_start_activity",
          "args": [
            "sc"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_set_tx_mode",
          "args": [
            "sc"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "epic_set_tx_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "1617-1626",
          "snippet": "void\nepic_set_tx_mode (\n    epic_softc_t *sc )\n{\n\n    if( sc->txcon & TXCON_EARLY_TRANSMIT_ENABLE )\n\tCSR_WRITE_4( sc, ETXTHR, sc->tx_threshold );\n\n    CSR_WRITE_4( sc, TXCON, sc->txcon );\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_set_tx_mode (\n    epic_softc_t *sc )\n{\n\n    if( sc->txcon & TXCON_EARLY_TRANSMIT_ENABLE )\n\tCSR_WRITE_4( sc, ETXTHR, sc->tx_threshold );\n\n    CSR_WRITE_4( sc, TXCON, sc->txcon );\n}"
        }
      },
      {
        "call_info": {
          "callee": "epic_stop_activity",
          "args": [
            "sc"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "COMMAND",
            "COMMAND_TXUGO | COMMAND_TXQUEUED"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": TX underrun error, tx threshold increased to %d\\n\",EPIC_ARGS(sc),sc->tx_threshold)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": TX underrun error, early tx disabled\\n\",EPIC_ARGS(sc))"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": CRC/Alignment error\\n\",EPIC_ARGS(sc))"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_init",
          "args": [
            "sc"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "epic_init_rings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "1841-1886",
          "snippet": "int\nepic_init_rings(epic_softc_t * sc){\n\tint i;\n\n\tsc->cur_rx = sc->cur_tx = sc->dirty_tx = sc->pending_txs = 0;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct epic_rx_buffer *buf = sc->rx_buffer + i;\n\t\tstruct epic_rx_desc *desc = sc->rx_desc + i;\n\n\t\tdesc->status = 0;\t\t/* Owned by driver */\n\t\tdesc->next = vtophys( sc->rx_desc + ((i+1) & RX_RING_MASK) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_rx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! rx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tEPIC_MGETCLUSTER( buf->mbuf );\n\t\tif( NULL == buf->mbuf ) {\n\t\t\tepic_free_rings(sc);\n\t\t\treturn -1;\n\t\t}\n\t\tdesc->bufaddr = vtophys( mtod(buf->mbuf,caddr_t) );\n\n\t\tdesc->buflength = ETHER_MAX_FRAME_LEN;\n\t\tdesc->status = 0x8000;\t\t\t/* Give to EPIC */\n\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct epic_tx_buffer *buf = sc->tx_buffer + i;\n\t\tstruct epic_tx_desc *desc = sc->tx_desc + i;\n\n\t\tdesc->status = 0;\n\t\tdesc->next = vtophys( sc->tx_desc + ( (i+1) & TX_RING_MASK ) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_tx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! tx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tbuf->mbuf = NULL;\n\t\tdesc->bufaddr = vtophys( sc->tx_flist + i );\n\t\tif( (desc->bufaddr & 3) || ((desc->bufaddr & 0xFFF) + sizeof(struct epic_frag_list) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! frag_list is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint\nepic_init_rings(epic_softc_t * sc){\n\tint i;\n\n\tsc->cur_rx = sc->cur_tx = sc->dirty_tx = sc->pending_txs = 0;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct epic_rx_buffer *buf = sc->rx_buffer + i;\n\t\tstruct epic_rx_desc *desc = sc->rx_desc + i;\n\n\t\tdesc->status = 0;\t\t/* Owned by driver */\n\t\tdesc->next = vtophys( sc->rx_desc + ((i+1) & RX_RING_MASK) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_rx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! rx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tEPIC_MGETCLUSTER( buf->mbuf );\n\t\tif( NULL == buf->mbuf ) {\n\t\t\tepic_free_rings(sc);\n\t\t\treturn -1;\n\t\t}\n\t\tdesc->bufaddr = vtophys( mtod(buf->mbuf,caddr_t) );\n\n\t\tdesc->buflength = ETHER_MAX_FRAME_LEN;\n\t\tdesc->status = 0x8000;\t\t\t/* Give to EPIC */\n\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tstruct epic_tx_buffer *buf = sc->tx_buffer + i;\n\t\tstruct epic_tx_desc *desc = sc->tx_desc + i;\n\n\t\tdesc->status = 0;\n\t\tdesc->next = vtophys( sc->tx_desc + ( (i+1) & TX_RING_MASK ) );\n\n\t\tif( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_tx_desc) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! tx_desc is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\n\t\tbuf->mbuf = NULL;\n\t\tdesc->bufaddr = vtophys( sc->tx_flist + i );\n\t\tif( (desc->bufaddr & 3) || ((desc->bufaddr & 0xFFF) + sizeof(struct epic_frag_list) > 0x1000 ) )\n\t\t\tprintf(EPIC_FORMAT \": WARNING! frag_list is misbound or misaligned\\n\",EPIC_ARGS(sc));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "epic_stop",
          "args": [
            "sc"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_dump_state",
          "args": [
            "sc"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "EPIC_FORMAT \": PCI fatal error occured (%s%s%s%s)\\n\"",
            "EPIC_ARGS(sc)",
            "(status&INTSTAT_PMA)?\"PMA\":\"\"",
            "(status&INTSTAT_PTA)?\" PTA\":\"\"",
            "(status&INTSTAT_APE)?\" APE\":\"\"",
            "(status&INTSTAT_DPE)?\" DPE\":\"\""
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "INTSTAT",
            "INTSTAT_GP2"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": link up\\n\",EPIC_ARGS(sc))"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": WARNING! link down\\n\",EPIC_ARGS(sc))"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_start_activity",
          "args": [
            "sc"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_stop_activity",
          "args": [
            "sc"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_WRITE_2",
          "args": [
            "sc",
            "DP83840_BMCR",
            "bmcr"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMCR"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": going halfduplex\\n\",EPIC_ARGS(sc))"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMCR"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": going fullduplex\\n\",EPIC_ARGS(sc))"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_autoneg",
          "args": [
            "sc"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "epic_autoneg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "1543-1613",
          "snippet": "int \nepic_autoneg(\n    epic_softc_t * sc)\n{\n\tu_int16_t media;\n\tu_int16_t i;\n\n        /* BMSR must be read twice to update the link status bit\n\t * since that bit is a latch bit\n         */\n\tPHY_READ_2( sc, DP83840_BMSR);\n\ti = PHY_READ_2( sc, DP83840_BMSR);\n        \n        if ((i & BMSR_LINK_STATUS) && (i & BMSR_AUTONEG_COMPLETE)){\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\n\t\tif ( i & (ANAR_100_TX_FD|ANAR_10_FD) )\n\t\t\treturn \tEPIC_FULL_DUPLEX;\n\t\telse\n\t\t\treturn EPIC_HALF_DUPLEX;\n        } else {   \n\t\t/*Auto-negotiation or link status is not 1\n\t\t  Thus the auto-negotiation failed and one\n\t\t  must take other means to fix it.\n\t\t */\n\n\t\t/* ANER must be read twice to get the correct reading for the \n\t\t * Multiple link fault bit -- it is a latched bit\n\t \t */\n \t\tPHY_READ_2( sc, DP83840_ANER );\n\t\ti = PHY_READ_2( sc, DP83840_ANER );\n\t\n\t\tif ( i & ANER_MULTIPLE_LINK_FAULT ) {\n\t\t\t/* it can be forced to 100Mb/s Half-Duplex */\n\t \t\tmedia = PHY_READ_2( sc, DP83840_BMCR );\n\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX);\n\t\t\tmedia |= BMCR_100MBPS;\n\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media );\n\t\t\n\t\t\t/* read BMSR again to determine link status */\n\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\ti=PHY_READ_2( sc, DP83840_BMSR );\n\t\t\n\t\t\tif (i & BMSR_LINK_STATUS){\n\t\t\t\t/* port is linked to the non Auto-Negotiation\n\t\t\t\t * 100Mbs partner.\n\t\t\t \t */\n\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmedia = PHY_READ_2( sc, DP83840_BMCR);\n\t\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX | BMCR_100MBPS);\n\t\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media);\n\t\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\t\ti = PHY_READ_2( sc, DP83840_BMSR );\n\n\t\t\t\tif (i & BMSR_LINK_STATUS) {\n\t\t\t\t\t/*port is linked to the non\n\t\t\t\t\t * Auto-Negotiation10Mbs partner\n\t\t\t \t \t */\n\t\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* If we get here we are most likely not connected\n\t\t * so lets default it to half duplex\n\t\t */\n\t\treturn EPIC_HALF_DUPLEX;\n\t}\n\t\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint \nepic_autoneg(\n    epic_softc_t * sc)\n{\n\tu_int16_t media;\n\tu_int16_t i;\n\n        /* BMSR must be read twice to update the link status bit\n\t * since that bit is a latch bit\n         */\n\tPHY_READ_2( sc, DP83840_BMSR);\n\ti = PHY_READ_2( sc, DP83840_BMSR);\n        \n        if ((i & BMSR_LINK_STATUS) && (i & BMSR_AUTONEG_COMPLETE)){\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\n\t\tif ( i & (ANAR_100_TX_FD|ANAR_10_FD) )\n\t\t\treturn \tEPIC_FULL_DUPLEX;\n\t\telse\n\t\t\treturn EPIC_HALF_DUPLEX;\n        } else {   \n\t\t/*Auto-negotiation or link status is not 1\n\t\t  Thus the auto-negotiation failed and one\n\t\t  must take other means to fix it.\n\t\t */\n\n\t\t/* ANER must be read twice to get the correct reading for the \n\t\t * Multiple link fault bit -- it is a latched bit\n\t \t */\n \t\tPHY_READ_2( sc, DP83840_ANER );\n\t\ti = PHY_READ_2( sc, DP83840_ANER );\n\t\n\t\tif ( i & ANER_MULTIPLE_LINK_FAULT ) {\n\t\t\t/* it can be forced to 100Mb/s Half-Duplex */\n\t \t\tmedia = PHY_READ_2( sc, DP83840_BMCR );\n\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX);\n\t\t\tmedia |= BMCR_100MBPS;\n\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media );\n\t\t\n\t\t\t/* read BMSR again to determine link status */\n\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\ti=PHY_READ_2( sc, DP83840_BMSR );\n\t\t\n\t\t\tif (i & BMSR_LINK_STATUS){\n\t\t\t\t/* port is linked to the non Auto-Negotiation\n\t\t\t\t * 100Mbs partner.\n\t\t\t \t */\n\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmedia = PHY_READ_2( sc, DP83840_BMCR);\n\t\t\t\tmedia &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX | BMCR_100MBPS);\n\t\t\t\tPHY_WRITE_2( sc, DP83840_BMCR, media);\n\t\t\t\tPHY_READ_2( sc, DP83840_BMSR );\n\t\t\t\ti = PHY_READ_2( sc, DP83840_BMSR );\n\n\t\t\t\tif (i & BMSR_LINK_STATUS) {\n\t\t\t\t\t/*port is linked to the non\n\t\t\t\t\t * Auto-Negotiation10Mbs partner\n\t\t\t \t \t */\n\t\t\t\t\treturn EPIC_HALF_DUPLEX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* If we get here we are most likely not connected\n\t\t * so lets default it to half duplex\n\t\t */\n\t\treturn EPIC_HALF_DUPLEX;\n\t}\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "QS6612_INTSTAT"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_ifstart",
          "args": [
            "&sc->sc_if"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "epic_ifstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "812-915",
          "snippet": "void\nepic_ifstart(struct ifnet * const ifp){\n\tepic_softc_t *sc = ifp->if_softc;\n\tstruct epic_tx_buffer *buf;\n\tstruct epic_tx_desc *desc;\n\tstruct epic_frag_list *flist;\n\tstruct mbuf *m0;\n\tregister struct mbuf *m;\n\tregister int i;\n\n#if 0\n\t/* If no link is established, simply free all mbufs in queue */\n\tPHY_READ_2( sc, DP83840_BMSR );\n\tif( !(BMSR_LINK_STATUS & PHY_READ_2( sc, DP83840_BMSR )) ){\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\twhile( m0 ) {\n\t\t\tm_freem(m0);\n\t\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/* Link is OK, queue packets to NIC */\n\twhile( sc->pending_txs < TX_RING_SIZE  ){\n\t\tbuf = sc->tx_buffer + sc->cur_tx;\n\t\tdesc = sc->tx_desc + sc->cur_tx;\n\t\tflist = sc->tx_flist + sc->cur_tx;\n\n\t\t/* Get next packet to send */\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\n\t\t/* If nothing to send, return */\n\t\tif( NULL == m0 ) return;\n\n\t\t/* If descriptor is busy, set IFF_OACTIVE and exit */\n\t\tif( desc->status & 0x8000 ) {\n\t\t\tdprintf((EPIC_FORMAT \": desc is busy in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\tif( buf->mbuf ) {\n\t\t\tdprintf((EPIC_FORMAT \": mbuf not freed in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Fill fragments list */\n\t\tfor( m=m0, i=0;\n\t\t    (NULL != m) && (i < EPIC_MAX_FRAGS);\n\t\t    m = m->m_next, i++ ) {\n\t\t\tflist->frag[i].fraglen = m->m_len; \n\t\t\tflist->frag[i].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t}\n\t\tflist->numfrags = i;\n\n\t\t/* If packet was more than EPIC_MAX_FRAGS parts, */\n\t\t/* recopy packet to new allocated mbuf cluster */\n\t\tif( NULL != m ){\n\t\t\tEPIC_MGETCLUSTER(m);\n\t\t\tif( NULL == m ){\n\t\t\t\tprintf(EPIC_FORMAT \": cannot allocate mbuf cluster\\n\",EPIC_ARGS(sc));\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tm_copydata( m0, 0, m0->m_pkthdr.len, mtod(m,caddr_t) );\n\t\t\tflist->frag[0].fraglen = \n\t\t\t     m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t\tflist->numfrags = 1;\n\t\t\tflist->frag[0].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t\tm_freem(m0);\n\t\t\tm0 = m;\n\t\t}\n\n\t\tbuf->mbuf = m0;\n\t\tsc->pending_txs++;\n\t\tsc->cur_tx = ( sc->cur_tx + 1 ) & TX_RING_MASK;\n\t\tdesc->control = 0x01;\n\t\tdesc->txlength = \n\t\t    max(m0->m_pkthdr.len,ETHER_MIN_LEN-ETHER_CRC_LEN);\n\t\tdesc->status = 0x8000;\n\t\tCSR_WRITE_4( sc, COMMAND, COMMAND_TXQUEUED );\n\n\t\t/* Set watchdog timer */\n\t\tifp->if_timer = 8;\n\n#if NBPFILTER > 0\n\t\tif( ifp->if_bpf ) \n#if defined(__FreeBSD__)\n\t\t\tbpf_mtap( ifp, m0 );\n#else /* __OpenBSD__ */\n\t\t\tbpf_mtap( ifp->if_bpf, m0 );\n#endif /* __FreeBSD__ */\n#endif\n\t}\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\treturn;\n\t\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_ifstart(struct ifnet * const ifp){\n\tepic_softc_t *sc = ifp->if_softc;\n\tstruct epic_tx_buffer *buf;\n\tstruct epic_tx_desc *desc;\n\tstruct epic_frag_list *flist;\n\tstruct mbuf *m0;\n\tregister struct mbuf *m;\n\tregister int i;\n\n#if 0\n\t/* If no link is established, simply free all mbufs in queue */\n\tPHY_READ_2( sc, DP83840_BMSR );\n\tif( !(BMSR_LINK_STATUS & PHY_READ_2( sc, DP83840_BMSR )) ){\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\twhile( m0 ) {\n\t\t\tm_freem(m0);\n\t\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/* Link is OK, queue packets to NIC */\n\twhile( sc->pending_txs < TX_RING_SIZE  ){\n\t\tbuf = sc->tx_buffer + sc->cur_tx;\n\t\tdesc = sc->tx_desc + sc->cur_tx;\n\t\tflist = sc->tx_flist + sc->cur_tx;\n\n\t\t/* Get next packet to send */\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\n\t\t/* If nothing to send, return */\n\t\tif( NULL == m0 ) return;\n\n\t\t/* If descriptor is busy, set IFF_OACTIVE and exit */\n\t\tif( desc->status & 0x8000 ) {\n\t\t\tdprintf((EPIC_FORMAT \": desc is busy in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\tif( buf->mbuf ) {\n\t\t\tdprintf((EPIC_FORMAT \": mbuf not freed in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Fill fragments list */\n\t\tfor( m=m0, i=0;\n\t\t    (NULL != m) && (i < EPIC_MAX_FRAGS);\n\t\t    m = m->m_next, i++ ) {\n\t\t\tflist->frag[i].fraglen = m->m_len; \n\t\t\tflist->frag[i].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t}\n\t\tflist->numfrags = i;\n\n\t\t/* If packet was more than EPIC_MAX_FRAGS parts, */\n\t\t/* recopy packet to new allocated mbuf cluster */\n\t\tif( NULL != m ){\n\t\t\tEPIC_MGETCLUSTER(m);\n\t\t\tif( NULL == m ){\n\t\t\t\tprintf(EPIC_FORMAT \": cannot allocate mbuf cluster\\n\",EPIC_ARGS(sc));\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tm_copydata( m0, 0, m0->m_pkthdr.len, mtod(m,caddr_t) );\n\t\t\tflist->frag[0].fraglen = \n\t\t\t     m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t\tflist->numfrags = 1;\n\t\t\tflist->frag[0].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t\tm_freem(m0);\n\t\t\tm0 = m;\n\t\t}\n\n\t\tbuf->mbuf = m0;\n\t\tsc->pending_txs++;\n\t\tsc->cur_tx = ( sc->cur_tx + 1 ) & TX_RING_MASK;\n\t\tdesc->control = 0x01;\n\t\tdesc->txlength = \n\t\t    max(m0->m_pkthdr.len,ETHER_MIN_LEN-ETHER_CRC_LEN);\n\t\tdesc->status = 0x8000;\n\t\tCSR_WRITE_4( sc, COMMAND, COMMAND_TXQUEUED );\n\n\t\t/* Set watchdog timer */\n\t\tifp->if_timer = 8;\n\n#if NBPFILTER > 0\n\t\tif( ifp->if_bpf ) \n#if defined(__FreeBSD__)\n\t\t\tbpf_mtap( ifp, m0 );\n#else /* __OpenBSD__ */\n\t\t\tbpf_mtap( ifp->if_bpf, m0 );\n#endif /* __FreeBSD__ */\n#endif\n\t}\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\treturn;\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "epic_tx_done",
          "args": [
            "sc"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "COMMAND",
            "COMMAND_RXQUEUED"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "COMMAND"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_dump_state",
          "args": [
            "sc"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_rx_done",
          "args": [
            "sc"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "INTSTAT",
            "status"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "INTSTAT"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\n#define EPIC_INTR_RET_TYPE int\n#define EPIC_INTR_RET_TYPE void\n\nEPIC_INTR_RET_TYPE\nepic_intr (\n    void *arg)\n{\n    epic_softc_t * sc = (epic_softc_t *) arg;\n    int status,i=4;\n#if defined(__OpenBSD__)\n    int claimed = 0;\n#endif\n\n\n    while( i-- && ((status = CSR_READ_4(sc, INTSTAT)) & INTSTAT_INT_ACTV) ){\n#if defined(__OpenBSD__)\n\tclaimed = 1;\n#endif\n\tCSR_WRITE_4( sc, INTSTAT, status );\n\n\tif( status & (INTSTAT_RQE|INTSTAT_RCC|INTSTAT_OVW) ) {\n            epic_rx_done( sc );\n            if( status & (INTSTAT_RQE|INTSTAT_OVW) ){\n#if defined(EPIC_DEBUG)\n                if( status & INTSTAT_OVW ) \n                    printf(EPIC_FORMAT \": RX buffer overflow\\n\",EPIC_ARGS(sc));\n                if( status & INTSTAT_RQE ) \n                    printf(EPIC_FORMAT \": RX FIFO overflow\\n\",EPIC_ARGS(sc));\n                if( sc->sc_if.if_flags & IFF_DEBUG ) \n                    epic_dump_state(sc);\n#endif\n                if( !(CSR_READ_4( sc, COMMAND ) & COMMAND_RXQUEUED) )\n                    CSR_WRITE_4( sc, COMMAND, COMMAND_RXQUEUED );\n                sc->sc_if.if_ierrors++;\n            }\n        }\n\n        if( status & (INTSTAT_TXC|INTSTAT_TCC|INTSTAT_TQE) ) {\n            epic_tx_done( sc );\n\t    if(!(sc->sc_if.if_flags & IFF_OACTIVE) &&\n\t\tsc->sc_if.if_snd.ifq_head )\n\t\t    epic_ifstart( &sc->sc_if );\n\t}\n\n        if( (status & INTSTAT_GP2) && (QS6612_OUI == sc->phyid) ) {\n\t    u_int32_t phystatus = PHY_READ_2( sc, QS6612_INTSTAT );\n\n\t    if( phystatus & INTSTAT_AN_COMPLETE ) {\n\t\tu_int32_t bmcr;\n\t\tif( epic_autoneg(sc) == EPIC_FULL_DUPLEX ) {\n\t\t    dprintf((EPIC_FORMAT \": going fullduplex\\n\",EPIC_ARGS(sc)));\n\t\t    bmcr = BMCR_FULL_DUPLEX | PHY_READ_2( sc, DP83840_BMCR );\n\t\t    sc->txcon |= TXCON_FULL_DUPLEX;\n\t\t} else {\n\t\t    /* Default to half-duplex */\n\t\t    dprintf((EPIC_FORMAT \": going halfduplex\\n\",EPIC_ARGS(sc)));\n\t\t    bmcr = ~BMCR_FULL_DUPLEX & PHY_READ_2( sc, DP83840_BMCR );\n\t\t    sc->txcon &= ~TXCON_FULL_DUPLEX;\n\t\t}\n\n\t\t/* There is apparently QS6612 chip bug: */\n\t\t/* BMCR_FULL_DUPLEX flag is not updated by */\n\t\t/* autonegotiation process, so update it by hands */\n\t\t/* so we can rely on it in epic_ifmedia_status() */\n\t\tPHY_WRITE_2( sc, DP83840_BMCR, bmcr );\n\n\t\tepic_stop_activity(sc);\n\t\tepic_set_tx_mode(sc);\n\t\tepic_start_activity(sc);\n\t    }\n\n\t    PHY_READ_2(sc, DP83840_BMSR);\n\t    if( !(PHY_READ_2(sc, DP83840_BMSR) & BMSR_LINK_STATUS) ) {\n\t\tdprintf((EPIC_FORMAT \": WARNING! link down\\n\",EPIC_ARGS(sc)));\n\t\tsc->flags |= EPIC_LINK_DOWN;\n\t    } else {\n    \t\tdprintf((EPIC_FORMAT \": link up\\n\",EPIC_ARGS(sc)));\n\t\tsc->flags &= ~EPIC_LINK_DOWN;\n\t    }\n\n\t    /* We should clear GP2 int again after we clear it on PHY */\n\t    CSR_WRITE_4( sc, INTSTAT, INTSTAT_GP2 ); \n\t}\n\n\t/* Check for errors */\n\tif( status & (INTSTAT_FATAL|INTSTAT_PMA|INTSTAT_PTA|\n\t\t      INTSTAT_APE|INTSTAT_DPE|INTSTAT_TXU|INTSTAT_RXE) ){\n    \t    if( status & (INTSTAT_FATAL|INTSTAT_PMA|INTSTAT_PTA|\n\t\t\t  INTSTAT_APE|INTSTAT_DPE) ){\n\t\tprintf(EPIC_FORMAT \": PCI fatal error occured (%s%s%s%s)\\n\",\n    \t\t    EPIC_ARGS(sc),\n\t\t    (status&INTSTAT_PMA)?\"PMA\":\"\",\n\t\t    (status&INTSTAT_PTA)?\" PTA\":\"\",\n\t\t    (status&INTSTAT_APE)?\" APE\":\"\",\n\t\t    (status&INTSTAT_DPE)?\" DPE\":\"\"\n\t\t);\n\n\t\tepic_dump_state(sc);\n\n\t\tepic_stop(sc);\n\t\tepic_init(sc);\n\t\t\n\t    \tbreak;\n\t    }\n\n\t    if (status & INTSTAT_RXE) {\n\t\tdprintf((EPIC_FORMAT \": CRC/Alignment error\\n\",EPIC_ARGS(sc)));\n\t\tsc->sc_if.if_ierrors++;\n\t    }\n\n\t    /* Tx FIFO underflow. Increase tx threshold, */\n\t    /* if it grown above 2048, disable EARLY_TX */\n\t    if (status & INTSTAT_TXU) {\n\t\tif( sc->tx_threshold > 0x800 ) {\n\t\t    sc->txcon &= ~TXCON_EARLY_TRANSMIT_ENABLE;\n    \t\t    dprintf((EPIC_FORMAT \": TX underrun error, early tx disabled\\n\",EPIC_ARGS(sc)));\n\t\t} else {\n\t\t    sc->tx_threshold += 0x40;\n    \t\t    dprintf((EPIC_FORMAT \": TX underrun error, tx threshold increased to %d\\n\",EPIC_ARGS(sc),sc->tx_threshold));\n\t\t}\n\n\t\tCSR_WRITE_4(sc, COMMAND, COMMAND_TXUGO | COMMAND_TXQUEUED);\n\t\tepic_stop_activity(sc);\n\t\tepic_set_tx_mode(sc);\n\t\tepic_start_activity(sc);\n\t\tsc->sc_if.if_oerrors++;\n\t    }\n\t}\n    }\n\n    /* If no packets are pending, thus no timeouts */\n    if( sc->pending_txs == 0 ) sc->sc_if.if_timer = 0;\n\n#if defined(__OpenBSD__)\n    return claimed;\n#endif\n}"
  },
  {
    "function_name": "epic_ifstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "812-915",
    "snippet": "void\nepic_ifstart(struct ifnet * const ifp){\n\tepic_softc_t *sc = ifp->if_softc;\n\tstruct epic_tx_buffer *buf;\n\tstruct epic_tx_desc *desc;\n\tstruct epic_frag_list *flist;\n\tstruct mbuf *m0;\n\tregister struct mbuf *m;\n\tregister int i;\n\n#if 0\n\t/* If no link is established, simply free all mbufs in queue */\n\tPHY_READ_2( sc, DP83840_BMSR );\n\tif( !(BMSR_LINK_STATUS & PHY_READ_2( sc, DP83840_BMSR )) ){\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\twhile( m0 ) {\n\t\t\tm_freem(m0);\n\t\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/* Link is OK, queue packets to NIC */\n\twhile( sc->pending_txs < TX_RING_SIZE  ){\n\t\tbuf = sc->tx_buffer + sc->cur_tx;\n\t\tdesc = sc->tx_desc + sc->cur_tx;\n\t\tflist = sc->tx_flist + sc->cur_tx;\n\n\t\t/* Get next packet to send */\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\n\t\t/* If nothing to send, return */\n\t\tif( NULL == m0 ) return;\n\n\t\t/* If descriptor is busy, set IFF_OACTIVE and exit */\n\t\tif( desc->status & 0x8000 ) {\n\t\t\tdprintf((EPIC_FORMAT \": desc is busy in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\tif( buf->mbuf ) {\n\t\t\tdprintf((EPIC_FORMAT \": mbuf not freed in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Fill fragments list */\n\t\tfor( m=m0, i=0;\n\t\t    (NULL != m) && (i < EPIC_MAX_FRAGS);\n\t\t    m = m->m_next, i++ ) {\n\t\t\tflist->frag[i].fraglen = m->m_len; \n\t\t\tflist->frag[i].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t}\n\t\tflist->numfrags = i;\n\n\t\t/* If packet was more than EPIC_MAX_FRAGS parts, */\n\t\t/* recopy packet to new allocated mbuf cluster */\n\t\tif( NULL != m ){\n\t\t\tEPIC_MGETCLUSTER(m);\n\t\t\tif( NULL == m ){\n\t\t\t\tprintf(EPIC_FORMAT \": cannot allocate mbuf cluster\\n\",EPIC_ARGS(sc));\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tm_copydata( m0, 0, m0->m_pkthdr.len, mtod(m,caddr_t) );\n\t\t\tflist->frag[0].fraglen = \n\t\t\t     m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t\tflist->numfrags = 1;\n\t\t\tflist->frag[0].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t\tm_freem(m0);\n\t\t\tm0 = m;\n\t\t}\n\n\t\tbuf->mbuf = m0;\n\t\tsc->pending_txs++;\n\t\tsc->cur_tx = ( sc->cur_tx + 1 ) & TX_RING_MASK;\n\t\tdesc->control = 0x01;\n\t\tdesc->txlength = \n\t\t    max(m0->m_pkthdr.len,ETHER_MIN_LEN-ETHER_CRC_LEN);\n\t\tdesc->status = 0x8000;\n\t\tCSR_WRITE_4( sc, COMMAND, COMMAND_TXQUEUED );\n\n\t\t/* Set watchdog timer */\n\t\tifp->if_timer = 8;\n\n#if NBPFILTER > 0\n\t\tif( ifp->if_bpf ) \n#if defined(__FreeBSD__)\n\t\t\tbpf_mtap( ifp, m0 );\n#else /* __OpenBSD__ */\n\t\t\tbpf_mtap( ifp->if_bpf, m0 );\n#endif /* __FreeBSD__ */\n#endif\n\t}\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\treturn;\n\t\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp",
            "m0"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "COMMAND",
            "COMMAND_TXQUEUED"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "m0->m_pkthdr.len",
            "ETHER_MIN_LEN-ETHER_CRC_LEN"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, caddr_t)"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m0",
            "0",
            "m0->m_pkthdr.len",
            "mtod(m,caddr_t)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "EPIC_FORMAT \": cannot allocate mbuf cluster\\n\"",
            "EPIC_ARGS(sc)"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_MGETCLUSTER",
          "args": [
            "m"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, caddr_t)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": mbuf not freed in ifstart, up and down interface please\\n\",EPIC_ARGS(sc))"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(EPIC_FORMAT \": desc is busy in ifstart, up and down interface please\\n\",EPIC_ARGS(sc))"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EPIC_ARGS",
          "args": [
            "sc"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMSR"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_ifstart(struct ifnet * const ifp){\n\tepic_softc_t *sc = ifp->if_softc;\n\tstruct epic_tx_buffer *buf;\n\tstruct epic_tx_desc *desc;\n\tstruct epic_frag_list *flist;\n\tstruct mbuf *m0;\n\tregister struct mbuf *m;\n\tregister int i;\n\n#if 0\n\t/* If no link is established, simply free all mbufs in queue */\n\tPHY_READ_2( sc, DP83840_BMSR );\n\tif( !(BMSR_LINK_STATUS & PHY_READ_2( sc, DP83840_BMSR )) ){\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\twhile( m0 ) {\n\t\t\tm_freem(m0);\n\t\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/* Link is OK, queue packets to NIC */\n\twhile( sc->pending_txs < TX_RING_SIZE  ){\n\t\tbuf = sc->tx_buffer + sc->cur_tx;\n\t\tdesc = sc->tx_desc + sc->cur_tx;\n\t\tflist = sc->tx_flist + sc->cur_tx;\n\n\t\t/* Get next packet to send */\n\t\tIF_DEQUEUE( &ifp->if_snd, m0 );\n\n\t\t/* If nothing to send, return */\n\t\tif( NULL == m0 ) return;\n\n\t\t/* If descriptor is busy, set IFF_OACTIVE and exit */\n\t\tif( desc->status & 0x8000 ) {\n\t\t\tdprintf((EPIC_FORMAT \": desc is busy in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\tif( buf->mbuf ) {\n\t\t\tdprintf((EPIC_FORMAT \": mbuf not freed in ifstart, up and down interface please\\n\",EPIC_ARGS(sc)));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Fill fragments list */\n\t\tfor( m=m0, i=0;\n\t\t    (NULL != m) && (i < EPIC_MAX_FRAGS);\n\t\t    m = m->m_next, i++ ) {\n\t\t\tflist->frag[i].fraglen = m->m_len; \n\t\t\tflist->frag[i].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t}\n\t\tflist->numfrags = i;\n\n\t\t/* If packet was more than EPIC_MAX_FRAGS parts, */\n\t\t/* recopy packet to new allocated mbuf cluster */\n\t\tif( NULL != m ){\n\t\t\tEPIC_MGETCLUSTER(m);\n\t\t\tif( NULL == m ){\n\t\t\t\tprintf(EPIC_FORMAT \": cannot allocate mbuf cluster\\n\",EPIC_ARGS(sc));\n\t\t\t\tm_freem(m0);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tm_copydata( m0, 0, m0->m_pkthdr.len, mtod(m,caddr_t) );\n\t\t\tflist->frag[0].fraglen = \n\t\t\t     m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\n\t\t\tflist->numfrags = 1;\n\t\t\tflist->frag[0].fragaddr = vtophys( mtod(m, caddr_t) );\n\t\t\tm_freem(m0);\n\t\t\tm0 = m;\n\t\t}\n\n\t\tbuf->mbuf = m0;\n\t\tsc->pending_txs++;\n\t\tsc->cur_tx = ( sc->cur_tx + 1 ) & TX_RING_MASK;\n\t\tdesc->control = 0x01;\n\t\tdesc->txlength = \n\t\t    max(m0->m_pkthdr.len,ETHER_MIN_LEN-ETHER_CRC_LEN);\n\t\tdesc->status = 0x8000;\n\t\tCSR_WRITE_4( sc, COMMAND, COMMAND_TXQUEUED );\n\n\t\t/* Set watchdog timer */\n\t\tifp->if_timer = 8;\n\n#if NBPFILTER > 0\n\t\tif( ifp->if_bpf ) \n#if defined(__FreeBSD__)\n\t\t\tbpf_mtap( ifp, m0 );\n#else /* __OpenBSD__ */\n\t\t\tbpf_mtap( ifp->if_bpf, m0 );\n#endif /* __FreeBSD__ */\n#endif\n\t}\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\treturn;\n\t\n}"
  },
  {
    "function_name": "epic_common_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "756-805",
    "snippet": "int\nepic_common_attach(\n    epic_softc_t *sc)\n{\n\tint i;\n\tcaddr_t pool;\n\n\ti = sizeof(struct epic_frag_list)*TX_RING_SIZE +\n\t    sizeof(struct epic_rx_desc)*RX_RING_SIZE + \n\t    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE,\n\tsc->pool = (epic_softc_t *) malloc( i, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->pool == NULL) {\n\t\tprintf(\": can't allocate memory for buffers\\n\");\n\t\treturn -1;\n\t}\n\tbzero(sc->pool, i);\n\n\t/* Align pool on PAGE_SIZE */\n\tpool = (caddr_t)sc->pool;\n\tpool = (caddr_t)((u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));\n\n\t/* Distribute memory */\n\tsc->tx_flist = (void *)pool;\n\tpool += sizeof(struct epic_frag_list)*TX_RING_SIZE;\n\tsc->rx_desc = (void *)pool;\n\tpool += sizeof(struct epic_rx_desc)*RX_RING_SIZE;\n\tsc->tx_desc = (void *)pool;\n\n\t/* Bring the chip out of low-power mode. */\n\tCSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);\n\n\t/* Workaround for Application Note 7-15 */\n\tfor (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);\n\n\t/* Read mac address from EEPROM */\n\tfor (i = 0; i < ETHER_ADDR_LEN / sizeof(u_int16_t); i++)\n\t\t((u_int16_t *)sc->sc_macaddr)[i] = epic_read_eeprom(sc,i);\n\n\t/* Identify PHY */\n\tsc->phyid = PHY_READ_2(sc, DP83840_PHYIDR1 )<<6;\n\tsc->phyid|= (PHY_READ_2( sc, DP83840_PHYIDR2 )>>10)&0x3F;\n\tif( QS6612_OUI != sc->phyid ) \n\t\tprintf(\": WARNING! PHY unknown (0x%x)\",sc->phyid);\n\n\tsc->tx_threshold = TRANSMIT_THRESHOLD;\n\tsc->txcon = TXCON_DEFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": WARNING! PHY unknown (0x%x)\"",
            "sc->phyid"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_PHYIDR2"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_PHYIDR1"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_read_eeprom",
          "args": [
            "sc",
            "i"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "TEST1",
            "TEST1_CLOCK_TEST"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "GENCTL",
            "GENCTL_SOFT_RESET"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pool + PAGE_SIZE - 1"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->pool",
            "i"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "i",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint\nepic_common_attach(\n    epic_softc_t *sc)\n{\n\tint i;\n\tcaddr_t pool;\n\n\ti = sizeof(struct epic_frag_list)*TX_RING_SIZE +\n\t    sizeof(struct epic_rx_desc)*RX_RING_SIZE + \n\t    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE,\n\tsc->pool = (epic_softc_t *) malloc( i, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->pool == NULL) {\n\t\tprintf(\": can't allocate memory for buffers\\n\");\n\t\treturn -1;\n\t}\n\tbzero(sc->pool, i);\n\n\t/* Align pool on PAGE_SIZE */\n\tpool = (caddr_t)sc->pool;\n\tpool = (caddr_t)((u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));\n\n\t/* Distribute memory */\n\tsc->tx_flist = (void *)pool;\n\tpool += sizeof(struct epic_frag_list)*TX_RING_SIZE;\n\tsc->rx_desc = (void *)pool;\n\tpool += sizeof(struct epic_rx_desc)*RX_RING_SIZE;\n\tsc->tx_desc = (void *)pool;\n\n\t/* Bring the chip out of low-power mode. */\n\tCSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);\n\n\t/* Workaround for Application Note 7-15 */\n\tfor (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);\n\n\t/* Read mac address from EEPROM */\n\tfor (i = 0; i < ETHER_ADDR_LEN / sizeof(u_int16_t); i++)\n\t\t((u_int16_t *)sc->sc_macaddr)[i] = epic_read_eeprom(sc,i);\n\n\t/* Identify PHY */\n\tsc->phyid = PHY_READ_2(sc, DP83840_PHYIDR1 )<<6;\n\tsc->phyid|= (PHY_READ_2( sc, DP83840_PHYIDR2 )>>10)&0x3F;\n\tif( QS6612_OUI != sc->phyid ) \n\t\tprintf(\": WARNING! PHY unknown (0x%x)\",sc->phyid);\n\n\tsc->tx_threshold = TRANSMIT_THRESHOLD;\n\tsc->txcon = TXCON_DEFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "epic_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "616-622",
    "snippet": "void\nepic_shutdown(\n    int howto,\n    void *sc)\n{\n\tepic_stop(sc);\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "epic_stop",
          "args": [
            "sc"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_shutdown(\n    int howto,\n    void *sc)\n{\n\tepic_stop(sc);\n}"
  },
  {
    "function_name": "epic_freebsd_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "437-614",
    "snippet": "void\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))",
      "#define EPIC_NOIFMEDIA\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "at_shutdown",
          "args": [
            "epic_shutdown",
            "sc",
            "SHUTDOWN_POST_SYNC"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc",
            "M_DEVBUF"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "epic_freebsd_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "437-614",
          "snippet": "void\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pci_map_int",
          "args": [
            "config_id",
            "epic_intr",
            "(void*)sc",
            "&net_imask"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->ifmedia",
            "tmp"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "epic_mtypes[i]",
            "0",
            "NULL"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->ifmedia",
            "0",
            "epic_ifmedia_change",
            "epic_ifmedia_status"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_LPAR"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMCR"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_read_eeprom",
          "args": [
            "sc",
            "i"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_WRITE",
          "args": [
            "PCI_CFCS",
            "command"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFCS"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_common_attach",
          "args": [
            "sc"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "epic_common_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "756-805",
          "snippet": "int\nepic_common_attach(\n    epic_softc_t *sc)\n{\n\tint i;\n\tcaddr_t pool;\n\n\ti = sizeof(struct epic_frag_list)*TX_RING_SIZE +\n\t    sizeof(struct epic_rx_desc)*RX_RING_SIZE + \n\t    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE,\n\tsc->pool = (epic_softc_t *) malloc( i, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->pool == NULL) {\n\t\tprintf(\": can't allocate memory for buffers\\n\");\n\t\treturn -1;\n\t}\n\tbzero(sc->pool, i);\n\n\t/* Align pool on PAGE_SIZE */\n\tpool = (caddr_t)sc->pool;\n\tpool = (caddr_t)((u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));\n\n\t/* Distribute memory */\n\tsc->tx_flist = (void *)pool;\n\tpool += sizeof(struct epic_frag_list)*TX_RING_SIZE;\n\tsc->rx_desc = (void *)pool;\n\tpool += sizeof(struct epic_rx_desc)*RX_RING_SIZE;\n\tsc->tx_desc = (void *)pool;\n\n\t/* Bring the chip out of low-power mode. */\n\tCSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);\n\n\t/* Workaround for Application Note 7-15 */\n\tfor (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);\n\n\t/* Read mac address from EEPROM */\n\tfor (i = 0; i < ETHER_ADDR_LEN / sizeof(u_int16_t); i++)\n\t\t((u_int16_t *)sc->sc_macaddr)[i] = epic_read_eeprom(sc,i);\n\n\t/* Identify PHY */\n\tsc->phyid = PHY_READ_2(sc, DP83840_PHYIDR1 )<<6;\n\tsc->phyid|= (PHY_READ_2( sc, DP83840_PHYIDR2 )>>10)&0x3F;\n\tif( QS6612_OUI != sc->phyid ) \n\t\tprintf(\": WARNING! PHY unknown (0x%x)\",sc->phyid);\n\n\tsc->tx_threshold = TRANSMIT_THRESHOLD;\n\tsc->txcon = TXCON_DEFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint\nepic_common_attach(\n    epic_softc_t *sc)\n{\n\tint i;\n\tcaddr_t pool;\n\n\ti = sizeof(struct epic_frag_list)*TX_RING_SIZE +\n\t    sizeof(struct epic_rx_desc)*RX_RING_SIZE + \n\t    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE,\n\tsc->pool = (epic_softc_t *) malloc( i, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->pool == NULL) {\n\t\tprintf(\": can't allocate memory for buffers\\n\");\n\t\treturn -1;\n\t}\n\tbzero(sc->pool, i);\n\n\t/* Align pool on PAGE_SIZE */\n\tpool = (caddr_t)sc->pool;\n\tpool = (caddr_t)((u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));\n\n\t/* Distribute memory */\n\tsc->tx_flist = (void *)pool;\n\tpool += sizeof(struct epic_frag_list)*TX_RING_SIZE;\n\tsc->rx_desc = (void *)pool;\n\tpool += sizeof(struct epic_rx_desc)*RX_RING_SIZE;\n\tsc->tx_desc = (void *)pool;\n\n\t/* Bring the chip out of low-power mode. */\n\tCSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);\n\n\t/* Workaround for Application Note 7-15 */\n\tfor (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);\n\n\t/* Read mac address from EEPROM */\n\tfor (i = 0; i < ETHER_ADDR_LEN / sizeof(u_int16_t); i++)\n\t\t((u_int16_t *)sc->sc_macaddr)[i] = epic_read_eeprom(sc,i);\n\n\t/* Identify PHY */\n\tsc->phyid = PHY_READ_2(sc, DP83840_PHYIDR1 )<<6;\n\tsc->phyid|= (PHY_READ_2( sc, DP83840_PHYIDR2 )>>10)&0x3F;\n\tif( QS6612_OUI != sc->phyid ) \n\t\tprintf(\": WARNING! PHY unknown (0x%x)\",sc->phyid);\n\n\tsc->tx_threshold = TRANSMIT_THRESHOLD;\n\tsc->txcon = TXCON_DEFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_map_mem",
          "args": [
            "config_id",
            "PCI_CBMA",
            "(vm_offset_t *) &(sc->csr)",
            "(vm_offset_t *) &pmembase"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFCS"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_WRITE",
          "args": [
            "PCI_CFCS",
            "command"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFCS"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_map_port",
          "args": [
            "config_id",
            "PCI_CBIO",
            "(u_short *) &(sc->iobase)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFCS"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_WRITE",
          "args": [
            "PCI_CFCS",
            "command"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFCS"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc",
            "sizeof(epic_softc_t)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(epic_softc_t)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\n#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))\n#define EPIC_NOIFMEDIA\t1\n\nvoid\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}"
  },
  {
    "function_name": "epic_freebsd_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "419-431",
    "snippet": "const char*\nepic_freebsd_probe(\n    pcici_t config_id,\n    pcidi_t device_id)\n{\n\tif( PCI_VENDORID(device_id) != SMC_VENDORID )\n\t\treturn NULL;\n\n\tif( PCI_CHIPID(device_id) == CHIPID_83C170 )\n\t\treturn \"SMC 83c170\";\n\n\treturn NULL;\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "device_id"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDORID",
          "args": [
            "device_id"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nconst char*\nepic_freebsd_probe(\n    pcici_t config_id,\n    pcidi_t device_id)\n{\n\tif( PCI_VENDORID(device_id) != SMC_VENDORID )\n\t\treturn NULL;\n\n\tif( PCI_CHIPID(device_id) == CHIPID_83C170 )\n\t\treturn \"SMC 83c170\";\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "epic_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "391-396",
    "snippet": "void\nepic_shutdown(\n    void *sc)\n{\n\tepic_stop(sc);\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "epic_stop",
          "args": [
            "sc"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nvoid\nepic_shutdown(\n    void *sc)\n{\n\tepic_stop(sc);\n}"
  },
  {
    "function_name": "epic_openbsd_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "236-388",
    "snippet": "void\nepic_openbsd_attach(\n    struct device *parent,\n    struct device *self,\n    void *aux )\n{\n\tepic_softc_t *sc = (epic_softc_t*)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tstruct ifnet *ifp;\n\tbus_addr_t iobase;\n\tbus_size_t iosize; \n\tint i;\n\tu_int32_t command;\n#if !defined(EPIC_NOIFMEDIA)\n\tint tmp;\n#endif\n\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_IO_ENABLE |\n\t    PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef EPIC_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif( pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\tif( bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sc_sh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif( pci_mem_find(pc, pa->pa_tag, PCI_CBMA, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif( bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st = pa->pa_memt;\n#endif\n\n\tifp = &sc->sc_if;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname,IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\n\t/* Do common attach procedure */\n\tif( epic_common_attach(sc) ) return;\n\n\t/* Map interrupt */\n\tif( pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": can't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, epic_intr, sc, \n\t    self->dv_xname);\n\n\tif( NULL == sc->sc_ih ) {\n\t\tprintf(\": can't establish interrupt\");\n\t\tif( intrstr )printf(\" at %s\",intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t} \n\tprintf(\": %s\",intrstr);\n\n\t/* Display some info */\n\tprintf(\" address %s\",ether_sprintf(sc->sc_macaddr));\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps\");\n\t\telse printf(\"10Mbps\");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\" FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\" FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\t/* Attach os interface and bpf */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\t/* Set shutdown routine to stop DMA process */ \n\tshutdownhook_establish(epic_shutdown, sc);\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))",
      "#define EPIC_NOIFMEDIA\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "epic_shutdown",
            "sc"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->ifmedia",
            "tmp"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "epic_mtypes[i]",
            "0",
            "NULL"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->ifmedia",
            "0",
            "epic_ifmedia_change",
            "epic_ifmedia_status"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_LPAR"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ_2",
          "args": [
            "sc",
            "DP83840_BMCR"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_macaddr"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "epic_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epic_common_attach",
          "args": [
            "sc"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "epic_common_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "756-805",
          "snippet": "int\nepic_common_attach(\n    epic_softc_t *sc)\n{\n\tint i;\n\tcaddr_t pool;\n\n\ti = sizeof(struct epic_frag_list)*TX_RING_SIZE +\n\t    sizeof(struct epic_rx_desc)*RX_RING_SIZE + \n\t    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE,\n\tsc->pool = (epic_softc_t *) malloc( i, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->pool == NULL) {\n\t\tprintf(\": can't allocate memory for buffers\\n\");\n\t\treturn -1;\n\t}\n\tbzero(sc->pool, i);\n\n\t/* Align pool on PAGE_SIZE */\n\tpool = (caddr_t)sc->pool;\n\tpool = (caddr_t)((u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));\n\n\t/* Distribute memory */\n\tsc->tx_flist = (void *)pool;\n\tpool += sizeof(struct epic_frag_list)*TX_RING_SIZE;\n\tsc->rx_desc = (void *)pool;\n\tpool += sizeof(struct epic_rx_desc)*RX_RING_SIZE;\n\tsc->tx_desc = (void *)pool;\n\n\t/* Bring the chip out of low-power mode. */\n\tCSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);\n\n\t/* Workaround for Application Note 7-15 */\n\tfor (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);\n\n\t/* Read mac address from EEPROM */\n\tfor (i = 0; i < ETHER_ADDR_LEN / sizeof(u_int16_t); i++)\n\t\t((u_int16_t *)sc->sc_macaddr)[i] = epic_read_eeprom(sc,i);\n\n\t/* Identify PHY */\n\tsc->phyid = PHY_READ_2(sc, DP83840_PHYIDR1 )<<6;\n\tsc->phyid|= (PHY_READ_2( sc, DP83840_PHYIDR2 )>>10)&0x3F;\n\tif( QS6612_OUI != sc->phyid ) \n\t\tprintf(\": WARNING! PHY unknown (0x%x)\",sc->phyid);\n\n\tsc->tx_threshold = TRANSMIT_THRESHOLD;\n\tsc->txcon = TXCON_DEFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint\nepic_common_attach(\n    epic_softc_t *sc)\n{\n\tint i;\n\tcaddr_t pool;\n\n\ti = sizeof(struct epic_frag_list)*TX_RING_SIZE +\n\t    sizeof(struct epic_rx_desc)*RX_RING_SIZE + \n\t    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE,\n\tsc->pool = (epic_softc_t *) malloc( i, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->pool == NULL) {\n\t\tprintf(\": can't allocate memory for buffers\\n\");\n\t\treturn -1;\n\t}\n\tbzero(sc->pool, i);\n\n\t/* Align pool on PAGE_SIZE */\n\tpool = (caddr_t)sc->pool;\n\tpool = (caddr_t)((u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));\n\n\t/* Distribute memory */\n\tsc->tx_flist = (void *)pool;\n\tpool += sizeof(struct epic_frag_list)*TX_RING_SIZE;\n\tsc->rx_desc = (void *)pool;\n\tpool += sizeof(struct epic_rx_desc)*RX_RING_SIZE;\n\tsc->tx_desc = (void *)pool;\n\n\t/* Bring the chip out of low-power mode. */\n\tCSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);\n\n\t/* Workaround for Application Note 7-15 */\n\tfor (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);\n\n\t/* Read mac address from EEPROM */\n\tfor (i = 0; i < ETHER_ADDR_LEN / sizeof(u_int16_t); i++)\n\t\t((u_int16_t *)sc->sc_macaddr)[i] = epic_read_eeprom(sc,i);\n\n\t/* Identify PHY */\n\tsc->phyid = PHY_READ_2(sc, DP83840_PHYIDR1 )<<6;\n\tsc->phyid|= (PHY_READ_2( sc, DP83840_PHYIDR2 )>>10)&0x3F;\n\tif( QS6612_OUI != sc->phyid ) \n\t\tprintf(\": WARNING! PHY unknown (0x%x)\",sc->phyid);\n\n\tsc->tx_threshold = TRANSMIT_THRESHOLD;\n\tsc->txcon = TXCON_DEFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->sc_sh"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_CBMA",
            "&iobase",
            "&iosize",
            "NULL"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&sc->sc_sh"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_CBIO",
            "&iobase",
            "&iosize"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\n#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))\n#define EPIC_NOIFMEDIA\t1\n\nvoid\nepic_openbsd_attach(\n    struct device *parent,\n    struct device *self,\n    void *aux )\n{\n\tepic_softc_t *sc = (epic_softc_t*)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tstruct ifnet *ifp;\n\tbus_addr_t iobase;\n\tbus_size_t iosize; \n\tint i;\n\tu_int32_t command;\n#if !defined(EPIC_NOIFMEDIA)\n\tint tmp;\n#endif\n\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_IO_ENABLE |\n\t    PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef EPIC_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif( pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\tif( bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sc_sh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\treturn;\n\t}\n\tif( pci_mem_find(pc, pa->pa_tag, PCI_CBMA, &iobase, &iosize, NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t\treturn;\n\t}\n\tif( bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st = pa->pa_memt;\n#endif\n\n\tifp = &sc->sc_if;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname,IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\n\t/* Do common attach procedure */\n\tif( epic_common_attach(sc) ) return;\n\n\t/* Map interrupt */\n\tif( pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": can't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, epic_intr, sc, \n\t    self->dv_xname);\n\n\tif( NULL == sc->sc_ih ) {\n\t\tprintf(\": can't establish interrupt\");\n\t\tif( intrstr )printf(\" at %s\",intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t} \n\tprintf(\": %s\",intrstr);\n\n\t/* Display some info */\n\tprintf(\" address %s\",ether_sprintf(sc->sc_macaddr));\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps\");\n\t\telse printf(\"10Mbps\");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\" FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\" FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\t/* Attach os interface and bpf */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\t/* Set shutdown routine to stop DMA process */ \n\tshutdownhook_establish(epic_shutdown, sc);\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "epic_openbsd_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
    "lines": "220-234",
    "snippet": "int \nepic_openbsd_probe(\n    struct device *parent,\n    void *match,\n    void *aux )\n{\n\tstruct pci_attach_args *pa = aux;\n\tif( PCI_VENDOR(pa->pa_id) != SMC_VENDORID )\n\t\treturn 0;\n\n\tif( PCI_PRODUCT(pa->pa_id) == CHIPID_83C170 )\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <pci/if_txvar.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_mib.h>",
      "#include <dev/pci/if_txvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sockio.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\nint \nepic_openbsd_probe(\n    struct device *parent,\n    void *match,\n    void *aux )\n{\n\tstruct pci_attach_args *pa = aux;\n\tif( PCI_VENDOR(pa->pa_id) != SMC_VENDORID )\n\t\treturn 0;\n\n\tif( PCI_PRODUCT(pa->pa_id) == CHIPID_83C170 )\n\t\treturn 1;\n\n\treturn 0;\n}"
  }
]