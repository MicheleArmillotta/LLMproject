[
  {
    "function_name": "ad1848_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1683-1691",
    "snippet": "int\nad1848_get_props(addr)\n\tvoid *addr;\n{\n\tstruct ad1848_softc *sc = addr;\n\n\treturn AUDIO_PROP_MMAP |\n\t       (sc->sc_drq != sc->sc_recdrq ? AUDIO_PROP_FULLDUPLEX : 0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_get_props(addr)\n\tvoid *addr;\n{\n\tstruct ad1848_softc *sc = addr;\n\n\treturn AUDIO_PROP_MMAP |\n\t       (sc->sc_drq != sc->sc_recdrq ? AUDIO_PROP_FULLDUPLEX : 0);\n}"
  },
  {
    "function_name": "ad1848_mappage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1673-1681",
    "snippet": "int\nad1848_mappage(addr, mem, off, prot)\n\tvoid *addr;\n        void *mem;\n        int off;\n\tint prot;\n{\n\treturn isa_mappage(mem, off, prot);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_mappage",
          "args": [
            "mem",
            "off",
            "prot"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "isa_mappage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "729-745",
          "snippet": "int\nisa_mappage(mem, off, prot)\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\tstruct isa_mem *m;\n\n\tfor(m = isa_mem_head; m && m->kva != (caddr_t)mem; m = m->next)\n\t\t;\n\tif (!m) {\n\t\tprintf(\"isa_mappage: mapping unallocted memory\\n\");\n\t\treturn -1;\n\t}\n\treturn (isa_dmamem_mmap(m->isadev, m->chan, m->addr, m->size, off,\n\t    prot, BUS_DMA_WAITOK));\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\n\nint\nisa_mappage(mem, off, prot)\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\tstruct isa_mem *m;\n\n\tfor(m = isa_mem_head; m && m->kva != (caddr_t)mem; m = m->next)\n\t\t;\n\tif (!m) {\n\t\tprintf(\"isa_mappage: mapping unallocted memory\\n\");\n\t\treturn -1;\n\t}\n\treturn (isa_dmamem_mmap(m->isadev, m->chan, m->addr, m->size, off,\n\t    prot, BUS_DMA_WAITOK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_mappage(addr, mem, off, prot)\n\tvoid *addr;\n        void *mem;\n        int off;\n\tint prot;\n{\n\treturn isa_mappage(mem, off, prot);\n}"
  },
  {
    "function_name": "ad1848_round",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1663-1671",
    "snippet": "unsigned long\nad1848_round(addr, size)\n\tvoid *addr;\n\tunsigned long size;\n{\n\tif (size > MAX_ISADMA)\n\t\tsize = MAX_ISADMA;\n\treturn size;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "unsigned long size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\nunsigned long size;\n\nunsigned long\nad1848_round(addr, size)\n\tvoid *addr;\n\tunsigned long size;\n{\n\tif (size > MAX_ISADMA)\n\t\tsize = MAX_ISADMA;\n\treturn size;\n}"
  },
  {
    "function_name": "ad1848_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1654-1661",
    "snippet": "void\nad1848_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int pool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_free",
          "args": [
            "ptr",
            "pool"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "isa_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "708-727",
          "snippet": "void\nisa_free(addr, pool)\n\tvoid *addr;\n\tint pool;\n{\n\tstruct isa_mem **mp, *m;\n\tcaddr_t kva = (caddr_t)addr;\n\n\tfor(mp = &isa_mem_head; *mp && (*mp)->kva != kva; mp = &(*mp)->next)\n\t\t;\n\tm = *mp;\n\tif (!m) {\n\t\tprintf(\"isa_free: freeing unallocted memory\\n\");\n\t\treturn;\n\t}\n\t*mp = m->next;\n\tisa_dmamem_unmap(m->isadev, m->chan, kva, m->size);\n\tisa_dmamem_free(m->isadev, m->chan, m->addr, m->size);\n\tfree(m, pool);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;",
            "int pool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct isa_mem {\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tbus_addr_t addr;\n\tcaddr_t kva;\n\tstruct isa_mem *next;\n} *isa_mem_head = 0;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\nint pool;\n\nvoid\nisa_free(addr, pool)\n\tvoid *addr;\n\tint pool;\n{\n\tstruct isa_mem **mp, *m;\n\tcaddr_t kva = (caddr_t)addr;\n\n\tfor(mp = &isa_mem_head; *mp && (*mp)->kva != kva; mp = &(*mp)->next)\n\t\t;\n\tm = *mp;\n\tif (!m) {\n\t\tprintf(\"isa_free: freeing unallocted memory\\n\");\n\t\treturn;\n\t}\n\t*mp = m->next;\n\tisa_dmamem_unmap(m->isadev, m->chan, kva, m->size);\n\tisa_dmamem_free(m->isadev, m->chan, m->addr, m->size);\n\tfree(m, pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool;\n\nvoid\nad1848_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}"
  },
  {
    "function_name": "ad1848_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1607-1640",
    "snippet": "int\nad1848_intr(arg)\n\tvoid *arg;\n{\n    struct ad1848_softc *sc = arg;\n    int retval = 0;\n    u_char status;\n    \n    /* Get intr status */\n    status = ADREAD(sc, AD1848_STATUS);\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_intr: intr=%p status=%x\\n\", sc->sc_intr, status);\n#endif\n    sc->sc_locked = 0;\n    sc->sc_interrupts++;\n    \n    /* Handle interrupt */\n    if (sc->sc_intr && (status & INTERRUPT_STATUS)) {\n\t/* ACK DMA read because it may be in a bounce buffer */\n\t/* XXX Do write to mask DMA ? */\n\tif ((sc->sc_dma_flags & DMAMODE_READ) && sc->sc_recrun == NOTRUNNING)\n\t    isa_dmadone(sc->sc_isa, sc->sc_recdrq);\n\t(*sc->sc_intr)(sc->sc_arg);\n\tretval = 1;\n    }\n\n    /* clear interrupt */\n    if (status & INTERRUPT_STATUS)\n\tADWRITE(sc, AD1848_STATUS, 0);\n\n    return(retval);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_STATUS",
            "0"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_arg"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmadone",
          "args": [
            "sc->sc_isa",
            "sc->sc_recdrq"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmadone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "513-540",
          "snippet": "void\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ad1848_intr: intr=%p status=%x\\n\"",
            "sc->sc_intr",
            "status"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_STATUS"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_intr(arg)\n\tvoid *arg;\n{\n    struct ad1848_softc *sc = arg;\n    int retval = 0;\n    u_char status;\n    \n    /* Get intr status */\n    status = ADREAD(sc, AD1848_STATUS);\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_intr: intr=%p status=%x\\n\", sc->sc_intr, status);\n#endif\n    sc->sc_locked = 0;\n    sc->sc_interrupts++;\n    \n    /* Handle interrupt */\n    if (sc->sc_intr && (status & INTERRUPT_STATUS)) {\n\t/* ACK DMA read because it may be in a bounce buffer */\n\t/* XXX Do write to mask DMA ? */\n\tif ((sc->sc_dma_flags & DMAMODE_READ) && sc->sc_recrun == NOTRUNNING)\n\t    isa_dmadone(sc->sc_isa, sc->sc_recdrq);\n\t(*sc->sc_intr)(sc->sc_arg);\n\tretval = 1;\n    }\n\n    /* clear interrupt */\n    if (status & INTERRUPT_STATUS)\n\tADWRITE(sc, AD1848_STATUS, 0);\n\n    return(retval);\n}"
  },
  {
    "function_name": "ad1848_dma_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1548-1605",
    "snippet": "int\nad1848_dma_output(addr, p, cc, intr, arg)\n    void *addr;\n    void *p;\n    int cc;\n    void (*intr) __P((void *));\n    void *arg;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n    \n    if (sc->sc_locked) {\n\tDPRINTF((\"ad1848_dma_output: locked\\n\"));\n\treturn 0;\n    }\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 0)\n\tprintf(\"ad1848_dma_output: cc=%d at %p 0x%p (0x%p)\\n\", cc, p, intr, arg);\n#endif\n    sc->sc_locked = 1;\n    sc->sc_intr = intr;\n    sc->sc_arg = arg;\n\n    switch (sc->sc_playrun) {\n    case NOTRUNNING:\n\tsc->sc_dma_flags = DMAMODE_WRITE;\n\tsc->sc_dma_bp = p;\n\tsc->sc_dma_cnt = cc;\n\tisa_dmastart(sc->sc_isa, sc->sc_drq, p, cc, NULL,\n\t\t     DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\tgoto startpcm;\n    case DMARUNNING:\n\tsc->sc_playrun = PCMRUNNING;\n    startpcm:\n\tif (sc->precision == 16)\n\t    cc >>= 1;\n\tif (sc->channels == 2)\n\t    cc >>= 1;\n\tcc--;\n\n\tif (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_PLAY) {\n\t    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));\n\t    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));\n\n\t    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n\t    ad_write(sc, SP_INTERFACE_CONFIG, (PLAYBACK_ENABLE|reg));\n\n\t    sc->sc_lastcc = cc;\n\t    sc->sc_mode = AUMODE_PLAY;\n\t}\n\tbreak;\n    case PCMRUNNING:\n\tbreak;\n    }\n    \n    return 0;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG",
            "(PLAYBACK_ENABLE|reg)"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(cc >> 8) & 0xff"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc & 0xff"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_isa",
            "sc->sc_drq",
            "p",
            "cc",
            "NULL",
            "DMAMODE_WRITE",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ad1848_dma_output: cc=%d at %p 0x%p (0x%p)\\n\"",
            "cc",
            "p",
            "intr",
            "arg"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_dma_output: locked\\n\")"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_dma_output(addr, p, cc, intr, arg)\n    void *addr;\n    void *p;\n    int cc;\n    void (*intr) __P((void *));\n    void *arg;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n    \n    if (sc->sc_locked) {\n\tDPRINTF((\"ad1848_dma_output: locked\\n\"));\n\treturn 0;\n    }\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 0)\n\tprintf(\"ad1848_dma_output: cc=%d at %p 0x%p (0x%p)\\n\", cc, p, intr, arg);\n#endif\n    sc->sc_locked = 1;\n    sc->sc_intr = intr;\n    sc->sc_arg = arg;\n\n    switch (sc->sc_playrun) {\n    case NOTRUNNING:\n\tsc->sc_dma_flags = DMAMODE_WRITE;\n\tsc->sc_dma_bp = p;\n\tsc->sc_dma_cnt = cc;\n\tisa_dmastart(sc->sc_isa, sc->sc_drq, p, cc, NULL,\n\t\t     DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\tgoto startpcm;\n    case DMARUNNING:\n\tsc->sc_playrun = PCMRUNNING;\n    startpcm:\n\tif (sc->precision == 16)\n\t    cc >>= 1;\n\tif (sc->channels == 2)\n\t    cc >>= 1;\n\tcc--;\n\n\tif (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_PLAY) {\n\t    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));\n\t    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));\n\n\t    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n\t    ad_write(sc, SP_INTERFACE_CONFIG, (PLAYBACK_ENABLE|reg));\n\n\t    sc->sc_lastcc = cc;\n\t    sc->sc_mode = AUMODE_PLAY;\n\t}\n\tbreak;\n    case PCMRUNNING:\n\tbreak;\n    }\n    \n    return 0;\n}"
  },
  {
    "function_name": "ad1848_dma_init_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1530-1546",
    "snippet": "int\nad1848_dma_init_output(addr, buf, cc)\n    void *addr;\n    void *buf;\n    int cc;\n{\n    struct ad1848_softc *sc = addr;\n\n    sc->sc_playrun = DMARUNNING;\n    sc->sc_dma_flags = DMAMODE_WRITE | DMAMODE_LOOP;\n    sc->sc_dma_bp = buf;\n    sc->sc_dma_cnt = cc;\n    isa_dmastart(sc->sc_isa, sc->sc_drq, buf, cc, NULL,\n\t\t sc->sc_dma_flags, BUS_DMA_NOWAIT);\n    DPRINTF((\"ad1848_dma_init_output: %p %d\\n\", buf, cc));\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_dma_init_output: %p %d\\n\", buf, cc)"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_isa",
            "sc->sc_drq",
            "buf",
            "cc",
            "NULL",
            "sc->sc_dma_flags",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_dma_init_output(addr, buf, cc)\n    void *addr;\n    void *buf;\n    int cc;\n{\n    struct ad1848_softc *sc = addr;\n\n    sc->sc_playrun = DMARUNNING;\n    sc->sc_dma_flags = DMAMODE_WRITE | DMAMODE_LOOP;\n    sc->sc_dma_bp = buf;\n    sc->sc_dma_cnt = cc;\n    isa_dmastart(sc->sc_isa, sc->sc_drq, buf, cc, NULL,\n\t\t sc->sc_dma_flags, BUS_DMA_NOWAIT);\n    DPRINTF((\"ad1848_dma_init_output: %p %d\\n\", buf, cc));\n    return 0;\n}"
  },
  {
    "function_name": "ad1848_dma_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1463-1528",
    "snippet": "int\nad1848_dma_input(addr, p, cc, intr, arg)\n    void *addr;\n    void *p;\n    int cc;\n    void (*intr) __P((void *));\n    void *arg;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n    \n    if (sc->sc_locked) {\n\tDPRINTF((\"ad1848_dma_input: locked\\n\"));\n\treturn 0;\n    }\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_dma_input: cc=%d %p (%p)\\n\", cc, intr, arg);\n#endif\n    sc->sc_locked = 1;\n    sc->sc_intr = intr;\n    sc->sc_arg = arg;\n\n    switch (sc->sc_recrun) {\n    case NOTRUNNING:\n\tsc->sc_dma_flags = DMAMODE_READ;\n\tsc->sc_dma_bp = p;\n\tsc->sc_dma_cnt = cc;\n\tisa_dmastart(sc->sc_isa, sc->sc_recdrq, p, cc, NULL,\n\t\t     DMAMODE_READ, BUS_DMA_NOWAIT);\n\tgoto startpcm;\n    case DMARUNNING:\n\tsc->sc_recrun = PCMRUNNING;\n    startpcm:\n\tif (sc->precision == 16)\n\t    cc >>= 1;\n\tif (sc->channels == 2)\n\t    cc >>= 1;\n\tcc--;\n    \n\tif (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_RECORD) {\n\t    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));\n\t    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));\n\n\t    if (sc->mode == 2) {\n\t\tad_write(sc, CS_LOWER_REC_CNT, (u_char)(cc & 0xff));\n\t\tad_write(sc, CS_UPPER_REC_CNT, (u_char)((cc >> 8) & 0xff));\n\t    }\n\n\t    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n\t    ad_write(sc, SP_INTERFACE_CONFIG, (CAPTURE_ENABLE|reg));\n\n\t    sc->sc_lastcc = cc;\n\t    sc->sc_mode = AUMODE_RECORD;\n#ifdef AUDIO_DEBUG\n\t    if (ad1848debug > 1)\n\t\t    printf(\"ad1848_dma_input: started capture\\n\");\n#endif\n\t}\n    case PCMRUNNING:\n\tbreak;\n    }\n    \n    return 0;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ad1848_dma_input: started capture\\n\""
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG",
            "(CAPTURE_ENABLE|reg)"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(cc >> 8) & 0xff"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc & 0xff"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(cc >> 8) & 0xff"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc & 0xff"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_isa",
            "sc->sc_recdrq",
            "p",
            "cc",
            "NULL",
            "DMAMODE_READ",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_dma_input: locked\\n\")"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_dma_input(addr, p, cc, intr, arg)\n    void *addr;\n    void *p;\n    int cc;\n    void (*intr) __P((void *));\n    void *arg;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n    \n    if (sc->sc_locked) {\n\tDPRINTF((\"ad1848_dma_input: locked\\n\"));\n\treturn 0;\n    }\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_dma_input: cc=%d %p (%p)\\n\", cc, intr, arg);\n#endif\n    sc->sc_locked = 1;\n    sc->sc_intr = intr;\n    sc->sc_arg = arg;\n\n    switch (sc->sc_recrun) {\n    case NOTRUNNING:\n\tsc->sc_dma_flags = DMAMODE_READ;\n\tsc->sc_dma_bp = p;\n\tsc->sc_dma_cnt = cc;\n\tisa_dmastart(sc->sc_isa, sc->sc_recdrq, p, cc, NULL,\n\t\t     DMAMODE_READ, BUS_DMA_NOWAIT);\n\tgoto startpcm;\n    case DMARUNNING:\n\tsc->sc_recrun = PCMRUNNING;\n    startpcm:\n\tif (sc->precision == 16)\n\t    cc >>= 1;\n\tif (sc->channels == 2)\n\t    cc >>= 1;\n\tcc--;\n    \n\tif (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_RECORD) {\n\t    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));\n\t    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));\n\n\t    if (sc->mode == 2) {\n\t\tad_write(sc, CS_LOWER_REC_CNT, (u_char)(cc & 0xff));\n\t\tad_write(sc, CS_UPPER_REC_CNT, (u_char)((cc >> 8) & 0xff));\n\t    }\n\n\t    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n\t    ad_write(sc, SP_INTERFACE_CONFIG, (CAPTURE_ENABLE|reg));\n\n\t    sc->sc_lastcc = cc;\n\t    sc->sc_mode = AUMODE_RECORD;\n#ifdef AUDIO_DEBUG\n\t    if (ad1848debug > 1)\n\t\t    printf(\"ad1848_dma_input: started capture\\n\");\n#endif\n\t}\n    case PCMRUNNING:\n\tbreak;\n    }\n    \n    return 0;\n}"
  },
  {
    "function_name": "ad1848_dma_init_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1442-1458",
    "snippet": "int\nad1848_dma_init_input(addr, buf, cc)\n    void *addr;\n    void *buf;\n    int cc;\n{\n    struct ad1848_softc *sc = addr;\n\n    sc->sc_recrun = DMARUNNING;\n    sc->sc_dma_flags = DMAMODE_READ | DMAMODE_LOOP;\n    sc->sc_dma_bp = buf;\n    sc->sc_dma_cnt = cc;\n    isa_dmastart(sc->sc_isa, sc->sc_recdrq, buf, cc, NULL,\n\t\t sc->sc_dma_flags, BUS_DMA_NOWAIT);\n    DPRINTF((\"ad1848_dma_init_input: %p %d\\n\", buf, cc));\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_dma_init_input: %p %d\\n\", buf, cc)"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_isa",
            "sc->sc_recdrq",
            "buf",
            "cc",
            "NULL",
            "sc->sc_dma_flags",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_dma_init_input(addr, buf, cc)\n    void *addr;\n    void *buf;\n    int cc;\n{\n    struct ad1848_softc *sc = addr;\n\n    sc->sc_recrun = DMARUNNING;\n    sc->sc_dma_flags = DMAMODE_READ | DMAMODE_LOOP;\n    sc->sc_dma_bp = buf;\n    sc->sc_dma_cnt = cc;\n    isa_dmastart(sc->sc_isa, sc->sc_recdrq, buf, cc, NULL,\n\t\t sc->sc_dma_flags, BUS_DMA_NOWAIT);\n    DPRINTF((\"ad1848_dma_init_input: %p %d\\n\", buf, cc));\n    return 0;\n}"
  },
  {
    "function_name": "ad1848_halt_in_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1426-1440",
    "snippet": "int\nad1848_halt_in_dma(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n    \n    DPRINTF((\"ad1848: ad1848_halt_in_dma\\n\"));\n\n    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n    ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~CAPTURE_ENABLE));\n    sc->sc_locked = 0;\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG",
            "(reg & ~CAPTURE_ENABLE)"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: ad1848_halt_in_dma\\n\")"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_halt_in_dma(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n    \n    DPRINTF((\"ad1848: ad1848_halt_in_dma\\n\"));\n\n    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n    ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~CAPTURE_ENABLE));\n    sc->sc_locked = 0;\n\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_halt_out_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1410-1424",
    "snippet": "int\nad1848_halt_out_dma(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n\t\n    DPRINTF((\"ad1848: ad1848_halt_out_dma\\n\"));\n\n    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n    ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~PLAYBACK_ENABLE));\n    sc->sc_locked = 0;\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG",
            "(reg & ~PLAYBACK_ENABLE)"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: ad1848_halt_out_dma\\n\")"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_halt_out_dma(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char reg;\n\t\n    DPRINTF((\"ad1848: ad1848_halt_out_dma\\n\"));\n\n    reg = ad_read(sc, SP_INTERFACE_CONFIG);\n    ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~PLAYBACK_ENABLE));\n    sc->sc_locked = 0;\n\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_set_speed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1334-1405",
    "snippet": "int\nad1848_set_speed(sc, argp)\n    struct ad1848_softc *sc;\n    u_long *argp;\n{\n    /*\n     * The sampling speed is encoded in the least significant nible of I8. The\n     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 Mhz) and other\n     * three bits select the divisor (indirectly):\n     *\n     * The available speeds are in the following table. Keep the speeds in\n     * the increasing order.\n     */\n    typedef struct {\n\tint\tspeed;\n\tu_char\tbits;\n    } speed_struct;\n    u_long arg = *argp;\n\n    static speed_struct speed_table[] =  {\n\t{5510, (0 << 1) | 1},\n\t{5510, (0 << 1) | 1},\n\t{6620, (7 << 1) | 1},\n\t{8000, (0 << 1) | 0},\n\t{9600, (7 << 1) | 0},\n\t{11025, (1 << 1) | 1},\n\t{16000, (1 << 1) | 0},\n\t{18900, (2 << 1) | 1},\n\t{22050, (3 << 1) | 1},\n\t{27420, (2 << 1) | 0},\n\t{32000, (3 << 1) | 0},\n\t{33075, (6 << 1) | 1},\n\t{37800, (4 << 1) | 1},\n\t{44100, (5 << 1) | 1},\n\t{48000, (6 << 1) | 0}\n    };\n\n    int i, n, selected = -1;\n\n    n = sizeof(speed_table) / sizeof(speed_struct);\n\n    if (arg < speed_table[0].speed)\n\tselected = 0;\n    if (arg > speed_table[n - 1].speed)\n\tselected = n - 1;\n\n    for (i = 1 /*really*/ ; selected == -1 && i < n; i++)\n\tif (speed_table[i].speed == arg)\n\t    selected = i;\n\telse if (speed_table[i].speed > arg) {\n\t    int diff1, diff2;\n\n\t    diff1 = arg - speed_table[i - 1].speed;\n\t    diff2 = speed_table[i].speed - arg;\n\n\t    if (diff1 < diff2)\n\t\tselected = i - 1;\n\t    else\n\t\tselected = i;\n\t}\n\n    if (selected == -1) {\n\tprintf(\"ad1848: Can't find speed???\\n\");\n\tselected = 3;\n    }\n\n    sc->speed_bits = speed_table[selected].bits;\n    sc->need_commit = 1;\n    *argp = speed_table[selected].speed;\n\n    return (0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tad1848_set_speed"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ad1848: Can't find speed???\\n\""
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tad1848_set_speed;\n\nint\nad1848_set_speed(sc, argp)\n    struct ad1848_softc *sc;\n    u_long *argp;\n{\n    /*\n     * The sampling speed is encoded in the least significant nible of I8. The\n     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 Mhz) and other\n     * three bits select the divisor (indirectly):\n     *\n     * The available speeds are in the following table. Keep the speeds in\n     * the increasing order.\n     */\n    typedef struct {\n\tint\tspeed;\n\tu_char\tbits;\n    } speed_struct;\n    u_long arg = *argp;\n\n    static speed_struct speed_table[] =  {\n\t{5510, (0 << 1) | 1},\n\t{5510, (0 << 1) | 1},\n\t{6620, (7 << 1) | 1},\n\t{8000, (0 << 1) | 0},\n\t{9600, (7 << 1) | 0},\n\t{11025, (1 << 1) | 1},\n\t{16000, (1 << 1) | 0},\n\t{18900, (2 << 1) | 1},\n\t{22050, (3 << 1) | 1},\n\t{27420, (2 << 1) | 0},\n\t{32000, (3 << 1) | 0},\n\t{33075, (6 << 1) | 1},\n\t{37800, (4 << 1) | 1},\n\t{44100, (5 << 1) | 1},\n\t{48000, (6 << 1) | 0}\n    };\n\n    int i, n, selected = -1;\n\n    n = sizeof(speed_table) / sizeof(speed_struct);\n\n    if (arg < speed_table[0].speed)\n\tselected = 0;\n    if (arg > speed_table[n - 1].speed)\n\tselected = n - 1;\n\n    for (i = 1 /*really*/ ; selected == -1 && i < n; i++)\n\tif (speed_table[i].speed == arg)\n\t    selected = i;\n\telse if (speed_table[i].speed > arg) {\n\t    int diff1, diff2;\n\n\t    diff1 = arg - speed_table[i - 1].speed;\n\t    diff2 = speed_table[i].speed - arg;\n\n\t    if (diff1 < diff2)\n\t\tselected = i - 1;\n\t    else\n\t\tselected = i;\n\t}\n\n    if (selected == -1) {\n\tprintf(\"ad1848: Can't find speed???\\n\");\n\tselected = 3;\n    }\n\n    sc->speed_bits = speed_table[selected].bits;\n    sc->need_commit = 1;\n    *argp = speed_table[selected].speed;\n\n    return (0);\n}"
  },
  {
    "function_name": "ad1848_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1309-1332",
    "snippet": "void\nad1848_reset(sc)\n    struct ad1848_softc *sc;\n{\n    u_char r;\n    \n    DPRINTF((\"ad1848_reset\\n\"));\n    \n    /* Clear the PEN and CEN bits */\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n    if (sc->mode == 2) {\n\t    ADWRITE(sc, AD1848_IADDR, CS_IRQ_STATUS);\n\t    ADWRITE(sc, AD1848_IDATA, 0);\n    }\n    /* Clear interrupt status */\n    ADWRITE(sc, AD1848_STATUS, 0);\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tad1848_reset",
      "static int ad_read",
      "static void ad_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_dump_regs",
          "args": [
            "sc"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_dump_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "250-270",
          "snippet": "void\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nvoid\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_STATUS",
            "0"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IDATA",
            "0"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IADDR",
            "CS_IRQ_STATUS"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG",
            "r"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_reset\\n\")"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tad1848_reset;\nstatic int ad_read;\nstatic void ad_write;\n\nvoid\nad1848_reset(sc)\n    struct ad1848_softc *sc;\n{\n    u_char r;\n    \n    DPRINTF((\"ad1848_reset\\n\"));\n    \n    /* Clear the PEN and CEN bits */\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n    if (sc->mode == 2) {\n\t    ADWRITE(sc, AD1848_IADDR, CS_IRQ_STATUS);\n\t    ADWRITE(sc, AD1848_IDATA, 0);\n    }\n    /* Clear interrupt status */\n    ADWRITE(sc, AD1848_STATUS, 0);\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}"
  },
  {
    "function_name": "ad1848_commit_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1233-1307",
    "snippet": "int\nad1848_commit_settings(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    int timeout;\n    u_char fs;\n    int s;\n\n    if (!sc->need_commit)\n\treturn 0;\n\n    s = splaudio();\n    \n    ad1848_mute_monitor(sc, 1);\n    \n    ad_set_MCE(sc, 1);\t\t/* Enables changes to the format select reg */\n\n    fs = sc->speed_bits | (sc->format_bits << 5);\n\n    if (sc->channels == 2)\n\tfs |= FMT_STEREO;\n\n    ad_write(sc, SP_CLOCK_DATA_FORMAT, fs);\n\n    /*\n     * If mode == 2 (CS4231), set I28 also. It's the capture format register.\n     */\n    if (sc->mode == 2) {\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/*\n\t * Write to I8 starts resyncronization. Wait until it completes.\n\t */\n\ttimeout = 100000;\n\twhile (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\t    timeout--;\n\n\tad_write(sc, CS_REC_FORMAT, fs);\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/* Now wait for resync for capture side of the house */\n    }\n    /*\n     * Write to I8 starts resyncronization. Wait until it completes.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tprintf(\"ad1848_commit: Auto calibration timed out\\n\");\n\n    /*\n     * Starts the calibration process and\n     * enters playback mode after it.\n     */\n    ad_set_MCE(sc, 0);\n    wait_for_calibration(sc);\n\n    ad1848_mute_monitor(sc, 0);\n\n    sc->sc_lastcc = -1;\n\n    splx(s);\n    \n    sc->need_commit = 0;\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tad1848_mute_monitor",
      "static void ad_write",
      "static void ad_set_MCE",
      "static void wait_for_calibration",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_mute_monitor",
          "args": [
            "sc",
            "0"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mute_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "721-737",
          "snippet": "void\nad1848_mute_monitor(addr, mute)\n\tvoid *addr;\n\tint mute;\n{\n\tstruct ad1848_softc *sc = addr;\n\n\tDPRINTF((\"ad1848_mute_monitor: %smuting\\n\", mute ? \"\" : \"un\"));\n\tif (sc->mode == 2) {\n\t        ad1848_mute_channel(sc, AD1848_DAC_CHANNEL, mute ? MUTE_ALL : 0);\n\t\tad1848_mute_channel(sc, AD1848_MONO_CHANNEL, mute ? MUTE_MONO : 0);\n\t\tad1848_mute_channel(sc, AD1848_LINE_CHANNEL, mute ? MUTE_ALL : 0);\n\t}\n\t\t\n\tad1848_mute_channel(sc, AD1848_AUX2_CHANNEL, mute ? MUTE_ALL : 0);\n\tad1848_mute_channel(sc, AD1848_AUX1_CHANNEL, mute ? MUTE_ALL : 0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tad1848_mute_monitor",
            "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tad1848_mute_monitor;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\nad1848_mute_monitor(addr, mute)\n\tvoid *addr;\n\tint mute;\n{\n\tstruct ad1848_softc *sc = addr;\n\n\tDPRINTF((\"ad1848_mute_monitor: %smuting\\n\", mute ? \"\" : \"un\"));\n\tif (sc->mode == 2) {\n\t        ad1848_mute_channel(sc, AD1848_DAC_CHANNEL, mute ? MUTE_ALL : 0);\n\t\tad1848_mute_channel(sc, AD1848_MONO_CHANNEL, mute ? MUTE_MONO : 0);\n\t\tad1848_mute_channel(sc, AD1848_LINE_CHANNEL, mute ? MUTE_ALL : 0);\n\t}\n\t\t\n\tad1848_mute_channel(sc, AD1848_AUX2_CHANNEL, mute ? MUTE_ALL : 0);\n\tad1848_mute_channel(sc, AD1848_AUX1_CHANNEL, mute ? MUTE_ALL : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_calibration",
          "args": [
            "sc"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_calibration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "203-245",
          "snippet": "static void\nwait_for_calibration(sc)\n    struct ad1848_softc *sc;\n{\n    int timeout;\n\n    DPRINTF((\"ad1848: Auto calibration started.\\n\"));\n    /*\n     * Wait until the auto calibration process has finished.\n     *\n     * 1) Wait until the chip becomes ready (reads don't return 0x80).\n     * 2) Wait until the ACI bit of I11 gets on and then off.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1).\\n\"));\n\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) != SP_TEST_AND_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_TEST_AND_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1.5).\\n\"));\n\n    if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)) {\n\ttimeout = 100000;\n\twhile (timeout > 0 && !(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    timeout--;\n\n\tif (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    DPRINTF((\"ad1848: Auto calibration timed out(2).\\n\"));\n    }\n\n    timeout = 100000;\n    while (timeout > 0 && ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n\ttimeout--;\n    if (ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n        DPRINTF((\"ad1848: Auto calibration timed out(3).\\n\"));\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void wait_for_calibration"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void wait_for_calibration;\n\nstatic void\nwait_for_calibration(sc)\n    struct ad1848_softc *sc;\n{\n    int timeout;\n\n    DPRINTF((\"ad1848: Auto calibration started.\\n\"));\n    /*\n     * Wait until the auto calibration process has finished.\n     *\n     * 1) Wait until the chip becomes ready (reads don't return 0x80).\n     * 2) Wait until the ACI bit of I11 gets on and then off.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1).\\n\"));\n\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) != SP_TEST_AND_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_TEST_AND_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1.5).\\n\"));\n\n    if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)) {\n\ttimeout = 100000;\n\twhile (timeout > 0 && !(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    timeout--;\n\n\tif (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    DPRINTF((\"ad1848: Auto calibration timed out(2).\\n\"));\n    }\n\n    timeout = 100000;\n    while (timeout > 0 && ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n\ttimeout--;\n    if (ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n        DPRINTF((\"ad1848: Auto calibration timed out(3).\\n\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_set_MCE",
          "args": [
            "sc",
            "0"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "ad_set_MCE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "190-201",
          "snippet": "static void\nad_set_MCE(sc, state)\n    struct ad1848_softc *sc;\n    int state;\n{\n    if (state)\n\tsc->MCE_bit = MODE_CHANGE_ENABLE;\n    else\n\tsc->MCE_bit = 0;\n\n    ADWRITE(sc, AD1848_IADDR, sc->MCE_bit);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_set_MCE"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_set_MCE;\n\nstatic void\nad_set_MCE(sc, state)\n    struct ad1848_softc *sc;\n    int state;\n{\n    if (state)\n\tsc->MCE_bit = MODE_CHANGE_ENABLE;\n    else\n\tsc->MCE_bit = 0;\n\n    ADWRITE(sc, AD1848_IADDR, sc->MCE_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ad1848_commit: Auto calibration timed out\\n\""
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IDATA"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IDATA"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "CS_REC_FORMAT",
            "fs"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IDATA"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IDATA"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tad1848_mute_monitor;\nstatic void ad_write;\nstatic void ad_set_MCE;\nstatic void wait_for_calibration;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_commit_settings(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    int timeout;\n    u_char fs;\n    int s;\n\n    if (!sc->need_commit)\n\treturn 0;\n\n    s = splaudio();\n    \n    ad1848_mute_monitor(sc, 1);\n    \n    ad_set_MCE(sc, 1);\t\t/* Enables changes to the format select reg */\n\n    fs = sc->speed_bits | (sc->format_bits << 5);\n\n    if (sc->channels == 2)\n\tfs |= FMT_STEREO;\n\n    ad_write(sc, SP_CLOCK_DATA_FORMAT, fs);\n\n    /*\n     * If mode == 2 (CS4231), set I28 also. It's the capture format register.\n     */\n    if (sc->mode == 2) {\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/*\n\t * Write to I8 starts resyncronization. Wait until it completes.\n\t */\n\ttimeout = 100000;\n\twhile (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\t    timeout--;\n\n\tad_write(sc, CS_REC_FORMAT, fs);\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/* Now wait for resync for capture side of the house */\n    }\n    /*\n     * Write to I8 starts resyncronization. Wait until it completes.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tprintf(\"ad1848_commit: Auto calibration timed out\\n\");\n\n    /*\n     * Starts the calibration process and\n     * enters playback mode after it.\n     */\n    ad_set_MCE(sc, 0);\n    wait_for_calibration(sc);\n\n    ad1848_mute_monitor(sc, 0);\n\n    sc->sc_lastcc = -1;\n\n    splx(s);\n    \n    sc->need_commit = 0;\n    return 0;\n}"
  },
  {
    "function_name": "ad1848_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1193-1228",
    "snippet": "void\nad1848_close(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char r;\n    \n    sc->sc_intr = 0;\n\n    DPRINTF((\"ad1848_close: stop DMA\\n\"));\n    if (sc->sc_playrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_drq);\n\tsc->sc_playrun = NOTRUNNING;\n    }\n    if (sc->sc_recrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_recdrq);\n\tsc->sc_recrun = NOTRUNNING;\n    }\n    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)0);\n    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)0);\n\n    /* Disable interrupts */\n    DPRINTF((\"ad1848_close: disable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, \n\t     ad_read(sc, SP_PIN_CONTROL) & ~INTERRUPT_ENABLE);\n\n    DPRINTF((\"ad1848_close: disable capture and playback\\n\"));\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_dump_regs",
          "args": [
            "sc"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_dump_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "250-270",
          "snippet": "void\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nvoid\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG",
            "r"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_INTERFACE_CONFIG"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_close: disable capture and playback\\n\")"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_close: disable intrs\\n\")"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmaabort",
          "args": [
            "sc->sc_isa",
            "sc->sc_recdrq"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmaabort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "424-439",
          "snippet": "void\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_close: stop DMA\\n\")"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\nad1848_close(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char r;\n    \n    sc->sc_intr = 0;\n\n    DPRINTF((\"ad1848_close: stop DMA\\n\"));\n    if (sc->sc_playrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_drq);\n\tsc->sc_playrun = NOTRUNNING;\n    }\n    if (sc->sc_recrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_recdrq);\n\tsc->sc_recrun = NOTRUNNING;\n    }\n    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)0);\n    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)0);\n\n    /* Disable interrupts */\n    DPRINTF((\"ad1848_close: disable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, \n\t     ad_read(sc, SP_PIN_CONTROL) & ~INTERRUPT_ENABLE);\n\n    DPRINTF((\"ad1848_close: disable capture and playback\\n\"));\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}"
  },
  {
    "function_name": "ad1848_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1165-1188",
    "snippet": "int\nad1848_open(addr, flags)\n    void *addr;\n    int flags;\n{\n    struct ad1848_softc *sc = addr;\n\n    DPRINTF((\"ad1848_open: sc=%p\\n\", sc));\n\n    sc->sc_intr = 0;\n    sc->sc_lastcc = -1;\n    sc->sc_locked = 0;\n\n    /* Enable interrupts */\n    DPRINTF((\"ad1848_open: enable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, INTERRUPT_ENABLE|ad_read(sc, SP_PIN_CONTROL));\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_dump_regs",
          "args": [
            "sc"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_dump_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "250-270",
          "snippet": "void\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nvoid\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_PIN_CONTROL",
            "INTERRUPT_ENABLE|ad_read(sc, SP_PIN_CONTROL)"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_PIN_CONTROL"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_open: enable intrs\\n\")"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_open: sc=%p\\n\", sc)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint flags;\n\nint\nad1848_open(addr, flags)\n    void *addr;\n    int flags;\n{\n    struct ad1848_softc *sc = addr;\n\n    DPRINTF((\"ad1848_open: sc=%p\\n\", sc));\n\n    sc->sc_intr = 0;\n    sc->sc_lastcc = -1;\n    sc->sc_locked = 0;\n\n    /* Enable interrupts */\n    DPRINTF((\"ad1848_open: enable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, INTERRUPT_ENABLE|ad_read(sc, SP_PIN_CONTROL));\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n\n    return 0;\n}"
  },
  {
    "function_name": "ad1848_round_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1150-1163",
    "snippet": "int\nad1848_round_blocksize(addr, blk)\n    void *addr;\n    int blk;\n{\n    struct ad1848_softc *sc = addr;\n\n    sc->sc_lastcc = -1;\n\n    /* Round to a multiple of the biggest sample size. */\n    blk &= -4;\n\n    return (blk);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "unsigned long size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\nunsigned long size;\n\nint\nad1848_round_blocksize(addr, blk)\n    void *addr;\n    int blk;\n{\n    struct ad1848_softc *sc = addr;\n\n    sc->sc_lastcc = -1;\n\n    /* Round to a multiple of the biggest sample size. */\n    blk &= -4;\n\n    return (blk);\n}"
  },
  {
    "function_name": "ad1848_get_rec_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1143-1148",
    "snippet": "int\nad1848_get_rec_port(sc)\n    struct ad1848_softc *sc;\n{\n    return(sc->rec_port);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_rec_port(sc)\n    struct ad1848_softc *sc;\n{\n    return(sc->rec_port);\n}"
  },
  {
    "function_name": "ad1848_set_rec_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1106-1141",
    "snippet": "int\nad1848_set_rec_port(sc, port)\n    struct ad1848_softc *sc;\n    int port;\n{\n    u_char inp, reg;\n    \n    DPRINTF((\"ad1848_set_rec_port: 0x%x\\n\", port));\n\n    if (port == MIC_IN_PORT) {\n\tinp = MIC_INPUT;\n    }\n    else if (port == LINE_IN_PORT) {\n\tinp = LINE_INPUT;\n    }\n    else if (port == DAC_IN_PORT) {\n\tinp = MIXED_DAC_INPUT;\n    }\n    else if (sc->mode == 2 && port == AUX1_IN_PORT) {\n\tinp = AUX_INPUT;\n    }\n    else\n\treturn(EINVAL);\n\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp|reg));\n\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp|reg));\n\n    sc->rec_port = port;\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_RIGHT_INPUT_CONTROL",
            "(inp|reg)"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_RIGHT_INPUT_CONTROL"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_set_rec_port: 0x%x\\n\", port)"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_rec_port(sc, port)\n    struct ad1848_softc *sc;\n    int port;\n{\n    u_char inp, reg;\n    \n    DPRINTF((\"ad1848_set_rec_port: 0x%x\\n\", port));\n\n    if (port == MIC_IN_PORT) {\n\tinp = MIC_INPUT;\n    }\n    else if (port == LINE_IN_PORT) {\n\tinp = LINE_INPUT;\n    }\n    else if (port == DAC_IN_PORT) {\n\tinp = MIXED_DAC_INPUT;\n    }\n    else if (sc->mode == 2 && port == AUX1_IN_PORT) {\n\tinp = AUX_INPUT;\n    }\n    else\n\treturn(EINVAL);\n\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp|reg));\n\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp|reg));\n\n    sc->rec_port = port;\n\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "1012-1104",
    "snippet": "int\nad1848_set_params(addr, setmode, usemode, p, r)\n    void *addr;\n    int setmode, usemode;\n    struct audio_params *p, *r;\n{\n    struct ad1848_softc *sc = addr;\n    int error, bits, enc;\n    void (*pswcode) __P((void *, u_char *buf, int cnt));\n    void (*rswcode) __P((void *, u_char *buf, int cnt));\n\n    DPRINTF((\"ad1848_set_params: %d %d %d %ld\\n\", \n\t     p->encoding, p->precision, p->channels, p->sample_rate));\n\n    enc = p->encoding;\n    pswcode = rswcode = 0;\n    switch (enc) {\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 8) {\n\t    enc = AUDIO_ENCODING_ULINEAR_LE;\n\t    pswcode = rswcode = change_sign8;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16 && sc->mode == 1) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = swap_bytes;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = change_sign16;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_BE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = swap_bytes_change_sign16;\n\t    rswcode = change_sign16_swap_bytes;\n\t}\n\tbreak;\n    }\n    switch (enc) {\n    case AUDIO_ENCODING_ULAW:\n\tbits = FMT_ULAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ALAW:\n\tbits = FMT_ALAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ADPCM:\n\tbits = FMT_ADPCM >> 5;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP_BE >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 8)\n\t    bits = FMT_PCM8 >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    default:\n\treturn EINVAL;\n    }\n\n    if (p->channels < 1 || p->channels > 2)\n\treturn EINVAL;\n\n    error = ad1848_set_speed(sc, &p->sample_rate);\n    if (error)\n\treturn error;\n\n    p->sw_code = pswcode;\n    r->sw_code = rswcode;\n\n    sc->format_bits = bits;\n    sc->channels = p->channels;\n    sc->precision = p->precision;\n    sc->need_commit = 1;\n\n    DPRINTF((\"ad1848_set_params succeeded, bits=%x\\n\", bits));\n    return (0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tad1848_set_speed",
      "int cnt;",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_set_params succeeded, bits=%x\\n\", bits)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_set_speed",
          "args": [
            "sc",
            "&p->sample_rate"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1334-1405",
          "snippet": "int\nad1848_set_speed(sc, argp)\n    struct ad1848_softc *sc;\n    u_long *argp;\n{\n    /*\n     * The sampling speed is encoded in the least significant nible of I8. The\n     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 Mhz) and other\n     * three bits select the divisor (indirectly):\n     *\n     * The available speeds are in the following table. Keep the speeds in\n     * the increasing order.\n     */\n    typedef struct {\n\tint\tspeed;\n\tu_char\tbits;\n    } speed_struct;\n    u_long arg = *argp;\n\n    static speed_struct speed_table[] =  {\n\t{5510, (0 << 1) | 1},\n\t{5510, (0 << 1) | 1},\n\t{6620, (7 << 1) | 1},\n\t{8000, (0 << 1) | 0},\n\t{9600, (7 << 1) | 0},\n\t{11025, (1 << 1) | 1},\n\t{16000, (1 << 1) | 0},\n\t{18900, (2 << 1) | 1},\n\t{22050, (3 << 1) | 1},\n\t{27420, (2 << 1) | 0},\n\t{32000, (3 << 1) | 0},\n\t{33075, (6 << 1) | 1},\n\t{37800, (4 << 1) | 1},\n\t{44100, (5 << 1) | 1},\n\t{48000, (6 << 1) | 0}\n    };\n\n    int i, n, selected = -1;\n\n    n = sizeof(speed_table) / sizeof(speed_struct);\n\n    if (arg < speed_table[0].speed)\n\tselected = 0;\n    if (arg > speed_table[n - 1].speed)\n\tselected = n - 1;\n\n    for (i = 1 /*really*/ ; selected == -1 && i < n; i++)\n\tif (speed_table[i].speed == arg)\n\t    selected = i;\n\telse if (speed_table[i].speed > arg) {\n\t    int diff1, diff2;\n\n\t    diff1 = arg - speed_table[i - 1].speed;\n\t    diff2 = speed_table[i].speed - arg;\n\n\t    if (diff1 < diff2)\n\t\tselected = i - 1;\n\t    else\n\t\tselected = i;\n\t}\n\n    if (selected == -1) {\n\tprintf(\"ad1848: Can't find speed???\\n\");\n\tselected = 3;\n    }\n\n    sc->speed_bits = speed_table[selected].bits;\n    sc->need_commit = 1;\n    *argp = speed_table[selected].speed;\n\n    return (0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tad1848_set_speed"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tad1848_set_speed;\n\nint\nad1848_set_speed(sc, argp)\n    struct ad1848_softc *sc;\n    u_long *argp;\n{\n    /*\n     * The sampling speed is encoded in the least significant nible of I8. The\n     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 Mhz) and other\n     * three bits select the divisor (indirectly):\n     *\n     * The available speeds are in the following table. Keep the speeds in\n     * the increasing order.\n     */\n    typedef struct {\n\tint\tspeed;\n\tu_char\tbits;\n    } speed_struct;\n    u_long arg = *argp;\n\n    static speed_struct speed_table[] =  {\n\t{5510, (0 << 1) | 1},\n\t{5510, (0 << 1) | 1},\n\t{6620, (7 << 1) | 1},\n\t{8000, (0 << 1) | 0},\n\t{9600, (7 << 1) | 0},\n\t{11025, (1 << 1) | 1},\n\t{16000, (1 << 1) | 0},\n\t{18900, (2 << 1) | 1},\n\t{22050, (3 << 1) | 1},\n\t{27420, (2 << 1) | 0},\n\t{32000, (3 << 1) | 0},\n\t{33075, (6 << 1) | 1},\n\t{37800, (4 << 1) | 1},\n\t{44100, (5 << 1) | 1},\n\t{48000, (6 << 1) | 0}\n    };\n\n    int i, n, selected = -1;\n\n    n = sizeof(speed_table) / sizeof(speed_struct);\n\n    if (arg < speed_table[0].speed)\n\tselected = 0;\n    if (arg > speed_table[n - 1].speed)\n\tselected = n - 1;\n\n    for (i = 1 /*really*/ ; selected == -1 && i < n; i++)\n\tif (speed_table[i].speed == arg)\n\t    selected = i;\n\telse if (speed_table[i].speed > arg) {\n\t    int diff1, diff2;\n\n\t    diff1 = arg - speed_table[i - 1].speed;\n\t    diff2 = speed_table[i].speed - arg;\n\n\t    if (diff1 < diff2)\n\t\tselected = i - 1;\n\t    else\n\t\tselected = i;\n\t}\n\n    if (selected == -1) {\n\tprintf(\"ad1848: Can't find speed???\\n\");\n\tselected = 3;\n    }\n\n    sc->speed_bits = speed_table[selected].bits;\n    sc->need_commit = 1;\n    *argp = speed_table[selected].speed;\n\n    return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_set_params: %d %d %d %ld\\n\", \n\t     p->encoding, p->precision, p->channels, p->sample_rate)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *, u_char *buf, int cnt)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *, u_char *buf, int cnt)"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tad1848_set_speed;\nint cnt;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_set_params(addr, setmode, usemode, p, r)\n    void *addr;\n    int setmode, usemode;\n    struct audio_params *p, *r;\n{\n    struct ad1848_softc *sc = addr;\n    int error, bits, enc;\n    void (*pswcode) __P((void *, u_char *buf, int cnt));\n    void (*rswcode) __P((void *, u_char *buf, int cnt));\n\n    DPRINTF((\"ad1848_set_params: %d %d %d %ld\\n\", \n\t     p->encoding, p->precision, p->channels, p->sample_rate));\n\n    enc = p->encoding;\n    pswcode = rswcode = 0;\n    switch (enc) {\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 8) {\n\t    enc = AUDIO_ENCODING_ULINEAR_LE;\n\t    pswcode = rswcode = change_sign8;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16 && sc->mode == 1) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = swap_bytes;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = change_sign16;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_BE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = swap_bytes_change_sign16;\n\t    rswcode = change_sign16_swap_bytes;\n\t}\n\tbreak;\n    }\n    switch (enc) {\n    case AUDIO_ENCODING_ULAW:\n\tbits = FMT_ULAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ALAW:\n\tbits = FMT_ALAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ADPCM:\n\tbits = FMT_ADPCM >> 5;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP_BE >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 8)\n\t    bits = FMT_PCM8 >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    default:\n\treturn EINVAL;\n    }\n\n    if (p->channels < 1 || p->channels > 2)\n\treturn EINVAL;\n\n    error = ad1848_set_speed(sc, &p->sample_rate);\n    if (error)\n\treturn error;\n\n    p->sw_code = pswcode;\n    r->sw_code = rswcode;\n\n    sc->format_bits = bits;\n    sc->channels = p->channels;\n    sc->precision = p->precision;\n    sc->need_commit = 1;\n\n    DPRINTF((\"ad1848_set_params succeeded, bits=%x\\n\", bits));\n    return (0);\n}"
  },
  {
    "function_name": "ad1848_query_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "937-1010",
    "snippet": "int\nad1848_query_encoding(addr, fp)\n    void *addr;\n    struct audio_encoding *fp;\n{\n    struct ad1848_softc *sc = addr;\n\n    switch (fp->index) {\n    case 0:\n\tstrcpy(fp->name, AudioEmulaw);\n\tfp->encoding = AUDIO_ENCODING_ULAW;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n    case 1:\n\tstrcpy(fp->name, AudioEalaw);\n\tfp->encoding = AUDIO_ENCODING_ALAW;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n    case 2:\n\tstrcpy(fp->name, AudioEslinear_le);\n\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tfp->precision = 16;\n\tfp->flags = 0;\n\tbreak;\n    case 3:\n\tstrcpy(fp->name, AudioEulinear);\n\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n\n    case 4: /* only on CS4231 */\n\tstrcpy(fp->name, AudioEslinear_be);\n\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\tfp->precision = 16;\n\tfp->flags = sc->mode == 1 ? AUDIO_ENCODINGFLAG_EMULATED : 0;\n\tbreak;\n\n    /* emulate some modes */\n    case 5:\n\tstrcpy(fp->name, AudioEslinear);\n\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\tfp->precision = 8;\n\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\tbreak;\n    case 6:\n\tstrcpy(fp->name, AudioEulinear_le);\n\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\tfp->precision = 16;\n\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\tbreak;\n    case 7:\n\tstrcpy(fp->name, AudioEulinear_be);\n\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\tfp->precision = 16;\n\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\tbreak;\n\n    case 8: /* only on CS4231 */\n\tif (sc->mode == 1)\n\t    return EINVAL;\n\tstrcpy(fp->name, AudioEadpcm);\n\tfp->encoding = AUDIO_ENCODING_ADPCM;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n    default:\n\treturn EINVAL;\n\t/*NOTREACHED*/\n    }\n    return (0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEadpcm"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_be"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_le"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_be"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_le"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEalaw"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEmulaw"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint flags;\n\nint\nad1848_query_encoding(addr, fp)\n    void *addr;\n    struct audio_encoding *fp;\n{\n    struct ad1848_softc *sc = addr;\n\n    switch (fp->index) {\n    case 0:\n\tstrcpy(fp->name, AudioEmulaw);\n\tfp->encoding = AUDIO_ENCODING_ULAW;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n    case 1:\n\tstrcpy(fp->name, AudioEalaw);\n\tfp->encoding = AUDIO_ENCODING_ALAW;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n    case 2:\n\tstrcpy(fp->name, AudioEslinear_le);\n\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tfp->precision = 16;\n\tfp->flags = 0;\n\tbreak;\n    case 3:\n\tstrcpy(fp->name, AudioEulinear);\n\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n\n    case 4: /* only on CS4231 */\n\tstrcpy(fp->name, AudioEslinear_be);\n\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\tfp->precision = 16;\n\tfp->flags = sc->mode == 1 ? AUDIO_ENCODINGFLAG_EMULATED : 0;\n\tbreak;\n\n    /* emulate some modes */\n    case 5:\n\tstrcpy(fp->name, AudioEslinear);\n\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\tfp->precision = 8;\n\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\tbreak;\n    case 6:\n\tstrcpy(fp->name, AudioEulinear_le);\n\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\tfp->precision = 16;\n\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\tbreak;\n    case 7:\n\tstrcpy(fp->name, AudioEulinear_be);\n\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\tfp->precision = 16;\n\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\tbreak;\n\n    case 8: /* only on CS4231 */\n\tif (sc->mode == 1)\n\t    return EINVAL;\n\tstrcpy(fp->name, AudioEadpcm);\n\tfp->encoding = AUDIO_ENCODING_ADPCM;\n\tfp->precision = 8;\n\tfp->flags = 0;\n\tbreak;\n    default:\n\treturn EINVAL;\n\t/*NOTREACHED*/\n    }\n    return (0);\n}"
  },
  {
    "function_name": "ad1848_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "867-934",
    "snippet": "int     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
      "static ad1848_devmap_t *ad1848_mixer_find_dev",
      "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
      "int cnt;",
      "mixer_ctrl_t *cp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Invalid kind\\n\""
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_rec_port",
          "args": [
            "ac",
            "cp->un.ord"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_rec_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1106-1141",
          "snippet": "int\nad1848_set_rec_port(sc, port)\n    struct ad1848_softc *sc;\n    int port;\n{\n    u_char inp, reg;\n    \n    DPRINTF((\"ad1848_set_rec_port: 0x%x\\n\", port));\n\n    if (port == MIC_IN_PORT) {\n\tinp = MIC_INPUT;\n    }\n    else if (port == LINE_IN_PORT) {\n\tinp = LINE_INPUT;\n    }\n    else if (port == DAC_IN_PORT) {\n\tinp = MIXED_DAC_INPUT;\n    }\n    else if (sc->mode == 2 && port == AUX1_IN_PORT) {\n\tinp = AUX_INPUT;\n    }\n    else\n\treturn(EINVAL);\n\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp|reg));\n\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp|reg));\n\n    sc->rec_port = port;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_rec_port(sc, port)\n    struct ad1848_softc *sc;\n    int port;\n{\n    u_char inp, reg;\n    \n    DPRINTF((\"ad1848_set_rec_port: 0x%x\\n\", port));\n\n    if (port == MIC_IN_PORT) {\n\tinp = MIC_INPUT;\n    }\n    else if (port == LINE_IN_PORT) {\n\tinp = LINE_INPUT;\n    }\n    else if (port == DAC_IN_PORT) {\n\tinp = MIXED_DAC_INPUT;\n    }\n    else if (sc->mode == 2 && port == AUX1_IN_PORT) {\n\tinp = AUX_INPUT;\n    }\n    else\n\treturn(EINVAL);\n\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp|reg));\n\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp|reg));\n\n    sc->rec_port = port;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_mic_gain",
          "args": [
            "ac",
            "&vol"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_mic_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "739-759",
          "snippet": "int\nad1848_set_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg;\n    \n    DPRINTF((\"cs4231_set_mic_gain: %d\\n\", gp->left));\n\n    if (gp->left > AUDIO_MAX_GAIN/2) {\n\t    sc->mic_gain_on = 1;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg | INPUT_MIC_GAIN_ENABLE);\n    } else {\n\t    sc->mic_gain_on = 0;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg & ~INPUT_MIC_GAIN_ENABLE);\n    }\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg;\n    \n    DPRINTF((\"cs4231_set_mic_gain: %d\\n\", gp->left));\n\n    if (gp->left > AUDIO_MAX_GAIN/2) {\n\t    sc->mic_gain_on = 1;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg | INPUT_MIC_GAIN_ENABLE);\n    } else {\n\t    sc->mic_gain_on = 0;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg & ~INPUT_MIC_GAIN_ENABLE);\n    }\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_to_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_to_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "145-160",
          "snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_rec_gain",
          "args": [
            "ac",
            "&vol"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_rec_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "696-718",
          "snippet": "int\nad1848_set_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg, gain;\n    \n    DPRINTF((\"ad1848_set_rec_gain: %d:%d\\n\", gp->left, gp->right));\n\n    sc->rec_gain = *gp;\n\n    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg, gain;\n    \n    DPRINTF((\"ad1848_set_rec_gain: %d:%d\\n\", gp->left, gp->right));\n\n    sc->rec_gain = *gp;\n\n    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mute_channel",
          "args": [
            "ac",
            "dev",
            "ac->mute[dev]"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mute_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "607-640",
          "snippet": "void \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nvoid \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_channel_gain",
          "args": [
            "ac",
            "dev",
            "&vol"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_channel_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "643-674",
          "snippet": "int\nad1848_set_channel_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    struct ad1848_mixerinfo *info = &mixer_channel_info[device];\n    u_char reg;\n    u_int atten;\n\n    sc->gains[device] = *gp;\n\n    atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits)/AUDIO_MAX_GAIN;\n\n    reg = ad_read(sc, info->left_reg) & (info->atten_mask);\n    if (device == AD1848_MONITOR_CHANNEL)\n      reg |= ((atten & info->atten_bits) << 2);\n    else\n      reg |= ((atten & info->atten_bits));\n\n    ad_write(sc, info->left_reg, reg);\n\n    if (!info->right_reg)\n      return (0);\n\n    atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, info->right_reg);\n    reg &= (info->atten_mask);\n    ad_write(sc, info->right_reg, (atten& info->atten_bits)|reg);\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nint\nad1848_set_channel_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    struct ad1848_mixerinfo *info = &mixer_channel_info[device];\n    u_char reg;\n    u_int atten;\n\n    sc->gains[device] = *gp;\n\n    atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits)/AUDIO_MAX_GAIN;\n\n    reg = ad_read(sc, info->left_reg) & (info->atten_mask);\n    if (device == AD1848_MONITOR_CHANNEL)\n      reg |= ((atten & info->atten_bits) << 2);\n    else\n      reg |= ((atten & info->atten_bits));\n\n    ad_write(sc, info->left_reg, reg);\n\n    if (!info->right_reg)\n      return (0);\n\n    atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, info->right_reg);\n    reg &= (info->atten_mask);\n    ad_write(sc, info->right_reg, (atten& info->atten_bits)|reg);\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_find_dev",
          "args": [
            "map",
            "cnt",
            "cp"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
  },
  {
    "function_name": "ad1848_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "793-865",
    "snippet": "int     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
      "static ad1848_devmap_t *ad1848_mixer_find_dev",
      "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
      "int cnt;",
      "mixer_ctrl_t *cp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Invalid kind\\n\""
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_get_rec_port",
          "args": [
            "ac"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_get_rec_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1143-1148",
          "snippet": "int\nad1848_get_rec_port(sc)\n    struct ad1848_softc *sc;\n{\n    return(sc->rec_port);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_rec_port(sc)\n    struct ad1848_softc *sc;\n{\n    return(sc->rec_port);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_from_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_from_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "162-177",
          "snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_get_mic_gain",
          "args": [
            "ac",
            "&vol"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_get_mic_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "761-771",
          "snippet": "int\nad1848_get_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n\tif (sc->mic_gain_on)\n\t\tgp->left = gp->right = AUDIO_MAX_GAIN;\n\telse\n\t\tgp->left = gp->right = AUDIO_MIN_GAIN;\n\treturn(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n\tif (sc->mic_gain_on)\n\t\tgp->left = gp->right = AUDIO_MAX_GAIN;\n\telse\n\t\tgp->left = gp->right = AUDIO_MIN_GAIN;\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_get_rec_gain",
          "args": [
            "ac",
            "&vol"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_get_rec_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "687-694",
          "snippet": "int\nad1848_get_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->rec_gain;\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->rec_gain;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_get_device_gain",
          "args": [
            "ac",
            "dev",
            "&vol"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_get_device_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "677-685",
          "snippet": "int\nad1848_get_device_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->gains[device];\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_device_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->gains[device];\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_find_dev",
          "args": [
            "map",
            "cnt",
            "cp"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
  },
  {
    "function_name": "ad1848_get_mic_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "761-771",
    "snippet": "int\nad1848_get_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n\tif (sc->mic_gain_on)\n\t\tgp->left = gp->right = AUDIO_MAX_GAIN;\n\telse\n\t\tgp->left = gp->right = AUDIO_MIN_GAIN;\n\treturn(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n\tif (sc->mic_gain_on)\n\t\tgp->left = gp->right = AUDIO_MAX_GAIN;\n\telse\n\t\tgp->left = gp->right = AUDIO_MIN_GAIN;\n\treturn(0);\n}"
  },
  {
    "function_name": "ad1848_set_mic_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "739-759",
    "snippet": "int\nad1848_set_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg;\n    \n    DPRINTF((\"cs4231_set_mic_gain: %d\\n\", gp->left));\n\n    if (gp->left > AUDIO_MAX_GAIN/2) {\n\t    sc->mic_gain_on = 1;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg | INPUT_MIC_GAIN_ENABLE);\n    } else {\n\t    sc->mic_gain_on = 0;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg & ~INPUT_MIC_GAIN_ENABLE);\n    }\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_LEFT_INPUT_CONTROL",
            "reg & ~INPUT_MIC_GAIN_ENABLE"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_LEFT_INPUT_CONTROL"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cs4231_set_mic_gain: %d\\n\", gp->left)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg;\n    \n    DPRINTF((\"cs4231_set_mic_gain: %d\\n\", gp->left));\n\n    if (gp->left > AUDIO_MAX_GAIN/2) {\n\t    sc->mic_gain_on = 1;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg | INPUT_MIC_GAIN_ENABLE);\n    } else {\n\t    sc->mic_gain_on = 0;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg & ~INPUT_MIC_GAIN_ENABLE);\n    }\n\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_mute_monitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "721-737",
    "snippet": "void\nad1848_mute_monitor(addr, mute)\n\tvoid *addr;\n\tint mute;\n{\n\tstruct ad1848_softc *sc = addr;\n\n\tDPRINTF((\"ad1848_mute_monitor: %smuting\\n\", mute ? \"\" : \"un\"));\n\tif (sc->mode == 2) {\n\t        ad1848_mute_channel(sc, AD1848_DAC_CHANNEL, mute ? MUTE_ALL : 0);\n\t\tad1848_mute_channel(sc, AD1848_MONO_CHANNEL, mute ? MUTE_MONO : 0);\n\t\tad1848_mute_channel(sc, AD1848_LINE_CHANNEL, mute ? MUTE_ALL : 0);\n\t}\n\t\t\n\tad1848_mute_channel(sc, AD1848_AUX2_CHANNEL, mute ? MUTE_ALL : 0);\n\tad1848_mute_channel(sc, AD1848_AUX1_CHANNEL, mute ? MUTE_ALL : 0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tad1848_mute_monitor",
      "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_mute_channel",
          "args": [
            "sc",
            "AD1848_AUX1_CHANNEL",
            "mute ? MUTE_ALL : 0"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mute_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "607-640",
          "snippet": "void \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nvoid \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_mute_monitor: %smuting\\n\", mute ? \"\" : \"un\")"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tad1848_mute_monitor;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\nad1848_mute_monitor(addr, mute)\n\tvoid *addr;\n\tint mute;\n{\n\tstruct ad1848_softc *sc = addr;\n\n\tDPRINTF((\"ad1848_mute_monitor: %smuting\\n\", mute ? \"\" : \"un\"));\n\tif (sc->mode == 2) {\n\t        ad1848_mute_channel(sc, AD1848_DAC_CHANNEL, mute ? MUTE_ALL : 0);\n\t\tad1848_mute_channel(sc, AD1848_MONO_CHANNEL, mute ? MUTE_MONO : 0);\n\t\tad1848_mute_channel(sc, AD1848_LINE_CHANNEL, mute ? MUTE_ALL : 0);\n\t}\n\t\t\n\tad1848_mute_channel(sc, AD1848_AUX2_CHANNEL, mute ? MUTE_ALL : 0);\n\tad1848_mute_channel(sc, AD1848_AUX1_CHANNEL, mute ? MUTE_ALL : 0);\n}"
  },
  {
    "function_name": "ad1848_set_rec_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "696-718",
    "snippet": "int\nad1848_set_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg, gain;\n    \n    DPRINTF((\"ad1848_set_rec_gain: %d:%d\\n\", gp->left, gp->right));\n\n    sc->rec_gain = *gp;\n\n    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "SP_RIGHT_INPUT_CONTROL",
            "(gain&0x0f)|reg"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_RIGHT_INPUT_CONTROL"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848_set_rec_gain: %d:%d\\n\", gp->left, gp->right)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg, gain;\n    \n    DPRINTF((\"ad1848_set_rec_gain: %d:%d\\n\", gp->left, gp->right));\n\n    sc->rec_gain = *gp;\n\n    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_get_rec_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "687-694",
    "snippet": "int\nad1848_get_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->rec_gain;\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->rec_gain;\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_get_device_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "677-685",
    "snippet": "int\nad1848_get_device_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->gains[device];\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_get_device_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->gains[device];\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_set_channel_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "643-674",
    "snippet": "int\nad1848_set_channel_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    struct ad1848_mixerinfo *info = &mixer_channel_info[device];\n    u_char reg;\n    u_int atten;\n\n    sc->gains[device] = *gp;\n\n    atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits)/AUDIO_MAX_GAIN;\n\n    reg = ad_read(sc, info->left_reg) & (info->atten_mask);\n    if (device == AD1848_MONITOR_CHANNEL)\n      reg |= ((atten & info->atten_bits) << 2);\n    else\n      reg |= ((atten & info->atten_bits));\n\n    ad_write(sc, info->left_reg, reg);\n\n    if (!info->right_reg)\n      return (0);\n\n    atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, info->right_reg);\n    reg &= (info->atten_mask);\n    ad_write(sc, info->right_reg, (atten& info->atten_bits)|reg);\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "info->right_reg",
            "(atten& info->atten_bits)|reg"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "info->right_reg"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nint\nad1848_set_channel_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    struct ad1848_mixerinfo *info = &mixer_channel_info[device];\n    u_char reg;\n    u_int atten;\n\n    sc->gains[device] = *gp;\n\n    atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits)/AUDIO_MAX_GAIN;\n\n    reg = ad_read(sc, info->left_reg) & (info->atten_mask);\n    if (device == AD1848_MONITOR_CHANNEL)\n      reg |= ((atten & info->atten_bits) << 2);\n    else\n      reg |= ((atten & info->atten_bits));\n\n    ad_write(sc, info->left_reg, reg);\n\n    if (!info->right_reg)\n      return (0);\n\n    atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, info->right_reg);\n    reg &= (info->atten_mask);\n    ad_write(sc, info->right_reg, (atten& info->atten_bits)|reg);\n\n    return(0);\n}"
  },
  {
    "function_name": "ad1848_mute_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "607-640",
    "snippet": "void \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write",
      "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "mixer_channel_info[device].right_reg",
            "reg & ~0x80"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "mixer_channel_info[device].right_reg"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nvoid \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}"
  },
  {
    "function_name": "ad1848_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "502-577",
    "snippet": "void\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};",
      "void\tad1848_reset",
      "static int ad_read",
      "static void ad_write",
      "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": %s\"",
            "sc->chip_name"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_rec_port",
          "args": [
            "sc",
            "MIC_IN_PORT"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_rec_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1106-1141",
          "snippet": "int\nad1848_set_rec_port(sc, port)\n    struct ad1848_softc *sc;\n    int port;\n{\n    u_char inp, reg;\n    \n    DPRINTF((\"ad1848_set_rec_port: 0x%x\\n\", port));\n\n    if (port == MIC_IN_PORT) {\n\tinp = MIC_INPUT;\n    }\n    else if (port == LINE_IN_PORT) {\n\tinp = LINE_INPUT;\n    }\n    else if (port == DAC_IN_PORT) {\n\tinp = MIXED_DAC_INPUT;\n    }\n    else if (sc->mode == 2 && port == AUX1_IN_PORT) {\n\tinp = AUX_INPUT;\n    }\n    else\n\treturn(EINVAL);\n\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp|reg));\n\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp|reg));\n\n    sc->rec_port = port;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_rec_port(sc, port)\n    struct ad1848_softc *sc;\n    int port;\n{\n    u_char inp, reg;\n    \n    DPRINTF((\"ad1848_set_rec_port: 0x%x\\n\", port));\n\n    if (port == MIC_IN_PORT) {\n\tinp = MIC_INPUT;\n    }\n    else if (port == LINE_IN_PORT) {\n\tinp = LINE_INPUT;\n    }\n    else if (port == DAC_IN_PORT) {\n\tinp = MIXED_DAC_INPUT;\n    }\n    else if (sc->mode == 2 && port == AUX1_IN_PORT) {\n\tinp = AUX_INPUT;\n    }\n    else\n\treturn(EINVAL);\n\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp|reg));\n\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_SOURCE_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp|reg));\n\n    sc->rec_port = port;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_channel_gain",
          "args": [
            "sc",
            "AD1848_AUX2_CHANNEL",
            "&vol_0"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_channel_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "643-674",
          "snippet": "int\nad1848_set_channel_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    struct ad1848_mixerinfo *info = &mixer_channel_info[device];\n    u_char reg;\n    u_int atten;\n\n    sc->gains[device] = *gp;\n\n    atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits)/AUDIO_MAX_GAIN;\n\n    reg = ad_read(sc, info->left_reg) & (info->atten_mask);\n    if (device == AD1848_MONITOR_CHANNEL)\n      reg |= ((atten & info->atten_bits) << 2);\n    else\n      reg |= ((atten & info->atten_bits));\n\n    ad_write(sc, info->left_reg, reg);\n\n    if (!info->right_reg)\n      return (0);\n\n    atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, info->right_reg);\n    reg &= (info->atten_mask);\n    ad_write(sc, info->right_reg, (atten& info->atten_bits)|reg);\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nint\nad1848_set_channel_gain(sc, device, gp)\n    struct ad1848_softc *sc;\n    int device;\n    struct ad1848_volume *gp;\n{\n    struct ad1848_mixerinfo *info = &mixer_channel_info[device];\n    u_char reg;\n    u_int atten;\n\n    sc->gains[device] = *gp;\n\n    atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits)/AUDIO_MAX_GAIN;\n\n    reg = ad_read(sc, info->left_reg) & (info->atten_mask);\n    if (device == AD1848_MONITOR_CHANNEL)\n      reg |= ((atten & info->atten_bits) << 2);\n    else\n      reg |= ((atten & info->atten_bits));\n\n    ad_write(sc, info->left_reg, reg);\n\n    if (!info->right_reg)\n      return (0);\n\n    atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, info->right_reg);\n    reg &= (info->atten_mask);\n    ad_write(sc, info->right_reg, (atten& info->atten_bits)|reg);\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_rec_gain",
          "args": [
            "sc",
            "&vol_mid"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_rec_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "696-718",
          "snippet": "int\nad1848_set_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg, gain;\n    \n    DPRINTF((\"ad1848_set_rec_gain: %d:%d\\n\", gp->left, gp->right));\n\n    sc->rec_gain = *gp;\n\n    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_rec_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg, gain;\n    \n    DPRINTF((\"ad1848_set_rec_gain: %d:%d\\n\", gp->left, gp->right));\n\n    sc->rec_gain = *gp;\n\n    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;\n    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);\n    reg &= INPUT_GAIN_MASK;\n    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_params",
          "args": [
            "sc",
            "AUMODE_RECORD|AUMODE_PLAY",
            "0",
            "&pparams",
            "&rparams"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1012-1104",
          "snippet": "int\nad1848_set_params(addr, setmode, usemode, p, r)\n    void *addr;\n    int setmode, usemode;\n    struct audio_params *p, *r;\n{\n    struct ad1848_softc *sc = addr;\n    int error, bits, enc;\n    void (*pswcode) __P((void *, u_char *buf, int cnt));\n    void (*rswcode) __P((void *, u_char *buf, int cnt));\n\n    DPRINTF((\"ad1848_set_params: %d %d %d %ld\\n\", \n\t     p->encoding, p->precision, p->channels, p->sample_rate));\n\n    enc = p->encoding;\n    pswcode = rswcode = 0;\n    switch (enc) {\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 8) {\n\t    enc = AUDIO_ENCODING_ULINEAR_LE;\n\t    pswcode = rswcode = change_sign8;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16 && sc->mode == 1) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = swap_bytes;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = change_sign16;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_BE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = swap_bytes_change_sign16;\n\t    rswcode = change_sign16_swap_bytes;\n\t}\n\tbreak;\n    }\n    switch (enc) {\n    case AUDIO_ENCODING_ULAW:\n\tbits = FMT_ULAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ALAW:\n\tbits = FMT_ALAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ADPCM:\n\tbits = FMT_ADPCM >> 5;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP_BE >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 8)\n\t    bits = FMT_PCM8 >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    default:\n\treturn EINVAL;\n    }\n\n    if (p->channels < 1 || p->channels > 2)\n\treturn EINVAL;\n\n    error = ad1848_set_speed(sc, &p->sample_rate);\n    if (error)\n\treturn error;\n\n    p->sw_code = pswcode;\n    r->sw_code = rswcode;\n\n    sc->format_bits = bits;\n    sc->channels = p->channels;\n    sc->precision = p->precision;\n    sc->need_commit = 1;\n\n    DPRINTF((\"ad1848_set_params succeeded, bits=%x\\n\", bits));\n    return (0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tad1848_set_speed",
            "int cnt;",
            "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tad1848_set_speed;\nint cnt;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_set_params(addr, setmode, usemode, p, r)\n    void *addr;\n    int setmode, usemode;\n    struct audio_params *p, *r;\n{\n    struct ad1848_softc *sc = addr;\n    int error, bits, enc;\n    void (*pswcode) __P((void *, u_char *buf, int cnt));\n    void (*rswcode) __P((void *, u_char *buf, int cnt));\n\n    DPRINTF((\"ad1848_set_params: %d %d %d %ld\\n\", \n\t     p->encoding, p->precision, p->channels, p->sample_rate));\n\n    enc = p->encoding;\n    pswcode = rswcode = 0;\n    switch (enc) {\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 8) {\n\t    enc = AUDIO_ENCODING_ULINEAR_LE;\n\t    pswcode = rswcode = change_sign8;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16 && sc->mode == 1) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = swap_bytes;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = change_sign16;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_BE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = swap_bytes_change_sign16;\n\t    rswcode = change_sign16_swap_bytes;\n\t}\n\tbreak;\n    }\n    switch (enc) {\n    case AUDIO_ENCODING_ULAW:\n\tbits = FMT_ULAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ALAW:\n\tbits = FMT_ALAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ADPCM:\n\tbits = FMT_ADPCM >> 5;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP_BE >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 8)\n\t    bits = FMT_PCM8 >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    default:\n\treturn EINVAL;\n    }\n\n    if (p->channels < 1 || p->channels > 2)\n\treturn EINVAL;\n\n    error = ad1848_set_speed(sc, &p->sample_rate);\n    if (error)\n\treturn error;\n\n    p->sw_code = pswcode;\n    r->sw_code = rswcode;\n\n    sc->format_bits = bits;\n    sc->channels = p->channels;\n    sc->precision = p->precision;\n    sc->need_commit = 1;\n\n    DPRINTF((\"ad1848_set_params succeeded, bits=%x\\n\", bits));\n    return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_reset",
          "args": [
            "sc"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1309-1332",
          "snippet": "void\nad1848_reset(sc)\n    struct ad1848_softc *sc;\n{\n    u_char r;\n    \n    DPRINTF((\"ad1848_reset\\n\"));\n    \n    /* Clear the PEN and CEN bits */\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n    if (sc->mode == 2) {\n\t    ADWRITE(sc, AD1848_IADDR, CS_IRQ_STATUS);\n\t    ADWRITE(sc, AD1848_IDATA, 0);\n    }\n    /* Clear interrupt status */\n    ADWRITE(sc, AD1848_STATUS, 0);\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tad1848_reset",
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tad1848_reset;\nstatic int ad_read;\nstatic void ad_write;\n\nvoid\nad1848_reset(sc)\n    struct ad1848_softc *sc;\n{\n    u_char r;\n    \n    DPRINTF((\"ad1848_reset\\n\"));\n    \n    /* Clear the PEN and CEN bits */\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n    if (sc->mode == 2) {\n\t    ADWRITE(sc, AD1848_IADDR, CS_IRQ_STATUS);\n\t    ADWRITE(sc, AD1848_IDATA, 0);\n    }\n    /* Clear interrupt status */\n    ADWRITE(sc, AD1848_STATUS, 0);\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "i",
            "ad1848_init_values[i]"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_dmamap_create",
          "args": [
            "sc->sc_isa",
            "sc->sc_recdrq",
            "MAX_ISADMA",
            "BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmamap_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "220-255",
          "snippet": "int\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\nint flags;\n\nint\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};\nvoid\tad1848_reset;\nstatic int ad_read;\nstatic void ad_write;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\n\nvoid\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}"
  },
  {
    "function_name": "ad1848_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "491-496",
    "snippet": "void\nad1848_unmap(sc)\n    struct ad1848_softc *sc;\n{\n    bus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "AD1848_NPORT"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nad1848_unmap(sc)\n    struct ad1848_softc *sc;\n{\n    bus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);\n}"
  },
  {
    "function_name": "ad1848_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "303-488",
    "snippet": "int\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void ad_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IDATA"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IADDR",
            "SP_TEST_AND_INIT"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "CS_VERSION_ID"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad_detect_H(%x)\\n\", tmp2)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_write",
          "args": [
            "sc",
            "2",
            "0xaa"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "ad_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "177-188",
          "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f))"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad_detect_D (%x)\\n\", tmp1)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad_detect_A %x\\n\", tmp)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}"
  },
  {
    "function_name": "ad1848_mapprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "276-298",
    "snippet": "int\nad1848_mapprobe(sc, iobase)\n    struct ad1848_softc *sc;\n    int iobase;\n{\n    if (!AD1848_BASE_VALID(iobase)) {\n#ifdef AUDIO_DEBUG\n\tprintf(\"ad1848: configured iobase %04x invalid\\n\", iobase);\n#endif\n\treturn 0;\n    }\n\n    sc->sc_iooffs = 0;\n    /* Map the AD1848 ports */\n    if (bus_space_map(sc->sc_iot, iobase, AD1848_NPORT, 0, &sc->sc_ioh))\n\treturn 0;\n\n    if (!ad1848_probe(sc)) {\n\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);\n\treturn 0;\n    } else\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "AD1848_NPORT"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_probe",
          "args": [
            "sc"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "303-488",
          "snippet": "int\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "iobase",
            "AD1848_NPORT",
            "0",
            "&sc->sc_ioh"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ad1848: configured iobase %04x invalid\\n\"",
            "iobase"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD1848_BASE_VALID",
          "args": [
            "iobase"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_mapprobe(sc, iobase)\n    struct ad1848_softc *sc;\n    int iobase;\n{\n    if (!AD1848_BASE_VALID(iobase)) {\n#ifdef AUDIO_DEBUG\n\tprintf(\"ad1848: configured iobase %04x invalid\\n\", iobase);\n#endif\n\treturn 0;\n    }\n\n    sc->sc_iooffs = 0;\n    /* Map the AD1848 ports */\n    if (bus_space_map(sc->sc_iot, iobase, AD1848_NPORT, 0, &sc->sc_ioh))\n\treturn 0;\n\n    if (!ad1848_probe(sc)) {\n\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);\n\treturn 0;\n    } else\n\treturn 1;\n}"
  },
  {
    "function_name": "ad1848_dump_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "250-270",
    "snippet": "void\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "i"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_STATUS"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nvoid\nad1848_dump_regs(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    u_char r;\n    \n    printf(\"ad1848 status=%02x\", ADREAD(sc, AD1848_STATUS));\n    printf(\" regs: \");\n    for (i = 0; i < 16; i++) {\n\tr = ad_read(sc, i);\n\tprintf(\"%02x \", r);\n    }\n    if (sc->mode == 2) {\n\t    for (i = 16; i < 32; i++) {\n\t\t    r = ad_read(sc, i);\n\t\t    printf(\"%02x \", r);\n\t    }\n    }\n    printf(\"\\n\");\n}"
  },
  {
    "function_name": "wait_for_calibration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "203-245",
    "snippet": "static void\nwait_for_calibration(sc)\n    struct ad1848_softc *sc;\n{\n    int timeout;\n\n    DPRINTF((\"ad1848: Auto calibration started.\\n\"));\n    /*\n     * Wait until the auto calibration process has finished.\n     *\n     * 1) Wait until the chip becomes ready (reads don't return 0x80).\n     * 2) Wait until the ACI bit of I11 gets on and then off.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1).\\n\"));\n\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) != SP_TEST_AND_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_TEST_AND_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1.5).\\n\"));\n\n    if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)) {\n\ttimeout = 100000;\n\twhile (timeout > 0 && !(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    timeout--;\n\n\tif (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    DPRINTF((\"ad1848: Auto calibration timed out(2).\\n\"));\n    }\n\n    timeout = 100000;\n    while (timeout > 0 && ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n\ttimeout--;\n    if (ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n        DPRINTF((\"ad1848: Auto calibration timed out(3).\\n\"));\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read",
      "static void wait_for_calibration"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: Auto calibration timed out(3).\\n\")"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_read",
          "args": [
            "sc",
            "SP_TEST_AND_INIT"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ad_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "161-175",
          "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: Auto calibration timed out(2).\\n\")"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: Auto calibration timed out(1.5).\\n\")"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IADDR",
            "SP_TEST_AND_INIT"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: Auto calibration timed out(1).\\n\")"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IADDR"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ad1848: Auto calibration started.\\n\")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void wait_for_calibration;\n\nstatic void\nwait_for_calibration(sc)\n    struct ad1848_softc *sc;\n{\n    int timeout;\n\n    DPRINTF((\"ad1848: Auto calibration started.\\n\"));\n    /*\n     * Wait until the auto calibration process has finished.\n     *\n     * 1) Wait until the chip becomes ready (reads don't return 0x80).\n     * 2) Wait until the ACI bit of I11 gets on and then off.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1).\\n\"));\n\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) != SP_TEST_AND_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_TEST_AND_INIT)\n\tDPRINTF((\"ad1848: Auto calibration timed out(1.5).\\n\"));\n\n    if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)) {\n\ttimeout = 100000;\n\twhile (timeout > 0 && !(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    timeout--;\n\n\tif (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))\n\t    DPRINTF((\"ad1848: Auto calibration timed out(2).\\n\"));\n    }\n\n    timeout = 100000;\n    while (timeout > 0 && ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n\ttimeout--;\n    if (ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)\n        DPRINTF((\"ad1848: Auto calibration timed out(3).\\n\"));\n}"
  },
  {
    "function_name": "ad_set_MCE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "190-201",
    "snippet": "static void\nad_set_MCE(sc, state)\n    struct ad1848_softc *sc;\n    int state;\n{\n    if (state)\n\tsc->MCE_bit = MODE_CHANGE_ENABLE;\n    else\n\tsc->MCE_bit = 0;\n\n    ADWRITE(sc, AD1848_IADDR, sc->MCE_bit);\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ad_set_MCE"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IADDR",
            "sc->MCE_bit"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_set_MCE;\n\nstatic void\nad_set_MCE(sc, state)\n    struct ad1848_softc *sc;\n    int state;\n{\n    if (state)\n\tsc->MCE_bit = MODE_CHANGE_ENABLE;\n    else\n\tsc->MCE_bit = 0;\n\n    ADWRITE(sc, AD1848_IADDR, sc->MCE_bit);\n}"
  },
  {
    "function_name": "ad_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "177-188",
    "snippet": "static void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ad_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IDATA",
            "data & 0xff"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IADDR",
            "(reg & 0xff) | sc->MCE_bit"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void ad_write;\n\nstatic void\nad_write(sc, reg, data)\n    struct ad1848_softc *sc;\n    int reg;\n    int data;\n{\n    int s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    ADWRITE(sc, AD1848_IDATA, data & 0xff);\n    splx(s);\n    /* printf(\"(%02x->%02x) \", reg|sc->MCE_bit, data); */\n}"
  },
  {
    "function_name": "ad_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
    "lines": "161-175",
    "snippet": "static int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}",
    "includes": [
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/audio_if.h>",
      "#include <vm/vm.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ad_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADREAD",
          "args": [
            "sc",
            "AD1848_IDATA"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADWRITE",
          "args": [
            "sc",
            "AD1848_IADDR",
            "(reg & 0xff) | sc->MCE_bit"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\n\nstatic int\nad_read(sc, reg)\n    struct ad1848_softc *sc;\n    int reg;\n{\n    int x, s;\n\n    s = splaudio();\n    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);\n    x = ADREAD(sc, AD1848_IDATA);\n    splx(s);\n    /*  printf(\"(%02x<-%02x) \", reg|sc->MCE_bit, x); */\n\n    return x;\n}"
  }
]