[
  {
    "function_name": "usb_disconnect_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "1271-1312",
    "snippet": "void\nusb_disconnect_port(up, parent)\n\tstruct usbd_port *up;\n\tdevice_ptr_t parent;\n{\n\tusbd_device_handle dev = up->device;\n\tchar *hubname = USBDEVPTRNAME(parent);\n\tint i;\n\n\tDPRINTFN(3,(\"uhub_disconnect: up=%p dev=%p port=%d\\n\", \n\t\t    up, dev, up->portno));\n\n#ifdef DIAGNOSTIC\n\tif (dev == NULL) {\n\t\tprintf(\"usb_disconnect_port: no device\\n\");\n\t\treturn;\n\t}\n#endif\n\n\tif (dev->subdevs != NULL) {\n\t\tDPRINTFN(3,(\"usb_disconnect_port: disconnect subdevs\\n\"));\n\t\tfor (i = 0; dev->subdevs[i]; i++) {\n\t\t\tprintf(\"%s: at %s\", USBDEVPTRNAME(dev->subdevs[i]), \n\t\t\t       hubname);\n\t\t\tif (up->portno != 0)\n\t\t\t\tprintf(\" port %d\", up->portno);\n\t\t\tprintf(\" (addr %d) disconnected\\n\", dev->address);\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\t\t\tconfig_detach(dev->subdevs[i], DETACH_FORCE);\n#elif defined(__FreeBSD__)\n                        device_delete_child(device_get_parent(dev->subdevs[i]),\n\t\t\t\t\t    dev->subdevs[i]);\n#endif\n\n\t\t}\n\t}\n\n\tusbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);\n\tdev->bus->devices[dev->address] = NULL;\n\tup->device = NULL;\n\tusb_free_device(dev);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_free_device",
          "args": [
            "dev"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_add_dev_event",
          "args": [
            "USB_EVENT_DEVICE_DETACH",
            "dev"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_add_dev_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "647-656",
          "snippet": "void\nusbd_add_dev_event(type, udev)\n\tint type;\n\tusbd_device_handle udev;\n{\n\tstruct usb_event ue;\n\n\tusbd_fill_deviceinfo(udev, &ue.u.ue_device);\n\tusb_add_event(type, &ue);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct",
            "usb_add_event __P((int, struct usb_event *));",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nvoid\nusbd_add_dev_event(type, udev)\n\tint type;\n\tusbd_device_handle udev;\n{\n\tstruct usb_event ue;\n\n\tusbd_fill_deviceinfo(udev, &ue.u.ue_device);\n\tusb_add_event(type, &ue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_delete_child",
          "args": [
            "device_get_parent(dev->subdevs[i])",
            "dev->subdevs[i]"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_parent",
          "args": [
            "dev->subdevs[i]"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_detach",
          "args": [
            "dev->subdevs[i]",
            "DETACH_FORCE"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (addr %d) disconnected\\n\"",
            "dev->address"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVPTRNAME",
          "args": [
            "dev->subdevs[i]"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"usb_disconnect_port: disconnect subdevs\\n\")"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhub_disconnect: up=%p dev=%p port=%d\\n\", \n\t\t    up, dev, up->portno)"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVPTRNAME",
          "args": [
            "parent"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_disconnect_port(up, parent)\n\tstruct usbd_port *up;\n\tdevice_ptr_t parent;\n{\n\tusbd_device_handle dev = up->device;\n\tchar *hubname = USBDEVPTRNAME(parent);\n\tint i;\n\n\tDPRINTFN(3,(\"uhub_disconnect: up=%p dev=%p port=%d\\n\", \n\t\t    up, dev, up->portno));\n\n#ifdef DIAGNOSTIC\n\tif (dev == NULL) {\n\t\tprintf(\"usb_disconnect_port: no device\\n\");\n\t\treturn;\n\t}\n#endif\n\n\tif (dev->subdevs != NULL) {\n\t\tDPRINTFN(3,(\"usb_disconnect_port: disconnect subdevs\\n\"));\n\t\tfor (i = 0; dev->subdevs[i]; i++) {\n\t\t\tprintf(\"%s: at %s\", USBDEVPTRNAME(dev->subdevs[i]), \n\t\t\t       hubname);\n\t\t\tif (up->portno != 0)\n\t\t\t\tprintf(\" port %d\", up->portno);\n\t\t\tprintf(\" (addr %d) disconnected\\n\", dev->address);\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\t\t\tconfig_detach(dev->subdevs[i], DETACH_FORCE);\n#elif defined(__FreeBSD__)\n                        device_delete_child(device_get_parent(dev->subdevs[i]),\n\t\t\t\t\t    dev->subdevs[i]);\n#endif\n\n\t\t}\n\t}\n\n\tusbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);\n\tdev->bus->devices[dev->address] = NULL;\n\tup->device = NULL;\n\tusb_free_device(dev);\n}"
  },
  {
    "function_name": "usb_free_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "1233-1252",
    "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dev",
            "M_USB"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "usbd_free_iface_data",
          "args": [
            "dev",
            "ifcidx"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_iface_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "507-515",
          "snippet": "void\nusbd_free_iface_data(dev, ifcno)\n\tusbd_device_handle dev;\n\tint ifcno;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifcno];\n\tif (ifc->endpoints)\n\t\tfree(ifc->endpoints, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_free_iface_data __P((usbd_device_handle dev, int ifcno));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_free_iface_data __P((usbd_device_handle dev, int ifcno));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_free_iface_data(dev, ifcno)\n\tusbd_device_handle dev;\n\tint ifcno;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifcno];\n\tif (ifc->endpoints)\n\t\tfree(ifc->endpoints, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_kill_pipe",
          "args": [
            "dev->default_pipe"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_kill_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "721-728",
          "snippet": "void\nusbd_kill_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->close(pipe);\n\tpipe->endpoint->refcnt--;\n\tfree(pipe, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_kill_pipe __P((usbd_pipe_handle));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_kill_pipe __P((usbd_pipe_handle));\n\nvoid\nusbd_kill_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->close(pipe);\n\tpipe->endpoint->refcnt--;\n\tfree(pipe, M_USB);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
  },
  {
    "function_name": "usbd_fill_deviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "1171-1231",
    "snippet": "void\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "p->status.wPortStatus"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "di->devnames[i]",
            "USBDEVPTRNAME(dev->subdevs[i])",
            "USB_MAX_DEVNAMELEN"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVPTRNAME",
          "args": [
            "dev->subdevs[i]"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dev->ddesc.bcdDevice"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dev->ddesc.idProduct"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dev->ddesc.idVendor"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_printBCD",
          "args": [
            "di->release",
            "UGETW(dev->ddesc.bcdDevice)"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_printBCD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "266-272",
          "snippet": "int\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dev->ddesc.bcdDevice"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_devinfo_vp",
          "args": [
            "dev",
            "di->vendor",
            "di->product"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_devinfo_vp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "219-264",
          "snippet": "void\nusbd_devinfo_vp(dev, v, p)\n\tusbd_device_handle dev;\n\tchar *v, *p;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar *vendor = 0, *product = 0;\n#ifdef USBVERBOSE\n\tstruct usb_knowndev *kdp;\n#endif\n\n\tif (dev == NULL) {\n\t\tv[0] = p[0] = '\\0';\n\t\treturn;\n\t}\n\n\tvendor = usbd_get_string(dev, udd->iManufacturer, v);\n\tproduct = usbd_get_string(dev, udd->iProduct, p);\n#ifdef USBVERBOSE\n\tif (vendor == NULL || product == NULL) {\n\t\tfor(kdp = usb_knowndevs;\n\t\t    kdp->vendorname != NULL;\n\t\t    kdp++) {\n\t\t\tif (kdp->vendor == UGETW(udd->idVendor) && \n\t\t\t    (kdp->product == UGETW(udd->idProduct) ||\n\t\t\t     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (kdp->vendorname != NULL) {\n\t\t\tif (!vendor)\n\t\t\t    vendor = kdp->vendorname;\n\t\t\tif (!product)\n\t\t\t    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?\n\t\t\t\tkdp->productname : NULL;\n\t\t}\n\t}\n#endif\n\tif (vendor != NULL)\n\t\tstrcpy(v, vendor);\n\telse\n\t\tsprintf(v, \"vendor 0x%04x\", UGETW(udd->idVendor));\n\tif (product != NULL)\n\t\tstrcpy(p, product);\n\telse\n\t\tsprintf(p, \"product 0x%04x\", UGETW(udd->idProduct));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tUSB_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */"
          ],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static char *usbd_get_string",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUSB_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */\n\nusbd_set_config __P((usbd_device_handle, int));\nStatic char *usbd_get_string;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_devinfo_vp(dev, v, p)\n\tusbd_device_handle dev;\n\tchar *v, *p;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar *vendor = 0, *product = 0;\n#ifdef USBVERBOSE\n\tstruct usb_knowndev *kdp;\n#endif\n\n\tif (dev == NULL) {\n\t\tv[0] = p[0] = '\\0';\n\t\treturn;\n\t}\n\n\tvendor = usbd_get_string(dev, udd->iManufacturer, v);\n\tproduct = usbd_get_string(dev, udd->iProduct, p);\n#ifdef USBVERBOSE\n\tif (vendor == NULL || product == NULL) {\n\t\tfor(kdp = usb_knowndevs;\n\t\t    kdp->vendorname != NULL;\n\t\t    kdp++) {\n\t\t\tif (kdp->vendor == UGETW(udd->idVendor) && \n\t\t\t    (kdp->product == UGETW(udd->idProduct) ||\n\t\t\t     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (kdp->vendorname != NULL) {\n\t\t\tif (!vendor)\n\t\t\t    vendor = kdp->vendorname;\n\t\t\tif (!product)\n\t\t\t    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?\n\t\t\t\tkdp->productname : NULL;\n\t\t}\n\t}\n#endif\n\tif (vendor != NULL)\n\t\tstrcpy(v, vendor);\n\telse\n\t\tsprintf(v, \"vendor 0x%04x\", UGETW(udd->idVendor));\n\tif (product != NULL)\n\t\tstrcpy(p, product);\n\telse\n\t\tsprintf(p, \"product 0x%04x\", UGETW(udd->idProduct));\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVUNIT",
          "args": [
            "dev->bus->bdev"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}"
  },
  {
    "function_name": "usbd_submatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "1126-1167",
    "snippet": "int\nusbd_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct cfdata *cf = match;\n#endif\n\tstruct usb_attach_arg *uaa = aux;\n\n\tDPRINTFN(5,(\"usbd_submatch port=%d,%d configno=%d,%d \"\n\t    \"ifaceno=%d,%d vendor=%d,%d product=%d,%d release=%d,%d\\n\",\n\t    uaa->port, cf->uhubcf_port,\n\t    uaa->configno, cf->uhubcf_configuration,\n\t    uaa->ifaceno, cf->uhubcf_interface,\n\t    uaa->vendor, cf->uhubcf_vendor,\n\t    uaa->product, cf->uhubcf_product,\n\t    uaa->release, cf->uhubcf_release));\n\tif (uaa->port != 0 &&\t/* root hub has port 0, it should match */\n\t    ((uaa->port != 0 &&\n\t      cf->uhubcf_port != UHUB_UNK_PORT &&\n\t      cf->uhubcf_port != uaa->port) ||\n\t     (uaa->configno != UHUB_UNK_CONFIGURATION &&\n\t      cf->uhubcf_configuration != UHUB_UNK_CONFIGURATION &&\n\t      cf->uhubcf_configuration != uaa->configno) ||\n\t     (uaa->ifaceno != UHUB_UNK_INTERFACE &&\n\t      cf->uhubcf_interface != UHUB_UNK_INTERFACE &&\n\t      cf->uhubcf_interface != uaa->ifaceno) ||\n\t     (uaa->vendor != UHUB_UNK_VENDOR &&\n\t      cf->uhubcf_vendor != UHUB_UNK_VENDOR &&\n\t      cf->uhubcf_vendor != uaa->vendor) ||\n\t     (uaa->product != UHUB_UNK_PRODUCT &&\n\t      cf->uhubcf_product != UHUB_UNK_PRODUCT &&\n\t      cf->uhubcf_product != uaa->product) ||\n\t     (uaa->release != UHUB_UNK_RELEASE &&\n\t      cf->uhubcf_release != UHUB_UNK_RELEASE &&\n\t      cf->uhubcf_release != uaa->release)\n\t     )\n\t   )\n\t\treturn 0;\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "cf",
            "aux"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_submatch port=%d,%d configno=%d,%d \"\n\t    \"ifaceno=%d,%d vendor=%d,%d product=%d,%d release=%d,%d\\n\",\n\t    uaa->port, cf->uhubcf_port,\n\t    uaa->configno, cf->uhubcf_configuration,\n\t    uaa->ifaceno, cf->uhubcf_interface,\n\t    uaa->vendor, cf->uhubcf_vendor,\n\t    uaa->product, cf->uhubcf_product,\n\t    uaa->release, cf->uhubcf_release)"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct cfdata *cf = match;\n#endif\n\tstruct usb_attach_arg *uaa = aux;\n\n\tDPRINTFN(5,(\"usbd_submatch port=%d,%d configno=%d,%d \"\n\t    \"ifaceno=%d,%d vendor=%d,%d product=%d,%d release=%d,%d\\n\",\n\t    uaa->port, cf->uhubcf_port,\n\t    uaa->configno, cf->uhubcf_configuration,\n\t    uaa->ifaceno, cf->uhubcf_interface,\n\t    uaa->vendor, cf->uhubcf_vendor,\n\t    uaa->product, cf->uhubcf_product,\n\t    uaa->release, cf->uhubcf_release));\n\tif (uaa->port != 0 &&\t/* root hub has port 0, it should match */\n\t    ((uaa->port != 0 &&\n\t      cf->uhubcf_port != UHUB_UNK_PORT &&\n\t      cf->uhubcf_port != uaa->port) ||\n\t     (uaa->configno != UHUB_UNK_CONFIGURATION &&\n\t      cf->uhubcf_configuration != UHUB_UNK_CONFIGURATION &&\n\t      cf->uhubcf_configuration != uaa->configno) ||\n\t     (uaa->ifaceno != UHUB_UNK_INTERFACE &&\n\t      cf->uhubcf_interface != UHUB_UNK_INTERFACE &&\n\t      cf->uhubcf_interface != uaa->ifaceno) ||\n\t     (uaa->vendor != UHUB_UNK_VENDOR &&\n\t      cf->uhubcf_vendor != UHUB_UNK_VENDOR &&\n\t      cf->uhubcf_vendor != uaa->vendor) ||\n\t     (uaa->product != UHUB_UNK_PRODUCT &&\n\t      cf->uhubcf_product != UHUB_UNK_PRODUCT &&\n\t      cf->uhubcf_product != uaa->product) ||\n\t     (uaa->release != UHUB_UNK_RELEASE &&\n\t      cf->uhubcf_release != UHUB_UNK_RELEASE &&\n\t      cf->uhubcf_release != uaa->release)\n\t     )\n\t   )\n\t\treturn 0;\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}"
  },
  {
    "function_name": "usbd_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "1081-1116",
    "snippet": "int\nusbd_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct usb_attach_arg *uaa = aux;\n\tchar devinfo[1024];\n\n\tDPRINTFN(15, (\"usbd_print dev=%p\\n\", uaa->device));\n\tif (pnp) {\n\t\tif (!uaa->usegeneric)\n\t\t\treturn (QUIET);\n\t\tusbd_devinfo(uaa->device, 1, devinfo);\n\t\tprintf(\"%s, %s\", devinfo, pnp);\n\t}\n\tif (uaa->port != 0)\n\t\tprintf(\" port %d\", uaa->port);\n\tif (uaa->configno != UHUB_UNK_CONFIGURATION)\n\t\tprintf(\" configuration %d\", uaa->configno);\n\tif (uaa->ifaceno != UHUB_UNK_INTERFACE)\n\t\tprintf(\" interface %d\", uaa->ifaceno);\n#if 0\n\t/* \n\t * It gets very crowded with these locators on the attach line.\n\t * They are not really needed since they are printed in the clear\n\t * by each driver.\n\t */\n\tif (uaa->vendor != UHUB_UNK_VENDOR)\n\t\tprintf(\" vendor 0x%04x\", uaa->vendor);\n\tif (uaa->product != UHUB_UNK_PRODUCT)\n\t\tprintf(\" product 0x%04x\", uaa->product);\n\tif (uaa->release != UHUB_UNK_RELEASE)\n\t\tprintf(\" release 0x%04x\", uaa->release);\n#endif\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" release 0x%04x\"",
            "uaa->release"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_devinfo",
          "args": [
            "uaa->device",
            "1",
            "devinfo"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "274-298",
          "snippet": "void\nusbd_devinfo(dev, showclass, cp)\n\tusbd_device_handle dev;\n\tint showclass;\n\tchar *cp;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar vendor[USB_MAX_STRING_LEN];\n\tchar product[USB_MAX_STRING_LEN];\n\tint bcdDevice, bcdUSB;\n\n\tusbd_devinfo_vp(dev, vendor, product);\n\tcp += sprintf(cp, \"%s%s%s\", vendor, *vendor ? \" \" : \"\", product);\n\tif (showclass)\n\t\tcp += sprintf(cp, \", class %d/%d\",\n\t\t\t      udd->bDeviceClass, udd->bDeviceSubClass);\n\tbcdUSB = UGETW(udd->bcdUSB);\n\tbcdDevice = UGETW(udd->bcdDevice);\n\tcp += sprintf(cp, \", rev \");\n\tcp += usbd_printBCD(cp, bcdUSB);\n\t*cp++ = '/';\n\tcp += usbd_printBCD(cp, bcdDevice);\n\tcp += sprintf(cp, \", addr %d\", dev->address);\n\t*cp = 0;\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_devinfo(dev, showclass, cp)\n\tusbd_device_handle dev;\n\tint showclass;\n\tchar *cp;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar vendor[USB_MAX_STRING_LEN];\n\tchar product[USB_MAX_STRING_LEN];\n\tint bcdDevice, bcdUSB;\n\n\tusbd_devinfo_vp(dev, vendor, product);\n\tcp += sprintf(cp, \"%s%s%s\", vendor, *vendor ? \" \" : \"\", product);\n\tif (showclass)\n\t\tcp += sprintf(cp, \", class %d/%d\",\n\t\t\t      udd->bDeviceClass, udd->bDeviceSubClass);\n\tbcdUSB = UGETW(udd->bcdUSB);\n\tbcdDevice = UGETW(udd->bcdDevice);\n\tcp += sprintf(cp, \", rev \");\n\tcp += usbd_printBCD(cp, bcdUSB);\n\t*cp++ = '/';\n\tcp += usbd_printBCD(cp, bcdDevice);\n\tcp += sprintf(cp, \", addr %d\", dev->address);\n\t*cp = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"usbd_print dev=%p\\n\", uaa->device)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nint\nusbd_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct usb_attach_arg *uaa = aux;\n\tchar devinfo[1024];\n\n\tDPRINTFN(15, (\"usbd_print dev=%p\\n\", uaa->device));\n\tif (pnp) {\n\t\tif (!uaa->usegeneric)\n\t\t\treturn (QUIET);\n\t\tusbd_devinfo(uaa->device, 1, devinfo);\n\t\tprintf(\"%s, %s\", devinfo, pnp);\n\t}\n\tif (uaa->port != 0)\n\t\tprintf(\" port %d\", uaa->port);\n\tif (uaa->configno != UHUB_UNK_CONFIGURATION)\n\t\tprintf(\" configuration %d\", uaa->configno);\n\tif (uaa->ifaceno != UHUB_UNK_INTERFACE)\n\t\tprintf(\" interface %d\", uaa->ifaceno);\n#if 0\n\t/* \n\t * It gets very crowded with these locators on the attach line.\n\t * They are not really needed since they are printed in the clear\n\t * by each driver.\n\t */\n\tif (uaa->vendor != UHUB_UNK_VENDOR)\n\t\tprintf(\" vendor 0x%04x\", uaa->vendor);\n\tif (uaa->product != UHUB_UNK_PRODUCT)\n\t\tprintf(\" product 0x%04x\", uaa->product);\n\tif (uaa->release != UHUB_UNK_RELEASE)\n\t\tprintf(\" release 0x%04x\", uaa->release);\n#endif\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "usbd_remove_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "1065-1078",
    "snippet": "void\nusbd_remove_device(dev, up)\n\tusbd_device_handle dev;\n\tstruct usbd_port *up;\n{\n\tDPRINTF((\"usbd_remove_device: %p\\n\", dev));\n  \n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tup->device = 0;\n\tdev->bus->devices[dev->address] = 0;\n\n\tfree(dev, M_USB);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dev",
            "M_USB"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_kill_pipe",
          "args": [
            "dev->default_pipe"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_kill_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "721-728",
          "snippet": "void\nusbd_kill_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->close(pipe);\n\tpipe->endpoint->refcnt--;\n\tfree(pipe, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_kill_pipe __P((usbd_pipe_handle));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_kill_pipe __P((usbd_pipe_handle));\n\nvoid\nusbd_kill_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->close(pipe);\n\tpipe->endpoint->refcnt--;\n\tfree(pipe, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_remove_device: %p\\n\", dev)"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_remove_device(dev, up)\n\tusbd_device_handle dev;\n\tstruct usbd_port *up;\n{\n\tDPRINTF((\"usbd_remove_device: %p\\n\", dev));\n  \n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tup->device = 0;\n\tdev->bus->devices[dev->address] = 0;\n\n\tfree(dev, M_USB);\n}"
  },
  {
    "function_name": "usbd_reload_device_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "1048-1063",
    "snippet": "usbd_status\nusbd_reload_device_desc(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_status err;\n\n\t/* Get the full device descriptor. */\n\terr = usbd_get_device_desc(dev, &dev->ddesc);\n\tif (err)\n\t\treturn (err);\n\n\t/* Figure out what's wrong with this device. */\n\tdev->quirks = usbd_find_quirk(&dev->ddesc);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "Static usbd_status",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_find_quirk",
          "args": [
            "&dev->ddesc"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_device_desc",
          "args": [
            "dev",
            "&dev->ddesc"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_device_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "121-129",
          "snippet": "usbd_status\nusbd_get_device_desc(dev, d)\n\tusbd_device_handle dev;\n\tusb_device_descriptor_t *d;\n{\n\tDPRINTFN(3,(\"usbd_get_device_desc:\\n\"));\n\treturn (usbd_get_desc(dev, UDESC_DEVICE, \n\t\t\t     0, USB_DEVICE_DESCRIPTOR_SIZE, d));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_device_desc(dev, d)\n\tusbd_device_handle dev;\n\tusb_device_descriptor_t *d;\n{\n\tDPRINTFN(3,(\"usbd_get_device_desc:\\n\"));\n\treturn (usbd_get_desc(dev, UDESC_DEVICE, \n\t\t\t     0, USB_DEVICE_DESCRIPTOR_SIZE, d));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_reload_device_desc(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_status err;\n\n\t/* Get the full device descriptor. */\n\terr = usbd_get_device_desc(dev, &dev->ddesc);\n\tif (err)\n\t\treturn (err);\n\n\t/* Figure out what's wrong with this device. */\n\tdev->quirks = usbd_find_quirk(&dev->ddesc);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_new_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "909-1046",
    "snippet": "usbd_status\nusbd_new_device(parent, bus, depth, lowspeed, port, up)\n\tdevice_ptr_t parent;\n\tusbd_bus_handle bus;\n\tint depth;\n\tint lowspeed;\n\tint port;\n\tstruct usbd_port *up;\n{\n\tusbd_device_handle dev;\n\tusb_device_descriptor_t *dd;\n\tusbd_status err;\n\tint addr;\n\tint i;\n\n\tDPRINTF((\"usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\\n\",\n\t\t bus, port, depth, lowspeed));\n\taddr = usbd_getnewaddr(bus);\n\tif (addr < 0) {\n\t\tprintf(\"%s: No free USB addresses, new device ignored.\\n\", \n\t\t       USBDEVNAME(bus->bdev));\n\t\treturn (USBD_NO_ADDR);\n\t}\n\n\tdev = malloc(sizeof *dev, M_USB, M_NOWAIT);\n\tif (dev == NULL)\n\t\treturn (USBD_NOMEM);\n\tmemset(dev, 0, sizeof(*dev));\n\n\tdev->bus = bus;\n\n\t/* Set up default endpoint handle. */\n\tdev->def_ep.edesc = &dev->def_ep_desc;\n\n\t/* Set up default endpoint descriptor. */\n\tdev->def_ep_desc.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE;\n\tdev->def_ep_desc.bDescriptorType = UDESC_ENDPOINT;\n\tdev->def_ep_desc.bEndpointAddress = USB_CONTROL_ENDPOINT;\n\tdev->def_ep_desc.bmAttributes = UE_CONTROL;\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);\n\tdev->def_ep_desc.bInterval = 0;\n\n\tdev->quirks = &usbd_no_quirk;\n\tdev->address = USB_START_ADDR;\n\tdev->ddesc.bMaxPacketSize = 0;\n\tdev->lowspeed = lowspeed != 0;\n\tdev->depth = depth;\n\tdev->powersrc = up;\n\tdev->langid = USBD_NOLANG;\n\tdev->cookie.cookie = ++usb_cookie_no;\n\n\t/* Establish the default pipe. */\n\terr = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,\n\t\t\t      &dev->default_pipe);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tup->device = dev;\n\tdd = &dev->ddesc;\n\t/* Try a few times in case the device is slow (i.e. outside specs.) */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* Get the first 8 bytes of the device descriptor. */\n\t\terr = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);\n\t\tif (!err)\n\t\t\tbreak;\n\t\tusbd_delay_ms(dev, 200);\n\t}\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting first desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tDPRINTF((\"usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, \"\n\t\t \"subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\\n\", \n\t\t addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,\n\t\t dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength, \n\t\t dev->lowspeed));\n\n\tif (dd->bDescriptorType != UDESC_DEVICE) {\n\t\t/* Illegal device descriptor */\n\t\tDPRINTFN(-1,(\"usbd_new_device: illegal descriptor %d\\n\",\n\t\t\t     dd->bDescriptorType));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (dd->bLength < USB_DEVICE_DESCRIPTOR_SIZE) {\n\t\tDPRINTFN(-1,(\"usbd_new_device: bad length %d\\n\", dd->bLength));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, dd->bMaxPacketSize);\n\n\terr = usbd_reload_device_desc(dev);\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting full desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\t/* Set the address */\n\terr = usbd_set_address(dev, addr);\n\tDPRINTFN(5,(\"usbd_new_device: setting device address=%d\\n\", addr));\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usb_new_device: set address %d failed\\n\", addr));\n\t\terr = USBD_SET_ADDR_FAILED;\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\t/* Allow device time to set new address */\n\tusbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);\n\n\tdev->address = addr;\t/* New device address now */\n\tbus->devices[addr] = dev;\n\n\t/* Assume 100mA bus powered for now. Changed when configured. */\n\tdev->power = USB_MIN_POWER;\n\tdev->self_powered = 0;\n\n\tDPRINTF((\"usbd_new_device: new dev (addr %d), dev=%p, parent=%p\\n\", \n\t\t addr, dev, parent));\n  \n\tusbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, dev);\n\n\terr = usbd_probe_and_attach(parent, dev, port, addr);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n  \t}\n\n  \treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "Static usbd_status",
      "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
      "Static u_int32_t usb_cookie_no = 0;",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_remove_device",
          "args": [
            "dev",
            "up"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_remove_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1065-1078",
          "snippet": "void\nusbd_remove_device(dev, up)\n\tusbd_device_handle dev;\n\tstruct usbd_port *up;\n{\n\tDPRINTF((\"usbd_remove_device: %p\\n\", dev));\n  \n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tup->device = 0;\n\tdev->bus->devices[dev->address] = 0;\n\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_remove_device(dev, up)\n\tusbd_device_handle dev;\n\tstruct usbd_port *up;\n{\n\tDPRINTF((\"usbd_remove_device: %p\\n\", dev));\n  \n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tup->device = 0;\n\tdev->bus->devices[dev->address] = 0;\n\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_probe_and_attach",
          "args": [
            "parent",
            "dev",
            "port",
            "addr"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_probe_and_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "743-900",
          "snippet": "usbd_status\nusbd_probe_and_attach(parent, dev, port, addr)\n\tdevice_ptr_t parent;\n\tusbd_device_handle dev;\n\tint port;\n\tint addr;\n{\n\tstruct usb_attach_arg uaa;\n\tusb_device_descriptor_t *dd = &dev->ddesc;\n\tint found, i, confi, nifaces;\n\tusbd_status err;\n\tdevice_ptr_t dv;\n\tusbd_interface_handle ifaces[256]; /* 256 is the absolute max */\n\n#if defined(__FreeBSD__)\n\t/* \n\t * XXX uaa is a static var. Not a problem as it _should_ be used only\n\t * during probe and attach. Should be changed however.\n\t */\n\tdevice_t bdev;\n\tbdev = device_add_child(parent, NULL, -1, &uaa);\n\tif (!bdev) {\n\t    printf(\"%s: Device creation failed\\n\", USBDEVNAME(dev->bus->bdev));\n\t    return (USBD_INVAL);\n\t}\n\tdevice_quiet(bdev);\n#endif\n\n\tuaa.device = dev;\n\tuaa.iface = NULL;\n\tuaa.ifaces = NULL;\n\tuaa.nifaces = 0;\n\tuaa.usegeneric = 0;\n\tuaa.port = port;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tuaa.vendor = UGETW(dd->idVendor);\n\tuaa.product = UGETW(dd->idProduct);\n\tuaa.release = UGETW(dd->bcdDevice);\n\n\t/* First try with device specific drivers. */\n\tDPRINTF((\"usbd_probe_and_attach: trying device specific drivers\\n\"));\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\tDPRINTF((\"usbd_probe_and_attach: no device specific driver found\\n\"));\n\n\tDPRINTF((\"usbd_probe_and_attach: looping over %d configurations\\n\",\n\t\t dd->bNumConfigurations));\n\t/* Next try with interface drivers. */\n\tfor (confi = 0; confi < dd->bNumConfigurations; confi++) {\n\t\tDPRINTFN(1,(\"usbd_probe_and_attach: trying config idx=%d\\n\",\n\t\t\t    confi));\n\t\terr = usbd_set_config_index(dev, confi, 1);\n\t\tif (err) {\n#ifdef USB_DEBUG\n\t\t\tDPRINTF((\"%s: port %d, set config at addr %d failed, \"\n\t\t\t\t \"error=%s\\n\", USBDEVPTRNAME(parent), port,\n\t\t\t\t addr, usbd_errstr(err)));\n#else\n\t\t\tprintf(\"%s: port %d, set config at addr %d failed\\n\",\n\t\t\t       USBDEVPTRNAME(parent), port, addr);\n#endif\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\n \t\t\treturn (err);\n\t\t}\n\t\tnifaces = dev->cdesc->bNumInterface;\n\t\tuaa.configno = dev->cdesc->bConfigurationValue;\n\t\tfor (i = 0; i < nifaces; i++)\n\t\t\tifaces[i] = &dev->ifaces[i];\n\t\tuaa.ifaces = ifaces;\n\t\tuaa.nifaces = nifaces;\n\t\tdev->subdevs = malloc((nifaces+1) * sizeof dv, M_USB,M_NOWAIT);\n\t\tif (dev->subdevs == NULL) {\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\n\t\tfound = 0;\n\t\tfor (i = 0; i < nifaces; i++) {\n\t\t\tif (ifaces[i] == NULL)\n\t\t\t\tcontinue; /* interface already claimed */\n\t\t\tuaa.iface = ifaces[i];\n\t\t\tuaa.ifaceno = ifaces[i]->idesc->bInterfaceNumber;\n\t\t\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print,\n\t\t\t\t\t   usbd_submatch);\n\t\t\tif (dv != NULL) {\n\t\t\t\tdev->subdevs[found++] = dv;\n\t\t\t\tdev->subdevs[found] = 0;\n\t\t\t\tifaces[i] = 0; /* consumed */\n\n#if defined(__FreeBSD__)\n\t\t\t\t/* create another child for the next iface */\n\t\t\t\tbdev = device_add_child(parent, NULL, -1,&uaa);\n\t\t\t\tif (!bdev) {\n\t\t\t\t\tprintf(\"%s: Device creation failed\\n\",\n\t\t\t\t\tUSBDEVNAME(dev->bus->bdev));\n\t\t\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t\t\t}\n\t\t\t\tdevice_quiet(bdev);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (found != 0) {\n#if defined(__FreeBSD__)\n\t\t\t/* remove the last created child again; it is unused */\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tfree(dev->subdevs, M_USB);\n\t\tdev->subdevs = 0;\n\t}\n\t/* No interfaces were attached in any of the configurations. */\n\n\tif (dd->bNumConfigurations > 1) /* don't change if only 1 config */\n\t\tusbd_set_config_index(dev, 0, 0);\n\n\tDPRINTF((\"usbd_probe_and_attach: no interface drivers found\\n\"));\n\n\t/* Finally try the generic driver. */\n\tuaa.iface = NULL;\n\tuaa.usegeneric = 1;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv != NULL) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == 0)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\t/* \n\t * The generic attach failed, but leave the device as it is.\n\t * We just did not find any drivers, that's all.  The device is\n\t * fully operational and not harming anyone.\n\t */\n\tDPRINTF((\"usbd_probe_and_attach: generic attach failed\\n\"));\n#if defined(__FreeBSD__)\n\tdevice_delete_child(parent, bdev);\n#endif\n \treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "Static usbd_status",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nStatic usbd_status;\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_probe_and_attach(parent, dev, port, addr)\n\tdevice_ptr_t parent;\n\tusbd_device_handle dev;\n\tint port;\n\tint addr;\n{\n\tstruct usb_attach_arg uaa;\n\tusb_device_descriptor_t *dd = &dev->ddesc;\n\tint found, i, confi, nifaces;\n\tusbd_status err;\n\tdevice_ptr_t dv;\n\tusbd_interface_handle ifaces[256]; /* 256 is the absolute max */\n\n#if defined(__FreeBSD__)\n\t/* \n\t * XXX uaa is a static var. Not a problem as it _should_ be used only\n\t * during probe and attach. Should be changed however.\n\t */\n\tdevice_t bdev;\n\tbdev = device_add_child(parent, NULL, -1, &uaa);\n\tif (!bdev) {\n\t    printf(\"%s: Device creation failed\\n\", USBDEVNAME(dev->bus->bdev));\n\t    return (USBD_INVAL);\n\t}\n\tdevice_quiet(bdev);\n#endif\n\n\tuaa.device = dev;\n\tuaa.iface = NULL;\n\tuaa.ifaces = NULL;\n\tuaa.nifaces = 0;\n\tuaa.usegeneric = 0;\n\tuaa.port = port;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tuaa.vendor = UGETW(dd->idVendor);\n\tuaa.product = UGETW(dd->idProduct);\n\tuaa.release = UGETW(dd->bcdDevice);\n\n\t/* First try with device specific drivers. */\n\tDPRINTF((\"usbd_probe_and_attach: trying device specific drivers\\n\"));\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\tDPRINTF((\"usbd_probe_and_attach: no device specific driver found\\n\"));\n\n\tDPRINTF((\"usbd_probe_and_attach: looping over %d configurations\\n\",\n\t\t dd->bNumConfigurations));\n\t/* Next try with interface drivers. */\n\tfor (confi = 0; confi < dd->bNumConfigurations; confi++) {\n\t\tDPRINTFN(1,(\"usbd_probe_and_attach: trying config idx=%d\\n\",\n\t\t\t    confi));\n\t\terr = usbd_set_config_index(dev, confi, 1);\n\t\tif (err) {\n#ifdef USB_DEBUG\n\t\t\tDPRINTF((\"%s: port %d, set config at addr %d failed, \"\n\t\t\t\t \"error=%s\\n\", USBDEVPTRNAME(parent), port,\n\t\t\t\t addr, usbd_errstr(err)));\n#else\n\t\t\tprintf(\"%s: port %d, set config at addr %d failed\\n\",\n\t\t\t       USBDEVPTRNAME(parent), port, addr);\n#endif\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\n \t\t\treturn (err);\n\t\t}\n\t\tnifaces = dev->cdesc->bNumInterface;\n\t\tuaa.configno = dev->cdesc->bConfigurationValue;\n\t\tfor (i = 0; i < nifaces; i++)\n\t\t\tifaces[i] = &dev->ifaces[i];\n\t\tuaa.ifaces = ifaces;\n\t\tuaa.nifaces = nifaces;\n\t\tdev->subdevs = malloc((nifaces+1) * sizeof dv, M_USB,M_NOWAIT);\n\t\tif (dev->subdevs == NULL) {\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\n\t\tfound = 0;\n\t\tfor (i = 0; i < nifaces; i++) {\n\t\t\tif (ifaces[i] == NULL)\n\t\t\t\tcontinue; /* interface already claimed */\n\t\t\tuaa.iface = ifaces[i];\n\t\t\tuaa.ifaceno = ifaces[i]->idesc->bInterfaceNumber;\n\t\t\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print,\n\t\t\t\t\t   usbd_submatch);\n\t\t\tif (dv != NULL) {\n\t\t\t\tdev->subdevs[found++] = dv;\n\t\t\t\tdev->subdevs[found] = 0;\n\t\t\t\tifaces[i] = 0; /* consumed */\n\n#if defined(__FreeBSD__)\n\t\t\t\t/* create another child for the next iface */\n\t\t\t\tbdev = device_add_child(parent, NULL, -1,&uaa);\n\t\t\t\tif (!bdev) {\n\t\t\t\t\tprintf(\"%s: Device creation failed\\n\",\n\t\t\t\t\tUSBDEVNAME(dev->bus->bdev));\n\t\t\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t\t\t}\n\t\t\t\tdevice_quiet(bdev);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (found != 0) {\n#if defined(__FreeBSD__)\n\t\t\t/* remove the last created child again; it is unused */\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tfree(dev->subdevs, M_USB);\n\t\tdev->subdevs = 0;\n\t}\n\t/* No interfaces were attached in any of the configurations. */\n\n\tif (dd->bNumConfigurations > 1) /* don't change if only 1 config */\n\t\tusbd_set_config_index(dev, 0, 0);\n\n\tDPRINTF((\"usbd_probe_and_attach: no interface drivers found\\n\"));\n\n\t/* Finally try the generic driver. */\n\tuaa.iface = NULL;\n\tuaa.usegeneric = 1;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv != NULL) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == 0)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\t/* \n\t * The generic attach failed, but leave the device as it is.\n\t * We just did not find any drivers, that's all.  The device is\n\t * fully operational and not harming anyone.\n\t */\n\tDPRINTF((\"usbd_probe_and_attach: generic attach failed\\n\"));\n#if defined(__FreeBSD__)\n\tdevice_delete_child(parent, bdev);\n#endif\n \treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_add_dev_event",
          "args": [
            "USB_EVENT_DEVICE_ATTACH",
            "dev"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_add_dev_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "647-656",
          "snippet": "void\nusbd_add_dev_event(type, udev)\n\tint type;\n\tusbd_device_handle udev;\n{\n\tstruct usb_event ue;\n\n\tusbd_fill_deviceinfo(udev, &ue.u.ue_device);\n\tusb_add_event(type, &ue);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct",
            "usb_add_event __P((int, struct usb_event *));",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nvoid\nusbd_add_dev_event(type, udev)\n\tint type;\n\tusbd_device_handle udev;\n{\n\tstruct usb_event ue;\n\n\tusbd_fill_deviceinfo(udev, &ue.u.ue_device);\n\tusb_add_event(type, &ue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_new_device: new dev (addr %d), dev=%p, parent=%p\\n\", \n\t\t addr, dev, parent)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "dev",
            "USB_SET_ADDRESS_SETTLE"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usb_new_device: set address %d failed\\n\", addr)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_new_device: setting device address=%d\\n\", addr)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_set_address",
          "args": [
            "dev",
            "addr"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "161-174",
          "snippet": "usbd_status\nusbd_set_address(dev, addr)\n\tusbd_device_handle dev;\n\tint addr;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_DEVICE;\n\treq.bRequest = UR_SET_ADDRESS;\n\tUSETW(req.wValue, addr);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\treturn usbd_do_request(dev, &req, 0);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_set_address(dev, addr)\n\tusbd_device_handle dev;\n\tint addr;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_DEVICE;\n\treq.bRequest = UR_SET_ADDRESS;\n\tUSETW(req.wValue, addr);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\treturn usbd_do_request(dev, &req, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usbd_new_device: addr=%d, getting full desc \"\n\t\t\t      \"failed\\n\", addr)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_reload_device_desc",
          "args": [
            "dev"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_reload_device_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1048-1063",
          "snippet": "usbd_status\nusbd_reload_device_desc(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_status err;\n\n\t/* Get the full device descriptor. */\n\terr = usbd_get_device_desc(dev, &dev->ddesc);\n\tif (err)\n\t\treturn (err);\n\n\t/* Figure out what's wrong with this device. */\n\tdev->quirks = usbd_find_quirk(&dev->ddesc);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_reload_device_desc(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_status err;\n\n\t/* Get the full device descriptor. */\n\terr = usbd_get_device_desc(dev, &dev->ddesc);\n\tif (err)\n\t\treturn (err);\n\n\t/* Figure out what's wrong with this device. */\n\tdev->quirks = usbd_find_quirk(&dev->ddesc);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "dev->def_ep_desc.wMaxPacketSize",
            "dd->bMaxPacketSize"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usbd_new_device: bad length %d\\n\", dd->bLength)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usbd_new_device: illegal descriptor %d\\n\",\n\t\t\t     dd->bDescriptorType)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, \"\n\t\t \"subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\\n\", \n\t\t addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,\n\t\t dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength, \n\t\t dev->lowspeed)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->bcdUSB"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usbd_new_device: addr=%d, getting first desc \"\n\t\t\t      \"failed\\n\", addr)"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_desc",
          "args": [
            "dev",
            "UDESC_DEVICE",
            "0",
            "USB_MAX_IPACKET",
            "dd"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "68-86",
          "snippet": "usbd_status\nusbd_get_desc(dev, type, index, len, desc)\n\tusbd_device_handle dev;\n\tint type, index;\n\tint len;\n\tvoid *desc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(3,(\"usbd_get_desc: type=%d, index=%d, len=%d\\n\",\n\t\t    type, index, len));\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, type, index);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request(dev, &req, desc));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_desc(dev, type, index, len, desc)\n\tusbd_device_handle dev;\n\tint type, index;\n\tint len;\n\tvoid *desc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(3,(\"usbd_get_desc: type=%d, index=%d, len=%d\\n\",\n\t\t    type, index, len));\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, type, index);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request(dev, &req, desc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_pipe",
          "args": [
            "dev",
            "0",
            "&dev->def_ep",
            "USBD_DEFAULT_INTERVAL",
            "&dev->default_pipe"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "677-718",
          "snippet": "usbd_status\nusbd_setup_pipe(dev, iface, ep, ival, pipe)\n\tusbd_device_handle dev;\n\tusbd_interface_handle iface; \n\tstruct usbd_endpoint *ep;\n\tint ival;\n\tusbd_pipe_handle *pipe;\n{\n\tusbd_pipe_handle p;\n\tusbd_status err;\n\n\tDPRINTFN(1,(\"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\\n\",\n\t\t    dev, iface, ep, pipe));\n\tp = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\tp->device = dev;\n\tp->iface = iface;\n\tp->endpoint = ep;\n\tep->refcnt++;\n\tp->refcnt = 1;\n\tp->intrxfer = 0;\n\tp->running = 0;\n\tp->aborting = 0;\n\tp->repeat = 0;\n\tp->interval = ival;\n\tSIMPLEQ_INIT(&p->queue);\n\tusb_callout_init(p->abort_handle);\n\terr = dev->bus->methods->open_pipe(p);\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usbd_setup_pipe: endpoint=0x%x failed, error=\"\n\t\t\t \"%s\\n\",\n\t\t\t ep->edesc->bEndpointAddress, usbd_errstr(err)));\n\t\tfree(p, M_USB);\n\t\treturn (err);\n\t}\n\t/* Clear any stall and make sure DATA0 toggle will be used next. */\n\tif (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)\n\t\tusbd_clear_endpoint_stall(p);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_kill_pipe __P((usbd_pipe_handle));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_kill_pipe __P((usbd_pipe_handle));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_setup_pipe(dev, iface, ep, ival, pipe)\n\tusbd_device_handle dev;\n\tusbd_interface_handle iface; \n\tstruct usbd_endpoint *ep;\n\tint ival;\n\tusbd_pipe_handle *pipe;\n{\n\tusbd_pipe_handle p;\n\tusbd_status err;\n\n\tDPRINTFN(1,(\"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\\n\",\n\t\t    dev, iface, ep, pipe));\n\tp = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\tp->device = dev;\n\tp->iface = iface;\n\tp->endpoint = ep;\n\tep->refcnt++;\n\tp->refcnt = 1;\n\tp->intrxfer = 0;\n\tp->running = 0;\n\tp->aborting = 0;\n\tp->repeat = 0;\n\tp->interval = ival;\n\tSIMPLEQ_INIT(&p->queue);\n\tusb_callout_init(p->abort_handle);\n\terr = dev->bus->methods->open_pipe(p);\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usbd_setup_pipe: endpoint=0x%x failed, error=\"\n\t\t\t \"%s\\n\",\n\t\t\t ep->edesc->bEndpointAddress, usbd_errstr(err)));\n\t\tfree(p, M_USB);\n\t\treturn (err);\n\t}\n\t/* Clear any stall and make sure DATA0 toggle will be used next. */\n\tif (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)\n\t\tusbd_clear_endpoint_stall(p);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "dev->def_ep_desc.wMaxPacketSize",
            "USB_MAX_IPACKET"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dev",
            "0",
            "sizeof(*dev)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *dev",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: No free USB addresses, new device ignored.\\n\"",
            "USBDEVNAME(bus->bdev)"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "bus->bdev"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_getnewaddr",
          "args": [
            "bus"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_getnewaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "730-740",
          "snippet": "int\nusbd_getnewaddr(bus)\n\tusbd_bus_handle bus;\n{\n\tint addr;\n\n\tfor (addr = 1; addr < USB_MAX_DEVICES; addr++)\n\t\tif (bus->devices[addr] == 0)\n\t\t\treturn (addr);\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\n\nint\nusbd_getnewaddr(bus)\n\tusbd_bus_handle bus;\n{\n\tint addr;\n\n\tfor (addr = 1; addr < USB_MAX_DEVICES; addr++)\n\t\tif (bus->devices[addr] == 0)\n\t\t\treturn (addr);\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\\n\",\n\t\t bus, port, depth, lowspeed)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nStatic usbd_status;\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nStatic u_int32_t usb_cookie_no = 0;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_new_device(parent, bus, depth, lowspeed, port, up)\n\tdevice_ptr_t parent;\n\tusbd_bus_handle bus;\n\tint depth;\n\tint lowspeed;\n\tint port;\n\tstruct usbd_port *up;\n{\n\tusbd_device_handle dev;\n\tusb_device_descriptor_t *dd;\n\tusbd_status err;\n\tint addr;\n\tint i;\n\n\tDPRINTF((\"usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\\n\",\n\t\t bus, port, depth, lowspeed));\n\taddr = usbd_getnewaddr(bus);\n\tif (addr < 0) {\n\t\tprintf(\"%s: No free USB addresses, new device ignored.\\n\", \n\t\t       USBDEVNAME(bus->bdev));\n\t\treturn (USBD_NO_ADDR);\n\t}\n\n\tdev = malloc(sizeof *dev, M_USB, M_NOWAIT);\n\tif (dev == NULL)\n\t\treturn (USBD_NOMEM);\n\tmemset(dev, 0, sizeof(*dev));\n\n\tdev->bus = bus;\n\n\t/* Set up default endpoint handle. */\n\tdev->def_ep.edesc = &dev->def_ep_desc;\n\n\t/* Set up default endpoint descriptor. */\n\tdev->def_ep_desc.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE;\n\tdev->def_ep_desc.bDescriptorType = UDESC_ENDPOINT;\n\tdev->def_ep_desc.bEndpointAddress = USB_CONTROL_ENDPOINT;\n\tdev->def_ep_desc.bmAttributes = UE_CONTROL;\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);\n\tdev->def_ep_desc.bInterval = 0;\n\n\tdev->quirks = &usbd_no_quirk;\n\tdev->address = USB_START_ADDR;\n\tdev->ddesc.bMaxPacketSize = 0;\n\tdev->lowspeed = lowspeed != 0;\n\tdev->depth = depth;\n\tdev->powersrc = up;\n\tdev->langid = USBD_NOLANG;\n\tdev->cookie.cookie = ++usb_cookie_no;\n\n\t/* Establish the default pipe. */\n\terr = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,\n\t\t\t      &dev->default_pipe);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tup->device = dev;\n\tdd = &dev->ddesc;\n\t/* Try a few times in case the device is slow (i.e. outside specs.) */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* Get the first 8 bytes of the device descriptor. */\n\t\terr = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);\n\t\tif (!err)\n\t\t\tbreak;\n\t\tusbd_delay_ms(dev, 200);\n\t}\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting first desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\tDPRINTF((\"usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, \"\n\t\t \"subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\\n\", \n\t\t addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,\n\t\t dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength, \n\t\t dev->lowspeed));\n\n\tif (dd->bDescriptorType != UDESC_DEVICE) {\n\t\t/* Illegal device descriptor */\n\t\tDPRINTFN(-1,(\"usbd_new_device: illegal descriptor %d\\n\",\n\t\t\t     dd->bDescriptorType));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (dd->bLength < USB_DEVICE_DESCRIPTOR_SIZE) {\n\t\tDPRINTFN(-1,(\"usbd_new_device: bad length %d\\n\", dd->bLength));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (USBD_INVAL);\n\t}\n\n\tUSETW(dev->def_ep_desc.wMaxPacketSize, dd->bMaxPacketSize);\n\n\terr = usbd_reload_device_desc(dev);\n\tif (err) {\n\t\tDPRINTFN(-1, (\"usbd_new_device: addr=%d, getting full desc \"\n\t\t\t      \"failed\\n\", addr));\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\n\t/* Set the address */\n\terr = usbd_set_address(dev, addr);\n\tDPRINTFN(5,(\"usbd_new_device: setting device address=%d\\n\", addr));\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usb_new_device: set address %d failed\\n\", addr));\n\t\terr = USBD_SET_ADDR_FAILED;\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n\t}\n\t/* Allow device time to set new address */\n\tusbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);\n\n\tdev->address = addr;\t/* New device address now */\n\tbus->devices[addr] = dev;\n\n\t/* Assume 100mA bus powered for now. Changed when configured. */\n\tdev->power = USB_MIN_POWER;\n\tdev->self_powered = 0;\n\n\tDPRINTF((\"usbd_new_device: new dev (addr %d), dev=%p, parent=%p\\n\", \n\t\t addr, dev, parent));\n  \n\tusbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, dev);\n\n\terr = usbd_probe_and_attach(parent, dev, port, addr);\n\tif (err) {\n\t\tusbd_remove_device(dev, up);\n\t\treturn (err);\n  \t}\n\n  \treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_probe_and_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "743-900",
    "snippet": "usbd_status\nusbd_probe_and_attach(parent, dev, port, addr)\n\tdevice_ptr_t parent;\n\tusbd_device_handle dev;\n\tint port;\n\tint addr;\n{\n\tstruct usb_attach_arg uaa;\n\tusb_device_descriptor_t *dd = &dev->ddesc;\n\tint found, i, confi, nifaces;\n\tusbd_status err;\n\tdevice_ptr_t dv;\n\tusbd_interface_handle ifaces[256]; /* 256 is the absolute max */\n\n#if defined(__FreeBSD__)\n\t/* \n\t * XXX uaa is a static var. Not a problem as it _should_ be used only\n\t * during probe and attach. Should be changed however.\n\t */\n\tdevice_t bdev;\n\tbdev = device_add_child(parent, NULL, -1, &uaa);\n\tif (!bdev) {\n\t    printf(\"%s: Device creation failed\\n\", USBDEVNAME(dev->bus->bdev));\n\t    return (USBD_INVAL);\n\t}\n\tdevice_quiet(bdev);\n#endif\n\n\tuaa.device = dev;\n\tuaa.iface = NULL;\n\tuaa.ifaces = NULL;\n\tuaa.nifaces = 0;\n\tuaa.usegeneric = 0;\n\tuaa.port = port;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tuaa.vendor = UGETW(dd->idVendor);\n\tuaa.product = UGETW(dd->idProduct);\n\tuaa.release = UGETW(dd->bcdDevice);\n\n\t/* First try with device specific drivers. */\n\tDPRINTF((\"usbd_probe_and_attach: trying device specific drivers\\n\"));\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\tDPRINTF((\"usbd_probe_and_attach: no device specific driver found\\n\"));\n\n\tDPRINTF((\"usbd_probe_and_attach: looping over %d configurations\\n\",\n\t\t dd->bNumConfigurations));\n\t/* Next try with interface drivers. */\n\tfor (confi = 0; confi < dd->bNumConfigurations; confi++) {\n\t\tDPRINTFN(1,(\"usbd_probe_and_attach: trying config idx=%d\\n\",\n\t\t\t    confi));\n\t\terr = usbd_set_config_index(dev, confi, 1);\n\t\tif (err) {\n#ifdef USB_DEBUG\n\t\t\tDPRINTF((\"%s: port %d, set config at addr %d failed, \"\n\t\t\t\t \"error=%s\\n\", USBDEVPTRNAME(parent), port,\n\t\t\t\t addr, usbd_errstr(err)));\n#else\n\t\t\tprintf(\"%s: port %d, set config at addr %d failed\\n\",\n\t\t\t       USBDEVPTRNAME(parent), port, addr);\n#endif\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\n \t\t\treturn (err);\n\t\t}\n\t\tnifaces = dev->cdesc->bNumInterface;\n\t\tuaa.configno = dev->cdesc->bConfigurationValue;\n\t\tfor (i = 0; i < nifaces; i++)\n\t\t\tifaces[i] = &dev->ifaces[i];\n\t\tuaa.ifaces = ifaces;\n\t\tuaa.nifaces = nifaces;\n\t\tdev->subdevs = malloc((nifaces+1) * sizeof dv, M_USB,M_NOWAIT);\n\t\tif (dev->subdevs == NULL) {\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\n\t\tfound = 0;\n\t\tfor (i = 0; i < nifaces; i++) {\n\t\t\tif (ifaces[i] == NULL)\n\t\t\t\tcontinue; /* interface already claimed */\n\t\t\tuaa.iface = ifaces[i];\n\t\t\tuaa.ifaceno = ifaces[i]->idesc->bInterfaceNumber;\n\t\t\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print,\n\t\t\t\t\t   usbd_submatch);\n\t\t\tif (dv != NULL) {\n\t\t\t\tdev->subdevs[found++] = dv;\n\t\t\t\tdev->subdevs[found] = 0;\n\t\t\t\tifaces[i] = 0; /* consumed */\n\n#if defined(__FreeBSD__)\n\t\t\t\t/* create another child for the next iface */\n\t\t\t\tbdev = device_add_child(parent, NULL, -1,&uaa);\n\t\t\t\tif (!bdev) {\n\t\t\t\t\tprintf(\"%s: Device creation failed\\n\",\n\t\t\t\t\tUSBDEVNAME(dev->bus->bdev));\n\t\t\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t\t\t}\n\t\t\t\tdevice_quiet(bdev);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (found != 0) {\n#if defined(__FreeBSD__)\n\t\t\t/* remove the last created child again; it is unused */\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tfree(dev->subdevs, M_USB);\n\t\tdev->subdevs = 0;\n\t}\n\t/* No interfaces were attached in any of the configurations. */\n\n\tif (dd->bNumConfigurations > 1) /* don't change if only 1 config */\n\t\tusbd_set_config_index(dev, 0, 0);\n\n\tDPRINTF((\"usbd_probe_and_attach: no interface drivers found\\n\"));\n\n\t/* Finally try the generic driver. */\n\tuaa.iface = NULL;\n\tuaa.usegeneric = 1;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv != NULL) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == 0)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\t/* \n\t * The generic attach failed, but leave the device as it is.\n\t * We just did not find any drivers, that's all.  The device is\n\t * fully operational and not harming anyone.\n\t */\n\tDPRINTF((\"usbd_probe_and_attach: generic attach failed\\n\"));\n#if defined(__FreeBSD__)\n\tdevice_delete_child(parent, bdev);\n#endif\n \treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "Static usbd_status",
      "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_delete_child",
          "args": [
            "parent",
            "bdev"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_probe_and_attach: generic attach failed\\n\")"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2 * sizeof dv",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_DO_ATTACH",
          "args": [
            "dev",
            "bdev",
            "parent",
            "&uaa",
            "usbd_print",
            "usbd_submatch"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_probe_and_attach: no interface drivers found\\n\")"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_set_config_index",
          "args": [
            "dev",
            "0",
            "0"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_config_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "554-673",
          "snippet": "usbd_status\nusbd_set_config_index(dev, index, msg)\n\tusbd_device_handle dev;\n\tint index;\n\tint msg;\n{\n\tusb_status_t ds;\n\tusb_config_descriptor_t cd, *cdp;\n\tusbd_status err;\n\tint ifcidx, nifc, len, selfpowered, power;\n\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index));\n\n\t/* XXX check that all interfaces are idle */\n\tif (dev->config != 0) {\n\t\tDPRINTF((\"usbd_set_config_index: free old config\\n\"));\n\t\t/* Free all configuration data structures. */\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t\tfree(dev->cdesc, M_USB);\n\t\tdev->ifaces = NULL;\n\t\tdev->cdesc = NULL;\n\t\tdev->config = 0;\n\t}\n\n\t/* Figure out what config number to use. */\n\terr = usbd_get_config_desc(dev, index, &cd);\n\tif (err)\n\t\treturn (err);\n\tlen = UGETW(cd.wTotalLength);\n\tcdp = malloc(len, M_USB, M_NOWAIT);\n\tif (cdp == NULL)\n\t\treturn (USBD_NOMEM);\n\terr = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);\n\tif (err)\n\t\tgoto bad;\n\tif (cdp->bDescriptorType != UDESC_CONFIG) {\n\t\tDPRINTFN(-1,(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType));\n\t\terr = USBD_INVAL;\n\t\tgoto bad;\n\t}\n\tselfpowered = 0;\n\tif (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&\n\t    cdp->bmAttributes & UC_SELF_POWERED) {\n\t\t/* May be self powered. */\n\t\tif (cdp->bmAttributes & UC_BUS_POWERED) {\n\t\t\t/* Must ask device. */\n\t\t\terr = usbd_get_device_status(dev, &ds);\n\t\t\tif (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))\n\t\t\t\tselfpowered = 1;\n\t\t\tDPRINTF((\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err)));\n\t\t} else\n\t\t\tselfpowered = 1;\n\t}\n\tDPRINTF((\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2));\n#ifdef USB_DEBUG\n\tif (dev->powersrc == NULL) {\n\t\tDPRINTF((\"usbd_set_config_index: No power source?\\n\"));\n\t\treturn (USBD_IOERROR);\n\t}\n#endif\n\tpower = cdp->bMaxPower * 2;\n\tif (power > dev->powersrc->power) {\n\t\t/* XXX print nicer message. */\n\t\tif (msg)\n\t\t\tprintf(\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\",\n\t\t\t       USBDEVNAME(dev->bus->bdev), dev->address, \n\t\t\t       cdp->bConfigurationValue, \n\t\t\t       power, dev->powersrc->power);\n\t\terr = USBD_NO_POWER;\n\t\tgoto bad;\n\t}\n\tdev->power = power;\n\tdev->self_powered = selfpowered;\n\n\tDPRINTF((\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\terr = usbd_set_config(dev, cdp->bConfigurationValue);\n\tif (err) {\n\t\tDPRINTF((\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err)));\n\t\tgoto bad;\n\t}\n\tDPRINTF((\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\tnifc = cdp->bNumInterface;\n\tdev->ifaces = malloc(nifc * sizeof(struct usbd_interface), \n\t\t\t     M_USB, M_NOWAIT);\n\tif (dev->ifaces == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad;\n\t}\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp));\n\tdev->cdesc = cdp;\n\tdev->config = cdp->bConfigurationValue;\n\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++) {\n\t\terr = usbd_fill_iface_data(dev, ifcidx, 0);\n\t\tif (err) {\n\t\t\twhile (--ifcidx >= 0)\n\t\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tfree(cdp, M_USB);\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "Static usbd_status",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;",
            "usb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nStatic usbd_status;\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;\nusb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;\n\nusbd_status\nusbd_set_config_index(dev, index, msg)\n\tusbd_device_handle dev;\n\tint index;\n\tint msg;\n{\n\tusb_status_t ds;\n\tusb_config_descriptor_t cd, *cdp;\n\tusbd_status err;\n\tint ifcidx, nifc, len, selfpowered, power;\n\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index));\n\n\t/* XXX check that all interfaces are idle */\n\tif (dev->config != 0) {\n\t\tDPRINTF((\"usbd_set_config_index: free old config\\n\"));\n\t\t/* Free all configuration data structures. */\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t\tfree(dev->cdesc, M_USB);\n\t\tdev->ifaces = NULL;\n\t\tdev->cdesc = NULL;\n\t\tdev->config = 0;\n\t}\n\n\t/* Figure out what config number to use. */\n\terr = usbd_get_config_desc(dev, index, &cd);\n\tif (err)\n\t\treturn (err);\n\tlen = UGETW(cd.wTotalLength);\n\tcdp = malloc(len, M_USB, M_NOWAIT);\n\tif (cdp == NULL)\n\t\treturn (USBD_NOMEM);\n\terr = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);\n\tif (err)\n\t\tgoto bad;\n\tif (cdp->bDescriptorType != UDESC_CONFIG) {\n\t\tDPRINTFN(-1,(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType));\n\t\terr = USBD_INVAL;\n\t\tgoto bad;\n\t}\n\tselfpowered = 0;\n\tif (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&\n\t    cdp->bmAttributes & UC_SELF_POWERED) {\n\t\t/* May be self powered. */\n\t\tif (cdp->bmAttributes & UC_BUS_POWERED) {\n\t\t\t/* Must ask device. */\n\t\t\terr = usbd_get_device_status(dev, &ds);\n\t\t\tif (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))\n\t\t\t\tselfpowered = 1;\n\t\t\tDPRINTF((\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err)));\n\t\t} else\n\t\t\tselfpowered = 1;\n\t}\n\tDPRINTF((\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2));\n#ifdef USB_DEBUG\n\tif (dev->powersrc == NULL) {\n\t\tDPRINTF((\"usbd_set_config_index: No power source?\\n\"));\n\t\treturn (USBD_IOERROR);\n\t}\n#endif\n\tpower = cdp->bMaxPower * 2;\n\tif (power > dev->powersrc->power) {\n\t\t/* XXX print nicer message. */\n\t\tif (msg)\n\t\t\tprintf(\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\",\n\t\t\t       USBDEVNAME(dev->bus->bdev), dev->address, \n\t\t\t       cdp->bConfigurationValue, \n\t\t\t       power, dev->powersrc->power);\n\t\terr = USBD_NO_POWER;\n\t\tgoto bad;\n\t}\n\tdev->power = power;\n\tdev->self_powered = selfpowered;\n\n\tDPRINTF((\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\terr = usbd_set_config(dev, cdp->bConfigurationValue);\n\tif (err) {\n\t\tDPRINTF((\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err)));\n\t\tgoto bad;\n\t}\n\tDPRINTF((\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\tnifc = cdp->bNumInterface;\n\tdev->ifaces = malloc(nifc * sizeof(struct usbd_interface), \n\t\t\t     M_USB, M_NOWAIT);\n\tif (dev->ifaces == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad;\n\t}\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp));\n\tdev->cdesc = cdp;\n\tdev->config = cdp->bConfigurationValue;\n\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++) {\n\t\terr = usbd_fill_iface_data(dev, ifcidx, 0);\n\t\tif (err) {\n\t\t\twhile (--ifcidx >= 0)\n\t\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tfree(cdp, M_USB);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dev->subdevs",
            "M_USB"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_delete_child",
          "args": [
            "parent",
            "bdev"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_quiet",
          "args": [
            "bdev"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Device creation failed\\n\"",
            "USBDEVNAME(dev->bus->bdev)"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "dev->bus->bdev"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_add_child",
          "args": [
            "parent",
            "NULL",
            "-1",
            "&uaa"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_DO_ATTACH",
          "args": [
            "dev",
            "bdev",
            "parent",
            "&uaa",
            "usbd_print",
            "usbd_submatch"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_delete_child",
          "args": [
            "parent",
            "bdev"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_delete_child",
          "args": [
            "parent",
            "bdev"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVPTRNAME",
          "args": [
            "parent"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: port %d, set config at addr %d failed, \"\n\t\t\t\t \"error=%s\\n\", USBDEVPTRNAME(parent), port,\n\t\t\t\t addr, usbd_errstr(err))"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVPTRNAME",
          "args": [
            "parent"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"usbd_probe_and_attach: trying config idx=%d\\n\",\n\t\t\t    confi)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_probe_and_attach: looping over %d configurations\\n\",\n\t\t dd->bNumConfigurations)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_probe_and_attach: no device specific driver found\\n\")"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_DO_ATTACH",
          "args": [
            "dev",
            "bdev",
            "parent",
            "&uaa",
            "usbd_print",
            "usbd_submatch"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_probe_and_attach: trying device specific drivers\\n\")"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->bcdDevice"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->idProduct"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dd->idVendor"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_quiet",
          "args": [
            "bdev"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "dev->bus->bdev"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_add_child",
          "args": [
            "parent",
            "NULL",
            "-1",
            "&uaa"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nStatic usbd_status;\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_probe_and_attach(parent, dev, port, addr)\n\tdevice_ptr_t parent;\n\tusbd_device_handle dev;\n\tint port;\n\tint addr;\n{\n\tstruct usb_attach_arg uaa;\n\tusb_device_descriptor_t *dd = &dev->ddesc;\n\tint found, i, confi, nifaces;\n\tusbd_status err;\n\tdevice_ptr_t dv;\n\tusbd_interface_handle ifaces[256]; /* 256 is the absolute max */\n\n#if defined(__FreeBSD__)\n\t/* \n\t * XXX uaa is a static var. Not a problem as it _should_ be used only\n\t * during probe and attach. Should be changed however.\n\t */\n\tdevice_t bdev;\n\tbdev = device_add_child(parent, NULL, -1, &uaa);\n\tif (!bdev) {\n\t    printf(\"%s: Device creation failed\\n\", USBDEVNAME(dev->bus->bdev));\n\t    return (USBD_INVAL);\n\t}\n\tdevice_quiet(bdev);\n#endif\n\n\tuaa.device = dev;\n\tuaa.iface = NULL;\n\tuaa.ifaces = NULL;\n\tuaa.nifaces = 0;\n\tuaa.usegeneric = 0;\n\tuaa.port = port;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tuaa.vendor = UGETW(dd->idVendor);\n\tuaa.product = UGETW(dd->idProduct);\n\tuaa.release = UGETW(dd->bcdDevice);\n\n\t/* First try with device specific drivers. */\n\tDPRINTF((\"usbd_probe_and_attach: trying device specific drivers\\n\"));\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\tDPRINTF((\"usbd_probe_and_attach: no device specific driver found\\n\"));\n\n\tDPRINTF((\"usbd_probe_and_attach: looping over %d configurations\\n\",\n\t\t dd->bNumConfigurations));\n\t/* Next try with interface drivers. */\n\tfor (confi = 0; confi < dd->bNumConfigurations; confi++) {\n\t\tDPRINTFN(1,(\"usbd_probe_and_attach: trying config idx=%d\\n\",\n\t\t\t    confi));\n\t\terr = usbd_set_config_index(dev, confi, 1);\n\t\tif (err) {\n#ifdef USB_DEBUG\n\t\t\tDPRINTF((\"%s: port %d, set config at addr %d failed, \"\n\t\t\t\t \"error=%s\\n\", USBDEVPTRNAME(parent), port,\n\t\t\t\t addr, usbd_errstr(err)));\n#else\n\t\t\tprintf(\"%s: port %d, set config at addr %d failed\\n\",\n\t\t\t       USBDEVPTRNAME(parent), port, addr);\n#endif\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\n \t\t\treturn (err);\n\t\t}\n\t\tnifaces = dev->cdesc->bNumInterface;\n\t\tuaa.configno = dev->cdesc->bConfigurationValue;\n\t\tfor (i = 0; i < nifaces; i++)\n\t\t\tifaces[i] = &dev->ifaces[i];\n\t\tuaa.ifaces = ifaces;\n\t\tuaa.nifaces = nifaces;\n\t\tdev->subdevs = malloc((nifaces+1) * sizeof dv, M_USB,M_NOWAIT);\n\t\tif (dev->subdevs == NULL) {\n#if defined(__FreeBSD__)\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\n\t\tfound = 0;\n\t\tfor (i = 0; i < nifaces; i++) {\n\t\t\tif (ifaces[i] == NULL)\n\t\t\t\tcontinue; /* interface already claimed */\n\t\t\tuaa.iface = ifaces[i];\n\t\t\tuaa.ifaceno = ifaces[i]->idesc->bInterfaceNumber;\n\t\t\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print,\n\t\t\t\t\t   usbd_submatch);\n\t\t\tif (dv != NULL) {\n\t\t\t\tdev->subdevs[found++] = dv;\n\t\t\t\tdev->subdevs[found] = 0;\n\t\t\t\tifaces[i] = 0; /* consumed */\n\n#if defined(__FreeBSD__)\n\t\t\t\t/* create another child for the next iface */\n\t\t\t\tbdev = device_add_child(parent, NULL, -1,&uaa);\n\t\t\t\tif (!bdev) {\n\t\t\t\t\tprintf(\"%s: Device creation failed\\n\",\n\t\t\t\t\tUSBDEVNAME(dev->bus->bdev));\n\t\t\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t\t\t}\n\t\t\t\tdevice_quiet(bdev);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (found != 0) {\n#if defined(__FreeBSD__)\n\t\t\t/* remove the last created child again; it is unused */\n\t\t\tdevice_delete_child(parent, bdev);\n#endif\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tfree(dev->subdevs, M_USB);\n\t\tdev->subdevs = 0;\n\t}\n\t/* No interfaces were attached in any of the configurations. */\n\n\tif (dd->bNumConfigurations > 1) /* don't change if only 1 config */\n\t\tusbd_set_config_index(dev, 0, 0);\n\n\tDPRINTF((\"usbd_probe_and_attach: no interface drivers found\\n\"));\n\n\t/* Finally try the generic driver. */\n\tuaa.iface = NULL;\n\tuaa.usegeneric = 1;\n\tuaa.configno = UHUB_UNK_CONFIGURATION;\n\tuaa.ifaceno = UHUB_UNK_INTERFACE;\n\tdv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);\n\tif (dv != NULL) {\n\t\tdev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);\n\t\tif (dev->subdevs == 0)\n\t\t\treturn (USBD_NOMEM);\n\t\tdev->subdevs[0] = dv;\n\t\tdev->subdevs[1] = 0;\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\t/* \n\t * The generic attach failed, but leave the device as it is.\n\t * We just did not find any drivers, that's all.  The device is\n\t * fully operational and not harming anyone.\n\t */\n\tDPRINTF((\"usbd_probe_and_attach: generic attach failed\\n\"));\n#if defined(__FreeBSD__)\n\tdevice_delete_child(parent, bdev);\n#endif\n \treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_getnewaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "730-740",
    "snippet": "int\nusbd_getnewaddr(bus)\n\tusbd_bus_handle bus;\n{\n\tint addr;\n\n\tfor (addr = 1; addr < USB_MAX_DEVICES; addr++)\n\t\tif (bus->devices[addr] == 0)\n\t\t\treturn (addr);\n\treturn (-1);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\n\nint\nusbd_getnewaddr(bus)\n\tusbd_bus_handle bus;\n{\n\tint addr;\n\n\tfor (addr = 1; addr < USB_MAX_DEVICES; addr++)\n\t\tif (bus->devices[addr] == 0)\n\t\t\treturn (addr);\n\treturn (-1);\n}"
  },
  {
    "function_name": "usbd_kill_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "721-728",
    "snippet": "void\nusbd_kill_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->close(pipe);\n\tpipe->endpoint->refcnt--;\n\tfree(pipe, M_USB);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_kill_pipe __P((usbd_pipe_handle));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pipe",
            "M_USB"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe->methods->close",
          "args": [
            "pipe"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_kill_pipe __P((usbd_pipe_handle));\n\nvoid\nusbd_kill_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->close(pipe);\n\tpipe->endpoint->refcnt--;\n\tfree(pipe, M_USB);\n}"
  },
  {
    "function_name": "usbd_setup_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "677-718",
    "snippet": "usbd_status\nusbd_setup_pipe(dev, iface, ep, ival, pipe)\n\tusbd_device_handle dev;\n\tusbd_interface_handle iface; \n\tstruct usbd_endpoint *ep;\n\tint ival;\n\tusbd_pipe_handle *pipe;\n{\n\tusbd_pipe_handle p;\n\tusbd_status err;\n\n\tDPRINTFN(1,(\"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\\n\",\n\t\t    dev, iface, ep, pipe));\n\tp = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\tp->device = dev;\n\tp->iface = iface;\n\tp->endpoint = ep;\n\tep->refcnt++;\n\tp->refcnt = 1;\n\tp->intrxfer = 0;\n\tp->running = 0;\n\tp->aborting = 0;\n\tp->repeat = 0;\n\tp->interval = ival;\n\tSIMPLEQ_INIT(&p->queue);\n\tusb_callout_init(p->abort_handle);\n\terr = dev->bus->methods->open_pipe(p);\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usbd_setup_pipe: endpoint=0x%x failed, error=\"\n\t\t\t \"%s\\n\",\n\t\t\t ep->edesc->bEndpointAddress, usbd_errstr(err)));\n\t\tfree(p, M_USB);\n\t\treturn (err);\n\t}\n\t/* Clear any stall and make sure DATA0 toggle will be used next. */\n\tif (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)\n\t\tusbd_clear_endpoint_stall(p);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "usbd_kill_pipe __P((usbd_pipe_handle));",
      "Static usbd_status",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "p"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UE_GET_ADDR",
          "args": [
            "ep->edesc->bEndpointAddress"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p",
            "M_USB"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usbd_setup_pipe: endpoint=0x%x failed, error=\"\n\t\t\t \"%s\\n\",\n\t\t\t ep->edesc->bEndpointAddress, usbd_errstr(err))"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->bus->methods->open_pipe",
          "args": [
            "p"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout_init",
          "args": [
            "p->abort_handle"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&p->queue"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dev->bus->pipe_size",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\\n\",\n\t\t    dev, iface, ep, pipe)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_kill_pipe __P((usbd_pipe_handle));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_setup_pipe(dev, iface, ep, ival, pipe)\n\tusbd_device_handle dev;\n\tusbd_interface_handle iface; \n\tstruct usbd_endpoint *ep;\n\tint ival;\n\tusbd_pipe_handle *pipe;\n{\n\tusbd_pipe_handle p;\n\tusbd_status err;\n\n\tDPRINTFN(1,(\"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\\n\",\n\t\t    dev, iface, ep, pipe));\n\tp = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\tp->device = dev;\n\tp->iface = iface;\n\tp->endpoint = ep;\n\tep->refcnt++;\n\tp->refcnt = 1;\n\tp->intrxfer = 0;\n\tp->running = 0;\n\tp->aborting = 0;\n\tp->repeat = 0;\n\tp->interval = ival;\n\tSIMPLEQ_INIT(&p->queue);\n\tusb_callout_init(p->abort_handle);\n\terr = dev->bus->methods->open_pipe(p);\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usbd_setup_pipe: endpoint=0x%x failed, error=\"\n\t\t\t \"%s\\n\",\n\t\t\t ep->edesc->bEndpointAddress, usbd_errstr(err)));\n\t\tfree(p, M_USB);\n\t\treturn (err);\n\t}\n\t/* Clear any stall and make sure DATA0 toggle will be used next. */\n\tif (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)\n\t\tusbd_clear_endpoint_stall(p);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_set_config_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "554-673",
    "snippet": "usbd_status\nusbd_set_config_index(dev, index, msg)\n\tusbd_device_handle dev;\n\tint index;\n\tint msg;\n{\n\tusb_status_t ds;\n\tusb_config_descriptor_t cd, *cdp;\n\tusbd_status err;\n\tint ifcidx, nifc, len, selfpowered, power;\n\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index));\n\n\t/* XXX check that all interfaces are idle */\n\tif (dev->config != 0) {\n\t\tDPRINTF((\"usbd_set_config_index: free old config\\n\"));\n\t\t/* Free all configuration data structures. */\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t\tfree(dev->cdesc, M_USB);\n\t\tdev->ifaces = NULL;\n\t\tdev->cdesc = NULL;\n\t\tdev->config = 0;\n\t}\n\n\t/* Figure out what config number to use. */\n\terr = usbd_get_config_desc(dev, index, &cd);\n\tif (err)\n\t\treturn (err);\n\tlen = UGETW(cd.wTotalLength);\n\tcdp = malloc(len, M_USB, M_NOWAIT);\n\tif (cdp == NULL)\n\t\treturn (USBD_NOMEM);\n\terr = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);\n\tif (err)\n\t\tgoto bad;\n\tif (cdp->bDescriptorType != UDESC_CONFIG) {\n\t\tDPRINTFN(-1,(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType));\n\t\terr = USBD_INVAL;\n\t\tgoto bad;\n\t}\n\tselfpowered = 0;\n\tif (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&\n\t    cdp->bmAttributes & UC_SELF_POWERED) {\n\t\t/* May be self powered. */\n\t\tif (cdp->bmAttributes & UC_BUS_POWERED) {\n\t\t\t/* Must ask device. */\n\t\t\terr = usbd_get_device_status(dev, &ds);\n\t\t\tif (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))\n\t\t\t\tselfpowered = 1;\n\t\t\tDPRINTF((\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err)));\n\t\t} else\n\t\t\tselfpowered = 1;\n\t}\n\tDPRINTF((\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2));\n#ifdef USB_DEBUG\n\tif (dev->powersrc == NULL) {\n\t\tDPRINTF((\"usbd_set_config_index: No power source?\\n\"));\n\t\treturn (USBD_IOERROR);\n\t}\n#endif\n\tpower = cdp->bMaxPower * 2;\n\tif (power > dev->powersrc->power) {\n\t\t/* XXX print nicer message. */\n\t\tif (msg)\n\t\t\tprintf(\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\",\n\t\t\t       USBDEVNAME(dev->bus->bdev), dev->address, \n\t\t\t       cdp->bConfigurationValue, \n\t\t\t       power, dev->powersrc->power);\n\t\terr = USBD_NO_POWER;\n\t\tgoto bad;\n\t}\n\tdev->power = power;\n\tdev->self_powered = selfpowered;\n\n\tDPRINTF((\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\terr = usbd_set_config(dev, cdp->bConfigurationValue);\n\tif (err) {\n\t\tDPRINTF((\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err)));\n\t\tgoto bad;\n\t}\n\tDPRINTF((\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\tnifc = cdp->bNumInterface;\n\tdev->ifaces = malloc(nifc * sizeof(struct usbd_interface), \n\t\t\t     M_USB, M_NOWAIT);\n\tif (dev->ifaces == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad;\n\t}\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp));\n\tdev->cdesc = cdp;\n\tdev->config = cdp->bConfigurationValue;\n\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++) {\n\t\terr = usbd_fill_iface_data(dev, ifcidx, 0);\n\t\tif (err) {\n\t\t\twhile (--ifcidx >= 0)\n\t\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tfree(cdp, M_USB);\n\treturn (err);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "Static usbd_status",
      "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
      "usb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;",
      "usb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cdp",
            "M_USB"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_free_iface_data",
          "args": [
            "dev",
            "ifcidx"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_iface_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "507-515",
          "snippet": "void\nusbd_free_iface_data(dev, ifcno)\n\tusbd_device_handle dev;\n\tint ifcno;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifcno];\n\tif (ifc->endpoints)\n\t\tfree(ifc->endpoints, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_free_iface_data __P((usbd_device_handle dev, int ifcno));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_free_iface_data __P((usbd_device_handle dev, int ifcno));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_free_iface_data(dev, ifcno)\n\tusbd_device_handle dev;\n\tint ifcno;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifcno];\n\tif (ifc->endpoints)\n\t\tfree(ifc->endpoints, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_fill_iface_data",
          "args": [
            "dev",
            "ifcidx",
            "0"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_fill_iface_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "441-505",
          "snippet": "usbd_status\nusbd_fill_iface_data(dev, ifaceidx, altidx)\n\tusbd_device_handle dev;\n\tint ifaceidx;\n\tint altidx;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifaceidx];\n\tchar *p, *end;\n\tint endpt, nendpt;\n\n\tDPRINTFN(4,(\"usbd_fill_iface_data: ifaceidx=%d altidx=%d\\n\",\n\t\t    ifaceidx, altidx));\n\tifc->device = dev;\n\tifc->idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);\n\tif (ifc->idesc == 0)\n\t\treturn (USBD_INVAL);\n\tifc->index = ifaceidx;\n\tifc->altindex = altidx;\n\tnendpt = ifc->idesc->bNumEndpoints;\n\tDPRINTFN(4,(\"usbd_fill_iface_data: found idesc nendpt=%d\\n\", nendpt));\n\tif (nendpt != 0) {\n\t\tifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),\n\t\t\t\t\tM_USB, M_NOWAIT);\n\t\tif (ifc->endpoints == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t} else\n\t\tifc->endpoints = NULL;\n\tifc->priv = NULL;\n\tp = (char *)ifc->idesc + ifc->idesc->bLength;\n\tend = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);\n#define ed ((usb_endpoint_descriptor_t *)p)\n\tfor (endpt = 0; endpt < nendpt; endpt++) {\n\t\tDPRINTFN(10,(\"usbd_fill_iface_data: endpt=%d\\n\", endpt));\n\t\tfor (; p < end; p += ed->bLength) {\n\t\t\ted = (usb_endpoint_descriptor_t *)p;\n\t\t\tDPRINTFN(10,(\"usbd_fill_iface_data: p=%p end=%p \"\n\t\t\t\t     \"len=%d type=%d\\n\",\n\t\t\t\t p, end, ed->bLength, ed->bDescriptorType));\n\t\t\tif (p + ed->bLength <= end && ed->bLength != 0 &&\n\t\t\t    ed->bDescriptorType == UDESC_ENDPOINT)\n\t\t\t\tgoto found;\n\t\t\tif (ed->bLength == 0 ||\n\t\t\t    ed->bDescriptorType == UDESC_INTERFACE)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* passed end, or bad desc */\n\t\tDPRINTF((\"usbd_fill_iface_data: bad descriptor(s): %s\\n\",\n\t\t\t ed->bLength == 0 ? \"0 length\" :\n\t\t\t ed->bDescriptorType == UDESC_INTERFACE ? \"iface desc\":\n\t\t\t \"out of data\"));\n\t\tgoto bad;\n\tfound:\n\t\tifc->endpoints[endpt].edesc = ed;\n\t\tifc->endpoints[endpt].refcnt = 0;\n\t\tp += ed->bLength;\n\t}\n#undef ed\n\tLIST_INIT(&ifc->pipes);\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tif (ifc->endpoints != NULL)\n\t\tfree(ifc->endpoints, M_USB);\n\treturn (USBD_INVAL);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ed ((usb_endpoint_descriptor_t *)p)"
          ],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
            "int ifaceidx;",
            "int altidx;",
            "int ifaceidx;",
            "int altidx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ed ((usb_endpoint_descriptor_t *)p)\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nint ifaceidx;\nint altidx;\nint ifaceidx;\nint altidx;\n\nusbd_status\nusbd_fill_iface_data(dev, ifaceidx, altidx)\n\tusbd_device_handle dev;\n\tint ifaceidx;\n\tint altidx;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifaceidx];\n\tchar *p, *end;\n\tint endpt, nendpt;\n\n\tDPRINTFN(4,(\"usbd_fill_iface_data: ifaceidx=%d altidx=%d\\n\",\n\t\t    ifaceidx, altidx));\n\tifc->device = dev;\n\tifc->idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);\n\tif (ifc->idesc == 0)\n\t\treturn (USBD_INVAL);\n\tifc->index = ifaceidx;\n\tifc->altindex = altidx;\n\tnendpt = ifc->idesc->bNumEndpoints;\n\tDPRINTFN(4,(\"usbd_fill_iface_data: found idesc nendpt=%d\\n\", nendpt));\n\tif (nendpt != 0) {\n\t\tifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),\n\t\t\t\t\tM_USB, M_NOWAIT);\n\t\tif (ifc->endpoints == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t} else\n\t\tifc->endpoints = NULL;\n\tifc->priv = NULL;\n\tp = (char *)ifc->idesc + ifc->idesc->bLength;\n\tend = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);\n#define ed ((usb_endpoint_descriptor_t *)p)\n\tfor (endpt = 0; endpt < nendpt; endpt++) {\n\t\tDPRINTFN(10,(\"usbd_fill_iface_data: endpt=%d\\n\", endpt));\n\t\tfor (; p < end; p += ed->bLength) {\n\t\t\ted = (usb_endpoint_descriptor_t *)p;\n\t\t\tDPRINTFN(10,(\"usbd_fill_iface_data: p=%p end=%p \"\n\t\t\t\t     \"len=%d type=%d\\n\",\n\t\t\t\t p, end, ed->bLength, ed->bDescriptorType));\n\t\t\tif (p + ed->bLength <= end && ed->bLength != 0 &&\n\t\t\t    ed->bDescriptorType == UDESC_ENDPOINT)\n\t\t\t\tgoto found;\n\t\t\tif (ed->bLength == 0 ||\n\t\t\t    ed->bDescriptorType == UDESC_INTERFACE)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* passed end, or bad desc */\n\t\tDPRINTF((\"usbd_fill_iface_data: bad descriptor(s): %s\\n\",\n\t\t\t ed->bLength == 0 ? \"0 length\" :\n\t\t\t ed->bDescriptorType == UDESC_INTERFACE ? \"iface desc\":\n\t\t\t \"out of data\"));\n\t\tgoto bad;\n\tfound:\n\t\tifc->endpoints[endpt].edesc = ed;\n\t\tifc->endpoints[endpt].refcnt = 0;\n\t\tp += ed->bLength;\n\t}\n#undef ed\n\tLIST_INIT(&ifc->pipes);\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tif (ifc->endpoints != NULL)\n\t\tfree(ifc->endpoints, M_USB);\n\treturn (USBD_INVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nifc * sizeof(struct usbd_interface)",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err))"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_set_config",
          "args": [
            "dev",
            "cdp->bConfigurationValue"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_config_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "554-673",
          "snippet": "usbd_status\nusbd_set_config_index(dev, index, msg)\n\tusbd_device_handle dev;\n\tint index;\n\tint msg;\n{\n\tusb_status_t ds;\n\tusb_config_descriptor_t cd, *cdp;\n\tusbd_status err;\n\tint ifcidx, nifc, len, selfpowered, power;\n\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index));\n\n\t/* XXX check that all interfaces are idle */\n\tif (dev->config != 0) {\n\t\tDPRINTF((\"usbd_set_config_index: free old config\\n\"));\n\t\t/* Free all configuration data structures. */\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t\tfree(dev->cdesc, M_USB);\n\t\tdev->ifaces = NULL;\n\t\tdev->cdesc = NULL;\n\t\tdev->config = 0;\n\t}\n\n\t/* Figure out what config number to use. */\n\terr = usbd_get_config_desc(dev, index, &cd);\n\tif (err)\n\t\treturn (err);\n\tlen = UGETW(cd.wTotalLength);\n\tcdp = malloc(len, M_USB, M_NOWAIT);\n\tif (cdp == NULL)\n\t\treturn (USBD_NOMEM);\n\terr = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);\n\tif (err)\n\t\tgoto bad;\n\tif (cdp->bDescriptorType != UDESC_CONFIG) {\n\t\tDPRINTFN(-1,(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType));\n\t\terr = USBD_INVAL;\n\t\tgoto bad;\n\t}\n\tselfpowered = 0;\n\tif (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&\n\t    cdp->bmAttributes & UC_SELF_POWERED) {\n\t\t/* May be self powered. */\n\t\tif (cdp->bmAttributes & UC_BUS_POWERED) {\n\t\t\t/* Must ask device. */\n\t\t\terr = usbd_get_device_status(dev, &ds);\n\t\t\tif (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))\n\t\t\t\tselfpowered = 1;\n\t\t\tDPRINTF((\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err)));\n\t\t} else\n\t\t\tselfpowered = 1;\n\t}\n\tDPRINTF((\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2));\n#ifdef USB_DEBUG\n\tif (dev->powersrc == NULL) {\n\t\tDPRINTF((\"usbd_set_config_index: No power source?\\n\"));\n\t\treturn (USBD_IOERROR);\n\t}\n#endif\n\tpower = cdp->bMaxPower * 2;\n\tif (power > dev->powersrc->power) {\n\t\t/* XXX print nicer message. */\n\t\tif (msg)\n\t\t\tprintf(\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\",\n\t\t\t       USBDEVNAME(dev->bus->bdev), dev->address, \n\t\t\t       cdp->bConfigurationValue, \n\t\t\t       power, dev->powersrc->power);\n\t\terr = USBD_NO_POWER;\n\t\tgoto bad;\n\t}\n\tdev->power = power;\n\tdev->self_powered = selfpowered;\n\n\tDPRINTF((\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\terr = usbd_set_config(dev, cdp->bConfigurationValue);\n\tif (err) {\n\t\tDPRINTF((\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err)));\n\t\tgoto bad;\n\t}\n\tDPRINTF((\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\tnifc = cdp->bNumInterface;\n\tdev->ifaces = malloc(nifc * sizeof(struct usbd_interface), \n\t\t\t     M_USB, M_NOWAIT);\n\tif (dev->ifaces == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad;\n\t}\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp));\n\tdev->cdesc = cdp;\n\tdev->config = cdp->bConfigurationValue;\n\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++) {\n\t\terr = usbd_fill_iface_data(dev, ifcidx, 0);\n\t\tif (err) {\n\t\t\twhile (--ifcidx >= 0)\n\t\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tfree(cdp, M_USB);\n\treturn (err);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\"",
            "USBDEVNAME(dev->bus->bdev)",
            "dev->address",
            "cdp->bConfigurationValue",
            "power",
            "dev->powersrc->power"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "dev->bus->bdev"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_set_config_index: No power source?\\n\")"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err))"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ds.wStatus"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ds.wStatus"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_device_status",
          "args": [
            "dev",
            "&ds"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_device_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "131-144",
          "snippet": "usbd_status\nusbd_get_device_status(dev, st)\n\tusbd_device_handle dev;\n\tusb_status_t *st;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, sizeof(usb_status_t));\n\treturn (usbd_do_request(dev, &req, st));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_device_status(dev, st)\n\tusbd_device_handle dev;\n\tusb_status_t *st;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, sizeof(usb_status_t));\n\treturn (usbd_do_request(dev, &req, st));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_desc",
          "args": [
            "dev",
            "UDESC_CONFIG",
            "index",
            "len",
            "cdp"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "68-86",
          "snippet": "usbd_status\nusbd_get_desc(dev, type, index, len, desc)\n\tusbd_device_handle dev;\n\tint type, index;\n\tint len;\n\tvoid *desc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(3,(\"usbd_get_desc: type=%d, index=%d, len=%d\\n\",\n\t\t    type, index, len));\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, type, index);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request(dev, &req, desc));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_desc(dev, type, index, len, desc)\n\tusbd_device_handle dev;\n\tint type, index;\n\tint len;\n\tvoid *desc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(3,(\"usbd_get_desc: type=%d, index=%d, len=%d\\n\",\n\t\t    type, index, len));\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, type, index);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request(dev, &req, desc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "cd.wTotalLength"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_config_desc",
          "args": [
            "dev",
            "index",
            "&cd"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_config_desc_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "110-119",
          "snippet": "usbd_status\nusbd_get_config_desc_full(dev, conf, d, size)\n\tusbd_device_handle dev;\n\tint conf;\n\tvoid *d;\n\tint size;\n{\n\tDPRINTFN(3,(\"usbd_get_config_desc_full: conf=%d\\n\", conf));\n\treturn (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_config_desc_full(dev, conf, d, size)\n\tusbd_device_handle dev;\n\tint conf;\n\tvoid *d;\n\tint size;\n{\n\tDPRINTFN(3,(\"usbd_get_config_desc_full: conf=%d\\n\", conf));\n\treturn (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_set_config_index: free old config\\n\")"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nStatic usbd_status;\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;\nusb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;\n\nusbd_status\nusbd_set_config_index(dev, index, msg)\n\tusbd_device_handle dev;\n\tint index;\n\tint msg;\n{\n\tusb_status_t ds;\n\tusb_config_descriptor_t cd, *cdp;\n\tusbd_status err;\n\tint ifcidx, nifc, len, selfpowered, power;\n\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index));\n\n\t/* XXX check that all interfaces are idle */\n\tif (dev->config != 0) {\n\t\tDPRINTF((\"usbd_set_config_index: free old config\\n\"));\n\t\t/* Free all configuration data structures. */\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t\tfree(dev->cdesc, M_USB);\n\t\tdev->ifaces = NULL;\n\t\tdev->cdesc = NULL;\n\t\tdev->config = 0;\n\t}\n\n\t/* Figure out what config number to use. */\n\terr = usbd_get_config_desc(dev, index, &cd);\n\tif (err)\n\t\treturn (err);\n\tlen = UGETW(cd.wTotalLength);\n\tcdp = malloc(len, M_USB, M_NOWAIT);\n\tif (cdp == NULL)\n\t\treturn (USBD_NOMEM);\n\terr = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);\n\tif (err)\n\t\tgoto bad;\n\tif (cdp->bDescriptorType != UDESC_CONFIG) {\n\t\tDPRINTFN(-1,(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType));\n\t\terr = USBD_INVAL;\n\t\tgoto bad;\n\t}\n\tselfpowered = 0;\n\tif (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&\n\t    cdp->bmAttributes & UC_SELF_POWERED) {\n\t\t/* May be self powered. */\n\t\tif (cdp->bmAttributes & UC_BUS_POWERED) {\n\t\t\t/* Must ask device. */\n\t\t\terr = usbd_get_device_status(dev, &ds);\n\t\t\tif (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))\n\t\t\t\tselfpowered = 1;\n\t\t\tDPRINTF((\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err)));\n\t\t} else\n\t\t\tselfpowered = 1;\n\t}\n\tDPRINTF((\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2));\n#ifdef USB_DEBUG\n\tif (dev->powersrc == NULL) {\n\t\tDPRINTF((\"usbd_set_config_index: No power source?\\n\"));\n\t\treturn (USBD_IOERROR);\n\t}\n#endif\n\tpower = cdp->bMaxPower * 2;\n\tif (power > dev->powersrc->power) {\n\t\t/* XXX print nicer message. */\n\t\tif (msg)\n\t\t\tprintf(\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\",\n\t\t\t       USBDEVNAME(dev->bus->bdev), dev->address, \n\t\t\t       cdp->bConfigurationValue, \n\t\t\t       power, dev->powersrc->power);\n\t\terr = USBD_NO_POWER;\n\t\tgoto bad;\n\t}\n\tdev->power = power;\n\tdev->self_powered = selfpowered;\n\n\tDPRINTF((\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\terr = usbd_set_config(dev, cdp->bConfigurationValue);\n\tif (err) {\n\t\tDPRINTF((\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err)));\n\t\tgoto bad;\n\t}\n\tDPRINTF((\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\tnifc = cdp->bNumInterface;\n\tdev->ifaces = malloc(nifc * sizeof(struct usbd_interface), \n\t\t\t     M_USB, M_NOWAIT);\n\tif (dev->ifaces == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad;\n\t}\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp));\n\tdev->cdesc = cdp;\n\tdev->config = cdp->bConfigurationValue;\n\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++) {\n\t\terr = usbd_fill_iface_data(dev, ifcidx, 0);\n\t\tif (err) {\n\t\t\twhile (--ifcidx >= 0)\n\t\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tfree(cdp, M_USB);\n\treturn (err);\n}"
  },
  {
    "function_name": "usbd_set_config_no",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "532-552",
    "snippet": "usbd_status\nusbd_set_config_no(dev, no, msg)\n\tusbd_device_handle dev;\n\tint no;\n\tint msg;\n{\n\tint index;\n\tusb_config_descriptor_t cd;\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"usbd_set_config_no: %d\\n\", no));\n\t/* Figure out what config index to use. */\n\tfor (index = 0; index < dev->ddesc.bNumConfigurations; index++) {\n\t\terr = usbd_get_config_desc(dev, index, &cd);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tif (cd.bConfigurationValue == no)\n\t\t\treturn (usbd_set_config_index(dev, index, msg));\n\t}\n\treturn (USBD_INVAL);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "Static usbd_status",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
      "usb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;",
      "usb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_set_config_index",
          "args": [
            "dev",
            "index",
            "msg"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_config_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "554-673",
          "snippet": "usbd_status\nusbd_set_config_index(dev, index, msg)\n\tusbd_device_handle dev;\n\tint index;\n\tint msg;\n{\n\tusb_status_t ds;\n\tusb_config_descriptor_t cd, *cdp;\n\tusbd_status err;\n\tint ifcidx, nifc, len, selfpowered, power;\n\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index));\n\n\t/* XXX check that all interfaces are idle */\n\tif (dev->config != 0) {\n\t\tDPRINTF((\"usbd_set_config_index: free old config\\n\"));\n\t\t/* Free all configuration data structures. */\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t\tfree(dev->cdesc, M_USB);\n\t\tdev->ifaces = NULL;\n\t\tdev->cdesc = NULL;\n\t\tdev->config = 0;\n\t}\n\n\t/* Figure out what config number to use. */\n\terr = usbd_get_config_desc(dev, index, &cd);\n\tif (err)\n\t\treturn (err);\n\tlen = UGETW(cd.wTotalLength);\n\tcdp = malloc(len, M_USB, M_NOWAIT);\n\tif (cdp == NULL)\n\t\treturn (USBD_NOMEM);\n\terr = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);\n\tif (err)\n\t\tgoto bad;\n\tif (cdp->bDescriptorType != UDESC_CONFIG) {\n\t\tDPRINTFN(-1,(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType));\n\t\terr = USBD_INVAL;\n\t\tgoto bad;\n\t}\n\tselfpowered = 0;\n\tif (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&\n\t    cdp->bmAttributes & UC_SELF_POWERED) {\n\t\t/* May be self powered. */\n\t\tif (cdp->bmAttributes & UC_BUS_POWERED) {\n\t\t\t/* Must ask device. */\n\t\t\terr = usbd_get_device_status(dev, &ds);\n\t\t\tif (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))\n\t\t\t\tselfpowered = 1;\n\t\t\tDPRINTF((\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err)));\n\t\t} else\n\t\t\tselfpowered = 1;\n\t}\n\tDPRINTF((\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2));\n#ifdef USB_DEBUG\n\tif (dev->powersrc == NULL) {\n\t\tDPRINTF((\"usbd_set_config_index: No power source?\\n\"));\n\t\treturn (USBD_IOERROR);\n\t}\n#endif\n\tpower = cdp->bMaxPower * 2;\n\tif (power > dev->powersrc->power) {\n\t\t/* XXX print nicer message. */\n\t\tif (msg)\n\t\t\tprintf(\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\",\n\t\t\t       USBDEVNAME(dev->bus->bdev), dev->address, \n\t\t\t       cdp->bConfigurationValue, \n\t\t\t       power, dev->powersrc->power);\n\t\terr = USBD_NO_POWER;\n\t\tgoto bad;\n\t}\n\tdev->power = power;\n\tdev->self_powered = selfpowered;\n\n\tDPRINTF((\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\terr = usbd_set_config(dev, cdp->bConfigurationValue);\n\tif (err) {\n\t\tDPRINTF((\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err)));\n\t\tgoto bad;\n\t}\n\tDPRINTF((\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\tnifc = cdp->bNumInterface;\n\tdev->ifaces = malloc(nifc * sizeof(struct usbd_interface), \n\t\t\t     M_USB, M_NOWAIT);\n\tif (dev->ifaces == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad;\n\t}\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp));\n\tdev->cdesc = cdp;\n\tdev->config = cdp->bConfigurationValue;\n\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++) {\n\t\terr = usbd_fill_iface_data(dev, ifcidx, 0);\n\t\tif (err) {\n\t\t\twhile (--ifcidx >= 0)\n\t\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tfree(cdp, M_USB);\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "Static usbd_status",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;",
            "usb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nStatic usbd_status;\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;\nusb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;\n\nusbd_status\nusbd_set_config_index(dev, index, msg)\n\tusbd_device_handle dev;\n\tint index;\n\tint msg;\n{\n\tusb_status_t ds;\n\tusb_config_descriptor_t cd, *cdp;\n\tusbd_status err;\n\tint ifcidx, nifc, len, selfpowered, power;\n\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p index=%d\\n\", dev, index));\n\n\t/* XXX check that all interfaces are idle */\n\tif (dev->config != 0) {\n\t\tDPRINTF((\"usbd_set_config_index: free old config\\n\"));\n\t\t/* Free all configuration data structures. */\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t\tfree(dev->cdesc, M_USB);\n\t\tdev->ifaces = NULL;\n\t\tdev->cdesc = NULL;\n\t\tdev->config = 0;\n\t}\n\n\t/* Figure out what config number to use. */\n\terr = usbd_get_config_desc(dev, index, &cd);\n\tif (err)\n\t\treturn (err);\n\tlen = UGETW(cd.wTotalLength);\n\tcdp = malloc(len, M_USB, M_NOWAIT);\n\tif (cdp == NULL)\n\t\treturn (USBD_NOMEM);\n\terr = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);\n\tif (err)\n\t\tgoto bad;\n\tif (cdp->bDescriptorType != UDESC_CONFIG) {\n\t\tDPRINTFN(-1,(\"usbd_set_config_index: bad desc %d\\n\",\n\t\t\t     cdp->bDescriptorType));\n\t\terr = USBD_INVAL;\n\t\tgoto bad;\n\t}\n\tselfpowered = 0;\n\tif (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&\n\t    cdp->bmAttributes & UC_SELF_POWERED) {\n\t\t/* May be self powered. */\n\t\tif (cdp->bmAttributes & UC_BUS_POWERED) {\n\t\t\t/* Must ask device. */\n\t\t\terr = usbd_get_device_status(dev, &ds);\n\t\t\tif (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))\n\t\t\t\tselfpowered = 1;\n\t\t\tDPRINTF((\"usbd_set_config_index: status=0x%04x, \"\n\t\t\t\t \"error=%s\\n\",\n\t\t\t\t UGETW(ds.wStatus), usbd_errstr(err)));\n\t\t} else\n\t\t\tselfpowered = 1;\n\t}\n\tDPRINTF((\"usbd_set_config_index: (addr %d) attr=0x%02x, \"\n\t\t \"selfpowered=%d, power=%d\\n\", \n\t\t dev->address, cdp->bmAttributes, \n\t\t selfpowered, cdp->bMaxPower * 2));\n#ifdef USB_DEBUG\n\tif (dev->powersrc == NULL) {\n\t\tDPRINTF((\"usbd_set_config_index: No power source?\\n\"));\n\t\treturn (USBD_IOERROR);\n\t}\n#endif\n\tpower = cdp->bMaxPower * 2;\n\tif (power > dev->powersrc->power) {\n\t\t/* XXX print nicer message. */\n\t\tif (msg)\n\t\t\tprintf(\"%s: device addr %d (config %d) exceeds power \"\n\t\t\t\t \"budget, %d mA > %d mA\\n\",\n\t\t\t       USBDEVNAME(dev->bus->bdev), dev->address, \n\t\t\t       cdp->bConfigurationValue, \n\t\t\t       power, dev->powersrc->power);\n\t\terr = USBD_NO_POWER;\n\t\tgoto bad;\n\t}\n\tdev->power = power;\n\tdev->self_powered = selfpowered;\n\n\tDPRINTF((\"usbd_set_config_index: set config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\terr = usbd_set_config(dev, cdp->bConfigurationValue);\n\tif (err) {\n\t\tDPRINTF((\"usbd_set_config_index: setting config=%d failed, \"\n\t\t\t \"error=%s\\n\",\n\t\t\t cdp->bConfigurationValue, usbd_errstr(err)));\n\t\tgoto bad;\n\t}\n\tDPRINTF((\"usbd_set_config_index: setting new config %d\\n\",\n\t\t cdp->bConfigurationValue));\n\tnifc = cdp->bNumInterface;\n\tdev->ifaces = malloc(nifc * sizeof(struct usbd_interface), \n\t\t\t     M_USB, M_NOWAIT);\n\tif (dev->ifaces == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad;\n\t}\n\tDPRINTFN(5,(\"usbd_set_config_index: dev=%p cdesc=%p\\n\", dev, cdp));\n\tdev->cdesc = cdp;\n\tdev->config = cdp->bConfigurationValue;\n\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++) {\n\t\terr = usbd_fill_iface_data(dev, ifcidx, 0);\n\t\tif (err) {\n\t\t\twhile (--ifcidx >= 0)\n\t\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tfree(cdp, M_USB);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_get_config_desc",
          "args": [
            "dev",
            "index",
            "&cd"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_config_desc_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "110-119",
          "snippet": "usbd_status\nusbd_get_config_desc_full(dev, conf, d, size)\n\tusbd_device_handle dev;\n\tint conf;\n\tvoid *d;\n\tint size;\n{\n\tDPRINTFN(3,(\"usbd_get_config_desc_full: conf=%d\\n\", conf));\n\treturn (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_config_desc_full(dev, conf, d, size)\n\tusbd_device_handle dev;\n\tint conf;\n\tvoid *d;\n\tint size;\n{\n\tDPRINTFN(3,(\"usbd_get_config_desc_full: conf=%d\\n\", conf));\n\treturn (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_set_config_no: %d\\n\", no)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;\nusb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;\n\nusbd_status\nusbd_set_config_no(dev, no, msg)\n\tusbd_device_handle dev;\n\tint no;\n\tint msg;\n{\n\tint index;\n\tusb_config_descriptor_t cd;\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"usbd_set_config_no: %d\\n\", no));\n\t/* Figure out what config index to use. */\n\tfor (index = 0; index < dev->ddesc.bNumConfigurations; index++) {\n\t\terr = usbd_get_config_desc(dev, index, &cd);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tif (cd.bConfigurationValue == no)\n\t\t\treturn (usbd_set_config_index(dev, index, msg));\n\t}\n\treturn (USBD_INVAL);\n}"
  },
  {
    "function_name": "usbd_set_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "517-530",
    "snippet": "Static usbd_status\nusbd_set_config(dev, conf)\n\tusbd_device_handle dev;\n\tint conf;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_DEVICE;\n\treq.bRequest = UR_SET_CONFIG;\n\tUSETW(req.wValue, conf);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "Static int",
      "Static void",
      "Static void",
      "Static usbd_status",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "dev",
            "&req",
            "0"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "0"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "conf"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic int;\nStatic void;\nStatic void;\nStatic usbd_status;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nStatic usbd_status\nusbd_set_config(dev, conf)\n\tusbd_device_handle dev;\n\tint conf;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_DEVICE;\n\treq.bRequest = UR_SET_CONFIG;\n\tUSETW(req.wValue, conf);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}"
  },
  {
    "function_name": "usbd_free_iface_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "507-515",
    "snippet": "void\nusbd_free_iface_data(dev, ifcno)\n\tusbd_device_handle dev;\n\tint ifcno;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifcno];\n\tif (ifc->endpoints)\n\t\tfree(ifc->endpoints, M_USB);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_free_iface_data __P((usbd_device_handle dev, int ifcno));",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ifc->endpoints",
            "M_USB"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_free_iface_data __P((usbd_device_handle dev, int ifcno));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_free_iface_data(dev, ifcno)\n\tusbd_device_handle dev;\n\tint ifcno;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifcno];\n\tif (ifc->endpoints)\n\t\tfree(ifc->endpoints, M_USB);\n}"
  },
  {
    "function_name": "usbd_fill_iface_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "441-505",
    "snippet": "usbd_status\nusbd_fill_iface_data(dev, ifaceidx, altidx)\n\tusbd_device_handle dev;\n\tint ifaceidx;\n\tint altidx;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifaceidx];\n\tchar *p, *end;\n\tint endpt, nendpt;\n\n\tDPRINTFN(4,(\"usbd_fill_iface_data: ifaceidx=%d altidx=%d\\n\",\n\t\t    ifaceidx, altidx));\n\tifc->device = dev;\n\tifc->idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);\n\tif (ifc->idesc == 0)\n\t\treturn (USBD_INVAL);\n\tifc->index = ifaceidx;\n\tifc->altindex = altidx;\n\tnendpt = ifc->idesc->bNumEndpoints;\n\tDPRINTFN(4,(\"usbd_fill_iface_data: found idesc nendpt=%d\\n\", nendpt));\n\tif (nendpt != 0) {\n\t\tifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),\n\t\t\t\t\tM_USB, M_NOWAIT);\n\t\tif (ifc->endpoints == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t} else\n\t\tifc->endpoints = NULL;\n\tifc->priv = NULL;\n\tp = (char *)ifc->idesc + ifc->idesc->bLength;\n\tend = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);\n#define ed ((usb_endpoint_descriptor_t *)p)\n\tfor (endpt = 0; endpt < nendpt; endpt++) {\n\t\tDPRINTFN(10,(\"usbd_fill_iface_data: endpt=%d\\n\", endpt));\n\t\tfor (; p < end; p += ed->bLength) {\n\t\t\ted = (usb_endpoint_descriptor_t *)p;\n\t\t\tDPRINTFN(10,(\"usbd_fill_iface_data: p=%p end=%p \"\n\t\t\t\t     \"len=%d type=%d\\n\",\n\t\t\t\t p, end, ed->bLength, ed->bDescriptorType));\n\t\t\tif (p + ed->bLength <= end && ed->bLength != 0 &&\n\t\t\t    ed->bDescriptorType == UDESC_ENDPOINT)\n\t\t\t\tgoto found;\n\t\t\tif (ed->bLength == 0 ||\n\t\t\t    ed->bDescriptorType == UDESC_INTERFACE)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* passed end, or bad desc */\n\t\tDPRINTF((\"usbd_fill_iface_data: bad descriptor(s): %s\\n\",\n\t\t\t ed->bLength == 0 ? \"0 length\" :\n\t\t\t ed->bDescriptorType == UDESC_INTERFACE ? \"iface desc\":\n\t\t\t \"out of data\"));\n\t\tgoto bad;\n\tfound:\n\t\tifc->endpoints[endpt].edesc = ed;\n\t\tifc->endpoints[endpt].refcnt = 0;\n\t\tp += ed->bLength;\n\t}\n#undef ed\n\tLIST_INIT(&ifc->pipes);\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tif (ifc->endpoints != NULL)\n\t\tfree(ifc->endpoints, M_USB);\n\treturn (USBD_INVAL);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ed ((usb_endpoint_descriptor_t *)p)"
    ],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "Static usbd_status",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
      "int ifaceidx;",
      "int altidx;",
      "int ifaceidx;",
      "int altidx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ifc->endpoints",
            "M_USB"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "usb_free_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1233-1252",
          "snippet": "void\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusb_free_device(dev)\n\tusbd_device_handle dev;\n{\n\tint ifcidx, nifc;\n\n\tif (dev->default_pipe != NULL)\n\t\tusbd_kill_pipe(dev->default_pipe);\n\tif (dev->ifaces != NULL) {\n\t\tnifc = dev->cdesc->bNumInterface;\n\t\tfor (ifcidx = 0; ifcidx < nifc; ifcidx++)\n\t\t\tusbd_free_iface_data(dev, ifcidx);\n\t\tfree(dev->ifaces, M_USB);\n\t}\n\tif (dev->cdesc != NULL)\n\t\tfree(dev->cdesc, M_USB);\n\tif (dev->subdevs != NULL)\n\t\tfree(dev->subdevs, M_USB);\n\tfree(dev, M_USB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&ifc->pipes"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_fill_iface_data: bad descriptor(s): %s\\n\",\n\t\t\t ed->bLength == 0 ? \"0 length\" :\n\t\t\t ed->bDescriptorType == UDESC_INTERFACE ? \"iface desc\":\n\t\t\t \"out of data\")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"usbd_fill_iface_data: p=%p end=%p \"\n\t\t\t\t     \"len=%d type=%d\\n\",\n\t\t\t\t p, end, ed->bLength, ed->bDescriptorType)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"usbd_fill_iface_data: endpt=%d\\n\", endpt)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dev->cdesc->wTotalLength"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nendpt * sizeof(struct usbd_endpoint)",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"usbd_fill_iface_data: found idesc nendpt=%d\\n\", nendpt)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_find_idesc",
          "args": [
            "dev->cdesc",
            "ifaceidx",
            "altidx"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"usbd_fill_iface_data: ifaceidx=%d altidx=%d\\n\",\n\t\t    ifaceidx, altidx)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ed ((usb_endpoint_descriptor_t *)p)\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nint ifaceidx;\nint altidx;\nint ifaceidx;\nint altidx;\n\nusbd_status\nusbd_fill_iface_data(dev, ifaceidx, altidx)\n\tusbd_device_handle dev;\n\tint ifaceidx;\n\tint altidx;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifaceidx];\n\tchar *p, *end;\n\tint endpt, nendpt;\n\n\tDPRINTFN(4,(\"usbd_fill_iface_data: ifaceidx=%d altidx=%d\\n\",\n\t\t    ifaceidx, altidx));\n\tifc->device = dev;\n\tifc->idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);\n\tif (ifc->idesc == 0)\n\t\treturn (USBD_INVAL);\n\tifc->index = ifaceidx;\n\tifc->altindex = altidx;\n\tnendpt = ifc->idesc->bNumEndpoints;\n\tDPRINTFN(4,(\"usbd_fill_iface_data: found idesc nendpt=%d\\n\", nendpt));\n\tif (nendpt != 0) {\n\t\tifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),\n\t\t\t\t\tM_USB, M_NOWAIT);\n\t\tif (ifc->endpoints == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t} else\n\t\tifc->endpoints = NULL;\n\tifc->priv = NULL;\n\tp = (char *)ifc->idesc + ifc->idesc->bLength;\n\tend = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);\n#define ed ((usb_endpoint_descriptor_t *)p)\n\tfor (endpt = 0; endpt < nendpt; endpt++) {\n\t\tDPRINTFN(10,(\"usbd_fill_iface_data: endpt=%d\\n\", endpt));\n\t\tfor (; p < end; p += ed->bLength) {\n\t\t\ted = (usb_endpoint_descriptor_t *)p;\n\t\t\tDPRINTFN(10,(\"usbd_fill_iface_data: p=%p end=%p \"\n\t\t\t\t     \"len=%d type=%d\\n\",\n\t\t\t\t p, end, ed->bLength, ed->bDescriptorType));\n\t\t\tif (p + ed->bLength <= end && ed->bLength != 0 &&\n\t\t\t    ed->bDescriptorType == UDESC_ENDPOINT)\n\t\t\t\tgoto found;\n\t\t\tif (ed->bLength == 0 ||\n\t\t\t    ed->bDescriptorType == UDESC_INTERFACE)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* passed end, or bad desc */\n\t\tDPRINTF((\"usbd_fill_iface_data: bad descriptor(s): %s\\n\",\n\t\t\t ed->bLength == 0 ? \"0 length\" :\n\t\t\t ed->bDescriptorType == UDESC_INTERFACE ? \"iface desc\":\n\t\t\t \"out of data\"));\n\t\tgoto bad;\n\tfound:\n\t\tifc->endpoints[endpt].edesc = ed;\n\t\tifc->endpoints[endpt].refcnt = 0;\n\t\tp += ed->bLength;\n\t}\n#undef ed\n\tLIST_INIT(&ifc->pipes);\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tif (ifc->endpoints != NULL)\n\t\tfree(ifc->endpoints, M_USB);\n\treturn (USBD_INVAL);\n}"
  },
  {
    "function_name": "usbd_reset_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "324-369",
    "snippet": "usbd_status\nusbd_reset_port(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\tint n;\n\t\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SET_FEATURE;\n\tUSETW(req.wValue, UHF_PORT_RESET);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request(dev, &req, 0);\n\tDPRINTFN(1,(\"usbd_reset_port: port %d reset done, error=%s\\n\",\n\t\t    port, usbd_errstr(err)));\n\tif (err)\n\t\treturn (err);\n\tn = 10;\n\tdo {\n\t\t/* Wait for device to recover from reset. */\n\t\tusbd_delay_ms(dev, USB_PORT_RESET_DELAY);\n\t\terr = usbd_get_port_status(dev, port, ps);\n\t\tif (err) {\n\t\t\tDPRINTF((\"usbd_reset_port: get status failed %d\\n\",\n\t\t\t\t err));\n\t\t\treturn (err);\n\t\t}\n\t} while ((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);\n\tif (n == 0) {\n\t\tprintf(\"usbd_reset_port: timeout\\n\");\n\t\treturn (USBD_IOERROR);\n\t}\n\terr = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);\n#ifdef USB_DEBUG\n\tif (err)\n\t\tDPRINTF((\"usbd_reset_port: clear port feature failed %d\\n\",\n\t\t\t err));\n#endif\n\n\t/* Wait for the device to recover from reset. */\n\tusbd_delay_ms(dev, USB_PORT_RESET_RECOVERY);\n\treturn (err);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "Static usbd_status",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "dev",
            "USB_PORT_RESET_RECOVERY"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_reset_port: clear port feature failed %d\\n\",\n\t\t\t err)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_clear_port_feature",
          "args": [
            "dev",
            "port",
            "UHF_C_PORT_RESET"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_port_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "222-235",
          "snippet": "usbd_status\nusbd_clear_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_clear_port_feature(dev, port, sel)\n\tusbd_device_handle dev;\n\tint port, sel;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, sel);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(dev, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_reset_port: timeout\\n\""
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ps->wPortChange"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_reset_port: get status failed %d\\n\",\n\t\t\t\t err)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_port_status",
          "args": [
            "dev",
            "port",
            "ps"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_port_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "176-190",
          "snippet": "usbd_status\nusbd_get_port_status(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_CLASS_OTHER;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, sizeof *ps);\n\treturn (usbd_do_request(dev, &req, ps));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_port_status(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_CLASS_OTHER;\n\treq.bRequest = UR_GET_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, sizeof *ps);\n\treturn (usbd_do_request(dev, &req, ps));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"usbd_reset_port: port %d reset done, error=%s\\n\",\n\t\t    port, usbd_errstr(err))"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "dev",
            "&req",
            "0"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "port"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "UHF_PORT_RESET"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_reset_port(dev, port, ps)\n\tusbd_device_handle dev;\n\tint port;\n\tusb_port_status_t *ps;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\tint n;\n\t\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SET_FEATURE;\n\tUSETW(req.wValue, UHF_PORT_RESET);\n\tUSETW(req.wIndex, port);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request(dev, &req, 0);\n\tDPRINTFN(1,(\"usbd_reset_port: port %d reset done, error=%s\\n\",\n\t\t    port, usbd_errstr(err)));\n\tif (err)\n\t\treturn (err);\n\tn = 10;\n\tdo {\n\t\t/* Wait for device to recover from reset. */\n\t\tusbd_delay_ms(dev, USB_PORT_RESET_DELAY);\n\t\terr = usbd_get_port_status(dev, port, ps);\n\t\tif (err) {\n\t\t\tDPRINTF((\"usbd_reset_port: get status failed %d\\n\",\n\t\t\t\t err));\n\t\t\treturn (err);\n\t\t}\n\t} while ((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);\n\tif (n == 0) {\n\t\tprintf(\"usbd_reset_port: timeout\\n\");\n\t\treturn (USBD_IOERROR);\n\t}\n\terr = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);\n#ifdef USB_DEBUG\n\tif (err)\n\t\tDPRINTF((\"usbd_reset_port: clear port feature failed %d\\n\",\n\t\t\t err));\n#endif\n\n\t/* Wait for the device to recover from reset. */\n\tusbd_delay_ms(dev, USB_PORT_RESET_RECOVERY);\n\treturn (err);\n}"
  },
  {
    "function_name": "usbd_delay_ms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "316-322",
    "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_getnewaddr __P((usbd_bus_handle bus));",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "dev->bus",
            "ms"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
  },
  {
    "function_name": "usb_delay_ms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "301-313",
    "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_getnewaddr __P((usbd_bus_handle bus));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&ms",
            "PRIBIO",
            "\"usbdly\"",
            "(ms*hz+999)/1000 + 1"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "(ms+1) * 1000"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
  },
  {
    "function_name": "usbd_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "274-298",
    "snippet": "void\nusbd_devinfo(dev, showclass, cp)\n\tusbd_device_handle dev;\n\tint showclass;\n\tchar *cp;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar vendor[USB_MAX_STRING_LEN];\n\tchar product[USB_MAX_STRING_LEN];\n\tint bcdDevice, bcdUSB;\n\n\tusbd_devinfo_vp(dev, vendor, product);\n\tcp += sprintf(cp, \"%s%s%s\", vendor, *vendor ? \" \" : \"\", product);\n\tif (showclass)\n\t\tcp += sprintf(cp, \", class %d/%d\",\n\t\t\t      udd->bDeviceClass, udd->bDeviceSubClass);\n\tbcdUSB = UGETW(udd->bcdUSB);\n\tbcdDevice = UGETW(udd->bcdDevice);\n\tcp += sprintf(cp, \", rev \");\n\tcp += usbd_printBCD(cp, bcdUSB);\n\t*cp++ = '/';\n\tcp += usbd_printBCD(cp, bcdDevice);\n\tcp += sprintf(cp, \", addr %d\", dev->address);\n\t*cp = 0;\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\", addr %d\"",
            "dev->address"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_printBCD",
          "args": [
            "cp",
            "bcdDevice"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_printBCD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "266-272",
          "snippet": "int\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\", rev \""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "udd->bcdDevice"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "udd->bcdUSB"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\", class %d/%d\"",
            "udd->bDeviceClass",
            "udd->bDeviceSubClass"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%s%s%s\"",
            "vendor",
            "*vendor ? \" \" : \"\"",
            "product"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_devinfo_vp",
          "args": [
            "dev",
            "vendor",
            "product"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_devinfo_vp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "219-264",
          "snippet": "void\nusbd_devinfo_vp(dev, v, p)\n\tusbd_device_handle dev;\n\tchar *v, *p;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar *vendor = 0, *product = 0;\n#ifdef USBVERBOSE\n\tstruct usb_knowndev *kdp;\n#endif\n\n\tif (dev == NULL) {\n\t\tv[0] = p[0] = '\\0';\n\t\treturn;\n\t}\n\n\tvendor = usbd_get_string(dev, udd->iManufacturer, v);\n\tproduct = usbd_get_string(dev, udd->iProduct, p);\n#ifdef USBVERBOSE\n\tif (vendor == NULL || product == NULL) {\n\t\tfor(kdp = usb_knowndevs;\n\t\t    kdp->vendorname != NULL;\n\t\t    kdp++) {\n\t\t\tif (kdp->vendor == UGETW(udd->idVendor) && \n\t\t\t    (kdp->product == UGETW(udd->idProduct) ||\n\t\t\t     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (kdp->vendorname != NULL) {\n\t\t\tif (!vendor)\n\t\t\t    vendor = kdp->vendorname;\n\t\t\tif (!product)\n\t\t\t    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?\n\t\t\t\tkdp->productname : NULL;\n\t\t}\n\t}\n#endif\n\tif (vendor != NULL)\n\t\tstrcpy(v, vendor);\n\telse\n\t\tsprintf(v, \"vendor 0x%04x\", UGETW(udd->idVendor));\n\tif (product != NULL)\n\t\tstrcpy(p, product);\n\telse\n\t\tsprintf(p, \"product 0x%04x\", UGETW(udd->idProduct));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tUSB_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */"
          ],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static char *usbd_get_string",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUSB_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */\n\nusbd_set_config __P((usbd_device_handle, int));\nStatic char *usbd_get_string;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_devinfo_vp(dev, v, p)\n\tusbd_device_handle dev;\n\tchar *v, *p;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar *vendor = 0, *product = 0;\n#ifdef USBVERBOSE\n\tstruct usb_knowndev *kdp;\n#endif\n\n\tif (dev == NULL) {\n\t\tv[0] = p[0] = '\\0';\n\t\treturn;\n\t}\n\n\tvendor = usbd_get_string(dev, udd->iManufacturer, v);\n\tproduct = usbd_get_string(dev, udd->iProduct, p);\n#ifdef USBVERBOSE\n\tif (vendor == NULL || product == NULL) {\n\t\tfor(kdp = usb_knowndevs;\n\t\t    kdp->vendorname != NULL;\n\t\t    kdp++) {\n\t\t\tif (kdp->vendor == UGETW(udd->idVendor) && \n\t\t\t    (kdp->product == UGETW(udd->idProduct) ||\n\t\t\t     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (kdp->vendorname != NULL) {\n\t\t\tif (!vendor)\n\t\t\t    vendor = kdp->vendorname;\n\t\t\tif (!product)\n\t\t\t    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?\n\t\t\t\tkdp->productname : NULL;\n\t\t}\n\t}\n#endif\n\tif (vendor != NULL)\n\t\tstrcpy(v, vendor);\n\telse\n\t\tsprintf(v, \"vendor 0x%04x\", UGETW(udd->idVendor));\n\tif (product != NULL)\n\t\tstrcpy(p, product);\n\telse\n\t\tsprintf(p, \"product 0x%04x\", UGETW(udd->idProduct));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_devinfo(dev, showclass, cp)\n\tusbd_device_handle dev;\n\tint showclass;\n\tchar *cp;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar vendor[USB_MAX_STRING_LEN];\n\tchar product[USB_MAX_STRING_LEN];\n\tint bcdDevice, bcdUSB;\n\n\tusbd_devinfo_vp(dev, vendor, product);\n\tcp += sprintf(cp, \"%s%s%s\", vendor, *vendor ? \" \" : \"\", product);\n\tif (showclass)\n\t\tcp += sprintf(cp, \", class %d/%d\",\n\t\t\t      udd->bDeviceClass, udd->bDeviceSubClass);\n\tbcdUSB = UGETW(udd->bcdUSB);\n\tbcdDevice = UGETW(udd->bcdDevice);\n\tcp += sprintf(cp, \", rev \");\n\tcp += usbd_printBCD(cp, bcdUSB);\n\t*cp++ = '/';\n\tcp += usbd_printBCD(cp, bcdDevice);\n\tcp += sprintf(cp, \", addr %d\", dev->address);\n\t*cp = 0;\n}"
  },
  {
    "function_name": "usbd_printBCD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "266-272",
    "snippet": "int\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cp",
            "\"%x.%02x\"",
            "bcd >> 8",
            "bcd & 0xff"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}"
  },
  {
    "function_name": "usbd_devinfo_vp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "219-264",
    "snippet": "void\nusbd_devinfo_vp(dev, v, p)\n\tusbd_device_handle dev;\n\tchar *v, *p;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar *vendor = 0, *product = 0;\n#ifdef USBVERBOSE\n\tstruct usb_knowndev *kdp;\n#endif\n\n\tif (dev == NULL) {\n\t\tv[0] = p[0] = '\\0';\n\t\treturn;\n\t}\n\n\tvendor = usbd_get_string(dev, udd->iManufacturer, v);\n\tproduct = usbd_get_string(dev, udd->iProduct, p);\n#ifdef USBVERBOSE\n\tif (vendor == NULL || product == NULL) {\n\t\tfor(kdp = usb_knowndevs;\n\t\t    kdp->vendorname != NULL;\n\t\t    kdp++) {\n\t\t\tif (kdp->vendor == UGETW(udd->idVendor) && \n\t\t\t    (kdp->product == UGETW(udd->idProduct) ||\n\t\t\t     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (kdp->vendorname != NULL) {\n\t\t\tif (!vendor)\n\t\t\t    vendor = kdp->vendorname;\n\t\t\tif (!product)\n\t\t\t    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?\n\t\t\t\tkdp->productname : NULL;\n\t\t}\n\t}\n#endif\n\tif (vendor != NULL)\n\t\tstrcpy(v, vendor);\n\telse\n\t\tsprintf(v, \"vendor 0x%04x\", UGETW(udd->idVendor));\n\tif (product != NULL)\n\t\tstrcpy(p, product);\n\telse\n\t\tsprintf(p, \"product 0x%04x\", UGETW(udd->idProduct));\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tUSB_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */"
    ],
    "globals_used": [
      "usbd_set_config __P((usbd_device_handle, int));",
      "Static char *usbd_get_string",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"product 0x%04x\"",
            "UGETW(udd->idProduct)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "udd->idProduct"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "product"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "v",
            "\"vendor 0x%04x\"",
            "UGETW(udd->idVendor)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "udd->idVendor"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "v",
            "vendor"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "udd->idProduct"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "udd->idVendor"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_string",
          "args": [
            "dev",
            "udd->iProduct",
            "p"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_string_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "151-171",
          "snippet": "usbd_status\nusbd_get_string_desc(dev, sindex, langid, sdesc)\n\tusbd_device_handle dev;\n\tint sindex;\n\tint langid;\n\tusb_string_descriptor_t *sdesc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_STRING, sindex);\n\tUSETW(req.wIndex, langid);\n\tUSETW(req.wLength, 1);\t/* only size byte first */\n\terr = usbd_do_request(dev, &req, sdesc);\n\tif (err)\n\t\treturn (err);\n\tUSETW(req.wLength, sdesc->bLength);\t/* the whole string */\n\treturn (usbd_do_request(dev, &req, sdesc));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_get_string_desc(dev, sindex, langid, sdesc)\n\tusbd_device_handle dev;\n\tint sindex;\n\tint langid;\n\tusb_string_descriptor_t *sdesc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_STRING, sindex);\n\tUSETW(req.wIndex, langid);\n\tUSETW(req.wLength, 1);\t/* only size byte first */\n\terr = usbd_do_request(dev, &req, sdesc);\n\tif (err)\n\t\treturn (err);\n\tUSETW(req.wLength, sdesc->bLength);\t/* the whole string */\n\treturn (usbd_do_request(dev, &req, sdesc));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUSB_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */\n\nusbd_set_config __P((usbd_device_handle, int));\nStatic char *usbd_get_string;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_devinfo_vp(dev, v, p)\n\tusbd_device_handle dev;\n\tchar *v, *p;\n{\n\tusb_device_descriptor_t *udd = &dev->ddesc;\n\tchar *vendor = 0, *product = 0;\n#ifdef USBVERBOSE\n\tstruct usb_knowndev *kdp;\n#endif\n\n\tif (dev == NULL) {\n\t\tv[0] = p[0] = '\\0';\n\t\treturn;\n\t}\n\n\tvendor = usbd_get_string(dev, udd->iManufacturer, v);\n\tproduct = usbd_get_string(dev, udd->iProduct, p);\n#ifdef USBVERBOSE\n\tif (vendor == NULL || product == NULL) {\n\t\tfor(kdp = usb_knowndevs;\n\t\t    kdp->vendorname != NULL;\n\t\t    kdp++) {\n\t\t\tif (kdp->vendor == UGETW(udd->idVendor) && \n\t\t\t    (kdp->product == UGETW(udd->idProduct) ||\n\t\t\t     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (kdp->vendorname != NULL) {\n\t\t\tif (!vendor)\n\t\t\t    vendor = kdp->vendorname;\n\t\t\tif (!product)\n\t\t\t    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?\n\t\t\t\tkdp->productname : NULL;\n\t\t}\n\t}\n#endif\n\tif (vendor != NULL)\n\t\tstrcpy(v, vendor);\n\telse\n\t\tsprintf(v, \"vendor 0x%04x\", UGETW(udd->idVendor));\n\tif (product != NULL)\n\t\tstrcpy(p, product);\n\telse\n\t\tsprintf(p, \"product 0x%04x\", UGETW(udd->idProduct));\n}"
  },
  {
    "function_name": "usbd_get_string_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
    "lines": "151-171",
    "snippet": "usbd_status\nusbd_get_string_desc(dev, sindex, langid, sdesc)\n\tusbd_device_handle dev;\n\tint sindex;\n\tint langid;\n\tusb_string_descriptor_t *sdesc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_STRING, sindex);\n\tUSETW(req.wIndex, langid);\n\tUSETW(req.wLength, 1);\t/* only size byte first */\n\terr = usbd_do_request(dev, &req, sdesc);\n\tif (err)\n\t\treturn (err);\n\tUSETW(req.wLength, sdesc->bLength);\t/* the whole string */\n\treturn (usbd_do_request(dev, &req, sdesc));\n}",
    "includes": [
      "#include <dev/usb/usbdevs_data.h>",
      "#include <machine/clock.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_set_config __P((usbd_device_handle, int));",
      "Static usbd_status",
      "const char *\nusbd_errstr(err)\n\tusbd_status err;",
      "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "dev",
            "&req",
            "sdesc"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "sdesc->bLength"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "1"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "langid"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW2",
          "args": [
            "req.wValue",
            "UDESC_STRING",
            "sindex"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_get_string_desc(dev, sindex, langid, sdesc)\n\tusbd_device_handle dev;\n\tint sindex;\n\tint langid;\n\tusb_string_descriptor_t *sdesc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_STRING, sindex);\n\tUSETW(req.wIndex, langid);\n\tUSETW(req.wLength, 1);\t/* only size byte first */\n\terr = usbd_do_request(dev, &req, sdesc);\n\tif (err)\n\t\treturn (err);\n\tUSETW(req.wLength, sdesc->bLength);\t/* the whole string */\n\treturn (usbd_do_request(dev, &req, sdesc));\n}"
  }
]