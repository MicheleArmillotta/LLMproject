[
  {
    "function_name": "rf_FreeSpareTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "730-744",
    "snippet": "void \nrf_FreeSpareTable(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tlong    i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_SpareTableEntry_t **table = info->SpareTable;\n\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Free(table[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t}\n\tRF_Free(table, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\tinfo->SpareTable = (RF_SpareTableEntry_t **) NULL;\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "table",
            "info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "table[i]",
            "info->BlocksPerTable * sizeof(RF_SpareTableEntry_t)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeSpareTable(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tlong    i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_SpareTableEntry_t **table = info->SpareTable;\n\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Free(table[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t}\n\tRF_Free(table, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\tinfo->SpareTable = (RF_SpareTableEntry_t **) NULL;\n}"
  },
  {
    "function_name": "rf_GetNumSpareRUsDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "720-727",
    "snippet": "RF_ReconUnitCount_t \nrf_GetNumSpareRUsDeclustered(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\n\treturn (((RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo)->TotSparePUsPerDisk);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_ReconUnitCount_t \nrf_GetNumSpareRUsDeclustered(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\n\treturn (((RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo)->TotSparePUsPerDisk);\n}"
  },
  {
    "function_name": "rf_SetSpareTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "682-718",
    "snippet": "int \nrf_SetSpareTable(raidPtr, data)\n\tRF_Raid_t *raidPtr;\n\tvoid   *data;\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SpareTableEntry_t **ptrs;\n\tint     i, retcode;\n\n\t/* what we need to copyin is a 2-d array, so first copyin the user\n\t * pointers to the rows in the table */\n\tRF_Malloc(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\tretcode = copyin((caddr_t) data, (caddr_t) ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\tif (retcode)\n\t\treturn (retcode);\n\n\t/* now allocate kernel space for the row pointers */\n\tRF_Malloc(info->SpareTable, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\n\t/* now allocate kernel space for each row in the table, and copy it in\n\t * from user space */\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Malloc(info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t), (RF_SpareTableEntry_t *));\n\t\tretcode = copyin(ptrs[i], info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t\tif (retcode) {\n\t\t\tinfo->SpareTable = NULL;\t/* blow off the memory\n\t\t\t\t\t\t\t * we've allocated */\n\t\t\treturn (retcode);\n\t\t}\n\t}\n\n\t/* free up the temporary array we used */\n\tRF_Free(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "ptrs",
            "info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ptrs[i]",
            "info->SpareTable[i]",
            "info->BlocksPerTable * sizeof(RF_SpareTableEntry_t)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "info->SpareTable[i]",
            "info->BlocksPerTable * sizeof(RF_SpareTableEntry_t)",
            "(RF_SpareTableEntry_t *)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "info->SpareTable",
            "info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *)",
            "(RF_SpareTableEntry_t **)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "(caddr_t) data",
            "(caddr_t) ptrs",
            "info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "ptrs",
            "info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *)",
            "(RF_SpareTableEntry_t **)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_SetSpareTable(raidPtr, data)\n\tRF_Raid_t *raidPtr;\n\tvoid   *data;\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SpareTableEntry_t **ptrs;\n\tint     i, retcode;\n\n\t/* what we need to copyin is a 2-d array, so first copyin the user\n\t * pointers to the rows in the table */\n\tRF_Malloc(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\tretcode = copyin((caddr_t) data, (caddr_t) ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\tif (retcode)\n\t\treturn (retcode);\n\n\t/* now allocate kernel space for the row pointers */\n\tRF_Malloc(info->SpareTable, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *), (RF_SpareTableEntry_t **));\n\n\t/* now allocate kernel space for each row in the table, and copy it in\n\t * from user space */\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Malloc(info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t), (RF_SpareTableEntry_t *));\n\t\tretcode = copyin(ptrs[i], info->SpareTable[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t\tif (retcode) {\n\t\t\tinfo->SpareTable = NULL;\t/* blow off the memory\n\t\t\t\t\t\t\t * we've allocated */\n\t\t\treturn (retcode);\n\t\t}\n\t}\n\n\t/* free up the temporary array we used */\n\tRF_Free(ptrs, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_InstallSpareTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "654-678",
    "snippet": "int \nrf_InstallSpareTable(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t frow,\n    RF_RowCol_t fcol)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SparetWait_t *req;\n\tint     retcode;\n\n\tRF_Malloc(req, sizeof(*req), (RF_SparetWait_t *));\n\treq->C = raidPtr->numCol;\n\treq->G = raidPtr->Layout.numDataCol + raidPtr->Layout.numParityCol;\n\treq->fcol = fcol;\n\treq->SUsPerPU = raidPtr->Layout.SUsPerPU;\n\treq->TablesPerSpareRegion = info->TablesPerSpareRegion;\n\treq->BlocksPerTable = info->BlocksPerTable;\n\treq->TableDepthInPUs = info->TableDepthInPUs;\n\treq->SpareSpaceDepthPerRegionInSUs = info->SpareSpaceDepthPerRegionInSUs;\n\n\tretcode = rf_GetSpareTableFromDaemon(req);\n\tRF_ASSERT(!retcode);\t/* XXX -- fix this to recover gracefully --\n\t\t\t\t * XXX */\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int     rf_GetSpareTableFromDaemon(RF_SparetWait_t * req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!retcode"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_GetSpareTableFromDaemon",
          "args": [
            "req"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GetSpareTableFromDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1316-1340",
          "snippet": "int \nrf_GetSpareTableFromDaemon(req)\n\tRF_SparetWait_t *req;\n{\n\tint     retcode;\n\n\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\treq->next = rf_sparet_wait_queue;\n\trf_sparet_wait_queue = req;\n\twakeup(&rf_sparet_wait_queue);\n\n\t/* mpsleep unlocks the mutex */\n\twhile (!rf_sparet_resp_queue) {\n\t\ttsleep(&rf_sparet_resp_queue, PRIBIO,\n\t\t    \"raidframe getsparetable\", 0);\n\t}\n\treq = rf_sparet_resp_queue;\n\trf_sparet_resp_queue = req->next;\n\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\n\tretcode = req->fcol;\n\tRF_Free(req, sizeof(*req));\t/* this is not the same req as we\n\t\t\t\t\t * alloc'd */\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)\n\nstatic RF_SparetWait_t",
            "static RF_SparetWait_t *rf_sparet_resp_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nRF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)\n\nstatic RF_SparetWait_t;\nstatic RF_SparetWait_t *rf_sparet_resp_queue;\n\nint \nrf_GetSpareTableFromDaemon(req)\n\tRF_SparetWait_t *req;\n{\n\tint     retcode;\n\n\tRF_LOCK_MUTEX(rf_sparet_wait_mutex);\n\treq->next = rf_sparet_wait_queue;\n\trf_sparet_wait_queue = req;\n\twakeup(&rf_sparet_wait_queue);\n\n\t/* mpsleep unlocks the mutex */\n\twhile (!rf_sparet_resp_queue) {\n\t\ttsleep(&rf_sparet_resp_queue, PRIBIO,\n\t\t    \"raidframe getsparetable\", 0);\n\t}\n\treq = rf_sparet_resp_queue;\n\trf_sparet_resp_queue = req->next;\n\tRF_UNLOCK_MUTEX(rf_sparet_wait_mutex);\n\n\tretcode = req->fcol;\n\tRF_Free(req, sizeof(*req));\t/* this is not the same req as we\n\t\t\t\t\t * alloc'd */\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "req",
            "sizeof(*req)",
            "(RF_SparetWait_t *)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint     rf_GetSpareTableFromDaemon(RF_SparetWait_t * req);\n\nint \nrf_InstallSpareTable(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t frow,\n    RF_RowCol_t fcol)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SparetWait_t *req;\n\tint     retcode;\n\n\tRF_Malloc(req, sizeof(*req), (RF_SparetWait_t *));\n\treq->C = raidPtr->numCol;\n\treq->G = raidPtr->Layout.numDataCol + raidPtr->Layout.numParityCol;\n\treq->fcol = fcol;\n\treq->SUsPerPU = raidPtr->Layout.SUsPerPU;\n\treq->TablesPerSpareRegion = info->TablesPerSpareRegion;\n\treq->BlocksPerTable = info->BlocksPerTable;\n\treq->TableDepthInPUs = info->TableDepthInPUs;\n\treq->SpareSpaceDepthPerRegionInSUs = info->SpareSpaceDepthPerRegionInSUs;\n\n\tretcode = rf_GetSpareTableFromDaemon(req);\n\tRF_ASSERT(!retcode);\t/* XXX -- fix this to recover gracefully --\n\t\t\t\t * XXX */\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_remap_to_spare_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "605-652",
    "snippet": "void \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\"",
            "(long) *outSU"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "*outCol != -1"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}"
  },
  {
    "function_name": "rf_MapSIDToPSIDDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "584-600",
    "snippet": "void \nrf_MapSIDToPSIDDeclustered(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\tRF_DeclusteredConfigInfo_t *info;\n\n\tinfo = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\n\t*psID = (stripeID / (layoutPtr->SUsPerPU * info->BlocksPerTable))\n\t    * info->BlocksPerTable + (stripeID % info->BlocksPerTable);\n\t*which_ru = (stripeID % (info->BlocksPerTable * layoutPtr->SUsPerPU))\n\t    / info->BlocksPerTable;\n\tRF_ASSERT((*which_ru) < layoutPtr->SUsPerPU / layoutPtr->SUsPerRU);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(*which_ru) < layoutPtr->SUsPerPU / layoutPtr->SUsPerRU"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapSIDToPSIDDeclustered(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\tRF_DeclusteredConfigInfo_t *info;\n\n\tinfo = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\n\t*psID = (stripeID / (layoutPtr->SUsPerPU * info->BlocksPerTable))\n\t    * info->BlocksPerTable + (stripeID % info->BlocksPerTable);\n\t*which_ru = (stripeID % (info->BlocksPerTable * layoutPtr->SUsPerPU))\n\t    / info->BlocksPerTable;\n\tRF_ASSERT((*which_ru) < layoutPtr->SUsPerPU / layoutPtr->SUsPerRU);\n}"
  },
  {
    "function_name": "rf_decluster_adjust_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "550-579",
    "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
  },
  {
    "function_name": "rf_GetDefaultNumFloatingReconBuffersDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "529-533",
    "snippet": "int \nrf_GetDefaultNumFloatingReconBuffersDeclustered(RF_Raid_t * raidPtr)\n{\n\treturn (100 * rf_numBufsToAccumulate);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffersDeclustered(RF_Raid_t * raidPtr)\n{\n\treturn (100 * rf_numBufsToAccumulate);\n}"
  },
  {
    "function_name": "rf_GetDefaultHeadSepLimitDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "516-523",
    "snippet": "RF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitDeclustered(\n    RF_Raid_t * raidPtr)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\treturn (info->Lambda * raidPtr->numFloatingReconBufs / info->TableDepthInPUs / rf_numBufsToAccumulate);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitDeclustered(\n    RF_Raid_t * raidPtr)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\treturn (info->Lambda * raidPtr->numFloatingReconBufs / info->TableDepthInPUs / rf_numBufsToAccumulate);\n}"
  },
  {
    "function_name": "rf_IdentifyStripeDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "467-492",
    "snippet": "void \nrf_IdentifyStripeDeclustered(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0;\n\tRF_StripeNum_t SUID = rf_RaidAddressToStripeUnitID(layoutPtr, addr);\n\tRF_StripeNum_t stripeID, FullTableID;\n\tint     tableOffset;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\t*outRow = FullTableID % raidPtr->numRow;\n\tstripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);\t/* find stripe offset\n\t\t\t\t\t\t\t\t * into array */\n\ttableOffset = (stripeID % info->BlocksPerTable);\t/* find offset into\n\t\t\t\t\t\t\t\t * block design table */\n\t*diskids = info->LayoutTable[tableOffset];\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_StripeUnitIDToStripeID",
          "args": [
            "layoutPtr",
            "SUID"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_decluster_adjust_params",
          "args": [
            "layoutPtr",
            "&SUID",
            "&sus_per_fulltable",
            "&fulltable_depth",
            "&base_suid"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "rf_decluster_adjust_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "550-579",
          "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "layoutPtr",
            "addr"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_IdentifyStripeDeclustered(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0;\n\tRF_StripeNum_t SUID = rf_RaidAddressToStripeUnitID(layoutPtr, addr);\n\tRF_StripeNum_t stripeID, FullTableID;\n\tint     tableOffset;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\t*outRow = FullTableID % raidPtr->numRow;\n\tstripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);\t/* find stripe offset\n\t\t\t\t\t\t\t\t * into array */\n\ttableOffset = (stripeID % info->BlocksPerTable);\t/* find offset into\n\t\t\t\t\t\t\t\t * block design table */\n\t*diskids = info->LayoutTable[tableOffset];\n}"
  },
  {
    "function_name": "rf_MapParityDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "395-463",
    "snippet": "void \nrf_MapParityDeclustered(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion = 0, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\t/* compute row & (possibly) spare space exactly as before */\n\tFullTableID = SUID / sus_per_fulltable;\n\tif (raidPtr->numRow == 1)\n\t\t*row = 0;\t/* avoid a mod and a div in the common case */\n\telse {\n\t\t*row = FullTableID % raidPtr->numRow;\n\t\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on\n\t\t\t\t\t\t * this disk */\n\t}\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\t/* compute BlockID and RepIndex exactly as before */\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\t/* TableOffset     = FullTableOffset % info->SUsPerTable; */\n\t/* BlockID         = (TableOffset / info->PUsPerBlock) %\n\t * info->BlocksPerTable; */\n\tBlockID = TableOffset / info->PUsPerBlock;\n\t/* BlockOffset     = TableOffset % info->PUsPerBlock; */\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\n\t/* the parity block is in the position indicated by RepIndex */\n\tRepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->PUsPerBlock - TableID;\n\t*col = info->LayoutTable[BlockID][RepIndex];\n\n\tif (remap) {\n\t\tRF_ASSERT(raidPtr->Disks[*row][*col].status == rf_ds_reconstructing || raidPtr->Disks[*row][*col].status == rf_ds_dist_spared ||\n\t\t    (rf_copyback_in_progress && raidPtr->Disks[*row][*col].status == rf_ds_optimal));\n\t\trf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);\n\t} else {\n\n\t\t/* compute sector as before, except use RepIndex instead of\n\t\t * BlockOffset */\n\t\toutSU = base_suid;\n\t\toutSU += FullTableID * fulltable_depth;\n\t\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\t\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\t\toutSU += info->OffsetTable[BlockID][RepIndex] * layoutPtr->SUsPerPU;\n\t}\n\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n\n\tRF_ASSERT(*col != -1);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern int rf_copyback_in_progress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "*col != -1"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_remap_to_spare_space",
          "args": [
            "layoutPtr",
            "info",
            "*row",
            "FullTableID",
            "TableID",
            "BlockID",
            "(base_suid) ? 1 : 0",
            "SpareRegion",
            "col",
            "&outSU"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "rf_remap_to_spare_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "605-652",
          "snippet": "void \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->Disks[*row][*col].status == rf_ds_reconstructing || raidPtr->Disks[*row][*col].status == rf_ds_dist_spared ||\n\t\t    (rf_copyback_in_progress && raidPtr->Disks[*row][*col].status == rf_ds_optimal)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_decluster_adjust_params",
          "args": [
            "layoutPtr",
            "&SUID",
            "&sus_per_fulltable",
            "&fulltable_depth",
            "&base_suid"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "rf_decluster_adjust_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "550-579",
          "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nextern int rf_copyback_in_progress;\n\nvoid \nrf_MapParityDeclustered(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion = 0, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\t/* compute row & (possibly) spare space exactly as before */\n\tFullTableID = SUID / sus_per_fulltable;\n\tif (raidPtr->numRow == 1)\n\t\t*row = 0;\t/* avoid a mod and a div in the common case */\n\telse {\n\t\t*row = FullTableID % raidPtr->numRow;\n\t\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on\n\t\t\t\t\t\t * this disk */\n\t}\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\t/* compute BlockID and RepIndex exactly as before */\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\t/* TableOffset     = FullTableOffset % info->SUsPerTable; */\n\t/* BlockID         = (TableOffset / info->PUsPerBlock) %\n\t * info->BlocksPerTable; */\n\tBlockID = TableOffset / info->PUsPerBlock;\n\t/* BlockOffset     = TableOffset % info->PUsPerBlock; */\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\n\t/* the parity block is in the position indicated by RepIndex */\n\tRepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->PUsPerBlock - TableID;\n\t*col = info->LayoutTable[BlockID][RepIndex];\n\n\tif (remap) {\n\t\tRF_ASSERT(raidPtr->Disks[*row][*col].status == rf_ds_reconstructing || raidPtr->Disks[*row][*col].status == rf_ds_dist_spared ||\n\t\t    (rf_copyback_in_progress && raidPtr->Disks[*row][*col].status == rf_ds_optimal));\n\t\trf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);\n\t} else {\n\n\t\t/* compute sector as before, except use RepIndex instead of\n\t\t * BlockOffset */\n\t\toutSU = base_suid;\n\t\toutSU += FullTableID * fulltable_depth;\n\t\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\t\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\t\toutSU += info->OffsetTable[BlockID][RepIndex] * layoutPtr->SUsPerPU;\n\t}\n\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n\n\tRF_ASSERT(*col != -1);\n}"
  },
  {
    "function_name": "rf_MapSectorDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "326-391",
    "snippet": "void \nrf_MapSectorDeclustered(raidPtr, raidSector, row, col, diskSector, remap)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidSector;\n\tRF_RowCol_t *row;\n\tRF_RowCol_t *col;\n\tRF_SectorNum_t *diskSector;\n\tint     remap;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion = 0, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\tif (raidPtr->numRow == 1)\n\t\t*row = 0;\t/* avoid a mod and a div in the common case */\n\telse {\n\t\t*row = FullTableID % raidPtr->numRow;\n\t\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on\n\t\t\t\t\t\t * this disk */\n\t}\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\tRepIndex = info->PUsPerBlock - TableID;\n\tif (!raidPtr->noRotate)\n\t\tBlockOffset += ((BlockOffset >= RepIndex) ? 1 : 0);\n\t*col = info->LayoutTable[BlockID][BlockOffset];\n\n\t/* remap to distributed spare space if indicated */\n\tif (remap) {\n\t\tRF_ASSERT(raidPtr->Disks[*row][*col].status == rf_ds_reconstructing || raidPtr->Disks[*row][*col].status == rf_ds_dist_spared ||\n\t\t    (rf_copyback_in_progress && raidPtr->Disks[*row][*col].status == rf_ds_optimal));\n\t\trf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);\n\t} else {\n\n\t\toutSU = base_suid;\n\t\toutSU += FullTableID * fulltable_depth;\t/* offs to strt of FT */\n\t\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\t\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\t/* offs to strt of tble */\n\t\toutSU += info->OffsetTable[BlockID][BlockOffset] * layoutPtr->SUsPerPU;\t/* offs to the PU */\n\t}\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\t/* offs to the SU within\n\t\t\t\t\t\t\t\t\t\t * a PU */\n\n\t/* convert SUs to sectors, and, if not aligned to SU boundary, add in\n\t * offset to sector.  */\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n\n\tRF_ASSERT(*col != -1);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern int rf_copyback_in_progress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "*col != -1"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_remap_to_spare_space",
          "args": [
            "layoutPtr",
            "info",
            "*row",
            "FullTableID",
            "TableID",
            "BlockID",
            "(base_suid) ? 1 : 0",
            "SpareRegion",
            "col",
            "&outSU"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "rf_remap_to_spare_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "605-652",
          "snippet": "void \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->Disks[*row][*col].status == rf_ds_reconstructing || raidPtr->Disks[*row][*col].status == rf_ds_dist_spared ||\n\t\t    (rf_copyback_in_progress && raidPtr->Disks[*row][*col].status == rf_ds_optimal)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_decluster_adjust_params",
          "args": [
            "layoutPtr",
            "&SUID",
            "&sus_per_fulltable",
            "&fulltable_depth",
            "&base_suid"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rf_decluster_adjust_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "550-579",
          "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nextern int rf_copyback_in_progress;\n\nvoid \nrf_MapSectorDeclustered(raidPtr, raidSector, row, col, diskSector, remap)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidSector;\n\tRF_RowCol_t *row;\n\tRF_RowCol_t *col;\n\tRF_SectorNum_t *diskSector;\n\tint     remap;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion = 0, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\tif (raidPtr->numRow == 1)\n\t\t*row = 0;\t/* avoid a mod and a div in the common case */\n\telse {\n\t\t*row = FullTableID % raidPtr->numRow;\n\t\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on\n\t\t\t\t\t\t * this disk */\n\t}\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\tRepIndex = info->PUsPerBlock - TableID;\n\tif (!raidPtr->noRotate)\n\t\tBlockOffset += ((BlockOffset >= RepIndex) ? 1 : 0);\n\t*col = info->LayoutTable[BlockID][BlockOffset];\n\n\t/* remap to distributed spare space if indicated */\n\tif (remap) {\n\t\tRF_ASSERT(raidPtr->Disks[*row][*col].status == rf_ds_reconstructing || raidPtr->Disks[*row][*col].status == rf_ds_dist_spared ||\n\t\t    (rf_copyback_in_progress && raidPtr->Disks[*row][*col].status == rf_ds_optimal));\n\t\trf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);\n\t} else {\n\n\t\toutSU = base_suid;\n\t\toutSU += FullTableID * fulltable_depth;\t/* offs to strt of FT */\n\t\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\t\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\t/* offs to strt of tble */\n\t\toutSU += info->OffsetTable[BlockID][BlockOffset] * layoutPtr->SUsPerPU;\t/* offs to the PU */\n\t}\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\t/* offs to the SU within\n\t\t\t\t\t\t\t\t\t\t * a PU */\n\n\t/* convert SUs to sectors, and, if not aligned to SU boundary, add in\n\t * offset to sector.  */\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n\n\tRF_ASSERT(*col != -1);\n}"
  },
  {
    "function_name": "rf_ConfigureDeclusteredDS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "306-324",
    "snippet": "int \nrf_ConfigureDeclusteredDS(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\trc = rf_ConfigureDeclustered(listp, raidPtr, cfgPtr);\n\tif (rc)\n\t\treturn (rc);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownDeclusteredDS, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"Got %d adding shutdown event for DeclusteredDS\\n\", rc);\n\t\trf_ShutdownDeclusteredDS(raidPtr);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ShutdownDeclusteredDS",
          "args": [
            "raidPtr"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownDeclusteredDS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "293-304",
          "snippet": "static void \nrf_ShutdownDeclusteredDS(arg)\n\tRF_ThreadArg_t arg;\n{\n\tRF_DeclusteredConfigInfo_t *info;\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tinfo = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tif (info->SpareTable)\n\t\trf_FreeSpareTable(raidPtr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_ShutdownDeclusteredDS(RF_ThreadArg_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void rf_ShutdownDeclusteredDS(RF_ThreadArg_t);\n\nstatic void \nrf_ShutdownDeclusteredDS(arg)\n\tRF_ThreadArg_t arg;\n{\n\tRF_DeclusteredConfigInfo_t *info;\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tinfo = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tif (info->SpareTable)\n\t\trf_FreeSpareTable(raidPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"Got %d adding shutdown event for DeclusteredDS\\n\"",
            "rc"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownDeclusteredDS",
            "raidPtr"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ConfigureDeclustered",
          "args": [
            "listp",
            "raidPtr",
            "cfgPtr"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ConfigureDeclusteredDS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "306-324",
          "snippet": "int \nrf_ConfigureDeclusteredDS(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\trc = rf_ConfigureDeclustered(listp, raidPtr, cfgPtr);\n\tif (rc)\n\t\treturn (rc);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownDeclusteredDS, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"Got %d adding shutdown event for DeclusteredDS\\n\", rc);\n\t\trf_ShutdownDeclusteredDS(raidPtr);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_ConfigureDeclusteredDS(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\trc = rf_ConfigureDeclustered(listp, raidPtr, cfgPtr);\n\tif (rc)\n\t\treturn (rc);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownDeclusteredDS, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"Got %d adding shutdown event for DeclusteredDS\\n\", rc);\n\t\trf_ShutdownDeclusteredDS(raidPtr);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownDeclusteredDS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "293-304",
    "snippet": "static void \nrf_ShutdownDeclusteredDS(arg)\n\tRF_ThreadArg_t arg;\n{\n\tRF_DeclusteredConfigInfo_t *info;\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tinfo = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tif (info->SpareTable)\n\t\trf_FreeSpareTable(raidPtr);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_ShutdownDeclusteredDS(RF_ThreadArg_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeSpareTable",
          "args": [
            "raidPtr"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeSpareTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "730-744",
          "snippet": "void \nrf_FreeSpareTable(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tlong    i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_SpareTableEntry_t **table = info->SpareTable;\n\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Free(table[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t}\n\tRF_Free(table, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\tinfo->SpareTable = (RF_SpareTableEntry_t **) NULL;\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeSpareTable(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tlong    i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_SpareTableEntry_t **table = info->SpareTable;\n\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Free(table[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t}\n\tRF_Free(table, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\tinfo->SpareTable = (RF_SpareTableEntry_t **) NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void rf_ShutdownDeclusteredDS(RF_ThreadArg_t);\n\nstatic void \nrf_ShutdownDeclusteredDS(arg)\n\tRF_ThreadArg_t arg;\n{\n\tRF_DeclusteredConfigInfo_t *info;\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tinfo = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tif (info->SpareTable)\n\t\trf_FreeSpareTable(raidPtr);\n}"
  },
  {
    "function_name": "rf_ConfigureDeclustered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
    "lines": "69-290",
    "snippet": "int \nrf_ConfigureDeclustered(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tint     b, v, k, r, lambda;\t/* block design params */\n\tint     i, j;\n\tRF_RowCol_t *first_avail_slot;\n\tRF_StripeCount_t complete_FT_count, numCompleteFullTablesPerDisk;\n\tRF_DeclusteredConfigInfo_t *info;\n\tRF_StripeCount_t PUsPerDisk, spareRegionDepthInPUs, numCompleteSpareRegionsPerDisk,\n\t        extraPUsPerDisk;\n\tRF_StripeCount_t totSparePUsPerDisk;\n\tRF_SectorNum_t diskOffsetOfLastFullTableInSUs;\n\tRF_SectorCount_t SpareSpaceInSUs;\n\tchar   *cfgBuf = (char *) (cfgPtr->layoutSpecific);\n\tRF_StripeNum_t l, SUID;\n\n\tSUID = l = 0;\n\tnumCompleteSpareRegionsPerDisk = 0;\n\n\t/* 1. create layout specific structure */\n\tRF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t), (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\tinfo->SpareTable = NULL;\n\n\t/* 2. extract parameters from the config structure */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t(void) bcopy(cfgBuf, info->sparemap_fname, RF_SPAREMAP_NAME_LEN);\n\t}\n\tcfgBuf += RF_SPAREMAP_NAME_LEN;\n\n\tb = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tv = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tk = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tr = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tlambda = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\traidPtr->noRotate = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\n\t/* the sparemaps are generated assuming that parity is rotated, so we\n\t * issue a warning if both distributed sparing and no-rotate are on at\n\t * the same time */\n\tif ((layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) && raidPtr->noRotate) {\n\t\tRF_ERRORMSG(\"Warning:  distributed sparing specified without parity rotation.\\n\");\n\t}\n\tif (raidPtr->numCol != v) {\n\t\tRF_ERRORMSG2(\"RAID: config error: table element count (%d) not equal to no. of cols (%d)\\n\", v, raidPtr->numCol);\n\t\treturn (EINVAL);\n\t}\n\t/* 3.  set up the values used in the mapping code */\n\tinfo->BlocksPerTable = b;\n\tinfo->Lambda = lambda;\n\tinfo->NumParityReps = info->groupSize = k;\n\tinfo->SUsPerTable = b * (k - 1) * layoutPtr->SUsPerPU;\t/* b blks, k-1 SUs each */\n\tinfo->SUsPerFullTable = k * info->SUsPerTable;\t/* rot k times */\n\tinfo->PUsPerBlock = k - 1;\n\tinfo->SUsPerBlock = info->PUsPerBlock * layoutPtr->SUsPerPU;\n\tinfo->TableDepthInPUs = (b * k) / v;\n\tinfo->FullTableDepthInPUs = info->TableDepthInPUs * k;\t/* k repetitions */\n\n\t/* used only in distributed sparing case */\n\tinfo->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);\t/* (v-1)/gcd fulltables */\n\tinfo->TablesPerSpareRegion = k * info->FullTablesPerSpareRegion;\n\tinfo->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion / (v - 1)) * layoutPtr->SUsPerPU;\n\n\t/* check to make sure the block design is sufficiently small */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tif (info->FullTableDepthInPUs * layoutPtr->SUsPerPU + info->SpareSpaceDepthPerRegionInSUs > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG3(\"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) info->FullTableDepthInPUs,\n\t\t\t    (int) info->SpareSpaceDepthPerRegionInSUs,\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t} else {\n\t\tif (info->TableDepthInPUs * layoutPtr->SUsPerPU > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) (info->TableDepthInPUs * layoutPtr->SUsPerPU), \\\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\n\t/* compute the size of each disk, and the number of tables in the last\n\t * fulltable (which need not be complete) */\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\n\t\tPUsPerDisk = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU;\n\t\tspareRegionDepthInPUs = (info->TablesPerSpareRegion * info->TableDepthInPUs +\n\t\t    (info->TablesPerSpareRegion * info->TableDepthInPUs) / (v - 1));\n\t\tinfo->SpareRegionDepthInSUs = spareRegionDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\tnumCompleteSpareRegionsPerDisk = PUsPerDisk / spareRegionDepthInPUs;\n\t\tinfo->NumCompleteSRs = numCompleteSpareRegionsPerDisk;\n\t\textraPUsPerDisk = PUsPerDisk % spareRegionDepthInPUs;\n\n\t\t/* assume conservatively that we need the full amount of spare\n\t\t * space in one region in order to provide spares for the\n\t\t * partial spare region at the end of the array.  We set \"i\"\n\t\t * to the number of tables in the partial spare region.  This\n\t\t * may actually include some fulltables. */\n\t\textraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tif (extraPUsPerDisk <= 0)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = extraPUsPerDisk / info->TableDepthInPUs;\n\n\t\tcomplete_FT_count = raidPtr->numRow * (numCompleteSpareRegionsPerDisk * (info->TablesPerSpareRegion / k) + i / k);\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk = i % k;\n\n\t\t/* note that in the last spare region, the spare space is\n\t\t * complete even though data/parity space is not */\n\t\ttotSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) * (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tinfo->TotSparePUsPerDisk = totSparePUsPerDisk;\n\n\t\tlayoutPtr->stripeUnitsPerDisk =\n\t\t    ((complete_FT_count / raidPtr->numRow) * info->FullTableDepthInPUs +\t/* data & parity space */\n\t\t    info->ExtraTablesPerDisk * info->TableDepthInPUs +\n\t\t    totSparePUsPerDisk\t/* spare space */\n\t\t    ) * layoutPtr->SUsPerPU;\n\t\tlayoutPtr->dataStripeUnitsPerDisk =\n\t\t    (complete_FT_count * info->FullTableDepthInPUs + info->ExtraTablesPerDisk * info->TableDepthInPUs)\n\t\t    * layoutPtr->SUsPerPU * (k - 1) / k;\n\n\t} else {\n\t\t/* non-dist spare case:  force each disk to contain an\n\t\t * integral number of tables */\n\t\tlayoutPtr->stripeUnitsPerDisk /= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\t\tlayoutPtr->stripeUnitsPerDisk *= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the number of tables in the last fulltable, which\n\t\t * need not be complete */\n\t\tcomplete_FT_count =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) * raidPtr->numRow;\n\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;\n\t}\n\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\t/* find the disk offset of the stripe unit where the last fulltable\n\t * starts */\n\tnumCompleteFullTablesPerDisk = complete_FT_count / raidPtr->numRow;\n\tdiskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk * info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tSpareSpaceInSUs = numCompleteSpareRegionsPerDisk * info->SpareSpaceDepthPerRegionInSUs;\n\t\tdiskOffsetOfLastFullTableInSUs += SpareSpaceInSUs;\n\t\tinfo->DiskOffsetOfLastSpareSpaceChunkInSUs =\n\t\t    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\t}\n\tinfo->DiskOffsetOfLastFullTableInSUs = diskOffsetOfLastFullTableInSUs;\n\tinfo->numCompleteFullTablesPerDisk = numCompleteFullTablesPerDisk;\n\n\t/* 4.  create and initialize the lookup tables */\n\tinfo->LayoutTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->LayoutTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->OffsetTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->OffsetTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->BlockTable = rf_make_2d_array(info->TableDepthInPUs * layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);\n\tif (info->BlockTable == NULL)\n\t\treturn (ENOMEM);\n\n\tfirst_avail_slot = rf_make_1d_array(v, NULL);\n\tif (first_avail_slot == NULL)\n\t\treturn (ENOMEM);\n\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++)\n\t\t\tinfo->LayoutTable[i][j] = *cfgBuf++;\n\n\t/* initialize offset table */\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tinfo->OffsetTable[i][j] = first_avail_slot[info->LayoutTable[i][j]];\n\t\t\tfirst_avail_slot[info->LayoutTable[i][j]]++;\n\t\t}\n\n\t/* initialize block table */\n\tfor (SUID = l = 0; l < layoutPtr->SUsPerPU; l++) {\n\t\tfor (i = 0; i < b; i++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tinfo->BlockTable[(info->OffsetTable[i][j] * layoutPtr->SUsPerPU) + l]\n\t\t\t\t    [info->LayoutTable[i][j]] = SUID;\n\t\t\t}\n\t\t\tSUID++;\n\t\t}\n\t}\n\n\trf_free_1d_array(first_avail_slot, v);\n\n\t/* 5.  set up the remaining redundant-but-useful parameters */\n\n\traidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow * info->ExtraTablesPerDisk) *\n\t    info->SUsPerTable * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numStripe = (raidPtr->totalSectors / layoutPtr->sectorsPerStripeUnit) / (k - 1);\n\n\t/* strange evaluation order below to try and minimize overflow\n\t * problems */\n\n\tlayoutPtr->dataSectorsPerStripe = (k - 1) * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = k - 1;\n\tlayoutPtr->numParityCol = 1;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raidframe.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_free_1d_array",
          "args": [
            "first_avail_slot",
            "v"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "rf_free_1d_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_utils.c",
          "lines": "90-96",
          "snippet": "void \nrf_free_1d_array(a, n)\n\tRF_RowCol_t *a;\n\tint     n;\n{\n\tRF_Free(a, n * sizeof(RF_RowCol_t));\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_utils.h\"",
            "#include <sys/time.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_utils.h\"\n#include <sys/time.h>\n#include \"rf_threadstuff.h\"\n\nvoid \nrf_free_1d_array(a, n)\n\tRF_RowCol_t *a;\n\tint     n;\n{\n\tRF_Free(a, n * sizeof(RF_RowCol_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_make_1d_array",
          "args": [
            "v",
            "NULL"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "info->TableDepthInPUs * layoutPtr->SUsPerPU",
            "raidPtr->numCol",
            "raidPtr->cleanupList"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "b",
            "k",
            "raidPtr->cleanupList"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "b",
            "k",
            "raidPtr->cleanupList"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\\n\"",
            "(int) (info->TableDepthInPUs * layoutPtr->SUsPerPU)",
            "(int) layoutPtr->stripeUnitsPerDisk"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\\n\"",
            "(int) info->FullTableDepthInPUs",
            "(int) info->SpareSpaceDepthPerRegionInSUs",
            "(int) layoutPtr->stripeUnitsPerDisk"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_gcd",
          "args": [
            "r",
            "v - 1"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "rf_gcd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_utils.c",
          "lines": "100-113",
          "snippet": "int \nrf_gcd(m, n)\n\tint     m;\n\tint     n;\n{\n\tint     t;\n\n\twhile (m > 0) {\n\t\tt = n % m;\n\t\tn = m;\n\t\tm = t;\n\t}\n\treturn (n);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_utils.h\"",
            "#include <sys/time.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_utils.h\"\n#include <sys/time.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_gcd(m, n)\n\tint     m;\n\tint     n;\n{\n\tint     t;\n\n\twhile (m > 0) {\n\t\tt = n % m;\n\t\tn = m;\n\t\tm = t;\n\t}\n\treturn (n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"RAID: config error: table element count (%d) not equal to no. of cols (%d)\\n\"",
            "v",
            "raidPtr->numCol"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Warning:  distributed sparing specified without parity rotation.\\n\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "cfgBuf",
            "info->sparemap_fname",
            "RF_SPAREMAP_NAME_LEN"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "info",
            "sizeof(RF_DeclusteredConfigInfo_t)",
            "(RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_ConfigureDeclustered(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tint     b, v, k, r, lambda;\t/* block design params */\n\tint     i, j;\n\tRF_RowCol_t *first_avail_slot;\n\tRF_StripeCount_t complete_FT_count, numCompleteFullTablesPerDisk;\n\tRF_DeclusteredConfigInfo_t *info;\n\tRF_StripeCount_t PUsPerDisk, spareRegionDepthInPUs, numCompleteSpareRegionsPerDisk,\n\t        extraPUsPerDisk;\n\tRF_StripeCount_t totSparePUsPerDisk;\n\tRF_SectorNum_t diskOffsetOfLastFullTableInSUs;\n\tRF_SectorCount_t SpareSpaceInSUs;\n\tchar   *cfgBuf = (char *) (cfgPtr->layoutSpecific);\n\tRF_StripeNum_t l, SUID;\n\n\tSUID = l = 0;\n\tnumCompleteSpareRegionsPerDisk = 0;\n\n\t/* 1. create layout specific structure */\n\tRF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t), (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\tinfo->SpareTable = NULL;\n\n\t/* 2. extract parameters from the config structure */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t(void) bcopy(cfgBuf, info->sparemap_fname, RF_SPAREMAP_NAME_LEN);\n\t}\n\tcfgBuf += RF_SPAREMAP_NAME_LEN;\n\n\tb = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tv = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tk = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tr = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tlambda = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\traidPtr->noRotate = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\n\t/* the sparemaps are generated assuming that parity is rotated, so we\n\t * issue a warning if both distributed sparing and no-rotate are on at\n\t * the same time */\n\tif ((layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) && raidPtr->noRotate) {\n\t\tRF_ERRORMSG(\"Warning:  distributed sparing specified without parity rotation.\\n\");\n\t}\n\tif (raidPtr->numCol != v) {\n\t\tRF_ERRORMSG2(\"RAID: config error: table element count (%d) not equal to no. of cols (%d)\\n\", v, raidPtr->numCol);\n\t\treturn (EINVAL);\n\t}\n\t/* 3.  set up the values used in the mapping code */\n\tinfo->BlocksPerTable = b;\n\tinfo->Lambda = lambda;\n\tinfo->NumParityReps = info->groupSize = k;\n\tinfo->SUsPerTable = b * (k - 1) * layoutPtr->SUsPerPU;\t/* b blks, k-1 SUs each */\n\tinfo->SUsPerFullTable = k * info->SUsPerTable;\t/* rot k times */\n\tinfo->PUsPerBlock = k - 1;\n\tinfo->SUsPerBlock = info->PUsPerBlock * layoutPtr->SUsPerPU;\n\tinfo->TableDepthInPUs = (b * k) / v;\n\tinfo->FullTableDepthInPUs = info->TableDepthInPUs * k;\t/* k repetitions */\n\n\t/* used only in distributed sparing case */\n\tinfo->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);\t/* (v-1)/gcd fulltables */\n\tinfo->TablesPerSpareRegion = k * info->FullTablesPerSpareRegion;\n\tinfo->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion / (v - 1)) * layoutPtr->SUsPerPU;\n\n\t/* check to make sure the block design is sufficiently small */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tif (info->FullTableDepthInPUs * layoutPtr->SUsPerPU + info->SpareSpaceDepthPerRegionInSUs > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG3(\"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) info->FullTableDepthInPUs,\n\t\t\t    (int) info->SpareSpaceDepthPerRegionInSUs,\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t} else {\n\t\tif (info->TableDepthInPUs * layoutPtr->SUsPerPU > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) (info->TableDepthInPUs * layoutPtr->SUsPerPU), \\\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\n\t/* compute the size of each disk, and the number of tables in the last\n\t * fulltable (which need not be complete) */\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\n\t\tPUsPerDisk = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU;\n\t\tspareRegionDepthInPUs = (info->TablesPerSpareRegion * info->TableDepthInPUs +\n\t\t    (info->TablesPerSpareRegion * info->TableDepthInPUs) / (v - 1));\n\t\tinfo->SpareRegionDepthInSUs = spareRegionDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\tnumCompleteSpareRegionsPerDisk = PUsPerDisk / spareRegionDepthInPUs;\n\t\tinfo->NumCompleteSRs = numCompleteSpareRegionsPerDisk;\n\t\textraPUsPerDisk = PUsPerDisk % spareRegionDepthInPUs;\n\n\t\t/* assume conservatively that we need the full amount of spare\n\t\t * space in one region in order to provide spares for the\n\t\t * partial spare region at the end of the array.  We set \"i\"\n\t\t * to the number of tables in the partial spare region.  This\n\t\t * may actually include some fulltables. */\n\t\textraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tif (extraPUsPerDisk <= 0)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = extraPUsPerDisk / info->TableDepthInPUs;\n\n\t\tcomplete_FT_count = raidPtr->numRow * (numCompleteSpareRegionsPerDisk * (info->TablesPerSpareRegion / k) + i / k);\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk = i % k;\n\n\t\t/* note that in the last spare region, the spare space is\n\t\t * complete even though data/parity space is not */\n\t\ttotSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) * (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tinfo->TotSparePUsPerDisk = totSparePUsPerDisk;\n\n\t\tlayoutPtr->stripeUnitsPerDisk =\n\t\t    ((complete_FT_count / raidPtr->numRow) * info->FullTableDepthInPUs +\t/* data & parity space */\n\t\t    info->ExtraTablesPerDisk * info->TableDepthInPUs +\n\t\t    totSparePUsPerDisk\t/* spare space */\n\t\t    ) * layoutPtr->SUsPerPU;\n\t\tlayoutPtr->dataStripeUnitsPerDisk =\n\t\t    (complete_FT_count * info->FullTableDepthInPUs + info->ExtraTablesPerDisk * info->TableDepthInPUs)\n\t\t    * layoutPtr->SUsPerPU * (k - 1) / k;\n\n\t} else {\n\t\t/* non-dist spare case:  force each disk to contain an\n\t\t * integral number of tables */\n\t\tlayoutPtr->stripeUnitsPerDisk /= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\t\tlayoutPtr->stripeUnitsPerDisk *= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the number of tables in the last fulltable, which\n\t\t * need not be complete */\n\t\tcomplete_FT_count =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) * raidPtr->numRow;\n\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;\n\t}\n\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\t/* find the disk offset of the stripe unit where the last fulltable\n\t * starts */\n\tnumCompleteFullTablesPerDisk = complete_FT_count / raidPtr->numRow;\n\tdiskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk * info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tSpareSpaceInSUs = numCompleteSpareRegionsPerDisk * info->SpareSpaceDepthPerRegionInSUs;\n\t\tdiskOffsetOfLastFullTableInSUs += SpareSpaceInSUs;\n\t\tinfo->DiskOffsetOfLastSpareSpaceChunkInSUs =\n\t\t    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\t}\n\tinfo->DiskOffsetOfLastFullTableInSUs = diskOffsetOfLastFullTableInSUs;\n\tinfo->numCompleteFullTablesPerDisk = numCompleteFullTablesPerDisk;\n\n\t/* 4.  create and initialize the lookup tables */\n\tinfo->LayoutTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->LayoutTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->OffsetTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->OffsetTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->BlockTable = rf_make_2d_array(info->TableDepthInPUs * layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);\n\tif (info->BlockTable == NULL)\n\t\treturn (ENOMEM);\n\n\tfirst_avail_slot = rf_make_1d_array(v, NULL);\n\tif (first_avail_slot == NULL)\n\t\treturn (ENOMEM);\n\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++)\n\t\t\tinfo->LayoutTable[i][j] = *cfgBuf++;\n\n\t/* initialize offset table */\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tinfo->OffsetTable[i][j] = first_avail_slot[info->LayoutTable[i][j]];\n\t\t\tfirst_avail_slot[info->LayoutTable[i][j]]++;\n\t\t}\n\n\t/* initialize block table */\n\tfor (SUID = l = 0; l < layoutPtr->SUsPerPU; l++) {\n\t\tfor (i = 0; i < b; i++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tinfo->BlockTable[(info->OffsetTable[i][j] * layoutPtr->SUsPerPU) + l]\n\t\t\t\t    [info->LayoutTable[i][j]] = SUID;\n\t\t\t}\n\t\t\tSUID++;\n\t\t}\n\t}\n\n\trf_free_1d_array(first_avail_slot, v);\n\n\t/* 5.  set up the remaining redundant-but-useful parameters */\n\n\traidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow * info->ExtraTablesPerDisk) *\n\t    info->SUsPerTable * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numStripe = (raidPtr->totalSectors / layoutPtr->sectorsPerStripeUnit) / (k - 1);\n\n\t/* strange evaluation order below to try and minimize overflow\n\t * problems */\n\n\tlayoutPtr->dataSectorsPerStripe = (k - 1) * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = k - 1;\n\tlayoutPtr->numParityCol = 1;\n\n\treturn (0);\n}"
  }
]