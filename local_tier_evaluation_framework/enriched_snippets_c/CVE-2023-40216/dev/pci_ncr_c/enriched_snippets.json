[
  {
    "function_name": "read_tekram_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "8022-8047",
    "snippet": "static int\nread_tekram_eeprom(ncb_p np, struct tekram_eeprom *buffer)\n{\n\tu_short *p = (u_short *) buffer;\n\tu_short sum = 0;\n\tint i;\n\n\tif (INB (nc_gpcntl) != 0x09)\n\t{\n\t\treturn 0;\n        }\n\tfor (i = 0; i < 64; i++)\n\t{\n\t\tu_short val;\nif((i&0x0f) == 0) printf (\"%02x:\", i*2);\n\t\tval = read_tekram_eeprom_reg (np, i);\n\t\tif (p)\n\t\t\t*p++ = val;\n\t\tsum += val;\nif((i&0x01) == 0x00) printf (\" \");\n\t\tprintf (\"%02x%02x\", val & 0xff, (val >> 8) & 0xff);\nif((i&0x0f) == 0x0f) printf (\"\\n\");\n\t}\nprintf (\"Sum = %04x\\n\", sum);\n\treturn sum == 0x1234;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "int\ti;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sum = %04x\\n\"",
            "sum"
          ],
          "line": 8045
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tekram_eeprom_reg",
          "args": [
            "np",
            "i"
          ],
          "line": 8037
        },
        "resolved": true,
        "details": {
          "function_name": "read_tekram_eeprom_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7997-8020",
          "snippet": "static u_short\nread_tekram_eeprom_reg (ncb_p np, int reg)\n{\n\tint bit;\n\tu_short result = 0;\n\tint cmd = 0x80 | reg;\n\n\tOUTB (nc_gpreg, 0x10);\n\n\ttekram_write_bit (np, 1);\n\tfor (bit = 7; bit >= 0; bit--)\n\t{\n\t\ttekram_write_bit (np, cmd >> bit);\n\t}\n\n\tfor (bit = 0; bit < 16; bit++)\n\t{\n\t\tresult <<= 1;\n\t\tresult |= tekram_read_bit (np);\n\t}\n\n\tOUTB (nc_gpreg, 0x00);\n\treturn result;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic u_short\nread_tekram_eeprom_reg (ncb_p np, int reg)\n{\n\tint bit;\n\tu_short result = 0;\n\tint cmd = 0x80 | reg;\n\n\tOUTB (nc_gpreg, 0x10);\n\n\ttekram_write_bit (np, 1);\n\tfor (bit = 7; bit >= 0; bit--)\n\t{\n\t\ttekram_write_bit (np, cmd >> bit);\n\t}\n\n\tfor (bit = 0; bit < 16; bit++)\n\t{\n\t\tresult <<= 1;\n\t\tresult |= tekram_read_bit (np);\n\t}\n\n\tOUTB (nc_gpreg, 0x00);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_gpcntl"
          ],
          "line": 8029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\n\nstatic int\nread_tekram_eeprom(ncb_p np, struct tekram_eeprom *buffer)\n{\n\tu_short *p = (u_short *) buffer;\n\tu_short sum = 0;\n\tint i;\n\n\tif (INB (nc_gpcntl) != 0x09)\n\t{\n\t\treturn 0;\n        }\n\tfor (i = 0; i < 64; i++)\n\t{\n\t\tu_short val;\nif((i&0x0f) == 0) printf (\"%02x:\", i*2);\n\t\tval = read_tekram_eeprom_reg (np, i);\n\t\tif (p)\n\t\t\t*p++ = val;\n\t\tsum += val;\nif((i&0x01) == 0x00) printf (\" \");\n\t\tprintf (\"%02x%02x\", val & 0xff, (val >> 8) & 0xff);\nif((i&0x0f) == 0x0f) printf (\"\\n\");\n\t}\nprintf (\"Sum = %04x\\n\", sum);\n\treturn sum == 0x1234;\n}"
  },
  {
    "function_name": "read_tekram_eeprom_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7997-8020",
    "snippet": "static u_short\nread_tekram_eeprom_reg (ncb_p np, int reg)\n{\n\tint bit;\n\tu_short result = 0;\n\tint cmd = 0x80 | reg;\n\n\tOUTB (nc_gpreg, 0x10);\n\n\ttekram_write_bit (np, 1);\n\tfor (bit = 7; bit >= 0; bit--)\n\t{\n\t\ttekram_write_bit (np, cmd >> bit);\n\t}\n\n\tfor (bit = 0; bit < 16; bit++)\n\t{\n\t\tresult <<= 1;\n\t\tresult |= tekram_read_bit (np);\n\t}\n\n\tOUTB (nc_gpreg, 0x00);\n\treturn result;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_gpreg",
            "0x00"
          ],
          "line": 8018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tekram_read_bit",
          "args": [
            "np"
          ],
          "line": 8015
        },
        "resolved": true,
        "details": {
          "function_name": "tekram_read_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7987-7995",
          "snippet": "static int\ntekram_read_bit (ncb_p np)\n{\n\tOUTB (nc_gpreg, 0x10);\n\tDELAY(10);\n\tOUTB (nc_gpreg, 0x14);\n\tDELAY(10);\n\treturn INB (nc_gpreg) & 1;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic int\ntekram_read_bit (ncb_p np)\n{\n\tOUTB (nc_gpreg, 0x10);\n\tDELAY(10);\n\tOUTB (nc_gpreg, 0x14);\n\tDELAY(10);\n\treturn INB (nc_gpreg) & 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tekram_write_bit",
          "args": [
            "np",
            "cmd >> bit"
          ],
          "line": 8009
        },
        "resolved": true,
        "details": {
          "function_name": "tekram_write_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7973-7985",
          "snippet": "static void\ntekram_write_bit (ncb_p np, int bit)\n{\n\tu_char val = 0x10 + ((bit & 1) << 1);\n\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val | 0x04);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void\ntekram_write_bit (ncb_p np, int bit)\n{\n\tu_char val = 0x10 + ((bit & 1) << 1);\n\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val | 0x04);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_gpreg",
            "0x10"
          ],
          "line": 8004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic u_short\nread_tekram_eeprom_reg (ncb_p np, int reg)\n{\n\tint bit;\n\tu_short result = 0;\n\tint cmd = 0x80 | reg;\n\n\tOUTB (nc_gpreg, 0x10);\n\n\ttekram_write_bit (np, 1);\n\tfor (bit = 7; bit >= 0; bit--)\n\t{\n\t\ttekram_write_bit (np, cmd >> bit);\n\t}\n\n\tfor (bit = 0; bit < 16; bit++)\n\t{\n\t\tresult <<= 1;\n\t\tresult |= tekram_read_bit (np);\n\t}\n\n\tOUTB (nc_gpreg, 0x00);\n\treturn result;\n}"
  },
  {
    "function_name": "tekram_read_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7987-7995",
    "snippet": "static int\ntekram_read_bit (ncb_p np)\n{\n\tOUTB (nc_gpreg, 0x10);\n\tDELAY(10);\n\tOUTB (nc_gpreg, 0x14);\n\tDELAY(10);\n\treturn INB (nc_gpreg) & 1;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_gpreg"
          ],
          "line": 7994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 7993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_gpreg",
            "0x14"
          ],
          "line": 7992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 7991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_gpreg",
            "0x10"
          ],
          "line": 7990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic int\ntekram_read_bit (ncb_p np)\n{\n\tOUTB (nc_gpreg, 0x10);\n\tDELAY(10);\n\tOUTB (nc_gpreg, 0x14);\n\tDELAY(10);\n\treturn INB (nc_gpreg) & 1;\n}"
  },
  {
    "function_name": "tekram_write_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7973-7985",
    "snippet": "static void\ntekram_write_bit (ncb_p np, int bit)\n{\n\tu_char val = 0x10 + ((bit & 1) << 1);\n\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val | 0x04);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 7984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_gpreg",
            "val"
          ],
          "line": 7983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 7982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_gpreg",
            "val | 0x04"
          ],
          "line": 7981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 7980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_gpreg",
            "val"
          ],
          "line": 7979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 7978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void\ntekram_write_bit (ncb_p np, int bit)\n{\n\tu_char val = 0x10 + ((bit & 1) << 1);\n\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val | 0x04);\n\tDELAY(10);\n\tOUTB (nc_gpreg, val);\n\tDELAY(10);\n}"
  },
  {
    "function_name": "ncr_getclock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7905-7937",
    "snippet": "static void ncr_getclock (ncb_p np, u_char multiplier)\n{\n\tunsigned char scntl3;\n\tunsigned char stest1;\n\tscntl3 = INB(nc_scntl3);\n\tstest1 = INB(nc_stest1);\n\t\n\tnp->multiplier = 1;\n\t/* always false, except for 875 with clock doubler selected */\n\tif ((stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {\n\t\tnp->multiplier\t= multiplier;\n\t\tnp->clock_khz\t= 40000 * multiplier;\n\t} else {\n\t\tif ((scntl3 & 7) == 0) {\n\t\t\tunsigned f1, f2;\n\t\t\t/* throw away first result */\n\t\t\t(void) ncrgetfreq (np, 11);\n\t\t\tf1 = ncrgetfreq (np, 11);\n\t\t\tf2 = ncrgetfreq (np, 11);\n\n\t\t\tif (bootverbose >= 2)\n\t\t\t  printf (\"\\tNCR clock is %uKHz, %uKHz\\n\", f1, f2);\n\t\t\tif (f1 > f2) f1 = f2;\t/* trust lower result\t*/\n\t\t\tif (f1 > 45000) {\n\t\t\t\tscntl3 = 5;\t/* >45Mhz: assume 80MHz\t*/\n\t\t\t} else {\n\t\t\t\tscntl3 = 3;\t/* <45Mhz: assume 40MHz\t*/\n\t\t\t}\n\t\t}\n\t\telse if ((scntl3 & 7) == 5)\n\t\t\tnp->clock_khz = 80000;\t/* Probably a 875 rev. 1 ? */\n\t}\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define bootverbose\t0",
      "#define bootverbose\tNCR_VERBOSE"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "u_char rev = PCI_REVISION(pa->pa_class);",
      "ncb_p np = (struct ncb*) 0;",
      "u_char\trev = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tNCR clock is %uKHz, %uKHz\\n\"",
            "f1",
            "f2"
          ],
          "line": 7926
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncrgetfreq",
          "args": [
            "np",
            "11"
          ],
          "line": 7923
        },
        "resolved": true,
        "details": {
          "function_name": "ncrgetfreq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7859-7903",
          "snippet": "static unsigned\nncrgetfreq (ncb_p np, int gen)\n{\n\tint ms = 0;\n\t/*\n\t * Measure GEN timer delay in order\n\t * to calculate SCSI clock frequency\n\t *\n\t * This code will never execute too\n\t * many loop iterations (if DELAY is\n\t * reasonably correct). It could get\n\t * too low a delay (too high a freq.)\n\t * if the CPU is slow executing the\n\t * loop for some reason (an NMI, for\n\t * example). For this reason we will\n\t * if multiple measurements are to be\n\t * performed trust the higher delay\n\t * (lower frequency returned).\n\t */\n\tOUTB (nc_stest1, 0);\t/* make sure clock doubler is OFF\t    */\n\tOUTW (nc_sien , 0);\t/* mask all scsi interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* clear pending scsi interrupt\t\t    */\n\tOUTB (nc_dien , 0);\t/* mask all dma interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* another one, just to be sure :)\t    */\n\tOUTB (nc_scntl3, 4);\t/* set pre-scaler to divide by 3\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_stime1, gen);\t/* set to nominal delay of (1<<gen) * 125us */\n\twhile (!(INW(nc_sist) & GEN) && ms++ < 1000)\n\t\tDELAY(1000);\t/* count ms\t\t\t\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_scntl3, 0);\n\t/*\n\t * Set prescaler to divide by whatever \"0\" means.\n\t * \"0\" ought to choose divide by 2, but appears\n\t * to set divide by 3.5 mode in my 53c810 ...\n\t */\n\tOUTB (nc_scntl3, 0);\n\n\tif (bootverbose >= 2)\n\t  \tprintf (\"\\tDelay (GEN=%d): %u msec\\n\", gen, ms);\n\t/*\n\t * adjust for prescaler, and convert into KHz\n\t */\n\treturn ms ? ((1 << gen) * 4440) / ms : 0;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define bootverbose\t0",
            "#define bootverbose\tNCR_VERBOSE"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic unsigned\nncrgetfreq (ncb_p np, int gen)\n{\n\tint ms = 0;\n\t/*\n\t * Measure GEN timer delay in order\n\t * to calculate SCSI clock frequency\n\t *\n\t * This code will never execute too\n\t * many loop iterations (if DELAY is\n\t * reasonably correct). It could get\n\t * too low a delay (too high a freq.)\n\t * if the CPU is slow executing the\n\t * loop for some reason (an NMI, for\n\t * example). For this reason we will\n\t * if multiple measurements are to be\n\t * performed trust the higher delay\n\t * (lower frequency returned).\n\t */\n\tOUTB (nc_stest1, 0);\t/* make sure clock doubler is OFF\t    */\n\tOUTW (nc_sien , 0);\t/* mask all scsi interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* clear pending scsi interrupt\t\t    */\n\tOUTB (nc_dien , 0);\t/* mask all dma interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* another one, just to be sure :)\t    */\n\tOUTB (nc_scntl3, 4);\t/* set pre-scaler to divide by 3\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_stime1, gen);\t/* set to nominal delay of (1<<gen) * 125us */\n\twhile (!(INW(nc_sist) & GEN) && ms++ < 1000)\n\t\tDELAY(1000);\t/* count ms\t\t\t\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_scntl3, 0);\n\t/*\n\t * Set prescaler to divide by whatever \"0\" means.\n\t * \"0\" ought to choose divide by 2, but appears\n\t * to set divide by 3.5 mode in my 53c810 ...\n\t */\n\tOUTB (nc_scntl3, 0);\n\n\tif (bootverbose >= 2)\n\t  \tprintf (\"\\tDelay (GEN=%d): %u msec\\n\", gen, ms);\n\t/*\n\t * adjust for prescaler, and convert into KHz\n\t */\n\treturn ms ? ((1 << gen) * 4440) / ms : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_stest1"
          ],
          "line": 7910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_scntl3"
          ],
          "line": 7909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n\nncb_p np = (void *)self;\nu_char rev = PCI_REVISION(pa->pa_class);\nncb_p np = (struct ncb*) 0;\nu_char\trev = 0;\n\nstatic void ncr_getclock (ncb_p np, u_char multiplier)\n{\n\tunsigned char scntl3;\n\tunsigned char stest1;\n\tscntl3 = INB(nc_scntl3);\n\tstest1 = INB(nc_stest1);\n\t\n\tnp->multiplier = 1;\n\t/* always false, except for 875 with clock doubler selected */\n\tif ((stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {\n\t\tnp->multiplier\t= multiplier;\n\t\tnp->clock_khz\t= 40000 * multiplier;\n\t} else {\n\t\tif ((scntl3 & 7) == 0) {\n\t\t\tunsigned f1, f2;\n\t\t\t/* throw away first result */\n\t\t\t(void) ncrgetfreq (np, 11);\n\t\t\tf1 = ncrgetfreq (np, 11);\n\t\t\tf2 = ncrgetfreq (np, 11);\n\n\t\t\tif (bootverbose >= 2)\n\t\t\t  printf (\"\\tNCR clock is %uKHz, %uKHz\\n\", f1, f2);\n\t\t\tif (f1 > f2) f1 = f2;\t/* trust lower result\t*/\n\t\t\tif (f1 > 45000) {\n\t\t\t\tscntl3 = 5;\t/* >45Mhz: assume 80MHz\t*/\n\t\t\t} else {\n\t\t\t\tscntl3 = 3;\t/* <45Mhz: assume 40MHz\t*/\n\t\t\t}\n\t\t}\n\t\telse if ((scntl3 & 7) == 5)\n\t\t\tnp->clock_khz = 80000;\t/* Probably a 875 rev. 1 ? */\n\t}\n}"
  },
  {
    "function_name": "ncrgetfreq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7859-7903",
    "snippet": "static unsigned\nncrgetfreq (ncb_p np, int gen)\n{\n\tint ms = 0;\n\t/*\n\t * Measure GEN timer delay in order\n\t * to calculate SCSI clock frequency\n\t *\n\t * This code will never execute too\n\t * many loop iterations (if DELAY is\n\t * reasonably correct). It could get\n\t * too low a delay (too high a freq.)\n\t * if the CPU is slow executing the\n\t * loop for some reason (an NMI, for\n\t * example). For this reason we will\n\t * if multiple measurements are to be\n\t * performed trust the higher delay\n\t * (lower frequency returned).\n\t */\n\tOUTB (nc_stest1, 0);\t/* make sure clock doubler is OFF\t    */\n\tOUTW (nc_sien , 0);\t/* mask all scsi interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* clear pending scsi interrupt\t\t    */\n\tOUTB (nc_dien , 0);\t/* mask all dma interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* another one, just to be sure :)\t    */\n\tOUTB (nc_scntl3, 4);\t/* set pre-scaler to divide by 3\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_stime1, gen);\t/* set to nominal delay of (1<<gen) * 125us */\n\twhile (!(INW(nc_sist) & GEN) && ms++ < 1000)\n\t\tDELAY(1000);\t/* count ms\t\t\t\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_scntl3, 0);\n\t/*\n\t * Set prescaler to divide by whatever \"0\" means.\n\t * \"0\" ought to choose divide by 2, but appears\n\t * to set divide by 3.5 mode in my 53c810 ...\n\t */\n\tOUTB (nc_scntl3, 0);\n\n\tif (bootverbose >= 2)\n\t  \tprintf (\"\\tDelay (GEN=%d): %u msec\\n\", gen, ms);\n\t/*\n\t * adjust for prescaler, and convert into KHz\n\t */\n\treturn ms ? ((1 << gen) * 4440) / ms : 0;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define bootverbose\t0",
      "#define bootverbose\tNCR_VERBOSE"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tDelay (GEN=%d): %u msec\\n\"",
            "gen",
            "ms"
          ],
          "line": 7898
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl3",
            "0"
          ],
          "line": 7895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl3",
            "0"
          ],
          "line": 7889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stime1",
            "0"
          ],
          "line": 7888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 7887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INW",
          "args": [
            "nc_sist"
          ],
          "line": 7886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stime1",
            "gen"
          ],
          "line": 7885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stime1",
            "0"
          ],
          "line": 7884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl3",
            "4"
          ],
          "line": 7883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INW",
          "args": [
            "nc_sist"
          ],
          "line": 7882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_dien",
            "0"
          ],
          "line": 7881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INW",
          "args": [
            "nc_sist"
          ],
          "line": 7880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTW",
          "args": [
            "nc_sien",
            "0"
          ],
          "line": 7879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest1",
            "0"
          ],
          "line": 7878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic unsigned\nncrgetfreq (ncb_p np, int gen)\n{\n\tint ms = 0;\n\t/*\n\t * Measure GEN timer delay in order\n\t * to calculate SCSI clock frequency\n\t *\n\t * This code will never execute too\n\t * many loop iterations (if DELAY is\n\t * reasonably correct). It could get\n\t * too low a delay (too high a freq.)\n\t * if the CPU is slow executing the\n\t * loop for some reason (an NMI, for\n\t * example). For this reason we will\n\t * if multiple measurements are to be\n\t * performed trust the higher delay\n\t * (lower frequency returned).\n\t */\n\tOUTB (nc_stest1, 0);\t/* make sure clock doubler is OFF\t    */\n\tOUTW (nc_sien , 0);\t/* mask all scsi interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* clear pending scsi interrupt\t\t    */\n\tOUTB (nc_dien , 0);\t/* mask all dma interrupts\t\t    */\n\t(void) INW (nc_sist);\t/* another one, just to be sure :)\t    */\n\tOUTB (nc_scntl3, 4);\t/* set pre-scaler to divide by 3\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_stime1, gen);\t/* set to nominal delay of (1<<gen) * 125us */\n\twhile (!(INW(nc_sist) & GEN) && ms++ < 1000)\n\t\tDELAY(1000);\t/* count ms\t\t\t\t    */\n\tOUTB (nc_stime1, 0);\t/* disable general purpose timer\t    */\n\tOUTB (nc_scntl3, 0);\n\t/*\n\t * Set prescaler to divide by whatever \"0\" means.\n\t * \"0\" ought to choose divide by 2, but appears\n\t * to set divide by 3.5 mode in my 53c810 ...\n\t */\n\tOUTB (nc_scntl3, 0);\n\n\tif (bootverbose >= 2)\n\t  \tprintf (\"\\tDelay (GEN=%d): %u msec\\n\", gen, ms);\n\t/*\n\t * adjust for prescaler, and convert into KHz\n\t */\n\treturn ms ? ((1 << gen) * 4440) / ms : 0;\n}"
  },
  {
    "function_name": "ncr_selectclock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7831-7854",
    "snippet": "static void ncr_selectclock(ncb_p np, u_char scntl3)\n{\n\tif (np->multiplier < 2) {\n\t\tOUTB(nc_scntl3,\tscntl3);\n\t\treturn;\n\t}\n\n\tif (bootverbose >= 2)\n\t\tprintf (\"%s: enabling clock multiplier\\n\", ncr_name(np));\n\n\tOUTB(nc_stest1, DBLEN);\t   /* Enable clock multiplier\t\t  */\n\tif (np->multiplier > 2) {  /* Poll bit 5 of stest4 for quadrupler */\n\t\tint i = 20;\n\t\twhile (!(INB(nc_stest4) & LCKFRQ) && --i > 0)\n\t\t\tDELAY(20);\n\t\tif (!i)\n\t\t\tprintf(\"%s: the chip cannot lock the frequency\\n\", ncr_name(np));\n\t} else\t\t\t/* Wait 20 micro-seconds for doubler\t*/\n\t\tDELAY(20);\n\tOUTB(nc_stest3, HSC);\t\t/* Halt the scsi clock\t\t*/\n\tOUTB(nc_scntl3,\tscntl3);\n\tOUTB(nc_stest1, (DBLEN|DBLSEL));/* Select clock multiplier\t*/\n\tOUTB(nc_stest3, 0x00);\t\t/* Restart scsi clock \t\t*/\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define bootverbose\t0",
      "#define bootverbose\tNCR_VERBOSE"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "int\ti;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest3",
            "0x00"
          ],
          "line": 7853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest1",
            "(DBLEN|DBLSEL)"
          ],
          "line": 7852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl3",
            "scntl3"
          ],
          "line": 7851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest3",
            "HSC"
          ],
          "line": 7850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 7849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: the chip cannot lock the frequency\\n\"",
            "ncr_name(np)"
          ],
          "line": 7847
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 7847
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 7845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_stest4"
          ],
          "line": 7844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest1",
            "DBLEN"
          ],
          "line": 7841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl3",
            "scntl3"
          ],
          "line": 7834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\n\nstatic void ncr_selectclock(ncb_p np, u_char scntl3)\n{\n\tif (np->multiplier < 2) {\n\t\tOUTB(nc_scntl3,\tscntl3);\n\t\treturn;\n\t}\n\n\tif (bootverbose >= 2)\n\t\tprintf (\"%s: enabling clock multiplier\\n\", ncr_name(np));\n\n\tOUTB(nc_stest1, DBLEN);\t   /* Enable clock multiplier\t\t  */\n\tif (np->multiplier > 2) {  /* Poll bit 5 of stest4 for quadrupler */\n\t\tint i = 20;\n\t\twhile (!(INB(nc_stest4) & LCKFRQ) && --i > 0)\n\t\t\tDELAY(20);\n\t\tif (!i)\n\t\t\tprintf(\"%s: the chip cannot lock the frequency\\n\", ncr_name(np));\n\t} else\t\t\t/* Wait 20 micro-seconds for doubler\t*/\n\t\tDELAY(20);\n\tOUTB(nc_stest3, HSC);\t\t/* Halt the scsi clock\t\t*/\n\tOUTB(nc_scntl3,\tscntl3);\n\tOUTB(nc_stest1, (DBLEN|DBLSEL));/* Select clock multiplier\t*/\n\tOUTB(nc_stest3, 0x00);\t\t/* Restart scsi clock \t\t*/\n}"
  },
  {
    "function_name": "ncr_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7778-7802",
    "snippet": "static u_long ncr_lookup(char * id)\n{\n\tstruct table_entry * p = device_tab;\n\tchar *d, *r, c;\n\n\tfor (;;p++) {\n\n\t\td = id+8;\n\t\tr = p->manufacturer;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+16;\n\t\tr = p->model;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+32;\n\t\tr = p->version;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\treturn (p->info);\n\t}\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic u_long ncr_lookup(char * id)\n{\n\tstruct table_entry * p = device_tab;\n\tchar *d, *r, c;\n\n\tfor (;;p++) {\n\n\t\td = id+8;\n\t\tr = p->manufacturer;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+16;\n\t\tr = p->model;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+32;\n\t\tr = p->version;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\treturn (p->info);\n\t}\n}"
  },
  {
    "function_name": "ncb_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7699-7743",
    "snippet": "static\tvoid ncb_profile (ncb_p np, ccb_p cp)\n{\n\tint co, da, st, en, di, se, post,work,disc;\n\tu_long diff;\n\n#ifdef __OpenBSD__\n\tPROFILE.end = mono_time;\n#else\n\tgettime(&PROFILE.end);\n#endif\n\n\tst = ncr_delta (&PROFILE.start,&PROFILE.status);\n\tif (st<0) return;\t/* status  not reached  */\n\n\tda = ncr_delta (&PROFILE.start,&PROFILE.data);\n\tif (da<0) return;\t/* No data transfer phase */\n\n\tco = ncr_delta (&PROFILE.start,&PROFILE.command);\n\tif (co<0) return;\t/* command not executed */\n\n\ten = ncr_delta (&PROFILE.start,&PROFILE.end),\n\tdi = ncr_delta (&PROFILE.start,&PROFILE.disconnect),\n\tse = ncr_delta (&PROFILE.start,&PROFILE.select);\n\tpost = en - st;\n\n\t/*\n\t**\t@PROFILE@  Disconnect time invalid if multiple disconnects\n\t*/\n\n\tif (di>=0) disc = se-di; else  disc = 0;\n\n\twork = (st - co) - disc;\n\n\tdiff = (np->disc_phys - np->disc_ref) & 0xff;\n\tnp->disc_ref += diff;\n\n\tnp->profile.num_trans\t+= 1;\n\tif (cp->xfer)\n\tnp->profile.num_bytes\t+= cp->xfer->datalen;\n\tnp->profile.num_disc\t+= diff;\n\tnp->profile.ms_setup\t+= co;\n\tnp->profile.ms_data\t+= work;\n\tnp->profile.ms_disc\t+= disc;\n\tnp->profile.ms_post\t+= post;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define PROFILE  cp->phys.header.stamp"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_delta",
          "args": [
            "&PROFILE.start",
            "&PROFILE.select"
          ],
          "line": 7721
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7690-7696",
          "snippet": "static\tint ncr_delta (struct timeval * from, struct timeval * to)\n{\n\tif (!from->tv_sec) return (-1);\n\tif (!to  ->tv_sec) return (-2);\n\treturn ( (to->tv_sec  - from->tv_sec  -       2)*1000+\n\t\t+(to->tv_usec - from->tv_usec + 2000000)/1000);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic\tint ncr_delta (struct timeval * from, struct timeval * to)\n{\n\tif (!from->tv_sec) return (-1);\n\tif (!to  ->tv_sec) return (-2);\n\treturn ( (to->tv_sec  - from->tv_sec  -       2)*1000+\n\t\t+(to->tv_usec - from->tv_usec + 2000000)/1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettime",
          "args": [
            "&PROFILE.end"
          ],
          "line": 7707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define PROFILE  cp->phys.header.stamp\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\nregister volatile u_int32_t data;\n\nstatic\tvoid ncb_profile (ncb_p np, ccb_p cp)\n{\n\tint co, da, st, en, di, se, post,work,disc;\n\tu_long diff;\n\n#ifdef __OpenBSD__\n\tPROFILE.end = mono_time;\n#else\n\tgettime(&PROFILE.end);\n#endif\n\n\tst = ncr_delta (&PROFILE.start,&PROFILE.status);\n\tif (st<0) return;\t/* status  not reached  */\n\n\tda = ncr_delta (&PROFILE.start,&PROFILE.data);\n\tif (da<0) return;\t/* No data transfer phase */\n\n\tco = ncr_delta (&PROFILE.start,&PROFILE.command);\n\tif (co<0) return;\t/* command not executed */\n\n\ten = ncr_delta (&PROFILE.start,&PROFILE.end),\n\tdi = ncr_delta (&PROFILE.start,&PROFILE.disconnect),\n\tse = ncr_delta (&PROFILE.start,&PROFILE.select);\n\tpost = en - st;\n\n\t/*\n\t**\t@PROFILE@  Disconnect time invalid if multiple disconnects\n\t*/\n\n\tif (di>=0) disc = se-di; else  disc = 0;\n\n\twork = (st - co) - disc;\n\n\tdiff = (np->disc_phys - np->disc_ref) & 0xff;\n\tnp->disc_ref += diff;\n\n\tnp->profile.num_trans\t+= 1;\n\tif (cp->xfer)\n\tnp->profile.num_bytes\t+= cp->xfer->datalen;\n\tnp->profile.num_disc\t+= diff;\n\tnp->profile.ms_setup\t+= co;\n\tnp->profile.ms_data\t+= work;\n\tnp->profile.ms_disc\t+= disc;\n\tnp->profile.ms_post\t+= post;\n}"
  },
  {
    "function_name": "ncr_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7690-7696",
    "snippet": "static\tint ncr_delta (struct timeval * from, struct timeval * to)\n{\n\tif (!from->tv_sec) return (-1);\n\tif (!to  ->tv_sec) return (-2);\n\treturn ( (to->tv_sec  - from->tv_sec  -       2)*1000+\n\t\t+(to->tv_usec - from->tv_usec + 2000000)/1000);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic\tint ncr_delta (struct timeval * from, struct timeval * to)\n{\n\tif (!from->tv_sec) return (-1);\n\tif (!to  ->tv_sec) return (-2);\n\treturn ( (to->tv_sec  - from->tv_sec  -       2)*1000+\n\t\t+(to->tv_usec - from->tv_usec + 2000000)/1000);\n}"
  },
  {
    "function_name": "ncr_snooptest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7585-7675",
    "snippet": "static int ncr_snooptest (struct ncb* np)\n{\n\tvolatile u_int32_t ncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc;\n\tint\ti, err=0;\n\n#if !defined(NCR_IOMAPPED) || defined(__OpenBSD__)\n#ifdef __OpenBSD__\n\tif (!np->sc_iomapped)\n#endif\n\t{\n\t\terr |= ncr_regtest (np);\n\t\tif (err) return (err);\n\t}\n#endif\n\t/*\n\t**\tinit\n\t*/\n\tpc  = NCB_SCRIPTH_PHYS (np, snooptest);\n\thost_wr = 1;\n\tncr_wr  = 2;\n\t/*\n\t**\tSet memory and register.\n\t*/\n\tncr_cache = host_wr;\n#if defined(__mips__)\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)&ncr_cache, sizeof (ncr_cache));\n#endif /* __mips__ */\n\tOUTL (nc_temp, SCR_BO(ncr_wr));\n\t/*\n\t**\tStart script (exchange values)\n\t*/\n\tOUTL (nc_dsp, pc);\n\t/*\n\t**\tWait 'til done (with timeout)\n\t*/\n\tfor (i=0; i<NCR_SNOOP_TIMEOUT; i++)\n\t\tif (INB(nc_istat) & (INTF|SIP|DIP))\n\t\t\tbreak;\n\t/*\n\t**\tSave termination position.\n\t*/\n\tpc = INL (nc_dsp);\n\t/*\n\t**\tRead memory and register.\n\t*/\n\thost_rd = ncr_cache;\n\tncr_rd  = SCR_BO(INL (nc_scratcha));\n\tncr_bk  = SCR_BO(INL (nc_temp));\n\t/*\n\t**\tReset ncr chip\n\t*/\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat,  0   );\n\t/*\n\t**\tcheck for timeout\n\t*/\n\tif (i>=NCR_SNOOP_TIMEOUT) {\n\t\tprintf (\"CACHE TEST FAILED: timeout.\\n\");\n\t\treturn (0x20);\n\t};\n\t/*\n\t**\tCheck termination position.\n\t*/\n\tif (pc != NCB_SCRIPTH_PHYS (np, snoopend)+8) {\n\t\tprintf (\"CACHE TEST FAILED: script execution failed.\\n\");\n\t\tprintf (\"start=%08lx, pc=%08lx, end=%08lx\\n\",\n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snooptest), (u_long) pc,\n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snoopend) +8);\n\t\treturn (0x40);\n\t};\n\t/*\n\t**\tShow results.\n\t*/\n\tif (host_wr != ncr_rd) {\n\t\tprintf (\"CACHE TEST FAILED: host wrote %d, ncr read %d.\\n\",\n\t\t\t(int) host_wr, (int) ncr_rd);\n\t\terr |= 1;\n\t};\n\tif (host_rd != ncr_wr) {\n\t\tprintf (\"CACHE TEST FAILED: ncr wrote %d, host read %d.\\n\",\n\t\t\t(int) ncr_wr, (int) host_rd);\n\t\terr |= 2;\n\t};\n\tif (ncr_bk != ncr_wr) {\n\t\tprintf (\"CACHE TEST FAILED: ncr wrote %d, read back %d.\\n\",\n\t\t\t(int) ncr_wr, (int) ncr_bk);\n\t\terr |= 4;\n\t};\n\treturn (err);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define NCR_SNOOP_TIMEOUT (1000000)"
    ],
    "globals_used": [
      "static int ncr_cache;",
      "pci_chipset_tag_t pc = pa->pa_pc;",
      "ncb_p np = (void *)self;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "int\ti;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CACHE TEST FAILED: ncr wrote %d, read back %d.\\n\"",
            "(int) ncr_wr",
            "(int) ncr_bk"
          ],
          "line": 7670
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "snoopend"
          ],
          "line": 7653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "snooptest"
          ],
          "line": 7652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "snoopend"
          ],
          "line": 7649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "0"
          ],
          "line": 7638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 7637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "SRST"
          ],
          "line": 7636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "INL (nc_temp)"
          ],
          "line": 7632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_temp"
          ],
          "line": 7632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "INL (nc_scratcha)"
          ],
          "line": 7631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_scratcha"
          ],
          "line": 7631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsp"
          ],
          "line": 7626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_istat"
          ],
          "line": 7621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "pc"
          ],
          "line": 7616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_temp",
            "SCR_BO(ncr_wr)"
          ],
          "line": 7612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "ncr_wr"
          ],
          "line": 7612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "np->sc_pc",
            "(vm_offset_t)&ncr_cache",
            "sizeof (ncr_cache)"
          ],
          "line": 7610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "snooptest"
          ],
          "line": 7602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_regtest",
          "args": [
            "np"
          ],
          "line": 7595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define NCR_SNOOP_TIMEOUT (1000000)\n\nstatic int ncr_cache;\npci_chipset_tag_t pc = pa->pa_pc;\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\n\nstatic int ncr_snooptest (struct ncb* np)\n{\n\tvolatile u_int32_t ncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc;\n\tint\ti, err=0;\n\n#if !defined(NCR_IOMAPPED) || defined(__OpenBSD__)\n#ifdef __OpenBSD__\n\tif (!np->sc_iomapped)\n#endif\n\t{\n\t\terr |= ncr_regtest (np);\n\t\tif (err) return (err);\n\t}\n#endif\n\t/*\n\t**\tinit\n\t*/\n\tpc  = NCB_SCRIPTH_PHYS (np, snooptest);\n\thost_wr = 1;\n\tncr_wr  = 2;\n\t/*\n\t**\tSet memory and register.\n\t*/\n\tncr_cache = host_wr;\n#if defined(__mips__)\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)&ncr_cache, sizeof (ncr_cache));\n#endif /* __mips__ */\n\tOUTL (nc_temp, SCR_BO(ncr_wr));\n\t/*\n\t**\tStart script (exchange values)\n\t*/\n\tOUTL (nc_dsp, pc);\n\t/*\n\t**\tWait 'til done (with timeout)\n\t*/\n\tfor (i=0; i<NCR_SNOOP_TIMEOUT; i++)\n\t\tif (INB(nc_istat) & (INTF|SIP|DIP))\n\t\t\tbreak;\n\t/*\n\t**\tSave termination position.\n\t*/\n\tpc = INL (nc_dsp);\n\t/*\n\t**\tRead memory and register.\n\t*/\n\thost_rd = ncr_cache;\n\tncr_rd  = SCR_BO(INL (nc_scratcha));\n\tncr_bk  = SCR_BO(INL (nc_temp));\n\t/*\n\t**\tReset ncr chip\n\t*/\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat,  0   );\n\t/*\n\t**\tcheck for timeout\n\t*/\n\tif (i>=NCR_SNOOP_TIMEOUT) {\n\t\tprintf (\"CACHE TEST FAILED: timeout.\\n\");\n\t\treturn (0x20);\n\t};\n\t/*\n\t**\tCheck termination position.\n\t*/\n\tif (pc != NCB_SCRIPTH_PHYS (np, snoopend)+8) {\n\t\tprintf (\"CACHE TEST FAILED: script execution failed.\\n\");\n\t\tprintf (\"start=%08lx, pc=%08lx, end=%08lx\\n\",\n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snooptest), (u_long) pc,\n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snoopend) +8);\n\t\treturn (0x40);\n\t};\n\t/*\n\t**\tShow results.\n\t*/\n\tif (host_wr != ncr_rd) {\n\t\tprintf (\"CACHE TEST FAILED: host wrote %d, ncr read %d.\\n\",\n\t\t\t(int) host_wr, (int) ncr_rd);\n\t\terr |= 1;\n\t};\n\tif (host_rd != ncr_wr) {\n\t\tprintf (\"CACHE TEST FAILED: ncr wrote %d, host read %d.\\n\",\n\t\t\t(int) ncr_wr, (int) host_rd);\n\t\terr |= 2;\n\t};\n\tif (ncr_bk != ncr_wr) {\n\t\tprintf (\"CACHE TEST FAILED: ncr wrote %d, read back %d.\\n\",\n\t\t\t(int) ncr_wr, (int) ncr_bk);\n\t\terr |= 4;\n\t};\n\treturn (err);\n}"
  },
  {
    "function_name": "ncr_scatter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7445-7547",
    "snippet": "static\tint\tncr_scatter\n\t(ncb_p np, struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)\n{\n\tu_long\tpaddr, pnext;\n\n\tu_short\tsegment  = 0;\n\tu_long\tsegsize, segaddr;\n\tu_long\tsize, csize    = 0;\n\tu_long\tchunk = MAX_SIZE;\n\tint\tfree;\n\n\tbzero (&phys->data, sizeof (phys->data));\n\tif (!datalen) return (0);\n\n\tpaddr = NCR_KVATOPHYS (np, (void *)vaddr);\n\n\t/*\n\t**\tinsert extra break points at a distance of chunk.\n\t**\tWe try to reduce the number of interrupts caused\n\t**\tby unexpected phase changes due to disconnects.\n\t**\tA typical harddisk may disconnect before ANY block.\n\t**\tIf we wanted to avoid unexpected phase changes at all\n\t**\twe had to use a break point every 512 bytes.\n\t**\tOf course the number of scatter/gather blocks is\n\t**\tlimited.\n\t*/\n\n\tfree = MAX_SCATTER - 1;\n\n#ifdef __OpenBSD__\n\tif (vaddr & (NBPG-1)) free -= datalen / NBPG;\n#else\n\tif (vaddr & PAGE_MASK) free -= datalen / PAGE_SIZE;\n#endif\n\n\tif (free>1)\n\t\twhile ((chunk * free >= 2 * datalen) && (chunk>=1024))\n\t\t\tchunk /= 2;\n\n\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\tprintf(\"ncr?:\\tscattering virtual=0x%x size=%d chunk=%d.\\n\",\n\t\t\t(unsigned) vaddr, (unsigned) datalen, (unsigned) chunk);\n\n\t/*\n\t**   Build data descriptors.\n\t*/\n\twhile (datalen && (segment < MAX_SCATTER)) {\n\n\t\t/*\n\t\t**\tthis segment is empty\n\t\t*/\n\t\tsegsize = 0;\n\t\tsegaddr = paddr;\n\t\tpnext   = paddr;\n\n\t\tif (!csize) csize = chunk;\n\n\t\twhile ((datalen) && (paddr == pnext) && (csize)) {\n\n\t\t\t/*\n\t\t\t**\tcontinue this segment\n\t\t\t*/\n#ifdef __OpenBSD__\n\t\t\tpnext = (paddr & (~(NBPG - 1))) + NBPG;\n#else\n\t\t\tpnext = (paddr & (~PAGE_MASK)) + PAGE_SIZE;\n#endif\n\n\t\t\t/*\n\t\t\t**\tCompute max size\n\t\t\t*/\n\n\t\t\tsize = pnext - paddr;\t\t/* page size */\n\t\t\tif (size > datalen) size = datalen;  /* data size */\n\t\t\tif (size > csize  ) size = csize  ;  /* chunksize */\n\n\t\t\tsegsize += size;\n\t\t\tvaddr   += size;\n\t\t\tcsize   -= size;\n\t\t\tdatalen -= size;\n\t\t\tpaddr    = NCR_KVATOPHYS (np, (void *)vaddr);\n\t\t};\n\n\t\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\t\tprintf (\"\\tseg #%d  addr=%x  size=%d  (rest=%d).\\n\",\n\t\t\tsegment,\n\t\t\t(unsigned) segaddr,\n\t\t\t(unsigned) segsize,\n\t\t\t(unsigned) datalen);\n\n\t\tphys->data[segment].addr = SCR_BO(segaddr);\n\t\tphys->data[segment].size = SCR_BO(segsize);\n\t\tsegment++;\n\t}\n\n\tif (datalen) {\n\t\tprintf(\"ncr?: scatter/gather failed (residue=%d).\\n\",\n\t\t\t(unsigned) datalen);\n\t\treturn (-1);\n\t};\n\n\treturn (segment);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_SCATTER  (0x0020)",
      "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)",
      "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)",
      "#define MAX_SCATTER (33)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ncr?: scatter/gather failed (residue=%d).\\n\"",
            "(unsigned) datalen"
          ],
          "line": 7541
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "segsize"
          ],
          "line": 7536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "segaddr"
          ],
          "line": 7535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "(void *)vaddr"
          ],
          "line": 7525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "(void *)vaddr"
          ],
          "line": 7459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&phys->data",
            "sizeof (phys->data)"
          ],
          "line": 7456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_SCATTER  (0x0020)\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)\n#define MAX_SCATTER (33)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\nregister volatile u_int32_t data;\n\nstatic\tint\tncr_scatter\n\t(ncb_p np, struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)\n{\n\tu_long\tpaddr, pnext;\n\n\tu_short\tsegment  = 0;\n\tu_long\tsegsize, segaddr;\n\tu_long\tsize, csize    = 0;\n\tu_long\tchunk = MAX_SIZE;\n\tint\tfree;\n\n\tbzero (&phys->data, sizeof (phys->data));\n\tif (!datalen) return (0);\n\n\tpaddr = NCR_KVATOPHYS (np, (void *)vaddr);\n\n\t/*\n\t**\tinsert extra break points at a distance of chunk.\n\t**\tWe try to reduce the number of interrupts caused\n\t**\tby unexpected phase changes due to disconnects.\n\t**\tA typical harddisk may disconnect before ANY block.\n\t**\tIf we wanted to avoid unexpected phase changes at all\n\t**\twe had to use a break point every 512 bytes.\n\t**\tOf course the number of scatter/gather blocks is\n\t**\tlimited.\n\t*/\n\n\tfree = MAX_SCATTER - 1;\n\n#ifdef __OpenBSD__\n\tif (vaddr & (NBPG-1)) free -= datalen / NBPG;\n#else\n\tif (vaddr & PAGE_MASK) free -= datalen / PAGE_SIZE;\n#endif\n\n\tif (free>1)\n\t\twhile ((chunk * free >= 2 * datalen) && (chunk>=1024))\n\t\t\tchunk /= 2;\n\n\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\tprintf(\"ncr?:\\tscattering virtual=0x%x size=%d chunk=%d.\\n\",\n\t\t\t(unsigned) vaddr, (unsigned) datalen, (unsigned) chunk);\n\n\t/*\n\t**   Build data descriptors.\n\t*/\n\twhile (datalen && (segment < MAX_SCATTER)) {\n\n\t\t/*\n\t\t**\tthis segment is empty\n\t\t*/\n\t\tsegsize = 0;\n\t\tsegaddr = paddr;\n\t\tpnext   = paddr;\n\n\t\tif (!csize) csize = chunk;\n\n\t\twhile ((datalen) && (paddr == pnext) && (csize)) {\n\n\t\t\t/*\n\t\t\t**\tcontinue this segment\n\t\t\t*/\n#ifdef __OpenBSD__\n\t\t\tpnext = (paddr & (~(NBPG - 1))) + NBPG;\n#else\n\t\t\tpnext = (paddr & (~PAGE_MASK)) + PAGE_SIZE;\n#endif\n\n\t\t\t/*\n\t\t\t**\tCompute max size\n\t\t\t*/\n\n\t\t\tsize = pnext - paddr;\t\t/* page size */\n\t\t\tif (size > datalen) size = datalen;  /* data size */\n\t\t\tif (size > csize  ) size = csize  ;  /* chunksize */\n\n\t\t\tsegsize += size;\n\t\t\tvaddr   += size;\n\t\t\tcsize   -= size;\n\t\t\tdatalen -= size;\n\t\t\tpaddr    = NCR_KVATOPHYS (np, (void *)vaddr);\n\t\t};\n\n\t\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\t\tprintf (\"\\tseg #%d  addr=%x  size=%d  (rest=%d).\\n\",\n\t\t\tsegment,\n\t\t\t(unsigned) segaddr,\n\t\t\t(unsigned) segsize,\n\t\t\t(unsigned) datalen);\n\n\t\tphys->data[segment].addr = SCR_BO(segaddr);\n\t\tphys->data[segment].size = SCR_BO(segsize);\n\t\tsegment++;\n\t}\n\n\tif (datalen) {\n\t\tprintf(\"ncr?: scatter/gather failed (residue=%d).\\n\",\n\t\t\t(unsigned) datalen);\n\t\treturn (-1);\n\t};\n\n\treturn (segment);\n}"
  },
  {
    "function_name": "ncr_opennings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7381-7427",
    "snippet": "static void ncr_opennings (ncb_p np, lcb_p lp, struct scsi_xfer * xp)\n{\n\t/*\n\t**\twant to reduce the number ...\n\t*/\n\tif (lp->actlink > lp->reqlink) {\n\n\t\t/*\n\t\t**\tTry to  reduce the count.\n\t\t**\tWe assume to run at splbio ..\n\t\t*/\n\t\tu_char diff = lp->actlink - lp->reqlink;\n\n\t\tif (!diff) return;\n\n#ifdef __OpenBSD__\n\t\tif (diff > xp->sc_link->openings)\n\t\t\tdiff = xp->sc_link->openings;\n\n\t\txp->sc_link->openings\t-= diff;\n#else\n\t\tif (diff > xp->sc_link->opennings)\n\t\t\tdiff = xp->sc_link->opennings;\n\n\t\txp->sc_link->opennings\t-= diff;\n#endif\n\t\tlp->actlink\t\t-= diff;\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t\treturn;\n\t};\n\n\t/*\n\t**\twant to increase the number ?\n\t*/\n\tif (lp->reqlink > lp->actlink) {\n\t\tu_char diff = lp->reqlink - lp->actlink;\n\n\t\txp->sc_link->openings\t+= diff;\n\t\tlp->actlink\t\t+= diff;\n\t\twakeup ((caddr_t) xp->sc_link);\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t};\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TAGS     (0x0400)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: actlink: diff=%d, new=%d, req=%d\\n\"",
            "ncr_name(np)",
            "diff",
            "lp->actlink",
            "lp->reqlink"
          ],
          "line": 7424
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 7425
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t) xp->sc_link"
          ],
          "line": 7422
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TAGS     (0x0400)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void ncr_opennings (ncb_p np, lcb_p lp, struct scsi_xfer * xp)\n{\n\t/*\n\t**\twant to reduce the number ...\n\t*/\n\tif (lp->actlink > lp->reqlink) {\n\n\t\t/*\n\t\t**\tTry to  reduce the count.\n\t\t**\tWe assume to run at splbio ..\n\t\t*/\n\t\tu_char diff = lp->actlink - lp->reqlink;\n\n\t\tif (!diff) return;\n\n#ifdef __OpenBSD__\n\t\tif (diff > xp->sc_link->openings)\n\t\t\tdiff = xp->sc_link->openings;\n\n\t\txp->sc_link->openings\t-= diff;\n#else\n\t\tif (diff > xp->sc_link->opennings)\n\t\t\tdiff = xp->sc_link->opennings;\n\n\t\txp->sc_link->opennings\t-= diff;\n#endif\n\t\tlp->actlink\t\t-= diff;\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t\treturn;\n\t};\n\n\t/*\n\t**\twant to increase the number ?\n\t*/\n\tif (lp->reqlink > lp->actlink) {\n\t\tu_char diff = lp->reqlink - lp->actlink;\n\n\t\txp->sc_link->openings\t+= diff;\n\t\tlp->actlink\t\t+= diff;\n\t\twakeup ((caddr_t) xp->sc_link);\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t};\n}"
  },
  {
    "function_name": "ncr_alloc_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7220-7370",
    "snippet": "static\tvoid ncr_alloc_ccb (ncb_p np, u_long target, u_long lun)\n{\n\ttcb_p tp;\n\tlcb_p lp;\n\tccb_p cp;\n\n\tassert (np != NULL);\n\n\tif (target>=MAX_TARGET) return;\n\tif (lun   >=MAX_LUN   ) return;\n\n\ttp=&np->target[target];\n\n\tif (!tp->jump_tcb.l_cmd) {\n\n\t\t/*\n\t\t**\tinitialize it.\n\t\t*/\n\t\ttp->jump_tcb.l_cmd   = SCR_BO((SCR_JUMP^IFFALSE (DATA (0x80 + target))));\n\t\ttp->jump_tcb.l_paddr = np->jump_tcb.l_paddr;\n\n\t\ttp->getscr[0] =\n\t\t\t(np->features & FE_PFEN)? SCR_BO(SCR_COPY(1)) : SCR_BO(SCR_COPY_F(1));\n\t\ttp->getscr[1] = SCR_BO(NCR_KVATOPHYS (np, &tp->sval));\n\t\ttp->getscr[2] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_sxfer));\n\t\ttp->getscr[3] = tp->getscr[0];\n\t\ttp->getscr[4] = SCR_BO(NCR_KVATOPHYS (np, &tp->wval));\n\t\ttp->getscr[5] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_scntl3));\n\n\t\tassert (( (offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t\toffsetof(struct tcb    , sval    )) &3) == 0);\n\t\tassert (( (offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t\toffsetof(struct tcb    , wval    )) &3) == 0);\n\n\t\ttp->call_lun.l_cmd   = SCR_BO((SCR_CALL));\n\t\ttp->call_lun.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_lun));\n\n\t\ttp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, abort));\n\t\tnp->jump_tcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &tp->jump_tcb));\n\n\t\ttp->usrtags = SCSI_NCR_DFLT_TAGS;\n\t\tncr_setmaxtags (tp, tp->usrtags);\n\t}\n\n\t/*\n\t**\tLogic unit control block\n\t*/\n\tlp = tp->lp[lun];\n\tif (!lp) {\n\t\t/*\n\t\t**\tAllocate a lcb\n\t\t*/\n\t\tlp = (lcb_p) malloc (sizeof (struct lcb), M_DEVBUF, M_NOWAIT);\n\t\tif (!lp) return;\n\n#if defined(__mips__)\n\t\tpci_sync_cache(np->sc_pc, (vm_offset_t)lp, sizeof (struct lcb));\n\t\tlp = (struct lcb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, lp));\n#endif /* __mips__ */\n\n\t\t/*\n\t\t**\tInitialize it\n\t\t*/\n\t\tbzero (lp, sizeof (*lp));\n\t\tlp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP ^ IFFALSE (DATA (lun))));\n\t\tlp->jump_lcb.l_paddr = tp->jump_lcb.l_paddr;\n\n\t\tlp->call_tag.l_cmd   = SCR_BO((SCR_CALL));\n\t\tlp->call_tag.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tag));\n\n\t\tlp->jump_ccb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\tlp->jump_ccb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, aborttag));\n\n\t\tlp->actlink = 1;\n\n\t\t/*\n\t\t**   Chain into LUN list\n\t\t*/\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &lp->jump_lcb));\n\t\ttp->lp[lun] = lp;\n\n\t}\n\n\t/*\n\t**\tLimit possible number of ccbs.\n\t**\n\t**\tIf tagged command queueing is enabled,\n\t**\tcan use more than one ccb.\n\t*/\n\n\tif (np->actccbs >= MAX_START-2)\n\t\treturn;\n\tif (lp->actccbs && (lp->actccbs >= lp->reqccbs))\n\t\treturn;\n\n\t/*\n\t**\tAllocate a ccb\n\t*/\n\tcp = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_NOWAIT);\n\n\tif (!cp)\n\t\treturn;\n\n#if defined(__mips__)\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)cp, sizeof (struct ccb));\n\tcp = (struct ccb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, cp));\n#endif /* __mips__ */\n\n\tif (DEBUG_FLAGS & DEBUG_ALLOC) {\n\t\tprintf (\"new ccb @%p.\\n\", cp);\n\t}\n\n\t/*\n\t**\tCount it\n\t*/\n\tlp->actccbs++;\n\tnp->actccbs++;\n\n\t/*\n\t**\tInitialize it\n\t*/\n\tbzero (cp, sizeof (*cp));\n\n\t/*\n\t**\tFill in physical addresses\n\t*/\n\n\tcp->p_ccb\t     = NCR_KVATOPHYS (np, cp);\n\n\t/*\n\t**\tChain into reselect list\n\t*/\n\tcp->jump_ccb.l_cmd   = SCR_BO(SCR_JUMP);\n\tcp->jump_ccb.l_paddr = lp->jump_ccb.l_paddr;\n\tlp->jump_ccb.l_paddr = SCR_BO(CCB_PHYS (cp, jump_ccb));\n\tcp->call_tmp.l_cmd   = SCR_BO(SCR_CALL);\n\tcp->call_tmp.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tmp));\n\n\t/*\n\t**\tChain into wakeup list\n\t*/\n\tcp->link_ccb      = np->ccb->link_ccb;\n\tnp->ccb->link_ccb  = cp;\n\n\t/*\n\t**\tChain into CCB list\n\t*/\n\tcp->next_ccb\t= lp->next_ccb;\n\tlp->next_ccb\t= cp;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_ALLOC    (0x0001)",
      "#define MAX_START   (256)",
      "#define MAX_LUN     (8)",
      "#define MAX_TARGET  (16)",
      "#define SCSI_NCR_DFLT_TAGS    (4)",
      "#define\tSCSI_NCR_DFLT_TAGS (0)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, resel_tmp)"
          ],
          "line": 7357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "resel_tmp"
          ],
          "line": 7357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "SCR_CALL"
          ],
          "line": 7356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "CCB_PHYS (cp, jump_ccb)"
          ],
          "line": 7355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "jump_ccb"
          ],
          "line": 7355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "SCR_JUMP"
          ],
          "line": 7353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "cp"
          ],
          "line": 7348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cp",
            "sizeof (*cp)"
          ],
          "line": 7342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"new ccb @%p.\\n\"",
            "cp"
          ],
          "line": 7330
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHYS_TO_UNCACHED",
          "args": [
            "NCR_KVATOPHYS(np, cp)"
          ],
          "line": 7326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "cp"
          ],
          "line": 7326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "np->sc_pc",
            "(vm_offset_t)cp",
            "sizeof (struct ccb)"
          ],
          "line": 7325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct ccb)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 7319
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, &lp->jump_lcb)"
          ],
          "line": 7299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&lp->jump_lcb"
          ],
          "line": 7299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPTH_PHYS (np, aborttag)"
          ],
          "line": 7292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "aborttag"
          ],
          "line": 7292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_JUMP)"
          ],
          "line": 7291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, resel_tag)"
          ],
          "line": 7289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "resel_tag"
          ],
          "line": 7289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_CALL)"
          ],
          "line": 7288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_JUMP ^ IFFALSE (DATA (lun)))"
          ],
          "line": 7285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "DATA (lun)"
          ],
          "line": 7285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATA",
          "args": [
            "lun"
          ],
          "line": 7285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof (*lp)"
          ],
          "line": 7284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_TO_UNCACHED",
          "args": [
            "NCR_KVATOPHYS(np, lp)"
          ],
          "line": 7278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "lp"
          ],
          "line": 7278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "np->sc_pc",
            "(vm_offset_t)lp",
            "sizeof (struct lcb)"
          ],
          "line": 7277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_setmaxtags",
          "args": [
            "tp",
            "tp->usrtags"
          ],
          "line": 7262
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, &tp->jump_tcb)"
          ],
          "line": 7259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&tp->jump_tcb"
          ],
          "line": 7259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPTH_PHYS (np, abort)"
          ],
          "line": 7258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "abort"
          ],
          "line": 7258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_JUMP)"
          ],
          "line": 7257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, resel_lun)"
          ],
          "line": 7255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "resel_lun"
          ],
          "line": 7255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_CALL)"
          ],
          "line": 7254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "( (offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t\toffsetof(struct tcb    , wval    )) &3) == 0"
          ],
          "line": 7251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "( (offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t\toffsetof(struct tcb    , sval    )) &3) == 0"
          ],
          "line": 7249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "np->paddr + offsetof (struct ncr_reg, nc_scntl3)"
          ],
          "line": 7247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, &tp->wval)"
          ],
          "line": 7246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&tp->wval"
          ],
          "line": 7246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "np->paddr + offsetof (struct ncr_reg, nc_sxfer)"
          ],
          "line": 7244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, &tp->sval)"
          ],
          "line": 7243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&tp->sval"
          ],
          "line": 7243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "SCR_COPY_F(1)"
          ],
          "line": 7242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_COPY_F",
          "args": [
            "1"
          ],
          "line": 7242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "SCR_COPY(1)"
          ],
          "line": 7242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_COPY",
          "args": [
            "1"
          ],
          "line": 7242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_JUMP^IFFALSE (DATA (0x80 + target)))"
          ],
          "line": 7238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "DATA (0x80 + target)"
          ],
          "line": 7238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATA",
          "args": [
            "0x80 + target"
          ],
          "line": 7238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "np != NULL"
          ],
          "line": 7226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_ALLOC    (0x0001)\n#define MAX_START   (256)\n#define MAX_LUN     (8)\n#define MAX_TARGET  (16)\n#define SCSI_NCR_DFLT_TAGS    (4)\n#define\tSCSI_NCR_DFLT_TAGS (0)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic\tvoid ncr_alloc_ccb (ncb_p np, u_long target, u_long lun)\n{\n\ttcb_p tp;\n\tlcb_p lp;\n\tccb_p cp;\n\n\tassert (np != NULL);\n\n\tif (target>=MAX_TARGET) return;\n\tif (lun   >=MAX_LUN   ) return;\n\n\ttp=&np->target[target];\n\n\tif (!tp->jump_tcb.l_cmd) {\n\n\t\t/*\n\t\t**\tinitialize it.\n\t\t*/\n\t\ttp->jump_tcb.l_cmd   = SCR_BO((SCR_JUMP^IFFALSE (DATA (0x80 + target))));\n\t\ttp->jump_tcb.l_paddr = np->jump_tcb.l_paddr;\n\n\t\ttp->getscr[0] =\n\t\t\t(np->features & FE_PFEN)? SCR_BO(SCR_COPY(1)) : SCR_BO(SCR_COPY_F(1));\n\t\ttp->getscr[1] = SCR_BO(NCR_KVATOPHYS (np, &tp->sval));\n\t\ttp->getscr[2] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_sxfer));\n\t\ttp->getscr[3] = tp->getscr[0];\n\t\ttp->getscr[4] = SCR_BO(NCR_KVATOPHYS (np, &tp->wval));\n\t\ttp->getscr[5] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_scntl3));\n\n\t\tassert (( (offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t\toffsetof(struct tcb    , sval    )) &3) == 0);\n\t\tassert (( (offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t\toffsetof(struct tcb    , wval    )) &3) == 0);\n\n\t\ttp->call_lun.l_cmd   = SCR_BO((SCR_CALL));\n\t\ttp->call_lun.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_lun));\n\n\t\ttp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, abort));\n\t\tnp->jump_tcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &tp->jump_tcb));\n\n\t\ttp->usrtags = SCSI_NCR_DFLT_TAGS;\n\t\tncr_setmaxtags (tp, tp->usrtags);\n\t}\n\n\t/*\n\t**\tLogic unit control block\n\t*/\n\tlp = tp->lp[lun];\n\tif (!lp) {\n\t\t/*\n\t\t**\tAllocate a lcb\n\t\t*/\n\t\tlp = (lcb_p) malloc (sizeof (struct lcb), M_DEVBUF, M_NOWAIT);\n\t\tif (!lp) return;\n\n#if defined(__mips__)\n\t\tpci_sync_cache(np->sc_pc, (vm_offset_t)lp, sizeof (struct lcb));\n\t\tlp = (struct lcb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, lp));\n#endif /* __mips__ */\n\n\t\t/*\n\t\t**\tInitialize it\n\t\t*/\n\t\tbzero (lp, sizeof (*lp));\n\t\tlp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP ^ IFFALSE (DATA (lun))));\n\t\tlp->jump_lcb.l_paddr = tp->jump_lcb.l_paddr;\n\n\t\tlp->call_tag.l_cmd   = SCR_BO((SCR_CALL));\n\t\tlp->call_tag.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tag));\n\n\t\tlp->jump_ccb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\tlp->jump_ccb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, aborttag));\n\n\t\tlp->actlink = 1;\n\n\t\t/*\n\t\t**   Chain into LUN list\n\t\t*/\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &lp->jump_lcb));\n\t\ttp->lp[lun] = lp;\n\n\t}\n\n\t/*\n\t**\tLimit possible number of ccbs.\n\t**\n\t**\tIf tagged command queueing is enabled,\n\t**\tcan use more than one ccb.\n\t*/\n\n\tif (np->actccbs >= MAX_START-2)\n\t\treturn;\n\tif (lp->actccbs && (lp->actccbs >= lp->reqccbs))\n\t\treturn;\n\n\t/*\n\t**\tAllocate a ccb\n\t*/\n\tcp = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_NOWAIT);\n\n\tif (!cp)\n\t\treturn;\n\n#if defined(__mips__)\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)cp, sizeof (struct ccb));\n\tcp = (struct ccb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, cp));\n#endif /* __mips__ */\n\n\tif (DEBUG_FLAGS & DEBUG_ALLOC) {\n\t\tprintf (\"new ccb @%p.\\n\", cp);\n\t}\n\n\t/*\n\t**\tCount it\n\t*/\n\tlp->actccbs++;\n\tnp->actccbs++;\n\n\t/*\n\t**\tInitialize it\n\t*/\n\tbzero (cp, sizeof (*cp));\n\n\t/*\n\t**\tFill in physical addresses\n\t*/\n\n\tcp->p_ccb\t     = NCR_KVATOPHYS (np, cp);\n\n\t/*\n\t**\tChain into reselect list\n\t*/\n\tcp->jump_ccb.l_cmd   = SCR_BO(SCR_JUMP);\n\tcp->jump_ccb.l_paddr = lp->jump_ccb.l_paddr;\n\tlp->jump_ccb.l_paddr = SCR_BO(CCB_PHYS (cp, jump_ccb));\n\tcp->call_tmp.l_cmd   = SCR_BO(SCR_CALL);\n\tcp->call_tmp.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tmp));\n\n\t/*\n\t**\tChain into wakeup list\n\t*/\n\tcp->link_ccb      = np->ccb->link_ccb;\n\tnp->ccb->link_ccb  = cp;\n\n\t/*\n\t**\tChain into CCB list\n\t*/\n\tcp->next_ccb\t= lp->next_ccb;\n\tlp->next_ccb\t= cp;\n}"
  },
  {
    "function_name": "ncr_free_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7197-7209",
    "snippet": "void ncr_free_ccb (ncb_p np, ccb_p cp, int flags)\n{\n\t/*\n\t**    sanity\n\t*/\n\n\tassert (cp != NULL);\n\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  host_status   phys.header.status[1]",
      "#define HS_IDLE\t\t(0)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t) cp"
          ],
          "line": 7208
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cp != NULL"
          ],
          "line": 7203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  host_status   phys.header.status[1]\n#define HS_IDLE\t\t(0)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nvoid ncr_free_ccb (ncb_p np, ccb_p cp, int flags)\n{\n\t/*\n\t**    sanity\n\t*/\n\n\tassert (cp != NULL);\n\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n}"
  },
  {
    "function_name": "ncr_get_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "7137-7186",
    "snippet": "static\tccb_p ncr_get_ccb\n\t(ncb_p np, u_long flags, u_long target, u_long lun)\n{\n\tlcb_p lp;\n\tccb_p cp = (ccb_p) 0;\n\tint oldspl;\n\n\toldspl = splbio();\n\t/*\n\t**\tLun structure available ?\n\t*/\n\n\tlp = np->target[target].lp[lun];\n\tif (lp) {\n\t\tcp = lp->next_ccb;\n\n\t\t/*\n\t\t**\tLook for free CCB\n\t\t*/\n\n\t\twhile (cp && cp->magic) {\n\t\t\tcp = cp->next_ccb;\n\t\t}\n\t}\n\n\t/*\n\t**\tif nothing available, take the default.\n\t*/\n\n\tif (!cp) cp = np->ccb;\n\n\t/*\n\t**\tWait until available.\n\t*/\n\n\twhile (cp->magic) {\n\t\tif (flags & SCSI_NOSLEEP) break;\n\t\tif (tsleep ((caddr_t)cp, PRIBIO|PCATCH, \"ncr\", 0))\n\t\t\tbreak;\n\t};\n\n\tif (cp->magic) {\n\t\tsplx(oldspl);\n\t\treturn ((ccb_p) 0);\n\t}\n\n\tcp->magic = 1;\n\tsplx(oldspl);\n\treturn (cp);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 7184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 7179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)cp",
            "PRIBIO|PCATCH",
            "\"ncr\"",
            "0"
          ],
          "line": 7174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 7144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic\tccb_p ncr_get_ccb\n\t(ncb_p np, u_long flags, u_long target, u_long lun)\n{\n\tlcb_p lp;\n\tccb_p cp = (ccb_p) 0;\n\tint oldspl;\n\n\toldspl = splbio();\n\t/*\n\t**\tLun structure available ?\n\t*/\n\n\tlp = np->target[target].lp[lun];\n\tif (lp) {\n\t\tcp = lp->next_ccb;\n\n\t\t/*\n\t\t**\tLook for free CCB\n\t\t*/\n\n\t\twhile (cp && cp->magic) {\n\t\t\tcp = cp->next_ccb;\n\t\t}\n\t}\n\n\t/*\n\t**\tif nothing available, take the default.\n\t*/\n\n\tif (!cp) cp = np->ccb;\n\n\t/*\n\t**\tWait until available.\n\t*/\n\n\twhile (cp->magic) {\n\t\tif (flags & SCSI_NOSLEEP) break;\n\t\tif (tsleep ((caddr_t)cp, PRIBIO|PCATCH, \"ncr\", 0))\n\t\t\tbreak;\n\t};\n\n\tif (cp->magic) {\n\t\tsplx(oldspl);\n\t\treturn ((ccb_p) 0);\n\t}\n\n\tcp->magic = 1;\n\tsplx(oldspl);\n\treturn (cp);\n}"
  },
  {
    "function_name": "ncr_int_sir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "6542-7126",
    "snippet": "void ncr_int_sir (ncb_p np)\n{\n\tu_char scntl3;\n\tu_char chg, ofs, per, fak, wide;\n\tu_char num = INB (nc_dsps);\n\tccb_p\tcp=0;\n\tu_long\tdsa;\n\tu_char\ttarget = INB (nc_sdid) & 0x0f;\n\ttcb_p\ttp     = &np->target[target];\n\tint     i;\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"I#%d\", num);\n\n\tswitch (num) {\n\tcase SIR_SENSE_RESTART:\n\tcase SIR_STALL_RESTART:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t**\tlookup the ccb\n\t\t*/\n\t\tdsa = INL (nc_dsa);\n\t\tcp = np->ccb;\n\t\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\t\tcp = cp->link_ccb;\n\n\t\tassert (cp);\n\t\tif (!cp)\n\t\t\tgoto out;\n\t\tassert (cp == np->header.cp);\n\t\tif (cp != np->header.cp)\n\t\t\tgoto out;\n\t}\n\n\tswitch (num) {\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of interrupted getcc selects\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_SENSE_RESTART:\n\t\t/*------------------------------------------\n\t\t**\tScript processor is idle.\n\t\t**\tLook for interrupted \"check cond\"\n\t\t**------------------------------------------\n\t\t*/\n\n\t\tif (DEBUG_FLAGS & DEBUG_RESTART)\n\t\t\tprintf (\"%s: int#%d\",ncr_name (np),num);\n\t\tcp = (ccb_p) 0;\n\t\tfor (i=0; i<MAX_TARGET; i++) {\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\" t%d\", i);\n\t\t\ttp = &np->target[i];\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\"+\");\n\t\t\tcp = tp->hold_cp;\n\t\t\tif (!cp) continue;\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\"+\");\n\t\t\tif ((cp->host_status==HS_BUSY) &&\n\t\t\t\t(cp->scsi_status==S_CHECK_COND))\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\"- (remove)\");\n\t\t\ttp->hold_cp = cp = (ccb_p) 0;\n\t\t};\n\n\t\tif (cp) {\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART)\n\t\t\t\tprintf (\"+ restart job ..\\n\");\n\t\t\tOUTL (nc_dsa, CCB_PHYS (cp, phys));\n\t\t\tOUTL (nc_dsp, NCB_SCRIPTH_PHYS (np, getcc));\n\t\t\treturn;\n\t\t};\n\n\t\t/*\n\t\t**\tno job, resume normal processing\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\" -- remove trap\\n\");\n\t\tWRITESCRIPT(start0[0], SCR_INT ^ IFFALSE (0));\n\t\tbreak;\n\n\tcase SIR_SENSE_FAILED:\n\t\t/*-------------------------------------------\n\t\t**\tWhile trying to select for\n\t\t**\tgetting the condition code,\n\t\t**\ta target reselected us.\n\t\t**-------------------------------------------\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_RESTART) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"in getcc reselect by t%d.\\n\",\n\t\t\t\tINB(nc_ssid) & 0x0f);\n\t\t}\n\n\t\t/*\n\t\t**\tMark this job\n\t\t*/\n\t\tcp->host_status = HS_BUSY;\n\t\tcp->scsi_status = S_CHECK_COND;\n\t\tnp->target[cp->xfer->sc_link->target].hold_cp = cp;\n\n\t\t/*\n\t\t**\tAnd patch code to restart it.\n\t\t*/\n\t\tWRITESCRIPT(start0[0], SCR_INT);\n\t\tbreak;\n\n/*-----------------------------------------------------------------------------\n**\n**\tWas Sie schon immer ueber transfermode negotiation wissen wollten ...\n**\n**\tWe try to negotiate sync and wide transfer only after\n**\ta successfull inquire command. We look at byte 7 of the\n**\tinquire data to determine the capabilities if the target.\n**\n**\tWhen we try to negotiate, we append the negotiation message\n**\tto the identify and (maybe) simple tag message.\n**\tThe host status field is set to HS_NEGOTIATE to mark this\n**\tsituation.\n**\n**\tIf the target doesn't answer this message immidiately\n**\t(as required by the standard), the SIR_NEGO_FAIL interrupt\n**\twill be raised eventually.\n**\tThe handler removes the HS_NEGOTIATE status, and sets the\n**\tnegotiated value to the default (async / nowide).\n**\n**\tIf we receive a matching answer immediately, we check it\n**\tfor validity, and set the values.\n**\n**\tIf we receive a Reject message immediately, we assume the\n**\tnegotiation has failed, and fall back to standard values.\n**\n**\tIf we receive a negotiation message while not in HS_NEGOTIATE\n**\tstate, it's a target initiated negotiation. We prepare a\n**\t(hopefully) valid answer, set our parameters, and send back\n**\tthis answer to the target.\n**\n**\tIf the target doesn't fetch the answer (no message out phase),\n**\twe assume the negotiation has failed, and fall back to default\n**\tsettings.\n**\n**\tWhen we set the values, we adjust them in all ccbs belonging\n**\tto this target, in the controller's register, and in the \"phys\"\n**\tfield of the controller's struct ncb.\n**\n**\tPossible cases:\t\t   hs  sir   msg_in value  send   goto\n**\tWe try try to negotiate:\n**\t-> target doesnt't msgin   NEG FAIL  noop   defa.  -      dispatch\n**\t-> target rejected our msg NEG FAIL  reject defa.  -      dispatch\n**\t-> target answered  (ok)   NEG SYNC  sdtr   set    -      clrack\n**\t-> target answered (!ok)   NEG SYNC  sdtr   defa.  REJ--->msg_bad\n**\t-> target answered  (ok)   NEG WIDE  wdtr   set    -      clrack\n**\t-> target answered (!ok)   NEG WIDE  wdtr   defa.  REJ--->msg_bad\n**\t-> any other msgin\t   NEG FAIL  noop   defa.  -      dispatch\n**\n**\tTarget tries to negotiate:\n**\t-> incoming message\t   --- SYNC  sdtr   set    SDTR   -\n**\t-> incoming message\t   --- WIDE  wdtr   set    WDTR   -\n**      We sent our answer:\n**\t-> target doesn't msgout   --- PROTO ?      defa.  -      dispatch\n**\n**-----------------------------------------------------------------------------\n*/\n\n\tcase SIR_NEGO_FAILED:\n\t\t/*-------------------------------------------------------\n\t\t**\n\t\t**\tNegotiation failed.\n\t\t**\tTarget doesn't send an answer message,\n\t\t**\tor target rejected our message.\n\t\t**\n\t\t**      Remove negotiation request.\n\t\t**\n\t\t**-------------------------------------------------------\n\t\t*/\n\t\tOUTB (HS_PRT, HS_BUSY);\n\n\t\t/* fall through */\n\n\tcase SIR_NEGO_PROTO:\n\t\t/*-------------------------------------------------------\n\t\t**\n\t\t**\tNegotiation failed.\n\t\t**\tTarget doesn't fetch the answer message.\n\t\t**\n\t\t**-------------------------------------------------------\n\t\t*/\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"negotiation failed sir=%x status=%x.\\n\",\n\t\t\t\tnum, cp->nego_status);\n\t\t};\n\n\t\t/*\n\t\t**\tany error in negotiation:\n\t\t**\tfall back to default mode.\n\t\t*/\n\t\tswitch (cp->nego_status) {\n\n\t\tcase NS_SYNC:\n\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\tbreak;\n\n\t\tcase NS_WIDE:\n\t\t\tncr_setwide (np, cp, 0, 0);\n\t\t\tbreak;\n\n\t\t};\n\t\tnp->msgin [0] = M_NOOP;\n\t\tnp->msgout[0] = M_NOOP;\n\t\tcp->nego_status = 0;\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, dispatch));\n\t\tbreak;\n\n\tcase SIR_NEGO_SYNC:\n\t\t/*\n\t\t**\tSynchronous request message received.\n\t\t*/\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync msgin: \");\n\t\t\t(void) ncr_show_msg (np->msgin);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t\t/*\n\t\t**\tget requested values.\n\t\t*/\n\n\t\tchg = 0;\n\t\tper = np->msgin[3];\n\t\tofs = np->msgin[4];\n\t\tif (ofs==0) per=255;\n\n\t\t/*\n\t\t**      if target sends SDTR message,\n\t\t**\t      it CAN transfer synch.\n\t\t*/\n\n\t\tif (ofs)\n\t\t\ttp->inqdata[7] |= INQ7_SYNC;\n\n\t\t/*\n\t\t**\tcheck values against driver limits.\n\t\t*/\n\n\t\tif (per < np->minsync)\n\t\t\t{chg = 1; per = np->minsync;}\n\t\tif (per < tp->minsync)\n\t\t\t{chg = 1; per = tp->minsync;}\n\t\tif (ofs > tp->maxoffs)\n\t\t\t{chg = 1; ofs = tp->maxoffs;}\n\n\t\t/*\n\t\t**\tCheck against controller limits.\n\t\t*/\n\n\t\tfak\t= 7;\n\t\tscntl3\t= 0;\n\t\tif (ofs != 0) {\n\t\t\tncr_getsync(np, per, &fak, &scntl3);\n\t\t\tif (fak > 7) {\n\t\t\t\tchg = 1;\n\t\t\t\tofs = 0;\n\t\t\t}\n\t\t}\n\t\tif (ofs == 0) {\n\t\t\tfak\t= 7;\n\t\t\tper\t= 0;\n\t\t\tscntl3\t= 0;\n\t\t\ttp->minsync = 0;\n\t\t}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync: per=%d scntl3=0x%x ofs=%d fak=%d chg=%d.\\n\",\n\t\t\t\tper, scntl3, ofs, fak, chg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_SYNC:\n\t\t\t\t/*\n\t\t\t\t**      This was an answer message\n\t\t\t\t*/\n\t\t\t\tif (chg) {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer wasn't acceptable.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer is ok.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setsync (np,cp,scntl3,(fak<<5)|ofs);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t};\n\t\t\t\treturn;\n\n\t\t\tcase NS_WIDE:\n\t\t\t\tncr_setwide (np, cp, 0, 0);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t**\tIt was a request. Set value and\n\t\t**      prepare an answer message\n\t\t*/\n\n\t\tncr_setsync (np, cp, scntl3, (fak<<5)|ofs);\n\n\t\tnp->msgout[0] = M_EXTENDED;\n\t\tnp->msgout[1] = 3;\n\t\tnp->msgout[2] = M_X_SYNC_REQ;\n\t\tnp->msgout[3] = per;\n\t\tnp->msgout[4] = ofs;\n\n\t\tcp->nego_status = NS_SYNC;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync msgout: \");\n\t\t\t(void) ncr_show_msg (np->msgout);\n\t\t\tprintf (\".\\n\");\n\t\t}\n\n\t\tif (!ofs) {\n\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\treturn;\n\t\t}\n\t\tnp->msgin [0] = M_NOOP;\n\n\t\tbreak;\n\n\tcase SIR_NEGO_WIDE:\n\t\t/*\n\t\t**\tWide request message received.\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide msgin: \");\n\t\t\t(void) ncr_show_msg (np->msgin);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t\t/*\n\t\t**\tget requested values.\n\t\t*/\n\n\t\tchg  = 0;\n\t\twide = np->msgin[3];\n\n\t\t/*\n\t\t**      if target sends WDTR message,\n\t\t**\t      it CAN transfer wide.\n\t\t*/\n\n\t\tif (wide)\n\t\t\ttp->inqdata[7] |= INQ7_WIDE16;\n\n\t\t/*\n\t\t**\tcheck values against driver limits.\n\t\t*/\n\n\t\tif (wide > tp->usrwide)\n\t\t\t{chg = 1; wide = tp->usrwide;}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide: wide=%d chg=%d.\\n\", wide, chg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_WIDE:\n\t\t\t\t/*\n\t\t\t\t**      This was an answer message\n\t\t\t\t*/\n\t\t\t\tif (chg) {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer wasn't acceptable.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setwide (np, cp, 0, 1);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer is ok.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setwide (np, cp, wide, 1);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t};\n\t\t\t\treturn;\n\n\t\t\tcase NS_SYNC:\n\t\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t**\tIt was a request, set value and\n\t\t**      prepare an answer message\n\t\t*/\n\n\t\tncr_setwide (np, cp, wide, 1);\n\n\t\tnp->msgout[0] = M_EXTENDED;\n\t\tnp->msgout[1] = 2;\n\t\tnp->msgout[2] = M_X_WIDE_REQ;\n\t\tnp->msgout[3] = wide;\n\n\t\tnp->msgin [0] = M_NOOP;\n\n\t\tcp->nego_status = NS_WIDE;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide msgout: \");\n\t\t\t(void) ncr_show_msg (np->msgout);\n\t\t\tprintf (\".\\n\");\n\t\t}\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of special messages\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_REJECT_RECEIVED:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received a M_REJECT message.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_REJECT received (%x:%x).\\n\",\n\t\t\t(unsigned)np->lastmsg, np->msgout[0]);\n\t\tbreak;\n\n\tcase SIR_REJECT_SENT:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an unknown message\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_REJECT sent for \");\n\t\t(void) ncr_show_msg (np->msgin);\n\t\tprintf (\".\\n\");\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of special messages\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_IGN_RESIDUE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an IGNORE RESIDUE message,\n\t\t**\twhich couldn't be handled by the script.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_IGN_RESIDUE received, but not yet implemented.\\n\");\n\t\tbreak;\n\n\tcase SIR_MISSING_SAVE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an DISCONNECT message,\n\t\t**\tbut the datapointer wasn't saved before.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_DISCONNECT received, but datapointer not saved:\\n\"\n\t\t\t\"\\tdata=%x save=%x goal=%x.\\n\",\n\t\t\t(unsigned) INL (nc_temp),\n\t\t\tSCR_BO((unsigned) np->header.savep),\n\t\t\tSCR_BO((unsigned) np->header.goalp));\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of a \"S_QUEUE_FULL\" status.\n**\n**\tThe current command has been rejected,\n**\tbecause there are too many in the command queue.\n**\tWe have started too many commands for that target.\n**\n**\tIf possible, reinsert at head of queue.\n**\tStall queue until there are no disconnected jobs\n**\t(ncr is REALLY idle). Then restart processing.\n**\n**\tWe should restart the current job after the controller\n**\thas become idle. But this is not yet implemented.\n**\n**--------------------------------------------------------------------\n*/\n\tcase SIR_STALL_QUEUE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tStall the start queue.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"queue full.\\n\");\n\n\t\tWRITESCRIPT(start1[0], SCR_INT);\n\n\t\t/*\n\t\t**\tTry to disable tagged transfers.\n\t\t*/\n\t\tncr_setmaxtags (&np->target[target], 0);\n\n\t\t/*\n\t\t** @QUEUE@\n\t\t**\n\t\t**\tShould update the launch field of the\n\t\t**\tcurrent job to be able to restart it.\n\t\t**\tThen prepend it to the start queue.\n\t\t*/\n\n\t\t/* fall through */\n\n\tcase SIR_STALL_RESTART:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tEnable selecting again,\n\t\t**\tif NO disconnected jobs.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\t\t/*\n\t\t**\tLook for a disconnected job.\n\t\t*/\n\t\tcp = np->ccb;\n\t\twhile (cp && cp->host_status != HS_DISCONNECT)\n\t\t\tcp = cp->link_ccb;\n\n\t\t/*\n\t\t**\tif there is one, ...\n\t\t*/\n\t\tif (cp) {\n\t\t\t/*\n\t\t\t**\twait for reselection\n\t\t\t*/\n\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, reselect));\n\t\t\treturn;\n\t\t};\n\n\t\t/*\n\t\t**\telse remove the interrupt.\n\t\t*/\n\n\t\tprintf (\"%s: queue empty.\\n\", ncr_name (np));\n\t\tWRITESCRIPT(start1[0], SCR_INT ^ IFFALSE (0));\n\t\tbreak;\n\t};\n\nout:\n\tOUTB (nc_dcntl, np->rv_dcntl | STD);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  nego_status   phys.nego_st",
      "#define  scsi_status   phys.header.status[2]",
      "#define  host_status   phys.header.status[1]",
      "#define  HS_PRT\tnc_scr1",
      "#define\tINQ7_WIDE16\t(0x20)",
      "#define\tINQ7_SYNC\t(0x10)",
      "#define NS_WIDE\t\t(2)",
      "#define NS_SYNC\t\t(1)",
      "#define\tSIR_MISSING_SAVE\t(12)",
      "#define\tSIR_IGN_RESIDUE\t\t(11)",
      "#define\tSIR_REJECT_SENT\t\t(10)",
      "#define\tSIR_REJECT_RECEIVED\t(9)",
      "#define\tSIR_NEGO_PROTO\t\t(8)",
      "#define\tSIR_NEGO_FAILED\t\t(7)",
      "#define\tSIR_NEGO_WIDE\t\t(6)",
      "#define\tSIR_NEGO_SYNC\t\t(5)",
      "#define\tSIR_STALL_QUEUE\t\t(4)",
      "#define\tSIR_STALL_RESTART\t(3)",
      "#define\tSIR_SENSE_FAILED\t(2)",
      "#define\tSIR_SENSE_RESTART\t(1)",
      "#define HS_DISCONNECT\t(3)\t/* Disconnected by target */",
      "#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/",
      "#define HS_BUSY\t\t(1)",
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_RESTART  (0x1000)",
      "#define DEBUG_NEGO     (0x0200)",
      "#define DEBUG_TINY     (0x0080)",
      "#define MAX_TARGET  (16)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "int\ti;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_dcntl",
            "np->rv_dcntl | STD"
          ],
          "line": 7125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT",
          "args": [
            "start1[0]",
            "SCR_INT ^ IFFALSE (0)"
          ],
          "line": 7120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "0"
          ],
          "line": 7120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: queue empty.\\n\"",
            "ncr_name (np)"
          ],
          "line": 7119
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 7119
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, reselect)"
          ],
          "line": 7111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "reselect"
          ],
          "line": 7111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_setmaxtags",
          "args": [
            "&np->target[target]",
            "0"
          ],
          "line": 7077
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT",
          "args": [
            "start1[0]",
            "SCR_INT"
          ],
          "line": 7072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 7069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(unsigned) np->header.goalp"
          ],
          "line": 7042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(unsigned) np->header.savep"
          ],
          "line": 7041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_temp"
          ],
          "line": 7040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 7037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 7024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_show_msg",
          "args": [
            "np->msgin"
          ],
          "line": 7004
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_show_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "6525-6540",
          "snippet": "static int ncr_show_msg (u_char * msg)\n{\n\tu_char i;\n\tprintf (\"%x\",*msg);\n\tif (*msg==M_EXTENDED) {\n\t\tfor (i=1;i<8;i++) {\n\t\t\tif (i-1>msg[1]) break;\n\t\t\tprintf (\"-%x\",msg[i]);\n\t\t};\n\t\treturn (i+1);\n\t} else if ((*msg & 0xf0) == 0x20) {\n\t\tprintf (\"-%x\",msg[1]);\n\t\treturn (2);\n\t};\n\treturn (1);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti;",
            "int\ti;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nint\ti;\nint\ti;\n\nstatic int ncr_show_msg (u_char * msg)\n{\n\tu_char i;\n\tprintf (\"%x\",*msg);\n\tif (*msg==M_EXTENDED) {\n\t\tfor (i=1;i<8;i++) {\n\t\t\tif (i-1>msg[1]) break;\n\t\t\tprintf (\"-%x\",msg[i]);\n\t\t};\n\t\treturn (i+1);\n\t} else if ((*msg & 0xf0) == 0x20) {\n\t\tprintf (\"-%x\",msg[1]);\n\t\treturn (2);\n\t};\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 7002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_setwide",
          "args": [
            "np",
            "cp",
            "wide",
            "1"
          ],
          "line": 6955
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setwide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5556-5611",
          "snippet": "static void ncr_setwide (ncb_p np, ccb_p cp, u_char wide, u_char ack)\n{\n\tstruct scsi_xfer *xp;\n\tu_short target = INB (nc_sdid) & 0x0f;\n\ttcb_p tp;\n\tu_char\tscntl3;\n\tu_char\tsxfer;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\ttp->widedone  =  wide+1;\n\tscntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);\n\n\tsxfer = ack ? 0 : tp->sval;\n\n\t/*\n\t**\t Stop there if sync/wide parameters are unchanged\n\t*/\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (scntl3 & EWS)\n\t\tprintf (\"WIDE SCSI (16 bit) enabled\\n\");\n\telse\n\t\tprintf (\"WIDE SCSI disabled\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  wide_status   phys.wide_st",
            "#define  sync_status   phys.sync_st",
            "#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */",
            "#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  wide_status   phys.wide_st\n#define  sync_status   phys.sync_st\n#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */\n#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void ncr_setwide (ncb_p np, ccb_p cp, u_char wide, u_char ack)\n{\n\tstruct scsi_xfer *xp;\n\tu_short target = INB (nc_sdid) & 0x0f;\n\ttcb_p tp;\n\tu_char\tscntl3;\n\tu_char\tsxfer;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\ttp->widedone  =  wide+1;\n\tscntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);\n\n\tsxfer = ack ? 0 : tp->sval;\n\n\t/*\n\t**\t Stop there if sync/wide parameters are unchanged\n\t*/\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (scntl3 & EWS)\n\t\tprintf (\"WIDE SCSI (16 bit) enabled\\n\");\n\telse\n\t\tprintf (\"WIDE SCSI disabled\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_setsync",
          "args": [
            "np",
            "cp",
            "0",
            "0xe0"
          ],
          "line": 6945
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5472-5544",
          "snippet": "static void ncr_setsync (ncb_p np, ccb_p cp, u_char scntl3, u_char sxfer)\n{\n\tstruct scsi_xfer *xp;\n\ttcb_p tp;\n\tint div;\n\tu_char target = INB (nc_sdid) & 0x0f;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\n\tif (!scntl3 || !(sxfer & 0x1f))\n\t\tscntl3 = np->rv_scntl3;\n\tscntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);\n\n\t/*\n\t**\tDeduce the value of controller sync period from scntl3.\n\t**\tperiod is in tenths of nano-seconds.\n\t*/\n\n\tdiv = ((scntl3 >> 4) & 0x7);\n\tif ((sxfer & 0x1f) && div)\n\t\ttp->period = (((sxfer>>5)+4)*div_10M[div-1])/np->clock_khz;\n\telse\n\t\ttp->period = 0xffff;\n\n\t/*\n\t**\t Stop there if sync parameters are unchanged\n\t*/\n\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (sxfer & 0x1f) {\n\t\tunsigned f10 = 100000 << (tp->widedone ? tp->widedone -1 : 0);\n\t\tunsigned mb10 = (f10 + tp->period/2) / tp->period;\n\t\t/*\n\t\t**  Disable extended Sreq/Sack filtering\n\t\t*/\n\t\tif (tp->period <= 2000) OUTOFFB (nc_stest2, EXT);\n\t\tprintf (\"%d.%d MB/s (%d ns, offset %d)\\n\",\n\t\t\tmb10 / 10, mb10 % 10, tp->period / 10, sxfer & 0x1f);\n\t} else  printf (\"asynchronous.\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  wide_status   phys.wide_st",
            "#define  sync_status   phys.sync_st",
            "#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */",
            "#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */"
          ],
          "globals_used": [
            "static u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};",
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  wide_status   phys.wide_st\n#define  sync_status   phys.sync_st\n#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */\n#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */\n\nstatic u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_setsync (ncb_p np, ccb_p cp, u_char scntl3, u_char sxfer)\n{\n\tstruct scsi_xfer *xp;\n\ttcb_p tp;\n\tint div;\n\tu_char target = INB (nc_sdid) & 0x0f;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\n\tif (!scntl3 || !(sxfer & 0x1f))\n\t\tscntl3 = np->rv_scntl3;\n\tscntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);\n\n\t/*\n\t**\tDeduce the value of controller sync period from scntl3.\n\t**\tperiod is in tenths of nano-seconds.\n\t*/\n\n\tdiv = ((scntl3 >> 4) & 0x7);\n\tif ((sxfer & 0x1f) && div)\n\t\ttp->period = (((sxfer>>5)+4)*div_10M[div-1])/np->clock_khz;\n\telse\n\t\ttp->period = 0xffff;\n\n\t/*\n\t**\t Stop there if sync parameters are unchanged\n\t*/\n\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (sxfer & 0x1f) {\n\t\tunsigned f10 = 100000 << (tp->widedone ? tp->widedone -1 : 0);\n\t\tunsigned mb10 = (f10 + tp->period/2) / tp->period;\n\t\t/*\n\t\t**  Disable extended Sreq/Sack filtering\n\t\t*/\n\t\tif (tp->period <= 2000) OUTOFFB (nc_stest2, EXT);\n\t\tprintf (\"%d.%d MB/s (%d ns, offset %d)\\n\",\n\t\t\tmb10 / 10, mb10 % 10, tp->period / 10, sxfer & 0x1f);\n\t} else  printf (\"asynchronous.\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, clrack)"
          ],
          "line": 6940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "clrack"
          ],
          "line": 6940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, msg_bad)"
          ],
          "line": 6934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "msg_bad"
          ],
          "line": 6934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "HS_PRT",
            "HS_BUSY"
          ],
          "line": 6922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "HS_PRT"
          ],
          "line": 6921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, msg_bad)"
          ],
          "line": 6876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "msg_bad"
          ],
          "line": 6876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, clrack)"
          ],
          "line": 6843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "clrack"
          ],
          "line": 6843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, msg_bad)"
          ],
          "line": 6837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "msg_bad"
          ],
          "line": 6837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "HS_PRT",
            "HS_BUSY"
          ],
          "line": 6825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "HS_PRT"
          ],
          "line": 6824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_getsync",
          "args": [
            "np",
            "per",
            "&fak",
            "&scntl3"
          ],
          "line": 6805
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_getsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5405-5463",
          "snippet": "static void ncr_getsync(ncb_p np, u_char sfac, u_char *fakp, u_char *scntl3p)\n{\n\tu_long\tclk = np->clock_khz;\t/* SCSI clock frequency in kHz\t*/\n\tint\tdiv = np->clock_divn;\t/* Number of divisors supported\t*/\n\tu_long\tfak;\t\t\t/* Sync factor in sxfer\t\t*/\n\tu_long\tper;\t\t\t/* Period in tenths of ns\t*/\n\tu_long\tkpc;\t\t\t/* (per * clk)\t\t\t*/\n\n\t/*\n\t**\tCompute the synchronous period in tenths of nano-seconds\n\t*/\n\tif\t(sfac <= 10)\tper = 250;\n\telse if\t(sfac == 11)\tper = 303;\n\telse if\t(sfac == 12)\tper = 500;\n\telse\t\t\tper = 40 * sfac;\n\n\t/*\n\t**\tLook for the greatest clock divisor that allows an\n\t**\tinput speed faster than the period.\n\t*/\n\tkpc = per * clk;\n\twhile (--div >= 0)\n\t\tif (kpc >= (div_10M[div] * 4)) break;\n\n\t/*\n\t**\tCalculate the lowest clock factor that allows an output\n\t**\tspeed not faster than the period.\n\t*/\n\tfak = (kpc - 1) / div_10M[div] + 1;\n\n#if 0\t/* You can #if 1 if you think this optimization is usefull */\n\n\tper = (fak * div_10M[div]) / clk;\n\n\t/*\n\t**\tWhy not to try the immediate lower divisor and to choose\n\t**\tthe one that allows the fastest output speed ?\n\t**\tWe dont want input speed too much greater than output speed.\n\t*/\n\tif (div >= 1 && fak < 6) {\n\t\tu_long fak2, per2;\n\t\tfak2 = (kpc - 1) / div_10M[div-1] + 1;\n\t\tper2 = (fak2 * div_10M[div-1]) / clk;\n\t\tif (per2 < per && fak2 <= 6) {\n\t\t\tfak = fak2;\n\t\t\tper = per2;\n\t\t\t--div;\n\t\t}\n\t}\n#endif\n\n\tif (fak < 4) fak = 4;\t/* Should never happen, too bad ... */\n\n\t/*\n\t**\tCompute and return sync parameters for the ncr\n\t*/\n\t*fakp\t\t= fak - 4;\n\t*scntl3p\t= ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};",
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_getsync(ncb_p np, u_char sfac, u_char *fakp, u_char *scntl3p)\n{\n\tu_long\tclk = np->clock_khz;\t/* SCSI clock frequency in kHz\t*/\n\tint\tdiv = np->clock_divn;\t/* Number of divisors supported\t*/\n\tu_long\tfak;\t\t\t/* Sync factor in sxfer\t\t*/\n\tu_long\tper;\t\t\t/* Period in tenths of ns\t*/\n\tu_long\tkpc;\t\t\t/* (per * clk)\t\t\t*/\n\n\t/*\n\t**\tCompute the synchronous period in tenths of nano-seconds\n\t*/\n\tif\t(sfac <= 10)\tper = 250;\n\telse if\t(sfac == 11)\tper = 303;\n\telse if\t(sfac == 12)\tper = 500;\n\telse\t\t\tper = 40 * sfac;\n\n\t/*\n\t**\tLook for the greatest clock divisor that allows an\n\t**\tinput speed faster than the period.\n\t*/\n\tkpc = per * clk;\n\twhile (--div >= 0)\n\t\tif (kpc >= (div_10M[div] * 4)) break;\n\n\t/*\n\t**\tCalculate the lowest clock factor that allows an output\n\t**\tspeed not faster than the period.\n\t*/\n\tfak = (kpc - 1) / div_10M[div] + 1;\n\n#if 0\t/* You can #if 1 if you think this optimization is usefull */\n\n\tper = (fak * div_10M[div]) / clk;\n\n\t/*\n\t**\tWhy not to try the immediate lower divisor and to choose\n\t**\tthe one that allows the fastest output speed ?\n\t**\tWe dont want input speed too much greater than output speed.\n\t*/\n\tif (div >= 1 && fak < 6) {\n\t\tu_long fak2, per2;\n\t\tfak2 = (kpc - 1) / div_10M[div-1] + 1;\n\t\tper2 = (fak2 * div_10M[div-1]) / clk;\n\t\tif (per2 < per && fak2 <= 6) {\n\t\t\tfak = fak2;\n\t\t\tper = per2;\n\t\t\t--div;\n\t\t}\n\t}\n#endif\n\n\tif (fak < 4) fak = 4;\t/* Should never happen, too bad ... */\n\n\t/*\n\t**\tCompute and return sync parameters for the ncr\n\t*/\n\t*fakp\t\t= fak - 4;\n\t*scntl3p\t= ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, dispatch)"
          ],
          "line": 6755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "dispatch"
          ],
          "line": 6755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "HS_PRT",
            "HS_BUSY"
          ],
          "line": 6718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT",
          "args": [
            "start0[0]",
            "SCR_INT"
          ],
          "line": 6647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_ssid"
          ],
          "line": 6634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT",
          "args": [
            "start0[0]",
            "SCR_INT ^ IFFALSE (0)"
          ],
          "line": 6621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "0"
          ],
          "line": 6621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPTH_PHYS (np, getcc)"
          ],
          "line": 6613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "getcc"
          ],
          "line": 6613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsa",
            "CCB_PHYS (cp, phys)"
          ],
          "line": 6612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "phys"
          ],
          "line": 6612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cp == np->header.cp"
          ],
          "line": 6571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cp"
          ],
          "line": 6568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "phys"
          ],
          "line": 6565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsa"
          ],
          "line": 6563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sdid"
          ],
          "line": 6549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_dsps"
          ],
          "line": 6546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  nego_status   phys.nego_st\n#define  scsi_status   phys.header.status[2]\n#define  host_status   phys.header.status[1]\n#define  HS_PRT\tnc_scr1\n#define\tINQ7_WIDE16\t(0x20)\n#define\tINQ7_SYNC\t(0x10)\n#define NS_WIDE\t\t(2)\n#define NS_SYNC\t\t(1)\n#define\tSIR_MISSING_SAVE\t(12)\n#define\tSIR_IGN_RESIDUE\t\t(11)\n#define\tSIR_REJECT_SENT\t\t(10)\n#define\tSIR_REJECT_RECEIVED\t(9)\n#define\tSIR_NEGO_PROTO\t\t(8)\n#define\tSIR_NEGO_FAILED\t\t(7)\n#define\tSIR_NEGO_WIDE\t\t(6)\n#define\tSIR_NEGO_SYNC\t\t(5)\n#define\tSIR_STALL_QUEUE\t\t(4)\n#define\tSIR_STALL_RESTART\t(3)\n#define\tSIR_SENSE_FAILED\t(2)\n#define\tSIR_SENSE_RESTART\t(1)\n#define HS_DISCONNECT\t(3)\t/* Disconnected by target */\n#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/\n#define HS_BUSY\t\t(1)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_RESTART  (0x1000)\n#define DEBUG_NEGO     (0x0200)\n#define DEBUG_TINY     (0x0080)\n#define MAX_TARGET  (16)\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nregister volatile u_int32_t data;\n\nvoid ncr_int_sir (ncb_p np)\n{\n\tu_char scntl3;\n\tu_char chg, ofs, per, fak, wide;\n\tu_char num = INB (nc_dsps);\n\tccb_p\tcp=0;\n\tu_long\tdsa;\n\tu_char\ttarget = INB (nc_sdid) & 0x0f;\n\ttcb_p\ttp     = &np->target[target];\n\tint     i;\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"I#%d\", num);\n\n\tswitch (num) {\n\tcase SIR_SENSE_RESTART:\n\tcase SIR_STALL_RESTART:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t**\tlookup the ccb\n\t\t*/\n\t\tdsa = INL (nc_dsa);\n\t\tcp = np->ccb;\n\t\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\t\tcp = cp->link_ccb;\n\n\t\tassert (cp);\n\t\tif (!cp)\n\t\t\tgoto out;\n\t\tassert (cp == np->header.cp);\n\t\tif (cp != np->header.cp)\n\t\t\tgoto out;\n\t}\n\n\tswitch (num) {\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of interrupted getcc selects\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_SENSE_RESTART:\n\t\t/*------------------------------------------\n\t\t**\tScript processor is idle.\n\t\t**\tLook for interrupted \"check cond\"\n\t\t**------------------------------------------\n\t\t*/\n\n\t\tif (DEBUG_FLAGS & DEBUG_RESTART)\n\t\t\tprintf (\"%s: int#%d\",ncr_name (np),num);\n\t\tcp = (ccb_p) 0;\n\t\tfor (i=0; i<MAX_TARGET; i++) {\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\" t%d\", i);\n\t\t\ttp = &np->target[i];\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\"+\");\n\t\t\tcp = tp->hold_cp;\n\t\t\tif (!cp) continue;\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\"+\");\n\t\t\tif ((cp->host_status==HS_BUSY) &&\n\t\t\t\t(cp->scsi_status==S_CHECK_COND))\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\"- (remove)\");\n\t\t\ttp->hold_cp = cp = (ccb_p) 0;\n\t\t};\n\n\t\tif (cp) {\n\t\t\tif (DEBUG_FLAGS & DEBUG_RESTART)\n\t\t\t\tprintf (\"+ restart job ..\\n\");\n\t\t\tOUTL (nc_dsa, CCB_PHYS (cp, phys));\n\t\t\tOUTL (nc_dsp, NCB_SCRIPTH_PHYS (np, getcc));\n\t\t\treturn;\n\t\t};\n\n\t\t/*\n\t\t**\tno job, resume normal processing\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_RESTART) printf (\" -- remove trap\\n\");\n\t\tWRITESCRIPT(start0[0], SCR_INT ^ IFFALSE (0));\n\t\tbreak;\n\n\tcase SIR_SENSE_FAILED:\n\t\t/*-------------------------------------------\n\t\t**\tWhile trying to select for\n\t\t**\tgetting the condition code,\n\t\t**\ta target reselected us.\n\t\t**-------------------------------------------\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_RESTART) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"in getcc reselect by t%d.\\n\",\n\t\t\t\tINB(nc_ssid) & 0x0f);\n\t\t}\n\n\t\t/*\n\t\t**\tMark this job\n\t\t*/\n\t\tcp->host_status = HS_BUSY;\n\t\tcp->scsi_status = S_CHECK_COND;\n\t\tnp->target[cp->xfer->sc_link->target].hold_cp = cp;\n\n\t\t/*\n\t\t**\tAnd patch code to restart it.\n\t\t*/\n\t\tWRITESCRIPT(start0[0], SCR_INT);\n\t\tbreak;\n\n/*-----------------------------------------------------------------------------\n**\n**\tWas Sie schon immer ueber transfermode negotiation wissen wollten ...\n**\n**\tWe try to negotiate sync and wide transfer only after\n**\ta successfull inquire command. We look at byte 7 of the\n**\tinquire data to determine the capabilities if the target.\n**\n**\tWhen we try to negotiate, we append the negotiation message\n**\tto the identify and (maybe) simple tag message.\n**\tThe host status field is set to HS_NEGOTIATE to mark this\n**\tsituation.\n**\n**\tIf the target doesn't answer this message immidiately\n**\t(as required by the standard), the SIR_NEGO_FAIL interrupt\n**\twill be raised eventually.\n**\tThe handler removes the HS_NEGOTIATE status, and sets the\n**\tnegotiated value to the default (async / nowide).\n**\n**\tIf we receive a matching answer immediately, we check it\n**\tfor validity, and set the values.\n**\n**\tIf we receive a Reject message immediately, we assume the\n**\tnegotiation has failed, and fall back to standard values.\n**\n**\tIf we receive a negotiation message while not in HS_NEGOTIATE\n**\tstate, it's a target initiated negotiation. We prepare a\n**\t(hopefully) valid answer, set our parameters, and send back\n**\tthis answer to the target.\n**\n**\tIf the target doesn't fetch the answer (no message out phase),\n**\twe assume the negotiation has failed, and fall back to default\n**\tsettings.\n**\n**\tWhen we set the values, we adjust them in all ccbs belonging\n**\tto this target, in the controller's register, and in the \"phys\"\n**\tfield of the controller's struct ncb.\n**\n**\tPossible cases:\t\t   hs  sir   msg_in value  send   goto\n**\tWe try try to negotiate:\n**\t-> target doesnt't msgin   NEG FAIL  noop   defa.  -      dispatch\n**\t-> target rejected our msg NEG FAIL  reject defa.  -      dispatch\n**\t-> target answered  (ok)   NEG SYNC  sdtr   set    -      clrack\n**\t-> target answered (!ok)   NEG SYNC  sdtr   defa.  REJ--->msg_bad\n**\t-> target answered  (ok)   NEG WIDE  wdtr   set    -      clrack\n**\t-> target answered (!ok)   NEG WIDE  wdtr   defa.  REJ--->msg_bad\n**\t-> any other msgin\t   NEG FAIL  noop   defa.  -      dispatch\n**\n**\tTarget tries to negotiate:\n**\t-> incoming message\t   --- SYNC  sdtr   set    SDTR   -\n**\t-> incoming message\t   --- WIDE  wdtr   set    WDTR   -\n**      We sent our answer:\n**\t-> target doesn't msgout   --- PROTO ?      defa.  -      dispatch\n**\n**-----------------------------------------------------------------------------\n*/\n\n\tcase SIR_NEGO_FAILED:\n\t\t/*-------------------------------------------------------\n\t\t**\n\t\t**\tNegotiation failed.\n\t\t**\tTarget doesn't send an answer message,\n\t\t**\tor target rejected our message.\n\t\t**\n\t\t**      Remove negotiation request.\n\t\t**\n\t\t**-------------------------------------------------------\n\t\t*/\n\t\tOUTB (HS_PRT, HS_BUSY);\n\n\t\t/* fall through */\n\n\tcase SIR_NEGO_PROTO:\n\t\t/*-------------------------------------------------------\n\t\t**\n\t\t**\tNegotiation failed.\n\t\t**\tTarget doesn't fetch the answer message.\n\t\t**\n\t\t**-------------------------------------------------------\n\t\t*/\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"negotiation failed sir=%x status=%x.\\n\",\n\t\t\t\tnum, cp->nego_status);\n\t\t};\n\n\t\t/*\n\t\t**\tany error in negotiation:\n\t\t**\tfall back to default mode.\n\t\t*/\n\t\tswitch (cp->nego_status) {\n\n\t\tcase NS_SYNC:\n\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\tbreak;\n\n\t\tcase NS_WIDE:\n\t\t\tncr_setwide (np, cp, 0, 0);\n\t\t\tbreak;\n\n\t\t};\n\t\tnp->msgin [0] = M_NOOP;\n\t\tnp->msgout[0] = M_NOOP;\n\t\tcp->nego_status = 0;\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, dispatch));\n\t\tbreak;\n\n\tcase SIR_NEGO_SYNC:\n\t\t/*\n\t\t**\tSynchronous request message received.\n\t\t*/\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync msgin: \");\n\t\t\t(void) ncr_show_msg (np->msgin);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t\t/*\n\t\t**\tget requested values.\n\t\t*/\n\n\t\tchg = 0;\n\t\tper = np->msgin[3];\n\t\tofs = np->msgin[4];\n\t\tif (ofs==0) per=255;\n\n\t\t/*\n\t\t**      if target sends SDTR message,\n\t\t**\t      it CAN transfer synch.\n\t\t*/\n\n\t\tif (ofs)\n\t\t\ttp->inqdata[7] |= INQ7_SYNC;\n\n\t\t/*\n\t\t**\tcheck values against driver limits.\n\t\t*/\n\n\t\tif (per < np->minsync)\n\t\t\t{chg = 1; per = np->minsync;}\n\t\tif (per < tp->minsync)\n\t\t\t{chg = 1; per = tp->minsync;}\n\t\tif (ofs > tp->maxoffs)\n\t\t\t{chg = 1; ofs = tp->maxoffs;}\n\n\t\t/*\n\t\t**\tCheck against controller limits.\n\t\t*/\n\n\t\tfak\t= 7;\n\t\tscntl3\t= 0;\n\t\tif (ofs != 0) {\n\t\t\tncr_getsync(np, per, &fak, &scntl3);\n\t\t\tif (fak > 7) {\n\t\t\t\tchg = 1;\n\t\t\t\tofs = 0;\n\t\t\t}\n\t\t}\n\t\tif (ofs == 0) {\n\t\t\tfak\t= 7;\n\t\t\tper\t= 0;\n\t\t\tscntl3\t= 0;\n\t\t\ttp->minsync = 0;\n\t\t}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync: per=%d scntl3=0x%x ofs=%d fak=%d chg=%d.\\n\",\n\t\t\t\tper, scntl3, ofs, fak, chg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_SYNC:\n\t\t\t\t/*\n\t\t\t\t**      This was an answer message\n\t\t\t\t*/\n\t\t\t\tif (chg) {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer wasn't acceptable.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer is ok.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setsync (np,cp,scntl3,(fak<<5)|ofs);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t};\n\t\t\t\treturn;\n\n\t\t\tcase NS_WIDE:\n\t\t\t\tncr_setwide (np, cp, 0, 0);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t**\tIt was a request. Set value and\n\t\t**      prepare an answer message\n\t\t*/\n\n\t\tncr_setsync (np, cp, scntl3, (fak<<5)|ofs);\n\n\t\tnp->msgout[0] = M_EXTENDED;\n\t\tnp->msgout[1] = 3;\n\t\tnp->msgout[2] = M_X_SYNC_REQ;\n\t\tnp->msgout[3] = per;\n\t\tnp->msgout[4] = ofs;\n\n\t\tcp->nego_status = NS_SYNC;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync msgout: \");\n\t\t\t(void) ncr_show_msg (np->msgout);\n\t\t\tprintf (\".\\n\");\n\t\t}\n\n\t\tif (!ofs) {\n\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\treturn;\n\t\t}\n\t\tnp->msgin [0] = M_NOOP;\n\n\t\tbreak;\n\n\tcase SIR_NEGO_WIDE:\n\t\t/*\n\t\t**\tWide request message received.\n\t\t*/\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide msgin: \");\n\t\t\t(void) ncr_show_msg (np->msgin);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t\t/*\n\t\t**\tget requested values.\n\t\t*/\n\n\t\tchg  = 0;\n\t\twide = np->msgin[3];\n\n\t\t/*\n\t\t**      if target sends WDTR message,\n\t\t**\t      it CAN transfer wide.\n\t\t*/\n\n\t\tif (wide)\n\t\t\ttp->inqdata[7] |= INQ7_WIDE16;\n\n\t\t/*\n\t\t**\tcheck values against driver limits.\n\t\t*/\n\n\t\tif (wide > tp->usrwide)\n\t\t\t{chg = 1; wide = tp->usrwide;}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide: wide=%d chg=%d.\\n\", wide, chg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_WIDE:\n\t\t\t\t/*\n\t\t\t\t**      This was an answer message\n\t\t\t\t*/\n\t\t\t\tif (chg) {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer wasn't acceptable.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setwide (np, cp, 0, 1);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t**\tAnswer is ok.\n\t\t\t\t\t*/\n\t\t\t\t\tncr_setwide (np, cp, wide, 1);\n\t\t\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t};\n\t\t\t\treturn;\n\n\t\t\tcase NS_SYNC:\n\t\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t**\tIt was a request, set value and\n\t\t**      prepare an answer message\n\t\t*/\n\n\t\tncr_setwide (np, cp, wide, 1);\n\n\t\tnp->msgout[0] = M_EXTENDED;\n\t\tnp->msgout[1] = 2;\n\t\tnp->msgout[2] = M_X_WIDE_REQ;\n\t\tnp->msgout[3] = wide;\n\n\t\tnp->msgin [0] = M_NOOP;\n\n\t\tcp->nego_status = NS_WIDE;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide msgout: \");\n\t\t\t(void) ncr_show_msg (np->msgout);\n\t\t\tprintf (\".\\n\");\n\t\t}\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of special messages\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_REJECT_RECEIVED:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received a M_REJECT message.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_REJECT received (%x:%x).\\n\",\n\t\t\t(unsigned)np->lastmsg, np->msgout[0]);\n\t\tbreak;\n\n\tcase SIR_REJECT_SENT:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an unknown message\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_REJECT sent for \");\n\t\t(void) ncr_show_msg (np->msgin);\n\t\tprintf (\".\\n\");\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of special messages\n**\n**--------------------------------------------------------------------\n*/\n\n\tcase SIR_IGN_RESIDUE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an IGNORE RESIDUE message,\n\t\t**\twhich couldn't be handled by the script.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_IGN_RESIDUE received, but not yet implemented.\\n\");\n\t\tbreak;\n\n\tcase SIR_MISSING_SAVE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tWe received an DISCONNECT message,\n\t\t**\tbut the datapointer wasn't saved before.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"M_DISCONNECT received, but datapointer not saved:\\n\"\n\t\t\t\"\\tdata=%x save=%x goal=%x.\\n\",\n\t\t\t(unsigned) INL (nc_temp),\n\t\t\tSCR_BO((unsigned) np->header.savep),\n\t\t\tSCR_BO((unsigned) np->header.goalp));\n\t\tbreak;\n\n/*--------------------------------------------------------------------\n**\n**\tProcessing of a \"S_QUEUE_FULL\" status.\n**\n**\tThe current command has been rejected,\n**\tbecause there are too many in the command queue.\n**\tWe have started too many commands for that target.\n**\n**\tIf possible, reinsert at head of queue.\n**\tStall queue until there are no disconnected jobs\n**\t(ncr is REALLY idle). Then restart processing.\n**\n**\tWe should restart the current job after the controller\n**\thas become idle. But this is not yet implemented.\n**\n**--------------------------------------------------------------------\n*/\n\tcase SIR_STALL_QUEUE:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tStall the start queue.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"queue full.\\n\");\n\n\t\tWRITESCRIPT(start1[0], SCR_INT);\n\n\t\t/*\n\t\t**\tTry to disable tagged transfers.\n\t\t*/\n\t\tncr_setmaxtags (&np->target[target], 0);\n\n\t\t/*\n\t\t** @QUEUE@\n\t\t**\n\t\t**\tShould update the launch field of the\n\t\t**\tcurrent job to be able to restart it.\n\t\t**\tThen prepend it to the start queue.\n\t\t*/\n\n\t\t/* fall through */\n\n\tcase SIR_STALL_RESTART:\n\t\t/*-----------------------------------------------\n\t\t**\n\t\t**\tEnable selecting again,\n\t\t**\tif NO disconnected jobs.\n\t\t**\n\t\t**-----------------------------------------------\n\t\t*/\n\t\t/*\n\t\t**\tLook for a disconnected job.\n\t\t*/\n\t\tcp = np->ccb;\n\t\twhile (cp && cp->host_status != HS_DISCONNECT)\n\t\t\tcp = cp->link_ccb;\n\n\t\t/*\n\t\t**\tif there is one, ...\n\t\t*/\n\t\tif (cp) {\n\t\t\t/*\n\t\t\t**\twait for reselection\n\t\t\t*/\n\t\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, reselect));\n\t\t\treturn;\n\t\t};\n\n\t\t/*\n\t\t**\telse remove the interrupt.\n\t\t*/\n\n\t\tprintf (\"%s: queue empty.\\n\", ncr_name (np));\n\t\tWRITESCRIPT(start1[0], SCR_INT ^ IFFALSE (0));\n\t\tbreak;\n\t};\n\nout:\n\tOUTB (nc_dcntl, np->rv_dcntl | STD);\n}"
  },
  {
    "function_name": "ncr_show_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "6525-6540",
    "snippet": "static int ncr_show_msg (u_char * msg)\n{\n\tu_char i;\n\tprintf (\"%x\",*msg);\n\tif (*msg==M_EXTENDED) {\n\t\tfor (i=1;i<8;i++) {\n\t\t\tif (i-1>msg[1]) break;\n\t\t\tprintf (\"-%x\",msg[i]);\n\t\t};\n\t\treturn (i+1);\n\t} else if ((*msg & 0xf0) == 0x20) {\n\t\tprintf (\"-%x\",msg[1]);\n\t\treturn (2);\n\t};\n\treturn (1);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti;",
      "int\ti;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-%x\"",
            "msg[1]"
          ],
          "line": 6536
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nint\ti;\nint\ti;\n\nstatic int ncr_show_msg (u_char * msg)\n{\n\tu_char i;\n\tprintf (\"%x\",*msg);\n\tif (*msg==M_EXTENDED) {\n\t\tfor (i=1;i<8;i++) {\n\t\t\tif (i-1>msg[1]) break;\n\t\t\tprintf (\"-%x\",msg[i]);\n\t\t};\n\t\treturn (i+1);\n\t} else if ((*msg & 0xf0) == 0x20) {\n\t\tprintf (\"-%x\",msg[1]);\n\t\treturn (2);\n\t};\n\treturn (1);\n}"
  },
  {
    "function_name": "ncr_int_ma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "6327-6514",
    "snippet": "static void ncr_int_ma (ncb_p np, u_char dstat)\n{\n\tu_int32_t\tdbc;\n\tu_int32_t\trest;\n\tu_int32_t\tdsa;\n\tu_int32_t\tdsp;\n\tu_int32_t\tnxtdsp;\n\tvoid\t*vdsp_base;\n\tsize_t\tvdsp_off;\n\tu_int32_t\toadr, olen;\n\tu_int32_t\t*tblp;\n\tncrcmd\t*newcmd;\n\tu_int32_t\tcmd, sbcl, delta, ss0, ss2, ctest5;\n\tccb_p\tcp;\n\n\tdsp = INL (nc_dsp);\n\tdsa = INL (nc_dsa);\n\tdbc = INL (nc_dbc);\n\tss0 = INB (nc_sstat0);\n\tss2 = INB (nc_sstat2);\n\tsbcl= INB (nc_sbcl);\n\n\tcmd = dbc >> 24;\n\trest= dbc & 0xffffff;\n\n\tctest5 = (np->rv_ctest5 & DFS) ? INB (nc_ctest5) : 0;\n\tif (ctest5 & DFS)\n\t\tdelta=(((ctest5<<8) | (INB (nc_dfifo) & 0xff)) - rest) & 0x3ff;\n\telse\n\t\tdelta=(INB (nc_dfifo) - rest) & 0x7f;\n\n\n\t/*\n\t**\tThe data in the dma fifo has not been transfered to\n\t**\tthe target -> add the amount to the rest\n\t**\tand clear the data.\n\t**\tCheck the sstat2 register in case of wide transfer.\n\t*/\n\n\tif (!(dstat & DFE)) rest += delta;\n\tif (ss0 & OLF) rest++;\n\tif (ss0 & ORF) rest++;\n\tif (INB(nc_scntl3) & EWS) {\n\t\tif (ss2 & OLF1) rest++;\n\t\tif (ss2 & ORF1) rest++;\n\t};\n\tOUTB (nc_ctest3, np->rv_ctest3 | CLF);\t/* clear dma fifo  */\n\tOUTB (nc_stest3, TE|CSF);\t\t/* clear scsi fifo */\n\n\t/*\n\t**\tlocate matching cp\n\t*/\n\tdsa = INL (nc_dsa);\n\tcp = np->ccb;\n\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\tcp = cp->link_ccb;\n\n\tif (!cp) {\n\t    printf (\"%s: SCSI phase error fixup: CCB already dequeued (%p)\\n\",\n\t\t    ncr_name (np), np->header.cp);\n\t    return;\n\t}\n\tif (cp != np->header.cp) {\n\t    printf (\"%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx) np->ccb = %p\\n\",\n\t\t    ncr_name (np), (u_long) cp, (u_long) np->header.cp, np->ccb);\n/*\t    return;*/\n\t}\n\n\t/*\n\t**\tfind the interrupted script command,\n\t**\tand the address at which to continue.\n\t*/\n\n\tif (dsp == NCR_KVATOPHYS (np, &cp->patch[2])) {\n\t\tvdsp_base = cp;\n\t\tvdsp_off = offsetof(struct ccb, patch[0]);\n\t\tnxtdsp = READSCRIPT_OFF(vdsp_base, vdsp_off + 3*4);\n\t} else if (dsp == NCR_KVATOPHYS (np, &cp->patch[6])) {\n\t\tvdsp_base = cp;\n\t\tvdsp_off = offsetof(struct ccb, patch[4]);\n\t\tnxtdsp = READSCRIPT_OFF(vdsp_base, vdsp_off + 3*4);\n\t} else if (dsp > np->p_script &&\n\t\t   dsp <= np->p_script + sizeof(struct script)) {\n\t\tvdsp_base = np->script;\n\t\tvdsp_off = dsp - np->p_script - 8;\n\t\tnxtdsp = dsp;\n\t} else {\n\t\tvdsp_base = np->scripth;\n\t\tvdsp_off = dsp - np->p_scripth - 8;\n\t\tnxtdsp = dsp;\n\t};\n\n\t/*\n\t**\tlog the information\n\t*/\n\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE)) {\n\t\tprintf (\"P%x%x \",cmd&7, sbcl&7);\n\t\tprintf (\"RL=%d D=%d SS0=%x \",\n\t\t\t(unsigned) rest, (unsigned) delta, ss0);\n\t};\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintf (\"\\nCP=%p CP2=%p DSP=%x NXT=%x VDSP_BASE=%p VDSP_OFF=0x%x CMD=%x \",\n\t\t\tcp, np->header.cp, (unsigned)dsp,\n\t\t\t(unsigned)nxtdsp, vdsp_base, (unsigned)vdsp_off, cmd);\n\t};\n\n\t/*\n\t**\tget old startaddress and old length.\n\t*/\n\n\toadr = READSCRIPT_OFF(vdsp_base, vdsp_off + 1*4);\n\n\tif (cmd & 0x10) {\t/* Table indirect */\n\t\ttblp = (u_int32_t *) ((char*) &cp->phys + oadr);\n\t\tolen = SCR_BO(tblp[0]);\n\t\toadr = SCR_BO(tblp[1]);\n\t} else {\n\t\ttblp = (u_int32_t *) 0;\n\t\tolen = READSCRIPT_OFF(vdsp_base, vdsp_off) & 0xffffff;\n\t};\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintf (\"OCMD=%x\\nTBLP=%p OLEN=%x OADR=%x\\n\",\n\t\t\t(unsigned) (READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24),\n\t\t\ttblp,\n\t\t\t(unsigned) olen,\n\t\t\t(unsigned) oadr);\n\t};\n\n\t/*\n\t**\tif old phase not dataphase, leave here.\n\t*/\n\n\tif (cmd != (READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24)) {\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"internal error: cmd=%02x != %02x=(vdsp[0] >> 24)\\n\",\n\t\t\t(unsigned)cmd,\n\t\t\t(unsigned)READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24);\n\t\t\n\t\treturn;\n\t}\n\tif (cmd & 0x06) {\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"phase change %x-%x %d@%08x resid=%d.\\n\",\n\t\t\tcmd&7, sbcl&7, (unsigned)olen,\n\t\t\t(unsigned)oadr, (unsigned)rest);\n\n\t\tOUTB (nc_dcntl, np->rv_dcntl | STD);\n\t\treturn;\n\t};\n\n\t/*\n\t**\tchoose the correct patch area.\n\t**\tif savep points to one, choose the other.\n\t*/\n\n\tnewcmd = cp->patch;\n\tif (cp->phys.header.savep == SCR_BO(NCR_KVATOPHYS (np, newcmd))) newcmd+=4;\n\n\t/*\n\t**\tfillin the commands\n\t*/\n\n\tnewcmd[0] = SCR_BO(((cmd & 0x0f) << 24) | rest);\n\tnewcmd[1] = SCR_BO(oadr + olen - rest);\n\tnewcmd[2] = SCR_BO(SCR_JUMP);\n\tnewcmd[3] = SCR_BO(nxtdsp);\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"newcmd[%ld] %x %x %x %x.\\n\",\n\t\t\t(long)(newcmd - cp->patch),\n\t\t\t(unsigned)newcmd[0],\n\t\t\t(unsigned)newcmd[1],\n\t\t\t(unsigned)newcmd[2],\n\t\t\t(unsigned)newcmd[3]);\n\t}\n\t/*\n\t**\tfake the return address (to the patch).\n\t**\tand restart script processor at dispatcher.\n\t*/\n\tnp->profile.num_break++;\n\tOUTL (nc_temp, NCR_KVATOPHYS (np, newcmd));\n\tif ((cmd & 7) == 0)\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, dispatch));\n\telse\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, checkatn));\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TINY     (0x0080)",
      "#define DEBUG_PHASE    (0x0002)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;",
      "u_int8_t\tistat, dstat;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, checkatn)"
          ],
          "line": 6513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "checkatn"
          ],
          "line": 6513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, dispatch)"
          ],
          "line": 6511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "dispatch"
          ],
          "line": 6511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_temp",
            "NCR_KVATOPHYS (np, newcmd)"
          ],
          "line": 6509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "newcmd"
          ],
          "line": 6509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"newcmd[%ld] %x %x %x %x.\\n\"",
            "(long)(newcmd - cp->patch)",
            "(unsigned)newcmd[0]",
            "(unsigned)newcmd[1]",
            "(unsigned)newcmd[2]",
            "(unsigned)newcmd[3]"
          ],
          "line": 6497
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "nxtdsp"
          ],
          "line": 6493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "SCR_JUMP"
          ],
          "line": 6492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "oadr + olen - rest"
          ],
          "line": 6491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "((cmd & 0x0f) << 24) | rest"
          ],
          "line": 6490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, newcmd)"
          ],
          "line": 6484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "newcmd"
          ],
          "line": 6484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_dcntl",
            "np->rv_dcntl | STD"
          ],
          "line": 6474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "vdsp_base",
            "vdsp_off"
          ],
          "line": 6464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 6461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "vdsp_base",
            "vdsp_off"
          ],
          "line": 6460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "vdsp_base",
            "vdsp_off"
          ],
          "line": 6450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "vdsp_base",
            "vdsp_off"
          ],
          "line": 6445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "tblp[1]"
          ],
          "line": 6442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "tblp[0]"
          ],
          "line": 6441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "vdsp_base",
            "vdsp_off + 1*4"
          ],
          "line": 6437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "vdsp_base",
            "vdsp_off + 3*4"
          ],
          "line": 6407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&cp->patch[6]"
          ],
          "line": 6404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "vdsp_base",
            "vdsp_off + 3*4"
          ],
          "line": 6403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&cp->patch[2]"
          ],
          "line": 6400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 6391
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "phys"
          ],
          "line": 6381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsa"
          ],
          "line": 6379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest3",
            "TE|CSF"
          ],
          "line": 6374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_ctest3",
            "np->rv_ctest3 | CLF"
          ],
          "line": 6373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_scntl3"
          ],
          "line": 6369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_dfifo"
          ],
          "line": 6356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_dfifo"
          ],
          "line": 6354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_ctest5"
          ],
          "line": 6352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sbcl"
          ],
          "line": 6347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sstat2"
          ],
          "line": 6346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sstat0"
          ],
          "line": 6345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dbc"
          ],
          "line": 6344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsa"
          ],
          "line": 6343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsp"
          ],
          "line": 6342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_PHASE    (0x0002)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\nu_int8_t\tistat, dstat;\nregister volatile u_int32_t data;\n\nstatic void ncr_int_ma (ncb_p np, u_char dstat)\n{\n\tu_int32_t\tdbc;\n\tu_int32_t\trest;\n\tu_int32_t\tdsa;\n\tu_int32_t\tdsp;\n\tu_int32_t\tnxtdsp;\n\tvoid\t*vdsp_base;\n\tsize_t\tvdsp_off;\n\tu_int32_t\toadr, olen;\n\tu_int32_t\t*tblp;\n\tncrcmd\t*newcmd;\n\tu_int32_t\tcmd, sbcl, delta, ss0, ss2, ctest5;\n\tccb_p\tcp;\n\n\tdsp = INL (nc_dsp);\n\tdsa = INL (nc_dsa);\n\tdbc = INL (nc_dbc);\n\tss0 = INB (nc_sstat0);\n\tss2 = INB (nc_sstat2);\n\tsbcl= INB (nc_sbcl);\n\n\tcmd = dbc >> 24;\n\trest= dbc & 0xffffff;\n\n\tctest5 = (np->rv_ctest5 & DFS) ? INB (nc_ctest5) : 0;\n\tif (ctest5 & DFS)\n\t\tdelta=(((ctest5<<8) | (INB (nc_dfifo) & 0xff)) - rest) & 0x3ff;\n\telse\n\t\tdelta=(INB (nc_dfifo) - rest) & 0x7f;\n\n\n\t/*\n\t**\tThe data in the dma fifo has not been transfered to\n\t**\tthe target -> add the amount to the rest\n\t**\tand clear the data.\n\t**\tCheck the sstat2 register in case of wide transfer.\n\t*/\n\n\tif (!(dstat & DFE)) rest += delta;\n\tif (ss0 & OLF) rest++;\n\tif (ss0 & ORF) rest++;\n\tif (INB(nc_scntl3) & EWS) {\n\t\tif (ss2 & OLF1) rest++;\n\t\tif (ss2 & ORF1) rest++;\n\t};\n\tOUTB (nc_ctest3, np->rv_ctest3 | CLF);\t/* clear dma fifo  */\n\tOUTB (nc_stest3, TE|CSF);\t\t/* clear scsi fifo */\n\n\t/*\n\t**\tlocate matching cp\n\t*/\n\tdsa = INL (nc_dsa);\n\tcp = np->ccb;\n\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\tcp = cp->link_ccb;\n\n\tif (!cp) {\n\t    printf (\"%s: SCSI phase error fixup: CCB already dequeued (%p)\\n\",\n\t\t    ncr_name (np), np->header.cp);\n\t    return;\n\t}\n\tif (cp != np->header.cp) {\n\t    printf (\"%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx) np->ccb = %p\\n\",\n\t\t    ncr_name (np), (u_long) cp, (u_long) np->header.cp, np->ccb);\n/*\t    return;*/\n\t}\n\n\t/*\n\t**\tfind the interrupted script command,\n\t**\tand the address at which to continue.\n\t*/\n\n\tif (dsp == NCR_KVATOPHYS (np, &cp->patch[2])) {\n\t\tvdsp_base = cp;\n\t\tvdsp_off = offsetof(struct ccb, patch[0]);\n\t\tnxtdsp = READSCRIPT_OFF(vdsp_base, vdsp_off + 3*4);\n\t} else if (dsp == NCR_KVATOPHYS (np, &cp->patch[6])) {\n\t\tvdsp_base = cp;\n\t\tvdsp_off = offsetof(struct ccb, patch[4]);\n\t\tnxtdsp = READSCRIPT_OFF(vdsp_base, vdsp_off + 3*4);\n\t} else if (dsp > np->p_script &&\n\t\t   dsp <= np->p_script + sizeof(struct script)) {\n\t\tvdsp_base = np->script;\n\t\tvdsp_off = dsp - np->p_script - 8;\n\t\tnxtdsp = dsp;\n\t} else {\n\t\tvdsp_base = np->scripth;\n\t\tvdsp_off = dsp - np->p_scripth - 8;\n\t\tnxtdsp = dsp;\n\t};\n\n\t/*\n\t**\tlog the information\n\t*/\n\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE)) {\n\t\tprintf (\"P%x%x \",cmd&7, sbcl&7);\n\t\tprintf (\"RL=%d D=%d SS0=%x \",\n\t\t\t(unsigned) rest, (unsigned) delta, ss0);\n\t};\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintf (\"\\nCP=%p CP2=%p DSP=%x NXT=%x VDSP_BASE=%p VDSP_OFF=0x%x CMD=%x \",\n\t\t\tcp, np->header.cp, (unsigned)dsp,\n\t\t\t(unsigned)nxtdsp, vdsp_base, (unsigned)vdsp_off, cmd);\n\t};\n\n\t/*\n\t**\tget old startaddress and old length.\n\t*/\n\n\toadr = READSCRIPT_OFF(vdsp_base, vdsp_off + 1*4);\n\n\tif (cmd & 0x10) {\t/* Table indirect */\n\t\ttblp = (u_int32_t *) ((char*) &cp->phys + oadr);\n\t\tolen = SCR_BO(tblp[0]);\n\t\toadr = SCR_BO(tblp[1]);\n\t} else {\n\t\ttblp = (u_int32_t *) 0;\n\t\tolen = READSCRIPT_OFF(vdsp_base, vdsp_off) & 0xffffff;\n\t};\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintf (\"OCMD=%x\\nTBLP=%p OLEN=%x OADR=%x\\n\",\n\t\t\t(unsigned) (READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24),\n\t\t\ttblp,\n\t\t\t(unsigned) olen,\n\t\t\t(unsigned) oadr);\n\t};\n\n\t/*\n\t**\tif old phase not dataphase, leave here.\n\t*/\n\n\tif (cmd != (READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24)) {\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"internal error: cmd=%02x != %02x=(vdsp[0] >> 24)\\n\",\n\t\t\t(unsigned)cmd,\n\t\t\t(unsigned)READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24);\n\t\t\n\t\treturn;\n\t}\n\tif (cmd & 0x06) {\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"phase change %x-%x %d@%08x resid=%d.\\n\",\n\t\t\tcmd&7, sbcl&7, (unsigned)olen,\n\t\t\t(unsigned)oadr, (unsigned)rest);\n\n\t\tOUTB (nc_dcntl, np->rv_dcntl | STD);\n\t\treturn;\n\t};\n\n\t/*\n\t**\tchoose the correct patch area.\n\t**\tif savep points to one, choose the other.\n\t*/\n\n\tnewcmd = cp->patch;\n\tif (cp->phys.header.savep == SCR_BO(NCR_KVATOPHYS (np, newcmd))) newcmd+=4;\n\n\t/*\n\t**\tfillin the commands\n\t*/\n\n\tnewcmd[0] = SCR_BO(((cmd & 0x0f) << 24) | rest);\n\tnewcmd[1] = SCR_BO(oadr + olen - rest);\n\tnewcmd[2] = SCR_BO(SCR_JUMP);\n\tnewcmd[3] = SCR_BO(nxtdsp);\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tPRINT_ADDR(cp->xfer);\n\t\tprintf (\"newcmd[%ld] %x %x %x %x.\\n\",\n\t\t\t(long)(newcmd - cp->patch),\n\t\t\t(unsigned)newcmd[0],\n\t\t\t(unsigned)newcmd[1],\n\t\t\t(unsigned)newcmd[2],\n\t\t\t(unsigned)newcmd[3]);\n\t}\n\t/*\n\t**\tfake the return address (to the patch).\n\t**\tand restart script processor at dispatcher.\n\t*/\n\tnp->profile.num_break++;\n\tOUTL (nc_temp, NCR_KVATOPHYS (np, newcmd));\n\tif ((cmd & 7) == 0)\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, dispatch));\n\telse\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, checkatn));\n}"
  },
  {
    "function_name": "ncr_int_sto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "6276-6311",
    "snippet": "void ncr_int_sto (ncb_p np)\n{\n\tu_long dsa, scratcha, diff;\n\tccb_p cp;\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"T\");\n\n\t/*\n\t**\tlook for ccb and set the status.\n\t*/\n\n\tdsa = INL (nc_dsa);\n\tcp = np->ccb;\n\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\tcp = cp->link_ccb;\n\n\tif (cp) {\n\t\tcp-> host_status = HS_SEL_TIMEOUT;\n\t\tncr_complete (np, cp);\n\t};\n\n\t/*\n\t**\trepair start queue\n\t*/\n\n\tscratcha = INL (nc_scratcha);\n\tdiff = scratcha - NCB_SCRIPTH_PHYS (np, tryloop);\n\n/*\tassert ((diff <= MAX_START * 20) && !(diff % 20));*/\n\n\tif ((diff <= MAX_START * 20) && !(diff % 20)) {\n\t\tWRITESCRIPT(startpos[0], scratcha);\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n\t\treturn;\n\t};\n\tncr_init (np, \"selection timeout\", HS_FAIL);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  host_status   phys.header.status[1]",
      "#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */",
      "#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */",
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TINY     (0x0080)",
      "#define MAX_START   (256)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_init",
          "args": [
            "np",
            "\"selection timeout\"",
            "HS_FAIL"
          ],
          "line": 6310
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5208-5340",
          "snippet": "void ncr_init (ncb_p np, char * msg, u_long code)\n{\n\tint\ti;\n\tu_long\tusrsync;\n\tu_char\tusrwide;\n\n\t/*\n\t**\tReset chip.\n\t*/\n\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat, 0);\n\n\t/*\n\t**\tMessage.\n\t*/\n\n\tif (msg) printf (\"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t/*\n\t**\tClear Start Queue\n\t*/\n\n\tfor (i=0;i<MAX_START;i++)\n\t\tnp -> squeue [i] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\n\tnp->squeueput = 0;\n\tWRITESCRIPT(startpos[0], NCB_SCRIPTH_PHYS (np, tryloop));\n\tWRITESCRIPT(start0  [0], SCR_INT ^ IFFALSE (0));\n\n\t/*\n\t**\tWakeup all pending jobs.\n\t*/\n\n\tncr_wakeup (np, code);\n\n\t/*\n\t**\tInit chip.\n\t*/\n\n\tOUTB (nc_istat,  0x00   );      /*  Remove Reset, abort ...\t     */\n\tOUTB (nc_scntl0, 0xca   );      /*  full arb., ena parity, par->ATN  */\n\tOUTB (nc_scntl1, 0x00\t);\t/*  odd parity, and remove CRST!!    */\n\tncr_selectclock(np, np->rv_scntl3); /* Select SCSI clock             */\n\tOUTB (nc_scid  , RRE|np->myaddr);/*  host adapter SCSI address       */\n\tOUTW (nc_respid, 1ul<<np->myaddr);/*  id to respond to\t\t     */\n\tOUTB (nc_istat , SIGP\t);\t/*  Signal Process\t\t     */\n\tOUTB (nc_dmode , np->rv_dmode);\t/* XXX modify burstlen ??? */\n\tOUTB (nc_dcntl , np->rv_dcntl);\n\tOUTB (nc_ctest3, np->rv_ctest3);\n\tOUTB (nc_ctest5, np->rv_ctest5);\n\tOUTB (nc_ctest4, np->rv_ctest4);/*  enable master parity checking    */\n\tOUTB (nc_stest2, np->rv_stest2|EXT); /* Extended Sreq/Sack filtering */\n\tOUTB (nc_stest3, TE     );\t/*  TolerANT enable\t\t     */\n\tOUTB (nc_stime0, 0x0b\t);\t/*  HTH = disabled, STO = 0.1 sec.   */\n\n\tif (bootverbose >= 2) {\n\t\tprintf (\"\\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\\n\",\n\t\t\tnp->rv_scntl3, np->rv_dmode, np->rv_dcntl);\n\t\tprintf (\"\\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\\n\",\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\t/*\n\t**    Enable GPIO0 pin for writing if LED support.\n\t*/\n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t/*\n\t**\tReinitialize usrsync.\n\t**\tHave to renegotiate synch mode.\n\t*/\n\n\tusrsync = 255;\n\tif (SCSI_NCR_DFLT_SYNC) {\n\t\tusrsync = SCSI_NCR_DFLT_SYNC;\n\t\tif (usrsync > np->maxsync)\n\t\t\tusrsync = np->maxsync;\n\t\tif (usrsync < np->minsync)\n\t\t\tusrsync = np->minsync;\n\t};\n\n\t/*\n\t**\tReinitialize usrwide.\n\t**\tHave to renegotiate wide mode.\n\t*/\n\n\tusrwide = (SCSI_NCR_MAX_WIDE);\n\tif (usrwide > np->maxwide) usrwide=np->maxwide;\n\n\t/*\n\t**\tDisable disconnects.\n\t*/\n\n\tnp->disc = 0;\n\n\t/*\n\t**\tFill in target structure.\n\t*/\n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\ttcb_p tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\ttp->usrsync = usrsync;\n\t\ttp->usrwide = usrwide;\n\n\t\tncr_negotiate (np, tp);\n\t}\n\n\t/*\n\t**      enable ints\n\t*/\n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t/*\n\t**    Start script processor.\n\t*/\n\n\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define bootverbose\t0",
            "#define bootverbose\tNCR_VERBOSE",
            "#define MAX_START   (256)",
            "#define MAX_TARGET  (16)",
            "#define SCSI_NCR_MAX_WIDE   (1)",
            "#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)",
            "#define\tSCSI_NCR_DFLT_SYNC 0",
            "#define SCSI_NCR_DFLT_SYNC   (10)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n#define MAX_START   (256)\n#define MAX_TARGET  (16)\n#define SCSI_NCR_MAX_WIDE   (1)\n#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)\n#define\tSCSI_NCR_DFLT_SYNC 0\n#define SCSI_NCR_DFLT_SYNC   (10)\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\n\nvoid ncr_init (ncb_p np, char * msg, u_long code)\n{\n\tint\ti;\n\tu_long\tusrsync;\n\tu_char\tusrwide;\n\n\t/*\n\t**\tReset chip.\n\t*/\n\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat, 0);\n\n\t/*\n\t**\tMessage.\n\t*/\n\n\tif (msg) printf (\"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t/*\n\t**\tClear Start Queue\n\t*/\n\n\tfor (i=0;i<MAX_START;i++)\n\t\tnp -> squeue [i] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\n\tnp->squeueput = 0;\n\tWRITESCRIPT(startpos[0], NCB_SCRIPTH_PHYS (np, tryloop));\n\tWRITESCRIPT(start0  [0], SCR_INT ^ IFFALSE (0));\n\n\t/*\n\t**\tWakeup all pending jobs.\n\t*/\n\n\tncr_wakeup (np, code);\n\n\t/*\n\t**\tInit chip.\n\t*/\n\n\tOUTB (nc_istat,  0x00   );      /*  Remove Reset, abort ...\t     */\n\tOUTB (nc_scntl0, 0xca   );      /*  full arb., ena parity, par->ATN  */\n\tOUTB (nc_scntl1, 0x00\t);\t/*  odd parity, and remove CRST!!    */\n\tncr_selectclock(np, np->rv_scntl3); /* Select SCSI clock             */\n\tOUTB (nc_scid  , RRE|np->myaddr);/*  host adapter SCSI address       */\n\tOUTW (nc_respid, 1ul<<np->myaddr);/*  id to respond to\t\t     */\n\tOUTB (nc_istat , SIGP\t);\t/*  Signal Process\t\t     */\n\tOUTB (nc_dmode , np->rv_dmode);\t/* XXX modify burstlen ??? */\n\tOUTB (nc_dcntl , np->rv_dcntl);\n\tOUTB (nc_ctest3, np->rv_ctest3);\n\tOUTB (nc_ctest5, np->rv_ctest5);\n\tOUTB (nc_ctest4, np->rv_ctest4);/*  enable master parity checking    */\n\tOUTB (nc_stest2, np->rv_stest2|EXT); /* Extended Sreq/Sack filtering */\n\tOUTB (nc_stest3, TE     );\t/*  TolerANT enable\t\t     */\n\tOUTB (nc_stime0, 0x0b\t);\t/*  HTH = disabled, STO = 0.1 sec.   */\n\n\tif (bootverbose >= 2) {\n\t\tprintf (\"\\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\\n\",\n\t\t\tnp->rv_scntl3, np->rv_dmode, np->rv_dcntl);\n\t\tprintf (\"\\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\\n\",\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\t/*\n\t**    Enable GPIO0 pin for writing if LED support.\n\t*/\n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t/*\n\t**\tReinitialize usrsync.\n\t**\tHave to renegotiate synch mode.\n\t*/\n\n\tusrsync = 255;\n\tif (SCSI_NCR_DFLT_SYNC) {\n\t\tusrsync = SCSI_NCR_DFLT_SYNC;\n\t\tif (usrsync > np->maxsync)\n\t\t\tusrsync = np->maxsync;\n\t\tif (usrsync < np->minsync)\n\t\t\tusrsync = np->minsync;\n\t};\n\n\t/*\n\t**\tReinitialize usrwide.\n\t**\tHave to renegotiate wide mode.\n\t*/\n\n\tusrwide = (SCSI_NCR_MAX_WIDE);\n\tif (usrwide > np->maxwide) usrwide=np->maxwide;\n\n\t/*\n\t**\tDisable disconnects.\n\t*/\n\n\tnp->disc = 0;\n\n\t/*\n\t**\tFill in target structure.\n\t*/\n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\ttcb_p tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\ttp->usrsync = usrsync;\n\t\ttp->usrwide = usrwide;\n\n\t\tncr_negotiate (np, tp);\n\t}\n\n\t/*\n\t**      enable ints\n\t*/\n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t/*\n\t**    Start script processor.\n\t*/\n\n\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, start)"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "start"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT",
          "args": [
            "startpos[0]",
            "scratcha"
          ],
          "line": 6306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "tryloop"
          ],
          "line": 6301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_scratcha"
          ],
          "line": 6300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_complete",
          "args": [
            "np",
            "cp"
          ],
          "line": 6293
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "4893-5151",
          "snippet": "void ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  xerr_status   phys.xerr_st",
            "#define  parity_status phys.header.status[3]",
            "#define  scsi_status   phys.header.status[2]",
            "#define  host_status   phys.header.status[1]",
            "#define\tUF_TRACE\t(0x01)",
            "#define CCB_MAGIC\t(0xf2691ad2)",
            "#define\tQUIRK_UPDATE\t(0x80)",
            "#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */",
            "#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */",
            "#define\tXE_OK\t\t(0)",
            "#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */",
            "#define HS_TIMEOUT\t(8)\t/* Software timeout       */",
            "#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */",
            "#define HS_COMPLETE\t(4)",
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_TINY     (0x0080)",
            "#define DEBUG_RESULT   (0x0010)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;",
            "int\ti;",
            "register volatile u_int32_t data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  xerr_status   phys.xerr_st\n#define  parity_status phys.header.status[3]\n#define  scsi_status   phys.header.status[2]\n#define  host_status   phys.header.status[1]\n#define\tUF_TRACE\t(0x01)\n#define CCB_MAGIC\t(0xf2691ad2)\n#define\tQUIRK_UPDATE\t(0x80)\n#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */\n#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */\n#define\tXE_OK\t\t(0)\n#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */\n#define HS_TIMEOUT\t(8)\t/* Software timeout       */\n#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */\n#define HS_COMPLETE\t(4)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_RESULT   (0x0010)\n\nncb_p np = (void *)self;\nu_long\tperiod;\nint\ti;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\nint\ti;\nregister volatile u_int32_t data;\n\nvoid ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "phys"
          ],
          "line": 6288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsa"
          ],
          "line": 6286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"T\""
          ],
          "line": 6280
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  host_status   phys.header.status[1]\n#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */\n#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n#define MAX_START   (256)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nvoid ncr_int_sto (ncb_p np)\n{\n\tu_long dsa, scratcha, diff;\n\tccb_p cp;\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"T\");\n\n\t/*\n\t**\tlook for ccb and set the status.\n\t*/\n\n\tdsa = INL (nc_dsa);\n\tcp = np->ccb;\n\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\tcp = cp->link_ccb;\n\n\tif (cp) {\n\t\tcp-> host_status = HS_SEL_TIMEOUT;\n\t\tncr_complete (np, cp);\n\t};\n\n\t/*\n\t**\trepair start queue\n\t*/\n\n\tscratcha = INL (nc_scratcha);\n\tdiff = scratcha - NCB_SCRIPTH_PHYS (np, tryloop);\n\n/*\tassert ((diff <= MAX_START * 20) && !(diff % 20));*/\n\n\tif ((diff <= MAX_START * 20) && !(diff % 20)) {\n\t\tWRITESCRIPT(startpos[0], scratcha);\n\t\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n\t\treturn;\n\t};\n\tncr_init (np, \"selection timeout\", HS_FAIL);\n}"
  },
  {
    "function_name": "ncr_log_hard_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5909-5956",
    "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "int\ti;",
      "u_int8_t\tistat, dstat;",
      "u_int16_t\tsist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\".\\n\""
          ],
          "line": 5955
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INB_OFF",
          "args": [
            "i"
          ],
          "line": 5954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 5952
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READSCRIPT_OFF",
          "args": [
            "script_base",
            "script_ofs"
          ],
          "line": 5949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dbc"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_scntl3"
          ],
          "line": 5943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sxfer"
          ],
          "line": 5943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sbdl"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sbcl"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_socl"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sdid"
          ],
          "line": 5941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsp"
          ],
          "line": 5918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
  },
  {
    "function_name": "ncr_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5759-5877",
    "snippet": "static void ncr_timeout (void *arg)\n{\n\tncb_p\tnp = arg;\n#ifdef __OpenBSD__\n\tu_long\tthistime = mono_time.tv_sec;\n#else\n\tu_long\tthistime = time.tv_sec;\n#endif\n\tu_long\tstep  = np->ticks;\n\tu_long\tcount = 0;\n\tlong signed   t;\n\tccb_p cp;\n\n\tif (np->lasttime != thistime) {\n\t\t/*\n\t\t**\tblock ncr interrupts\n\t\t*/\n\t\tint oldspl = splbio();\n\t\tnp->lasttime = thistime;\n\n\t\tncr_usercmd (np);\n\n\t\t/*----------------------------------------------------\n\t\t**\n\t\t**\thandle ncr chip timeouts\n\t\t**\n\t\t**\tAssumption:\n\t\t**\tWe have a chance to arbitrate for the\n\t\t**\tSCSI bus at least every 10 seconds.\n\t\t**\n\t\t**----------------------------------------------------\n\t\t*/\n\n\t\tt = thistime - np->heartbeat;\n\n\t\tif (t<2) np->latetime=0; else np->latetime++;\n\n\t\tif (np->latetime>2) {\n\t\t\t/*\n\t\t\t**      If there are no requests, the script\n\t\t\t**      processor will sleep on SEL_WAIT_RESEL.\n\t\t\t**      But we have to check whether it died.\n\t\t\t**      Let's try to wake it up.\n\t\t\t*/\n\t\t\tOUTB (nc_istat, SIGP);\n\t\t};\n\n\t\t/*----------------------------------------------------\n\t\t**\n\t\t**\thandle ccb timeouts\n\t\t**\n\t\t**----------------------------------------------------\n\t\t*/\n\n\t\tfor (cp=np->ccb; cp; cp=cp->link_ccb) {\n\t\t\t/*\n\t\t\t**\tlook for timed out ccbs.\n\t\t\t*/\n\t\t\tif (!cp->host_status) continue;\n\t\t\tcount++;\n\t\t\tif (cp->tlimit > thistime) continue;\n\n\t\t\t/*\n\t\t\t**\tDisable reselect.\n\t\t\t**      Remove it from startqueue.\n\t\t\t*/\n\t\t\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\t\t\tif (cp->phys.header.launch.l_paddr ==\n\t\t\t\tSCR_BO(NCB_SCRIPT_PHYS (np, select))) {\n\t\t\t\tprintf (\"%s: timeout ccb=%p (skip)\\n\",\n\t\t\t\t\tncr_name (np), cp);\n\t\t\t\tcp->phys.header.launch.l_paddr\n\t\t\t\t= SCR_BO(NCB_SCRIPT_PHYS (np, skip));\n\t\t\t};\n\n\t\t\tswitch (cp->host_status) {\n\n\t\t\tcase HS_BUSY:\n\t\t\tcase HS_NEGOTIATE:\n\t\t\t\t/*\n\t\t\t\t** still in start queue ?\n\t\t\t\t*/\n\t\t\t\tif (cp->phys.header.launch.l_paddr ==\n\t\t\t\t\tSCR_BO(NCB_SCRIPT_PHYS (np, skip)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* fall through */\n\t\t\tcase HS_DISCONNECT:\n\t\t\t\tcp->host_status=HS_TIMEOUT;\n\t\t\t};\n\t\t\tcp->tag = 0;\n\n\t\t\t/*\n\t\t\t**\twakeup this ccb.\n\t\t\t*/\n\t\t\tncr_complete (np, cp);\n\t\t};\n\t\tsplx (oldspl);\n\t}\n\n#ifdef __FreeBSD__\n\tnp->timeout_ch = timeout (ncr_timeout, (caddr_t) np, step ? step : 1);\n#else\n\ttimeout (ncr_timeout, (caddr_t) np, step ? step : 1);\n#endif\n\n\tif (INB(nc_istat) & (INTF|SIP|DIP)) {\n\n\t\t/*\n\t\t**\tProcess pending interrupts.\n\t\t*/\n\n\t\tint\toldspl\t= splbio ();\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"{\");\n\t\tncr_exception (np);\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"}\");\n\t\tsplx (oldspl);\n\t};\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  host_status   phys.header.status[1]",
      "#define HS_TIMEOUT\t(8)\t/* Software timeout       */",
      "#define HS_DISCONNECT\t(3)\t/* Disconnected by target */",
      "#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/",
      "#define HS_BUSY\t\t(1)",
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TINY     (0x0080)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 5875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"}\""
          ],
          "line": 5874
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_exception",
          "args": [
            "np"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 5871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_istat"
          ],
          "line": 5865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ncr_timeout",
            "(caddr_t) np",
            "step ? step : 1"
          ],
          "line": 5862
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_complete",
          "args": [
            "np",
            "cp"
          ],
          "line": 5854
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "4893-5151",
          "snippet": "void ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  xerr_status   phys.xerr_st",
            "#define  parity_status phys.header.status[3]",
            "#define  scsi_status   phys.header.status[2]",
            "#define  host_status   phys.header.status[1]",
            "#define\tUF_TRACE\t(0x01)",
            "#define CCB_MAGIC\t(0xf2691ad2)",
            "#define\tQUIRK_UPDATE\t(0x80)",
            "#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */",
            "#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */",
            "#define\tXE_OK\t\t(0)",
            "#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */",
            "#define HS_TIMEOUT\t(8)\t/* Software timeout       */",
            "#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */",
            "#define HS_COMPLETE\t(4)",
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_TINY     (0x0080)",
            "#define DEBUG_RESULT   (0x0010)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;",
            "int\ti;",
            "register volatile u_int32_t data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  xerr_status   phys.xerr_st\n#define  parity_status phys.header.status[3]\n#define  scsi_status   phys.header.status[2]\n#define  host_status   phys.header.status[1]\n#define\tUF_TRACE\t(0x01)\n#define CCB_MAGIC\t(0xf2691ad2)\n#define\tQUIRK_UPDATE\t(0x80)\n#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */\n#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */\n#define\tXE_OK\t\t(0)\n#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */\n#define HS_TIMEOUT\t(8)\t/* Software timeout       */\n#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */\n#define HS_COMPLETE\t(4)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_RESULT   (0x0010)\n\nncb_p np = (void *)self;\nu_long\tperiod;\nint\ti;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\nint\ti;\nregister volatile u_int32_t data;\n\nvoid ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, skip)"
          ],
          "line": 5842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "skip"
          ],
          "line": 5842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, skip)"
          ],
          "line": 5831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "skip"
          ],
          "line": 5831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 5829
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, select)"
          ],
          "line": 5827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "select"
          ],
          "line": 5827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_JUMP)"
          ],
          "line": 5825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "SIGP"
          ],
          "line": 5803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_usercmd",
          "args": [
            "np"
          ],
          "line": 5779
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_usercmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5682-5740",
          "snippet": "static void ncr_usercmd (ncb_p np)\n{\n\tu_char t;\n\ttcb_p tp;\n\n\tswitch (np->user.cmd) {\n\n\tcase 0: return;\n\n\tcase UC_SETSYNC:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrsync = np->user.data;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETTAGS:\n\t\tif (np->user.data > MAX_TAGS)\n\t\t\tbreak;\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrtags = np->user.data;\n\t\t\tncr_setmaxtags (tp, tp->usrtags);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETDEBUG:\n\t\tncr_debug = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETORDER:\n\t\tnp->order = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETWIDE:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tu_long size;\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\tsize = np->user.data;\n\t\t\tif (size > np->maxwide) size=np->maxwide;\n\t\t\ttp->usrwide = size;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETFLAG:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrflag = np->user.data;\n\t\t};\n\t\tbreak;\n\t}\n\tnp->user.cmd=0;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define UC_SETFLAG\t15",
            "#define UC_SETWIDE\t14",
            "#define UC_SETORDER\t13",
            "#define UC_SETDEBUG\t12",
            "#define UC_SETTAGS\t11",
            "#define UC_SETSYNC      10",
            "#define\tMAX_TAGS\t(16)\t\t/* hard limit */",
            "#define MAX_TARGET  (16)"
          ],
          "globals_used": [
            "static int ncr_debug = SCSI_NCR_DEBUG;",
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;",
            "register volatile u_int32_t data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define UC_SETFLAG\t15\n#define UC_SETWIDE\t14\n#define UC_SETORDER\t13\n#define UC_SETDEBUG\t12\n#define UC_SETTAGS\t11\n#define UC_SETSYNC      10\n#define\tMAX_TAGS\t(16)\t\t/* hard limit */\n#define MAX_TARGET  (16)\n\nstatic int ncr_debug = SCSI_NCR_DEBUG;\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\nregister volatile u_int32_t data;\n\nstatic void ncr_usercmd (ncb_p np)\n{\n\tu_char t;\n\ttcb_p tp;\n\n\tswitch (np->user.cmd) {\n\n\tcase 0: return;\n\n\tcase UC_SETSYNC:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrsync = np->user.data;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETTAGS:\n\t\tif (np->user.data > MAX_TAGS)\n\t\t\tbreak;\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrtags = np->user.data;\n\t\t\tncr_setmaxtags (tp, tp->usrtags);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETDEBUG:\n\t\tncr_debug = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETORDER:\n\t\tnp->order = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETWIDE:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tu_long size;\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\tsize = np->user.data;\n\t\t\tif (size > np->maxwide) size=np->maxwide;\n\t\t\ttp->usrwide = size;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETFLAG:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrflag = np->user.data;\n\t\t};\n\t\tbreak;\n\t}\n\tnp->user.cmd=0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 5776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  host_status   phys.header.status[1]\n#define HS_TIMEOUT\t(8)\t/* Software timeout       */\n#define HS_DISCONNECT\t(3)\t/* Disconnected by target */\n#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/\n#define HS_BUSY\t\t(1)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void ncr_timeout (void *arg)\n{\n\tncb_p\tnp = arg;\n#ifdef __OpenBSD__\n\tu_long\tthistime = mono_time.tv_sec;\n#else\n\tu_long\tthistime = time.tv_sec;\n#endif\n\tu_long\tstep  = np->ticks;\n\tu_long\tcount = 0;\n\tlong signed   t;\n\tccb_p cp;\n\n\tif (np->lasttime != thistime) {\n\t\t/*\n\t\t**\tblock ncr interrupts\n\t\t*/\n\t\tint oldspl = splbio();\n\t\tnp->lasttime = thistime;\n\n\t\tncr_usercmd (np);\n\n\t\t/*----------------------------------------------------\n\t\t**\n\t\t**\thandle ncr chip timeouts\n\t\t**\n\t\t**\tAssumption:\n\t\t**\tWe have a chance to arbitrate for the\n\t\t**\tSCSI bus at least every 10 seconds.\n\t\t**\n\t\t**----------------------------------------------------\n\t\t*/\n\n\t\tt = thistime - np->heartbeat;\n\n\t\tif (t<2) np->latetime=0; else np->latetime++;\n\n\t\tif (np->latetime>2) {\n\t\t\t/*\n\t\t\t**      If there are no requests, the script\n\t\t\t**      processor will sleep on SEL_WAIT_RESEL.\n\t\t\t**      But we have to check whether it died.\n\t\t\t**      Let's try to wake it up.\n\t\t\t*/\n\t\t\tOUTB (nc_istat, SIGP);\n\t\t};\n\n\t\t/*----------------------------------------------------\n\t\t**\n\t\t**\thandle ccb timeouts\n\t\t**\n\t\t**----------------------------------------------------\n\t\t*/\n\n\t\tfor (cp=np->ccb; cp; cp=cp->link_ccb) {\n\t\t\t/*\n\t\t\t**\tlook for timed out ccbs.\n\t\t\t*/\n\t\t\tif (!cp->host_status) continue;\n\t\t\tcount++;\n\t\t\tif (cp->tlimit > thistime) continue;\n\n\t\t\t/*\n\t\t\t**\tDisable reselect.\n\t\t\t**      Remove it from startqueue.\n\t\t\t*/\n\t\t\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\t\t\tif (cp->phys.header.launch.l_paddr ==\n\t\t\t\tSCR_BO(NCB_SCRIPT_PHYS (np, select))) {\n\t\t\t\tprintf (\"%s: timeout ccb=%p (skip)\\n\",\n\t\t\t\t\tncr_name (np), cp);\n\t\t\t\tcp->phys.header.launch.l_paddr\n\t\t\t\t= SCR_BO(NCB_SCRIPT_PHYS (np, skip));\n\t\t\t};\n\n\t\t\tswitch (cp->host_status) {\n\n\t\t\tcase HS_BUSY:\n\t\t\tcase HS_NEGOTIATE:\n\t\t\t\t/*\n\t\t\t\t** still in start queue ?\n\t\t\t\t*/\n\t\t\t\tif (cp->phys.header.launch.l_paddr ==\n\t\t\t\t\tSCR_BO(NCB_SCRIPT_PHYS (np, skip)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* fall through */\n\t\t\tcase HS_DISCONNECT:\n\t\t\t\tcp->host_status=HS_TIMEOUT;\n\t\t\t};\n\t\t\tcp->tag = 0;\n\n\t\t\t/*\n\t\t\t**\twakeup this ccb.\n\t\t\t*/\n\t\t\tncr_complete (np, cp);\n\t\t};\n\t\tsplx (oldspl);\n\t}\n\n#ifdef __FreeBSD__\n\tnp->timeout_ch = timeout (ncr_timeout, (caddr_t) np, step ? step : 1);\n#else\n\ttimeout (ncr_timeout, (caddr_t) np, step ? step : 1);\n#endif\n\n\tif (INB(nc_istat) & (INTF|SIP|DIP)) {\n\n\t\t/*\n\t\t**\tProcess pending interrupts.\n\t\t*/\n\n\t\tint\toldspl\t= splbio ();\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"{\");\n\t\tncr_exception (np);\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"}\");\n\t\tsplx (oldspl);\n\t};\n}"
  },
  {
    "function_name": "ncr_usercmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5682-5740",
    "snippet": "static void ncr_usercmd (ncb_p np)\n{\n\tu_char t;\n\ttcb_p tp;\n\n\tswitch (np->user.cmd) {\n\n\tcase 0: return;\n\n\tcase UC_SETSYNC:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrsync = np->user.data;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETTAGS:\n\t\tif (np->user.data > MAX_TAGS)\n\t\t\tbreak;\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrtags = np->user.data;\n\t\t\tncr_setmaxtags (tp, tp->usrtags);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETDEBUG:\n\t\tncr_debug = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETORDER:\n\t\tnp->order = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETWIDE:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tu_long size;\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\tsize = np->user.data;\n\t\t\tif (size > np->maxwide) size=np->maxwide;\n\t\t\ttp->usrwide = size;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETFLAG:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrflag = np->user.data;\n\t\t};\n\t\tbreak;\n\t}\n\tnp->user.cmd=0;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define UC_SETFLAG\t15",
      "#define UC_SETWIDE\t14",
      "#define UC_SETORDER\t13",
      "#define UC_SETDEBUG\t12",
      "#define UC_SETTAGS\t11",
      "#define UC_SETSYNC      10",
      "#define\tMAX_TAGS\t(16)\t\t/* hard limit */",
      "#define MAX_TARGET  (16)"
    ],
    "globals_used": [
      "static int ncr_debug = SCSI_NCR_DEBUG;",
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_negotiate",
          "args": [
            "np",
            "tp"
          ],
          "line": 5727
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_negotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5350-5393",
          "snippet": "static void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_setmaxtags",
          "args": [
            "tp",
            "tp->usrtags"
          ],
          "line": 5707
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define UC_SETFLAG\t15\n#define UC_SETWIDE\t14\n#define UC_SETORDER\t13\n#define UC_SETDEBUG\t12\n#define UC_SETTAGS\t11\n#define UC_SETSYNC      10\n#define\tMAX_TAGS\t(16)\t\t/* hard limit */\n#define MAX_TARGET  (16)\n\nstatic int ncr_debug = SCSI_NCR_DEBUG;\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\nregister volatile u_int32_t data;\n\nstatic void ncr_usercmd (ncb_p np)\n{\n\tu_char t;\n\ttcb_p tp;\n\n\tswitch (np->user.cmd) {\n\n\tcase 0: return;\n\n\tcase UC_SETSYNC:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrsync = np->user.data;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETTAGS:\n\t\tif (np->user.data > MAX_TAGS)\n\t\t\tbreak;\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrtags = np->user.data;\n\t\t\tncr_setmaxtags (tp, tp->usrtags);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETDEBUG:\n\t\tncr_debug = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETORDER:\n\t\tnp->order = np->user.data;\n\t\tbreak;\n\n\tcase UC_SETWIDE:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tu_long size;\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\tsize = np->user.data;\n\t\t\tif (size > np->maxwide) size=np->maxwide;\n\t\t\ttp->usrwide = size;\n\t\t\tncr_negotiate (np, tp);\n\t\t};\n\t\tbreak;\n\n\tcase UC_SETFLAG:\n\t\tfor (t=0; t<MAX_TARGET; t++) {\n\t\t\tif (!((np->user.target>>t)&1)) continue;\n\t\t\ttp = &np->target[t];\n\t\t\ttp->usrflag = np->user.data;\n\t\t};\n\t\tbreak;\n\t}\n\tnp->user.cmd=0;\n}"
  },
  {
    "function_name": "ncr_settags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5632-5673",
    "snippet": "static void ncr_settags (tcb_p tp, lcb_p lp, u_long usrtags)\n{\n\tu_char reqtags, tmp;\n\n\tif ((!tp) || (!lp)) return;\n\n\t/*\n\t**\tonly devices capable of tagges commands\n\t**\tonly disk devices\n\t**\tonly if enabled by user ..\n\t*/\n\tif ((tp->inqdata[0] & 0x1f) != 0x00\n\t    || (tp->inqdata[7] & INQ7_QUEUE) == 0\n\t    || (tp->quirks & QUIRK_NOTAGS) != 0) {\n\t    usrtags=0;\n\t}\n\tif (usrtags) {\n\t\treqtags = usrtags;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=reqtags;\n\t} else {\n\t\treqtags = 1;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=0;\n\t};\n\n\t/*\n\t**\tdon't announce more than available.\n\t*/\n\ttmp = lp->actccbs;\n\tif (tmp > reqtags) tmp = reqtags;\n\tlp->reqlink = tmp;\n\n\t/*\n\t**\tdon't discard if announced.\n\t*/\n\ttmp = lp->actlink;\n\tif (tmp < reqtags) tmp = reqtags;\n\tlp->reqccbs = tmp;\n\tif (lp->reqlink < lp->reqccbs)\n\t\tlp->reqlink = lp->reqccbs;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define\tINQ7_QUEUE\t(0x02)",
      "#define QUIRK_NOTAGS\t(0x40)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define\tINQ7_QUEUE\t(0x02)\n#define QUIRK_NOTAGS\t(0x40)\n\nstatic void ncr_settags (tcb_p tp, lcb_p lp, u_long usrtags)\n{\n\tu_char reqtags, tmp;\n\n\tif ((!tp) || (!lp)) return;\n\n\t/*\n\t**\tonly devices capable of tagges commands\n\t**\tonly disk devices\n\t**\tonly if enabled by user ..\n\t*/\n\tif ((tp->inqdata[0] & 0x1f) != 0x00\n\t    || (tp->inqdata[7] & INQ7_QUEUE) == 0\n\t    || (tp->quirks & QUIRK_NOTAGS) != 0) {\n\t    usrtags=0;\n\t}\n\tif (usrtags) {\n\t\treqtags = usrtags;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=reqtags;\n\t} else {\n\t\treqtags = 1;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=0;\n\t};\n\n\t/*\n\t**\tdon't announce more than available.\n\t*/\n\ttmp = lp->actccbs;\n\tif (tmp > reqtags) tmp = reqtags;\n\tlp->reqlink = tmp;\n\n\t/*\n\t**\tdon't discard if announced.\n\t*/\n\ttmp = lp->actlink;\n\tif (tmp < reqtags) tmp = reqtags;\n\tlp->reqccbs = tmp;\n\tif (lp->reqlink < lp->reqccbs)\n\t\tlp->reqlink = lp->reqccbs;\n}"
  },
  {
    "function_name": "ncr_setmaxtags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5620-5630",
    "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define MAX_LUN     (8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_settags",
          "args": [
            "tp",
            "lp",
            "usrtags"
          ],
          "line": 5628
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_settags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5632-5673",
          "snippet": "static void ncr_settags (tcb_p tp, lcb_p lp, u_long usrtags)\n{\n\tu_char reqtags, tmp;\n\n\tif ((!tp) || (!lp)) return;\n\n\t/*\n\t**\tonly devices capable of tagges commands\n\t**\tonly disk devices\n\t**\tonly if enabled by user ..\n\t*/\n\tif ((tp->inqdata[0] & 0x1f) != 0x00\n\t    || (tp->inqdata[7] & INQ7_QUEUE) == 0\n\t    || (tp->quirks & QUIRK_NOTAGS) != 0) {\n\t    usrtags=0;\n\t}\n\tif (usrtags) {\n\t\treqtags = usrtags;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=reqtags;\n\t} else {\n\t\treqtags = 1;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=0;\n\t};\n\n\t/*\n\t**\tdon't announce more than available.\n\t*/\n\ttmp = lp->actccbs;\n\tif (tmp > reqtags) tmp = reqtags;\n\tlp->reqlink = tmp;\n\n\t/*\n\t**\tdon't discard if announced.\n\t*/\n\ttmp = lp->actlink;\n\tif (tmp < reqtags) tmp = reqtags;\n\tlp->reqccbs = tmp;\n\tif (lp->reqlink < lp->reqccbs)\n\t\tlp->reqlink = lp->reqccbs;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define\tINQ7_QUEUE\t(0x02)",
            "#define QUIRK_NOTAGS\t(0x40)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define\tINQ7_QUEUE\t(0x02)\n#define QUIRK_NOTAGS\t(0x40)\n\nstatic void ncr_settags (tcb_p tp, lcb_p lp, u_long usrtags)\n{\n\tu_char reqtags, tmp;\n\n\tif ((!tp) || (!lp)) return;\n\n\t/*\n\t**\tonly devices capable of tagges commands\n\t**\tonly disk devices\n\t**\tonly if enabled by user ..\n\t*/\n\tif ((tp->inqdata[0] & 0x1f) != 0x00\n\t    || (tp->inqdata[7] & INQ7_QUEUE) == 0\n\t    || (tp->quirks & QUIRK_NOTAGS) != 0) {\n\t    usrtags=0;\n\t}\n\tif (usrtags) {\n\t\treqtags = usrtags;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=reqtags;\n\t} else {\n\t\treqtags = 1;\n\t\tif (lp->actlink <= 1)\n\t\t\tlp->usetags=0;\n\t};\n\n\t/*\n\t**\tdon't announce more than available.\n\t*/\n\ttmp = lp->actccbs;\n\tif (tmp > reqtags) tmp = reqtags;\n\tlp->reqlink = tmp;\n\n\t/*\n\t**\tdon't discard if announced.\n\t*/\n\ttmp = lp->actlink;\n\tif (tmp < reqtags) tmp = reqtags;\n\tlp->reqccbs = tmp;\n\tif (lp->reqlink < lp->reqccbs)\n\t\tlp->reqlink = lp->reqccbs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
  },
  {
    "function_name": "ncr_setwide",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5556-5611",
    "snippet": "static void ncr_setwide (ncb_p np, ccb_p cp, u_char wide, u_char ack)\n{\n\tstruct scsi_xfer *xp;\n\tu_short target = INB (nc_sdid) & 0x0f;\n\ttcb_p tp;\n\tu_char\tscntl3;\n\tu_char\tsxfer;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\ttp->widedone  =  wide+1;\n\tscntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);\n\n\tsxfer = ack ? 0 : tp->sval;\n\n\t/*\n\t**\t Stop there if sync/wide parameters are unchanged\n\t*/\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (scntl3 & EWS)\n\t\tprintf (\"WIDE SCSI (16 bit) enabled\\n\");\n\telse\n\t\tprintf (\"WIDE SCSI disabled\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  wide_status   phys.wide_st",
      "#define  sync_status   phys.sync_st",
      "#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */",
      "#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl3",
            "scntl3"
          ],
          "line": 5599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_sxfer",
            "sxfer"
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WIDE SCSI disabled\\n\""
          ],
          "line": 5592
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "target == (xp->sc_link->target & 0x0f)"
          ],
          "line": 5570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xp"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cp"
          ],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sdid"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  wide_status   phys.wide_st\n#define  sync_status   phys.sync_st\n#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */\n#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void ncr_setwide (ncb_p np, ccb_p cp, u_char wide, u_char ack)\n{\n\tstruct scsi_xfer *xp;\n\tu_short target = INB (nc_sdid) & 0x0f;\n\ttcb_p tp;\n\tu_char\tscntl3;\n\tu_char\tsxfer;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\ttp->widedone  =  wide+1;\n\tscntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);\n\n\tsxfer = ack ? 0 : tp->sval;\n\n\t/*\n\t**\t Stop there if sync/wide parameters are unchanged\n\t*/\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (scntl3 & EWS)\n\t\tprintf (\"WIDE SCSI (16 bit) enabled\\n\");\n\telse\n\t\tprintf (\"WIDE SCSI disabled\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}"
  },
  {
    "function_name": "ncr_setsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5472-5544",
    "snippet": "static void ncr_setsync (ncb_p np, ccb_p cp, u_char scntl3, u_char sxfer)\n{\n\tstruct scsi_xfer *xp;\n\ttcb_p tp;\n\tint div;\n\tu_char target = INB (nc_sdid) & 0x0f;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\n\tif (!scntl3 || !(sxfer & 0x1f))\n\t\tscntl3 = np->rv_scntl3;\n\tscntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);\n\n\t/*\n\t**\tDeduce the value of controller sync period from scntl3.\n\t**\tperiod is in tenths of nano-seconds.\n\t*/\n\n\tdiv = ((scntl3 >> 4) & 0x7);\n\tif ((sxfer & 0x1f) && div)\n\t\ttp->period = (((sxfer>>5)+4)*div_10M[div-1])/np->clock_khz;\n\telse\n\t\ttp->period = 0xffff;\n\n\t/*\n\t**\t Stop there if sync parameters are unchanged\n\t*/\n\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (sxfer & 0x1f) {\n\t\tunsigned f10 = 100000 << (tp->widedone ? tp->widedone -1 : 0);\n\t\tunsigned mb10 = (f10 + tp->period/2) / tp->period;\n\t\t/*\n\t\t**  Disable extended Sreq/Sack filtering\n\t\t*/\n\t\tif (tp->period <= 2000) OUTOFFB (nc_stest2, EXT);\n\t\tprintf (\"%d.%d MB/s (%d ns, offset %d)\\n\",\n\t\t\tmb10 / 10, mb10 % 10, tp->period / 10, sxfer & 0x1f);\n\t} else  printf (\"asynchronous.\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  wide_status   phys.wide_st",
      "#define  sync_status   phys.sync_st",
      "#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */",
      "#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */"
    ],
    "globals_used": [
      "static u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};",
      "ncb_p np = (void *)self;",
      "u_long\tperiod;",
      "ncb_p np = (struct ncb*) 0;",
      "u_long\tperiod;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl3",
            "scntl3"
          ],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_sxfer",
            "sxfer"
          ],
          "line": 5530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"asynchronous.\\n\""
          ],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTOFFB",
          "args": [
            "nc_stest2",
            "EXT"
          ],
          "line": 5522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 5515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "target == (xp->sc_link->target & 0x0f)"
          ],
          "line": 5485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xp"
          ],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cp"
          ],
          "line": 5479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_sdid"
          ],
          "line": 5477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  wide_status   phys.wide_st\n#define  sync_status   phys.sync_st\n#define  wide_st       header.status[7]\t/* MUST be ==3 mod 4 */\n#define  sync_st       header.status[5]\t/* MUST be ==1 mod 4 */\n\nstatic u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_setsync (ncb_p np, ccb_p cp, u_char scntl3, u_char sxfer)\n{\n\tstruct scsi_xfer *xp;\n\ttcb_p tp;\n\tint div;\n\tu_char target = INB (nc_sdid) & 0x0f;\n\n\tassert (cp);\n\tif (!cp) return;\n\n\txp = cp->xfer;\n\tassert (xp);\n\tif (!xp) return;\n\tassert (target == (xp->sc_link->target & 0x0f));\n\n\ttp = &np->target[target];\n\n\tif (!scntl3 || !(sxfer & 0x1f))\n\t\tscntl3 = np->rv_scntl3;\n\tscntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);\n\n\t/*\n\t**\tDeduce the value of controller sync period from scntl3.\n\t**\tperiod is in tenths of nano-seconds.\n\t*/\n\n\tdiv = ((scntl3 >> 4) & 0x7);\n\tif ((sxfer & 0x1f) && div)\n\t\ttp->period = (((sxfer>>5)+4)*div_10M[div-1])/np->clock_khz;\n\telse\n\t\ttp->period = 0xffff;\n\n\t/*\n\t**\t Stop there if sync parameters are unchanged\n\t*/\n\n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t/*\n\t**\tBells and whistles   ;-)\n\t*/\n\tPRINT_ADDR(xp);\n\tif (sxfer & 0x1f) {\n\t\tunsigned f10 = 100000 << (tp->widedone ? tp->widedone -1 : 0);\n\t\tunsigned mb10 = (f10 + tp->period/2) / tp->period;\n\t\t/*\n\t\t**  Disable extended Sreq/Sack filtering\n\t\t*/\n\t\tif (tp->period <= 2000) OUTOFFB (nc_stest2, EXT);\n\t\tprintf (\"%d.%d MB/s (%d ns, offset %d)\\n\",\n\t\t\tmb10 / 10, mb10 % 10, tp->period / 10, sxfer & 0x1f);\n\t} else  printf (\"asynchronous.\\n\");\n\n\t/*\n\t**\tset actual value and sync_status\n\t*/\n\tOUTB (nc_sxfer, sxfer);\n\tnp->sync_st = sxfer;\n\tOUTB (nc_scntl3, scntl3);\n\tnp->wide_st = scntl3;\n\n\t/*\n\t**\tpatch ALL ccbs of this target.\n\t*/\n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->xfer) continue;\n\t\tif (cp->xfer->sc_link->target != target) continue;\n\t\tcp->sync_status = sxfer;\n\t\tcp->wide_status = scntl3;\n\t};\n}"
  },
  {
    "function_name": "ncr_getsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5405-5463",
    "snippet": "static void ncr_getsync(ncb_p np, u_char sfac, u_char *fakp, u_char *scntl3p)\n{\n\tu_long\tclk = np->clock_khz;\t/* SCSI clock frequency in kHz\t*/\n\tint\tdiv = np->clock_divn;\t/* Number of divisors supported\t*/\n\tu_long\tfak;\t\t\t/* Sync factor in sxfer\t\t*/\n\tu_long\tper;\t\t\t/* Period in tenths of ns\t*/\n\tu_long\tkpc;\t\t\t/* (per * clk)\t\t\t*/\n\n\t/*\n\t**\tCompute the synchronous period in tenths of nano-seconds\n\t*/\n\tif\t(sfac <= 10)\tper = 250;\n\telse if\t(sfac == 11)\tper = 303;\n\telse if\t(sfac == 12)\tper = 500;\n\telse\t\t\tper = 40 * sfac;\n\n\t/*\n\t**\tLook for the greatest clock divisor that allows an\n\t**\tinput speed faster than the period.\n\t*/\n\tkpc = per * clk;\n\twhile (--div >= 0)\n\t\tif (kpc >= (div_10M[div] * 4)) break;\n\n\t/*\n\t**\tCalculate the lowest clock factor that allows an output\n\t**\tspeed not faster than the period.\n\t*/\n\tfak = (kpc - 1) / div_10M[div] + 1;\n\n#if 0\t/* You can #if 1 if you think this optimization is usefull */\n\n\tper = (fak * div_10M[div]) / clk;\n\n\t/*\n\t**\tWhy not to try the immediate lower divisor and to choose\n\t**\tthe one that allows the fastest output speed ?\n\t**\tWe dont want input speed too much greater than output speed.\n\t*/\n\tif (div >= 1 && fak < 6) {\n\t\tu_long fak2, per2;\n\t\tfak2 = (kpc - 1) / div_10M[div-1] + 1;\n\t\tper2 = (fak2 * div_10M[div-1]) / clk;\n\t\tif (per2 < per && fak2 <= 6) {\n\t\t\tfak = fak2;\n\t\t\tper = per2;\n\t\t\t--div;\n\t\t}\n\t}\n#endif\n\n\tif (fak < 4) fak = 4;\t/* Should never happen, too bad ... */\n\n\t/*\n\t**\tCompute and return sync parameters for the ncr\n\t*/\n\t*fakp\t\t= fak - 4;\n\t*scntl3p\t= ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};",
      "ncb_p np = (void *)self;",
      "u_long\tperiod;",
      "ncb_p np = (struct ncb*) 0;",
      "u_long\tperiod;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_getsync(ncb_p np, u_char sfac, u_char *fakp, u_char *scntl3p)\n{\n\tu_long\tclk = np->clock_khz;\t/* SCSI clock frequency in kHz\t*/\n\tint\tdiv = np->clock_divn;\t/* Number of divisors supported\t*/\n\tu_long\tfak;\t\t\t/* Sync factor in sxfer\t\t*/\n\tu_long\tper;\t\t\t/* Period in tenths of ns\t*/\n\tu_long\tkpc;\t\t\t/* (per * clk)\t\t\t*/\n\n\t/*\n\t**\tCompute the synchronous period in tenths of nano-seconds\n\t*/\n\tif\t(sfac <= 10)\tper = 250;\n\telse if\t(sfac == 11)\tper = 303;\n\telse if\t(sfac == 12)\tper = 500;\n\telse\t\t\tper = 40 * sfac;\n\n\t/*\n\t**\tLook for the greatest clock divisor that allows an\n\t**\tinput speed faster than the period.\n\t*/\n\tkpc = per * clk;\n\twhile (--div >= 0)\n\t\tif (kpc >= (div_10M[div] * 4)) break;\n\n\t/*\n\t**\tCalculate the lowest clock factor that allows an output\n\t**\tspeed not faster than the period.\n\t*/\n\tfak = (kpc - 1) / div_10M[div] + 1;\n\n#if 0\t/* You can #if 1 if you think this optimization is usefull */\n\n\tper = (fak * div_10M[div]) / clk;\n\n\t/*\n\t**\tWhy not to try the immediate lower divisor and to choose\n\t**\tthe one that allows the fastest output speed ?\n\t**\tWe dont want input speed too much greater than output speed.\n\t*/\n\tif (div >= 1 && fak < 6) {\n\t\tu_long fak2, per2;\n\t\tfak2 = (kpc - 1) / div_10M[div-1] + 1;\n\t\tper2 = (fak2 * div_10M[div-1]) / clk;\n\t\tif (per2 < per && fak2 <= 6) {\n\t\t\tfak = fak2;\n\t\t\tper = per2;\n\t\t\t--div;\n\t\t}\n\t}\n#endif\n\n\tif (fak < 4) fak = 4;\t/* Should never happen, too bad ... */\n\n\t/*\n\t**\tCompute and return sync parameters for the ncr\n\t*/\n\t*fakp\t\t= fak - 4;\n\t*scntl3p\t= ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);\n}"
  },
  {
    "function_name": "ncr_negotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5350-5393",
    "snippet": "static void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "u_long\tperiod;",
      "ncb_p np = (struct ncb*) 0;",
      "u_long\tperiod;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}"
  },
  {
    "function_name": "ncr_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5208-5340",
    "snippet": "void ncr_init (ncb_p np, char * msg, u_long code)\n{\n\tint\ti;\n\tu_long\tusrsync;\n\tu_char\tusrwide;\n\n\t/*\n\t**\tReset chip.\n\t*/\n\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat, 0);\n\n\t/*\n\t**\tMessage.\n\t*/\n\n\tif (msg) printf (\"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t/*\n\t**\tClear Start Queue\n\t*/\n\n\tfor (i=0;i<MAX_START;i++)\n\t\tnp -> squeue [i] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\n\tnp->squeueput = 0;\n\tWRITESCRIPT(startpos[0], NCB_SCRIPTH_PHYS (np, tryloop));\n\tWRITESCRIPT(start0  [0], SCR_INT ^ IFFALSE (0));\n\n\t/*\n\t**\tWakeup all pending jobs.\n\t*/\n\n\tncr_wakeup (np, code);\n\n\t/*\n\t**\tInit chip.\n\t*/\n\n\tOUTB (nc_istat,  0x00   );      /*  Remove Reset, abort ...\t     */\n\tOUTB (nc_scntl0, 0xca   );      /*  full arb., ena parity, par->ATN  */\n\tOUTB (nc_scntl1, 0x00\t);\t/*  odd parity, and remove CRST!!    */\n\tncr_selectclock(np, np->rv_scntl3); /* Select SCSI clock             */\n\tOUTB (nc_scid  , RRE|np->myaddr);/*  host adapter SCSI address       */\n\tOUTW (nc_respid, 1ul<<np->myaddr);/*  id to respond to\t\t     */\n\tOUTB (nc_istat , SIGP\t);\t/*  Signal Process\t\t     */\n\tOUTB (nc_dmode , np->rv_dmode);\t/* XXX modify burstlen ??? */\n\tOUTB (nc_dcntl , np->rv_dcntl);\n\tOUTB (nc_ctest3, np->rv_ctest3);\n\tOUTB (nc_ctest5, np->rv_ctest5);\n\tOUTB (nc_ctest4, np->rv_ctest4);/*  enable master parity checking    */\n\tOUTB (nc_stest2, np->rv_stest2|EXT); /* Extended Sreq/Sack filtering */\n\tOUTB (nc_stest3, TE     );\t/*  TolerANT enable\t\t     */\n\tOUTB (nc_stime0, 0x0b\t);\t/*  HTH = disabled, STO = 0.1 sec.   */\n\n\tif (bootverbose >= 2) {\n\t\tprintf (\"\\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\\n\",\n\t\t\tnp->rv_scntl3, np->rv_dmode, np->rv_dcntl);\n\t\tprintf (\"\\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\\n\",\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\t/*\n\t**    Enable GPIO0 pin for writing if LED support.\n\t*/\n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t/*\n\t**\tReinitialize usrsync.\n\t**\tHave to renegotiate synch mode.\n\t*/\n\n\tusrsync = 255;\n\tif (SCSI_NCR_DFLT_SYNC) {\n\t\tusrsync = SCSI_NCR_DFLT_SYNC;\n\t\tif (usrsync > np->maxsync)\n\t\t\tusrsync = np->maxsync;\n\t\tif (usrsync < np->minsync)\n\t\t\tusrsync = np->minsync;\n\t};\n\n\t/*\n\t**\tReinitialize usrwide.\n\t**\tHave to renegotiate wide mode.\n\t*/\n\n\tusrwide = (SCSI_NCR_MAX_WIDE);\n\tif (usrwide > np->maxwide) usrwide=np->maxwide;\n\n\t/*\n\t**\tDisable disconnects.\n\t*/\n\n\tnp->disc = 0;\n\n\t/*\n\t**\tFill in target structure.\n\t*/\n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\ttcb_p tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\ttp->usrsync = usrsync;\n\t\ttp->usrwide = usrwide;\n\n\t\tncr_negotiate (np, tp);\n\t}\n\n\t/*\n\t**      enable ints\n\t*/\n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t/*\n\t**    Start script processor.\n\t*/\n\n\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define bootverbose\t0",
      "#define bootverbose\tNCR_VERBOSE",
      "#define MAX_START   (256)",
      "#define MAX_TARGET  (16)",
      "#define SCSI_NCR_MAX_WIDE   (1)",
      "#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)",
      "#define\tSCSI_NCR_DFLT_SYNC 0",
      "#define SCSI_NCR_DFLT_SYNC   (10)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "int\ti;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OUTL",
          "args": [
            "nc_dsp",
            "NCB_SCRIPT_PHYS (np, start)"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "start"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_dien",
            "MDPE|BF|ABRT|SSI|SIR|IID"
          ],
          "line": 5333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTW",
          "args": [
            "nc_sien",
            "STO|HTH|MA|SGE|UDC|RST"
          ],
          "line": 5332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_negotiate",
          "args": [
            "np",
            "tp"
          ],
          "line": 5325
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_negotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5350-5393",
          "snippet": "static void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTOFFB",
          "args": [
            "nc_gpcntl",
            "0x01"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\\n\"",
            "np->rv_ctest3",
            "np->rv_ctest4",
            "np->rv_ctest5"
          ],
          "line": 5272
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stime0",
            "0x0b"
          ],
          "line": 5267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest3",
            "TE"
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_stest2",
            "np->rv_stest2|EXT"
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_ctest4",
            "np->rv_ctest4"
          ],
          "line": 5264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_ctest5",
            "np->rv_ctest5"
          ],
          "line": 5263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_ctest3",
            "np->rv_ctest3"
          ],
          "line": 5262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_dcntl",
            "np->rv_dcntl"
          ],
          "line": 5261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_dmode",
            "np->rv_dmode"
          ],
          "line": 5260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "SIGP"
          ],
          "line": 5259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTW",
          "args": [
            "nc_respid",
            "1ul<<np->myaddr"
          ],
          "line": 5258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scid",
            "RRE|np->myaddr"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_selectclock",
          "args": [
            "np",
            "np->rv_scntl3"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_selectclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7831-7854",
          "snippet": "static void ncr_selectclock(ncb_p np, u_char scntl3)\n{\n\tif (np->multiplier < 2) {\n\t\tOUTB(nc_scntl3,\tscntl3);\n\t\treturn;\n\t}\n\n\tif (bootverbose >= 2)\n\t\tprintf (\"%s: enabling clock multiplier\\n\", ncr_name(np));\n\n\tOUTB(nc_stest1, DBLEN);\t   /* Enable clock multiplier\t\t  */\n\tif (np->multiplier > 2) {  /* Poll bit 5 of stest4 for quadrupler */\n\t\tint i = 20;\n\t\twhile (!(INB(nc_stest4) & LCKFRQ) && --i > 0)\n\t\t\tDELAY(20);\n\t\tif (!i)\n\t\t\tprintf(\"%s: the chip cannot lock the frequency\\n\", ncr_name(np));\n\t} else\t\t\t/* Wait 20 micro-seconds for doubler\t*/\n\t\tDELAY(20);\n\tOUTB(nc_stest3, HSC);\t\t/* Halt the scsi clock\t\t*/\n\tOUTB(nc_scntl3,\tscntl3);\n\tOUTB(nc_stest1, (DBLEN|DBLSEL));/* Select clock multiplier\t*/\n\tOUTB(nc_stest3, 0x00);\t\t/* Restart scsi clock \t\t*/\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define bootverbose\t0",
            "#define bootverbose\tNCR_VERBOSE"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\n\nstatic void ncr_selectclock(ncb_p np, u_char scntl3)\n{\n\tif (np->multiplier < 2) {\n\t\tOUTB(nc_scntl3,\tscntl3);\n\t\treturn;\n\t}\n\n\tif (bootverbose >= 2)\n\t\tprintf (\"%s: enabling clock multiplier\\n\", ncr_name(np));\n\n\tOUTB(nc_stest1, DBLEN);\t   /* Enable clock multiplier\t\t  */\n\tif (np->multiplier > 2) {  /* Poll bit 5 of stest4 for quadrupler */\n\t\tint i = 20;\n\t\twhile (!(INB(nc_stest4) & LCKFRQ) && --i > 0)\n\t\t\tDELAY(20);\n\t\tif (!i)\n\t\t\tprintf(\"%s: the chip cannot lock the frequency\\n\", ncr_name(np));\n\t} else\t\t\t/* Wait 20 micro-seconds for doubler\t*/\n\t\tDELAY(20);\n\tOUTB(nc_stest3, HSC);\t\t/* Halt the scsi clock\t\t*/\n\tOUTB(nc_scntl3,\tscntl3);\n\tOUTB(nc_stest1, (DBLEN|DBLSEL));/* Select clock multiplier\t*/\n\tOUTB(nc_stest3, 0x00);\t\t/* Restart scsi clock \t\t*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl1",
            "0x00"
          ],
          "line": 5255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl0",
            "0xca"
          ],
          "line": 5254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "0x00"
          ],
          "line": 5253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_wakeup",
          "args": [
            "np",
            "code"
          ],
          "line": 5247
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5162-5197",
          "snippet": "void ncr_wakeup (ncb_p np, u_long code)\n{\n\t/*\n\t**\tStarting at the default ccb and following\n\t**\tthe links, complete all jobs with a\n\t**\thost_status greater than \"disconnect\".\n\t**\n\t**\tIf the \"code\" parameter is not zero,\n\t**\tcomplete all jobs that are not IDLE.\n\t*/\n\n\tccb_p cp = np->ccb;\n\twhile (cp) {\n\t\tswitch (cp->host_status) {\n\n\t\tcase HS_IDLE:\n\t\t\tbreak;\n\n\t\tcase HS_DISCONNECT:\n\t\t\tif(DEBUG_FLAGS & DEBUG_TINY) printf (\"D\");\n\t\t\t/* fall through */\n\n\t\tcase HS_BUSY:\n\t\tcase HS_NEGOTIATE:\n\t\t\tif (!code) break;\n\t\t\tcp->host_status = code;\n\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\tncr_complete (np, cp);\n\t\t\tbreak;\n\t\t};\n\t\tcp = cp -> link_ccb;\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  host_status   phys.header.status[1]",
            "#define HS_DISCONNECT\t(3)\t/* Disconnected by target */",
            "#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/",
            "#define HS_BUSY\t\t(1)",
            "#define HS_IDLE\t\t(0)",
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_TINY     (0x0080)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  host_status   phys.header.status[1]\n#define HS_DISCONNECT\t(3)\t/* Disconnected by target */\n#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/\n#define HS_BUSY\t\t(1)\n#define HS_IDLE\t\t(0)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nvoid ncr_wakeup (ncb_p np, u_long code)\n{\n\t/*\n\t**\tStarting at the default ccb and following\n\t**\tthe links, complete all jobs with a\n\t**\thost_status greater than \"disconnect\".\n\t**\n\t**\tIf the \"code\" parameter is not zero,\n\t**\tcomplete all jobs that are not IDLE.\n\t*/\n\n\tccb_p cp = np->ccb;\n\twhile (cp) {\n\t\tswitch (cp->host_status) {\n\n\t\tcase HS_IDLE:\n\t\t\tbreak;\n\n\t\tcase HS_DISCONNECT:\n\t\t\tif(DEBUG_FLAGS & DEBUG_TINY) printf (\"D\");\n\t\t\t/* fall through */\n\n\t\tcase HS_BUSY:\n\t\tcase HS_NEGOTIATE:\n\t\t\tif (!code) break;\n\t\t\tcp->host_status = code;\n\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\tncr_complete (np, cp);\n\t\t\tbreak;\n\t\t};\n\t\tcp = cp -> link_ccb;\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT",
          "args": [
            "start0  [0]",
            "SCR_INT ^ IFFALSE (0)"
          ],
          "line": 5241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "0"
          ],
          "line": 5241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT",
          "args": [
            "startpos[0]",
            "NCB_SCRIPTH_PHYS (np, tryloop)"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "tryloop"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, idle)"
          ],
          "line": 5233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "idle"
          ],
          "line": 5233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "0"
          ],
          "line": 5220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 5219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "SRST"
          ],
          "line": 5218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n#define MAX_START   (256)\n#define MAX_TARGET  (16)\n#define SCSI_NCR_MAX_WIDE   (1)\n#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)\n#define\tSCSI_NCR_DFLT_SYNC 0\n#define SCSI_NCR_DFLT_SYNC   (10)\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\n\nvoid ncr_init (ncb_p np, char * msg, u_long code)\n{\n\tint\ti;\n\tu_long\tusrsync;\n\tu_char\tusrwide;\n\n\t/*\n\t**\tReset chip.\n\t*/\n\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat, 0);\n\n\t/*\n\t**\tMessage.\n\t*/\n\n\tif (msg) printf (\"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t/*\n\t**\tClear Start Queue\n\t*/\n\n\tfor (i=0;i<MAX_START;i++)\n\t\tnp -> squeue [i] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\n\tnp->squeueput = 0;\n\tWRITESCRIPT(startpos[0], NCB_SCRIPTH_PHYS (np, tryloop));\n\tWRITESCRIPT(start0  [0], SCR_INT ^ IFFALSE (0));\n\n\t/*\n\t**\tWakeup all pending jobs.\n\t*/\n\n\tncr_wakeup (np, code);\n\n\t/*\n\t**\tInit chip.\n\t*/\n\n\tOUTB (nc_istat,  0x00   );      /*  Remove Reset, abort ...\t     */\n\tOUTB (nc_scntl0, 0xca   );      /*  full arb., ena parity, par->ATN  */\n\tOUTB (nc_scntl1, 0x00\t);\t/*  odd parity, and remove CRST!!    */\n\tncr_selectclock(np, np->rv_scntl3); /* Select SCSI clock             */\n\tOUTB (nc_scid  , RRE|np->myaddr);/*  host adapter SCSI address       */\n\tOUTW (nc_respid, 1ul<<np->myaddr);/*  id to respond to\t\t     */\n\tOUTB (nc_istat , SIGP\t);\t/*  Signal Process\t\t     */\n\tOUTB (nc_dmode , np->rv_dmode);\t/* XXX modify burstlen ??? */\n\tOUTB (nc_dcntl , np->rv_dcntl);\n\tOUTB (nc_ctest3, np->rv_ctest3);\n\tOUTB (nc_ctest5, np->rv_ctest5);\n\tOUTB (nc_ctest4, np->rv_ctest4);/*  enable master parity checking    */\n\tOUTB (nc_stest2, np->rv_stest2|EXT); /* Extended Sreq/Sack filtering */\n\tOUTB (nc_stest3, TE     );\t/*  TolerANT enable\t\t     */\n\tOUTB (nc_stime0, 0x0b\t);\t/*  HTH = disabled, STO = 0.1 sec.   */\n\n\tif (bootverbose >= 2) {\n\t\tprintf (\"\\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\\n\",\n\t\t\tnp->rv_scntl3, np->rv_dmode, np->rv_dcntl);\n\t\tprintf (\"\\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\\n\",\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\t/*\n\t**    Enable GPIO0 pin for writing if LED support.\n\t*/\n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t/*\n\t**\tReinitialize usrsync.\n\t**\tHave to renegotiate synch mode.\n\t*/\n\n\tusrsync = 255;\n\tif (SCSI_NCR_DFLT_SYNC) {\n\t\tusrsync = SCSI_NCR_DFLT_SYNC;\n\t\tif (usrsync > np->maxsync)\n\t\t\tusrsync = np->maxsync;\n\t\tif (usrsync < np->minsync)\n\t\t\tusrsync = np->minsync;\n\t};\n\n\t/*\n\t**\tReinitialize usrwide.\n\t**\tHave to renegotiate wide mode.\n\t*/\n\n\tusrwide = (SCSI_NCR_MAX_WIDE);\n\tif (usrwide > np->maxwide) usrwide=np->maxwide;\n\n\t/*\n\t**\tDisable disconnects.\n\t*/\n\n\tnp->disc = 0;\n\n\t/*\n\t**\tFill in target structure.\n\t*/\n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\ttcb_p tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\ttp->usrsync = usrsync;\n\t\ttp->usrwide = usrwide;\n\n\t\tncr_negotiate (np, tp);\n\t}\n\n\t/*\n\t**      enable ints\n\t*/\n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t/*\n\t**    Start script processor.\n\t*/\n\n\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n}"
  },
  {
    "function_name": "ncr_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "5162-5197",
    "snippet": "void ncr_wakeup (ncb_p np, u_long code)\n{\n\t/*\n\t**\tStarting at the default ccb and following\n\t**\tthe links, complete all jobs with a\n\t**\thost_status greater than \"disconnect\".\n\t**\n\t**\tIf the \"code\" parameter is not zero,\n\t**\tcomplete all jobs that are not IDLE.\n\t*/\n\n\tccb_p cp = np->ccb;\n\twhile (cp) {\n\t\tswitch (cp->host_status) {\n\n\t\tcase HS_IDLE:\n\t\t\tbreak;\n\n\t\tcase HS_DISCONNECT:\n\t\t\tif(DEBUG_FLAGS & DEBUG_TINY) printf (\"D\");\n\t\t\t/* fall through */\n\n\t\tcase HS_BUSY:\n\t\tcase HS_NEGOTIATE:\n\t\t\tif (!code) break;\n\t\t\tcp->host_status = code;\n\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\tncr_complete (np, cp);\n\t\t\tbreak;\n\t\t};\n\t\tcp = cp -> link_ccb;\n\t};\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  host_status   phys.header.status[1]",
      "#define HS_DISCONNECT\t(3)\t/* Disconnected by target */",
      "#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/",
      "#define HS_BUSY\t\t(1)",
      "#define HS_IDLE\t\t(0)",
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TINY     (0x0080)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_complete",
          "args": [
            "np",
            "cp"
          ],
          "line": 5192
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "4893-5151",
          "snippet": "void ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  xerr_status   phys.xerr_st",
            "#define  parity_status phys.header.status[3]",
            "#define  scsi_status   phys.header.status[2]",
            "#define  host_status   phys.header.status[1]",
            "#define\tUF_TRACE\t(0x01)",
            "#define CCB_MAGIC\t(0xf2691ad2)",
            "#define\tQUIRK_UPDATE\t(0x80)",
            "#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */",
            "#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */",
            "#define\tXE_OK\t\t(0)",
            "#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */",
            "#define HS_TIMEOUT\t(8)\t/* Software timeout       */",
            "#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */",
            "#define HS_COMPLETE\t(4)",
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_TINY     (0x0080)",
            "#define DEBUG_RESULT   (0x0010)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;",
            "int\ti;",
            "register volatile u_int32_t data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  xerr_status   phys.xerr_st\n#define  parity_status phys.header.status[3]\n#define  scsi_status   phys.header.status[2]\n#define  host_status   phys.header.status[1]\n#define\tUF_TRACE\t(0x01)\n#define CCB_MAGIC\t(0xf2691ad2)\n#define\tQUIRK_UPDATE\t(0x80)\n#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */\n#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */\n#define\tXE_OK\t\t(0)\n#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */\n#define HS_TIMEOUT\t(8)\t/* Software timeout       */\n#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */\n#define HS_COMPLETE\t(4)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_RESULT   (0x0010)\n\nncb_p np = (void *)self;\nu_long\tperiod;\nint\ti;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\nint\ti;\nregister volatile u_int32_t data;\n\nvoid ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"D\""
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  host_status   phys.header.status[1]\n#define HS_DISCONNECT\t(3)\t/* Disconnected by target */\n#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/\n#define HS_BUSY\t\t(1)\n#define HS_IDLE\t\t(0)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nvoid ncr_wakeup (ncb_p np, u_long code)\n{\n\t/*\n\t**\tStarting at the default ccb and following\n\t**\tthe links, complete all jobs with a\n\t**\thost_status greater than \"disconnect\".\n\t**\n\t**\tIf the \"code\" parameter is not zero,\n\t**\tcomplete all jobs that are not IDLE.\n\t*/\n\n\tccb_p cp = np->ccb;\n\twhile (cp) {\n\t\tswitch (cp->host_status) {\n\n\t\tcase HS_IDLE:\n\t\t\tbreak;\n\n\t\tcase HS_DISCONNECT:\n\t\t\tif(DEBUG_FLAGS & DEBUG_TINY) printf (\"D\");\n\t\t\t/* fall through */\n\n\t\tcase HS_BUSY:\n\t\tcase HS_NEGOTIATE:\n\t\t\tif (!code) break;\n\t\t\tcp->host_status = code;\n\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\tncr_complete (np, cp);\n\t\t\tbreak;\n\t\t};\n\t\tcp = cp -> link_ccb;\n\t};\n}"
  },
  {
    "function_name": "ncr_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "4893-5151",
    "snippet": "void ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  xerr_status   phys.xerr_st",
      "#define  parity_status phys.header.status[3]",
      "#define  scsi_status   phys.header.status[2]",
      "#define  host_status   phys.header.status[1]",
      "#define\tUF_TRACE\t(0x01)",
      "#define CCB_MAGIC\t(0xf2691ad2)",
      "#define\tQUIRK_UPDATE\t(0x80)",
      "#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */",
      "#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */",
      "#define\tXE_OK\t\t(0)",
      "#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */",
      "#define HS_TIMEOUT\t(8)\t/* Software timeout       */",
      "#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */",
      "#define HS_COMPLETE\t(4)",
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TINY     (0x0080)",
      "#define DEBUG_RESULT   (0x0010)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "u_long\tperiod;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "u_long\tperiod;",
      "int\ti;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xp"
          ],
          "line": 5150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_free_ccb",
          "args": [
            "np",
            "cp",
            "xp->flags"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7197-7209",
          "snippet": "void ncr_free_ccb (ncb_p np, ccb_p cp, int flags)\n{\n\t/*\n\t**    sanity\n\t*/\n\n\tassert (cp != NULL);\n\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  host_status   phys.header.status[1]",
            "#define HS_IDLE\t\t(0)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  host_status   phys.header.status[1]\n#define HS_IDLE\t\t(0)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nvoid ncr_free_ccb (ncb_p np, ccb_p cp, int flags)\n{\n\t/*\n\t**    sanity\n\t*/\n\n\tassert (cp != NULL);\n\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 5139
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 5118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 5102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 5069
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_opennings",
          "args": [
            "np",
            "lp",
            "xp"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_opennings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7381-7427",
          "snippet": "static void ncr_opennings (ncb_p np, lcb_p lp, struct scsi_xfer * xp)\n{\n\t/*\n\t**\twant to reduce the number ...\n\t*/\n\tif (lp->actlink > lp->reqlink) {\n\n\t\t/*\n\t\t**\tTry to  reduce the count.\n\t\t**\tWe assume to run at splbio ..\n\t\t*/\n\t\tu_char diff = lp->actlink - lp->reqlink;\n\n\t\tif (!diff) return;\n\n#ifdef __OpenBSD__\n\t\tif (diff > xp->sc_link->openings)\n\t\t\tdiff = xp->sc_link->openings;\n\n\t\txp->sc_link->openings\t-= diff;\n#else\n\t\tif (diff > xp->sc_link->opennings)\n\t\t\tdiff = xp->sc_link->opennings;\n\n\t\txp->sc_link->opennings\t-= diff;\n#endif\n\t\tlp->actlink\t\t-= diff;\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t\treturn;\n\t};\n\n\t/*\n\t**\twant to increase the number ?\n\t*/\n\tif (lp->reqlink > lp->actlink) {\n\t\tu_char diff = lp->reqlink - lp->actlink;\n\n\t\txp->sc_link->openings\t+= diff;\n\t\tlp->actlink\t\t+= diff;\n\t\twakeup ((caddr_t) xp->sc_link);\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_TAGS     (0x0400)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TAGS     (0x0400)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void ncr_opennings (ncb_p np, lcb_p lp, struct scsi_xfer * xp)\n{\n\t/*\n\t**\twant to reduce the number ...\n\t*/\n\tif (lp->actlink > lp->reqlink) {\n\n\t\t/*\n\t\t**\tTry to  reduce the count.\n\t\t**\tWe assume to run at splbio ..\n\t\t*/\n\t\tu_char diff = lp->actlink - lp->reqlink;\n\n\t\tif (!diff) return;\n\n#ifdef __OpenBSD__\n\t\tif (diff > xp->sc_link->openings)\n\t\t\tdiff = xp->sc_link->openings;\n\n\t\txp->sc_link->openings\t-= diff;\n#else\n\t\tif (diff > xp->sc_link->opennings)\n\t\t\tdiff = xp->sc_link->opennings;\n\n\t\txp->sc_link->opennings\t-= diff;\n#endif\n\t\tlp->actlink\t\t-= diff;\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t\treturn;\n\t};\n\n\t/*\n\t**\twant to increase the number ?\n\t*/\n\tif (lp->reqlink > lp->actlink) {\n\t\tu_char diff = lp->reqlink - lp->actlink;\n\n\t\txp->sc_link->openings\t+= diff;\n\t\tlp->actlink\t\t+= diff;\n\t\twakeup ((caddr_t) xp->sc_link);\n\t\tif (DEBUG_FLAGS & DEBUG_TAGS)\n\t\t\tprintf (\"%s: actlink: diff=%d, new=%d, req=%d\\n\",\n\t\t\t\tncr_name(np), diff, lp->actlink, lp->reqlink);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_negotiate",
          "args": [
            "np",
            "tp"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_negotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5350-5393",
          "snippet": "static void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nu_long\tperiod;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\n\nstatic void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t/*\n\t**\tminsync unit is 4ns !\n\t*/\n\n\tu_long minsync = tp->usrsync;\n\n\t/*\n\t**\tif not scsi 2\n\t**\tdon't believe FAST!\n\t*/\n\n\tif ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)\n\t\tminsync=50;\n\n\t/*\n\t**\tour limit ..\n\t*/\n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t/*\n\t**\tdivider limit\n\t*/\n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? np->maxoffs : 0);\n\n\t/*\n\t**\tperiod=0: has to negotiate sync transfer\n\t*/\n\n\ttp->period=0;\n\n\t/*\n\t**\twidedone=0: has to negotiate wide transfer\n\t*/\n\ttp->widedone=0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xp->data",
            "&tp->inqdata",
            "sizeof (tp->inqdata)"
          ],
          "line": 5026
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_alloc_ccb",
          "args": [
            "np",
            "xp->sc_link->target",
            "xp->sc_link->lun"
          ],
          "line": 5020
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_alloc_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7220-7370",
          "snippet": "static\tvoid ncr_alloc_ccb (ncb_p np, u_long target, u_long lun)\n{\n\ttcb_p tp;\n\tlcb_p lp;\n\tccb_p cp;\n\n\tassert (np != NULL);\n\n\tif (target>=MAX_TARGET) return;\n\tif (lun   >=MAX_LUN   ) return;\n\n\ttp=&np->target[target];\n\n\tif (!tp->jump_tcb.l_cmd) {\n\n\t\t/*\n\t\t**\tinitialize it.\n\t\t*/\n\t\ttp->jump_tcb.l_cmd   = SCR_BO((SCR_JUMP^IFFALSE (DATA (0x80 + target))));\n\t\ttp->jump_tcb.l_paddr = np->jump_tcb.l_paddr;\n\n\t\ttp->getscr[0] =\n\t\t\t(np->features & FE_PFEN)? SCR_BO(SCR_COPY(1)) : SCR_BO(SCR_COPY_F(1));\n\t\ttp->getscr[1] = SCR_BO(NCR_KVATOPHYS (np, &tp->sval));\n\t\ttp->getscr[2] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_sxfer));\n\t\ttp->getscr[3] = tp->getscr[0];\n\t\ttp->getscr[4] = SCR_BO(NCR_KVATOPHYS (np, &tp->wval));\n\t\ttp->getscr[5] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_scntl3));\n\n\t\tassert (( (offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t\toffsetof(struct tcb    , sval    )) &3) == 0);\n\t\tassert (( (offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t\toffsetof(struct tcb    , wval    )) &3) == 0);\n\n\t\ttp->call_lun.l_cmd   = SCR_BO((SCR_CALL));\n\t\ttp->call_lun.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_lun));\n\n\t\ttp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, abort));\n\t\tnp->jump_tcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &tp->jump_tcb));\n\n\t\ttp->usrtags = SCSI_NCR_DFLT_TAGS;\n\t\tncr_setmaxtags (tp, tp->usrtags);\n\t}\n\n\t/*\n\t**\tLogic unit control block\n\t*/\n\tlp = tp->lp[lun];\n\tif (!lp) {\n\t\t/*\n\t\t**\tAllocate a lcb\n\t\t*/\n\t\tlp = (lcb_p) malloc (sizeof (struct lcb), M_DEVBUF, M_NOWAIT);\n\t\tif (!lp) return;\n\n#if defined(__mips__)\n\t\tpci_sync_cache(np->sc_pc, (vm_offset_t)lp, sizeof (struct lcb));\n\t\tlp = (struct lcb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, lp));\n#endif /* __mips__ */\n\n\t\t/*\n\t\t**\tInitialize it\n\t\t*/\n\t\tbzero (lp, sizeof (*lp));\n\t\tlp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP ^ IFFALSE (DATA (lun))));\n\t\tlp->jump_lcb.l_paddr = tp->jump_lcb.l_paddr;\n\n\t\tlp->call_tag.l_cmd   = SCR_BO((SCR_CALL));\n\t\tlp->call_tag.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tag));\n\n\t\tlp->jump_ccb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\tlp->jump_ccb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, aborttag));\n\n\t\tlp->actlink = 1;\n\n\t\t/*\n\t\t**   Chain into LUN list\n\t\t*/\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &lp->jump_lcb));\n\t\ttp->lp[lun] = lp;\n\n\t}\n\n\t/*\n\t**\tLimit possible number of ccbs.\n\t**\n\t**\tIf tagged command queueing is enabled,\n\t**\tcan use more than one ccb.\n\t*/\n\n\tif (np->actccbs >= MAX_START-2)\n\t\treturn;\n\tif (lp->actccbs && (lp->actccbs >= lp->reqccbs))\n\t\treturn;\n\n\t/*\n\t**\tAllocate a ccb\n\t*/\n\tcp = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_NOWAIT);\n\n\tif (!cp)\n\t\treturn;\n\n#if defined(__mips__)\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)cp, sizeof (struct ccb));\n\tcp = (struct ccb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, cp));\n#endif /* __mips__ */\n\n\tif (DEBUG_FLAGS & DEBUG_ALLOC) {\n\t\tprintf (\"new ccb @%p.\\n\", cp);\n\t}\n\n\t/*\n\t**\tCount it\n\t*/\n\tlp->actccbs++;\n\tnp->actccbs++;\n\n\t/*\n\t**\tInitialize it\n\t*/\n\tbzero (cp, sizeof (*cp));\n\n\t/*\n\t**\tFill in physical addresses\n\t*/\n\n\tcp->p_ccb\t     = NCR_KVATOPHYS (np, cp);\n\n\t/*\n\t**\tChain into reselect list\n\t*/\n\tcp->jump_ccb.l_cmd   = SCR_BO(SCR_JUMP);\n\tcp->jump_ccb.l_paddr = lp->jump_ccb.l_paddr;\n\tlp->jump_ccb.l_paddr = SCR_BO(CCB_PHYS (cp, jump_ccb));\n\tcp->call_tmp.l_cmd   = SCR_BO(SCR_CALL);\n\tcp->call_tmp.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tmp));\n\n\t/*\n\t**\tChain into wakeup list\n\t*/\n\tcp->link_ccb      = np->ccb->link_ccb;\n\tnp->ccb->link_ccb  = cp;\n\n\t/*\n\t**\tChain into CCB list\n\t*/\n\tcp->next_ccb\t= lp->next_ccb;\n\tlp->next_ccb\t= cp;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_ALLOC    (0x0001)",
            "#define MAX_START   (256)",
            "#define MAX_LUN     (8)",
            "#define MAX_TARGET  (16)",
            "#define SCSI_NCR_DFLT_TAGS    (4)",
            "#define\tSCSI_NCR_DFLT_TAGS (0)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_ALLOC    (0x0001)\n#define MAX_START   (256)\n#define MAX_LUN     (8)\n#define MAX_TARGET  (16)\n#define SCSI_NCR_DFLT_TAGS    (4)\n#define\tSCSI_NCR_DFLT_TAGS (0)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic\tvoid ncr_alloc_ccb (ncb_p np, u_long target, u_long lun)\n{\n\ttcb_p tp;\n\tlcb_p lp;\n\tccb_p cp;\n\n\tassert (np != NULL);\n\n\tif (target>=MAX_TARGET) return;\n\tif (lun   >=MAX_LUN   ) return;\n\n\ttp=&np->target[target];\n\n\tif (!tp->jump_tcb.l_cmd) {\n\n\t\t/*\n\t\t**\tinitialize it.\n\t\t*/\n\t\ttp->jump_tcb.l_cmd   = SCR_BO((SCR_JUMP^IFFALSE (DATA (0x80 + target))));\n\t\ttp->jump_tcb.l_paddr = np->jump_tcb.l_paddr;\n\n\t\ttp->getscr[0] =\n\t\t\t(np->features & FE_PFEN)? SCR_BO(SCR_COPY(1)) : SCR_BO(SCR_COPY_F(1));\n\t\ttp->getscr[1] = SCR_BO(NCR_KVATOPHYS (np, &tp->sval));\n\t\ttp->getscr[2] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_sxfer));\n\t\ttp->getscr[3] = tp->getscr[0];\n\t\ttp->getscr[4] = SCR_BO(NCR_KVATOPHYS (np, &tp->wval));\n\t\ttp->getscr[5] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_scntl3));\n\n\t\tassert (( (offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t\toffsetof(struct tcb    , sval    )) &3) == 0);\n\t\tassert (( (offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t\toffsetof(struct tcb    , wval    )) &3) == 0);\n\n\t\ttp->call_lun.l_cmd   = SCR_BO((SCR_CALL));\n\t\ttp->call_lun.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_lun));\n\n\t\ttp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, abort));\n\t\tnp->jump_tcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &tp->jump_tcb));\n\n\t\ttp->usrtags = SCSI_NCR_DFLT_TAGS;\n\t\tncr_setmaxtags (tp, tp->usrtags);\n\t}\n\n\t/*\n\t**\tLogic unit control block\n\t*/\n\tlp = tp->lp[lun];\n\tif (!lp) {\n\t\t/*\n\t\t**\tAllocate a lcb\n\t\t*/\n\t\tlp = (lcb_p) malloc (sizeof (struct lcb), M_DEVBUF, M_NOWAIT);\n\t\tif (!lp) return;\n\n#if defined(__mips__)\n\t\tpci_sync_cache(np->sc_pc, (vm_offset_t)lp, sizeof (struct lcb));\n\t\tlp = (struct lcb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, lp));\n#endif /* __mips__ */\n\n\t\t/*\n\t\t**\tInitialize it\n\t\t*/\n\t\tbzero (lp, sizeof (*lp));\n\t\tlp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP ^ IFFALSE (DATA (lun))));\n\t\tlp->jump_lcb.l_paddr = tp->jump_lcb.l_paddr;\n\n\t\tlp->call_tag.l_cmd   = SCR_BO((SCR_CALL));\n\t\tlp->call_tag.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tag));\n\n\t\tlp->jump_ccb.l_cmd   = SCR_BO((SCR_JUMP));\n\t\tlp->jump_ccb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, aborttag));\n\n\t\tlp->actlink = 1;\n\n\t\t/*\n\t\t**   Chain into LUN list\n\t\t*/\n\t\ttp->jump_lcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &lp->jump_lcb));\n\t\ttp->lp[lun] = lp;\n\n\t}\n\n\t/*\n\t**\tLimit possible number of ccbs.\n\t**\n\t**\tIf tagged command queueing is enabled,\n\t**\tcan use more than one ccb.\n\t*/\n\n\tif (np->actccbs >= MAX_START-2)\n\t\treturn;\n\tif (lp->actccbs && (lp->actccbs >= lp->reqccbs))\n\t\treturn;\n\n\t/*\n\t**\tAllocate a ccb\n\t*/\n\tcp = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_NOWAIT);\n\n\tif (!cp)\n\t\treturn;\n\n#if defined(__mips__)\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)cp, sizeof (struct ccb));\n\tcp = (struct ccb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, cp));\n#endif /* __mips__ */\n\n\tif (DEBUG_FLAGS & DEBUG_ALLOC) {\n\t\tprintf (\"new ccb @%p.\\n\", cp);\n\t}\n\n\t/*\n\t**\tCount it\n\t*/\n\tlp->actccbs++;\n\tnp->actccbs++;\n\n\t/*\n\t**\tInitialize it\n\t*/\n\tbzero (cp, sizeof (*cp));\n\n\t/*\n\t**\tFill in physical addresses\n\t*/\n\n\tcp->p_ccb\t     = NCR_KVATOPHYS (np, cp);\n\n\t/*\n\t**\tChain into reselect list\n\t*/\n\tcp->jump_ccb.l_cmd   = SCR_BO(SCR_JUMP);\n\tcp->jump_ccb.l_paddr = lp->jump_ccb.l_paddr;\n\tlp->jump_ccb.l_paddr = SCR_BO(CCB_PHYS (cp, jump_ccb));\n\tcp->call_tmp.l_cmd   = SCR_BO(SCR_CALL);\n\tcp->call_tmp.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tmp));\n\n\t/*\n\t**\tChain into wakeup list\n\t*/\n\tcp->link_ccb      = np->ccb->link_ccb;\n\tnp->ccb->link_ccb  = cp;\n\n\t/*\n\t**\tChain into CCB list\n\t*/\n\tcp->next_ccb\t= lp->next_ccb;\n\tlp->next_ccb\t= cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncb_profile",
          "args": [
            "np",
            "cp"
          ],
          "line": 4920
        },
        "resolved": true,
        "details": {
          "function_name": "ncb_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7699-7743",
          "snippet": "static\tvoid ncb_profile (ncb_p np, ccb_p cp)\n{\n\tint co, da, st, en, di, se, post,work,disc;\n\tu_long diff;\n\n#ifdef __OpenBSD__\n\tPROFILE.end = mono_time;\n#else\n\tgettime(&PROFILE.end);\n#endif\n\n\tst = ncr_delta (&PROFILE.start,&PROFILE.status);\n\tif (st<0) return;\t/* status  not reached  */\n\n\tda = ncr_delta (&PROFILE.start,&PROFILE.data);\n\tif (da<0) return;\t/* No data transfer phase */\n\n\tco = ncr_delta (&PROFILE.start,&PROFILE.command);\n\tif (co<0) return;\t/* command not executed */\n\n\ten = ncr_delta (&PROFILE.start,&PROFILE.end),\n\tdi = ncr_delta (&PROFILE.start,&PROFILE.disconnect),\n\tse = ncr_delta (&PROFILE.start,&PROFILE.select);\n\tpost = en - st;\n\n\t/*\n\t**\t@PROFILE@  Disconnect time invalid if multiple disconnects\n\t*/\n\n\tif (di>=0) disc = se-di; else  disc = 0;\n\n\twork = (st - co) - disc;\n\n\tdiff = (np->disc_phys - np->disc_ref) & 0xff;\n\tnp->disc_ref += diff;\n\n\tnp->profile.num_trans\t+= 1;\n\tif (cp->xfer)\n\tnp->profile.num_bytes\t+= cp->xfer->datalen;\n\tnp->profile.num_disc\t+= diff;\n\tnp->profile.ms_setup\t+= co;\n\tnp->profile.ms_data\t+= work;\n\tnp->profile.ms_disc\t+= disc;\n\tnp->profile.ms_post\t+= post;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define PROFILE  cp->phys.header.stamp"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;",
            "register volatile u_int32_t data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define PROFILE  cp->phys.header.stamp\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\nregister volatile u_int32_t data;\n\nstatic\tvoid ncb_profile (ncb_p np, ccb_p cp)\n{\n\tint co, da, st, en, di, se, post,work,disc;\n\tu_long diff;\n\n#ifdef __OpenBSD__\n\tPROFILE.end = mono_time;\n#else\n\tgettime(&PROFILE.end);\n#endif\n\n\tst = ncr_delta (&PROFILE.start,&PROFILE.status);\n\tif (st<0) return;\t/* status  not reached  */\n\n\tda = ncr_delta (&PROFILE.start,&PROFILE.data);\n\tif (da<0) return;\t/* No data transfer phase */\n\n\tco = ncr_delta (&PROFILE.start,&PROFILE.command);\n\tif (co<0) return;\t/* command not executed */\n\n\ten = ncr_delta (&PROFILE.start,&PROFILE.end),\n\tdi = ncr_delta (&PROFILE.start,&PROFILE.disconnect),\n\tse = ncr_delta (&PROFILE.start,&PROFILE.select);\n\tpost = en - st;\n\n\t/*\n\t**\t@PROFILE@  Disconnect time invalid if multiple disconnects\n\t*/\n\n\tif (di>=0) disc = se-di; else  disc = 0;\n\n\twork = (st - co) - disc;\n\n\tdiff = (np->disc_phys - np->disc_ref) & 0xff;\n\tnp->disc_ref += diff;\n\n\tnp->profile.num_trans\t+= 1;\n\tif (cp->xfer)\n\tnp->profile.num_bytes\t+= cp->xfer->datalen;\n\tnp->profile.num_disc\t+= diff;\n\tnp->profile.ms_setup\t+= co;\n\tnp->profile.ms_data\t+= work;\n\tnp->profile.ms_disc\t+= disc;\n\tnp->profile.ms_post\t+= post;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, idle)"
          ],
          "line": 4915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "idle"
          ],
          "line": 4915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_JUMP)"
          ],
          "line": 4910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  xerr_status   phys.xerr_st\n#define  parity_status phys.header.status[3]\n#define  scsi_status   phys.header.status[2]\n#define  host_status   phys.header.status[1]\n#define\tUF_TRACE\t(0x01)\n#define CCB_MAGIC\t(0xf2691ad2)\n#define\tQUIRK_UPDATE\t(0x80)\n#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */\n#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */\n#define\tXE_OK\t\t(0)\n#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */\n#define HS_TIMEOUT\t(8)\t/* Software timeout       */\n#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */\n#define HS_COMPLETE\t(4)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_RESULT   (0x0010)\n\nncb_p np = (void *)self;\nu_long\tperiod;\nint\ti;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\nint\ti;\nregister volatile u_int32_t data;\n\nvoid ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}"
  },
  {
    "function_name": "ncr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "4330-4881",
    "snippet": "static int32_t ncr_start (struct scsi_xfer * xp)\n{\n\tncb_p np  = (ncb_p) xp->sc_link->adapter_softc;\n\n\tstruct scsi_generic * cmd = (struct scsi_generic *)xp->cmd;\n\tccb_p cp;\n\tlcb_p lp;\n\ttcb_p tp = &np->target[xp->sc_link->target];\n\n\tint\ti, oldspl, segments, flags = xp->flags, pollmode;\n\tu_char\tqidx, nego, idmsg, *msgptr;\n\tu_long  msglen, msglen2;\n\n\t/*---------------------------------------------\n\t**\n\t**   Reset SCSI bus\n\t**\n\t**\tInterrupt handler does the real work.\n\t**\n\t**---------------------------------------------\n\t*/\n\n\tif (flags & SCSI_RESET) {\n\t\tOUTB (nc_scntl1, CRST);\n\t\tDELAY (1000);\n\t\treturn(COMPLETE);\n\t};\n\n\t/*---------------------------------------------\n\t**\n\t**      Some shortcuts ...\n\t**\n\t**---------------------------------------------\n\t*/\n\n\tif ((xp->sc_link->target == np->myaddr\t  ) ||\n\t\t(xp->sc_link->target >= MAX_TARGET) ||\n\t\t(xp->sc_link->lun    >= MAX_LUN   ) ||\n\t\t(flags    & SCSI_DATA_UIO)) {\n\t\txp->error = XS_DRIVER_STUFFUP;\n\t\treturn(COMPLETE);\n\t};\n\n\t/*---------------------------------------------\n\t**\n\t**      Diskaccess to partial blocks?\n\t**\n\t**---------------------------------------------\n\t*/\n\n\tif ((xp->datalen & 0x1ff) && !(tp->inqdata[0] & 0x1f)) {\n\t\tswitch (cmd->opcode) {\n\t\tcase 0x28:  /* READ_BIG  (10) */\n\t\tcase 0xa8:  /* READ_HUGE (12) */\n\t\tcase 0x2a:  /* WRITE_BIG (10) */\n\t\tcase 0xaa:  /* WRITE_HUGE(12) */\n\t\t\tPRINT_ADDR(xp);\n\t\t\tprintf (\"access to partial disk block refused.\\n\");\n\t\t\txp->error = XS_DRIVER_STUFFUP;\n\t\t\treturn(COMPLETE);\n\t\t};\n\t};\n\n\tif ((unsigned)xp->datalen > 128*1024*1024) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"trying to transfer %8x bytes, mem addr = %p\\n\",\n\t\t\txp->datalen, xp->data);\n\t\t{\n\t\t\tint j;\n\t\t\tPRINT_ADDR(xp);\n\t\t\tprintf (\"command: %2x (\", cmd->opcode);\n\t\t\tfor (j = 0; j<11; j++)\n\t\t\t\tprintf (\" %2x\", cmd->bytes[j]);\n\t\t\tprintf (\")\\n\");\n\t\t}\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"CMD=%x F=%x A=%p L=%x \",\n\t\t\tcmd->opcode, (unsigned)xp->flags, xp->data,\n\t\t\t(unsigned)xp->datalen);\n\t}\n\n\t/*--------------------------------------------\n\t**\n\t**   Sanity checks ...\n\t**\tcopied from Elischer's Adaptec driver.\n\t**\n\t**--------------------------------------------\n\t*/\n\n\tflags = xp->flags;\n\tif (!(flags & INUSE)) {\n\t\tprintf(\"%s: ?INUSE?\\n\", ncr_name (np));\n\t\txp->flags |= INUSE;\n\t};\n\n\tif(flags & ITSDONE) {\n\t\tprintf(\"%s: ?ITSDONE?\\n\", ncr_name (np));\n\t\txp->flags &= ~ITSDONE;\n\t};\n\n\tif (xp->bp)\n\t\tflags |= (SCSI_NOSLEEP); /* just to be sure */\n\n\t/*---------------------------------------------------\n\t**\n\t**\tAssign a ccb / bind xp\n\t**\n\t**----------------------------------------------------\n\t*/\n\n#if defined(__mips__)\n\tif (xp->data && xp->datalen) {\n\t\tpci_sync_cache(np->sc_pc, (vm_offset_t)xp->data, xp->datalen);\n\t} \n\tpci_sync_cache(np->sc_pc, (vm_offset_t)xp->cmd, xp->cmdlen);\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)&xp->sense, sizeof(struct scsi_sense_data));\n#endif /* __mips__ */\n\n\toldspl = splbio();\n\n\tif (!(cp=ncr_get_ccb (np, flags, xp->sc_link->target,\n\t\txp->sc_link->lun))) {\n\t\tprintf (\"%s: no ccb.\\n\", ncr_name (np));\n\t\txp->error = XS_DRIVER_STUFFUP;\n\t\tsplx(oldspl);\n\t\treturn(TRY_AGAIN_LATER);\n\t};\n\tcp->xfer = xp;\n\n\t/*---------------------------------------------------\n\t**\n\t**\ttimestamp\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tbzero (&cp->phys.header.stamp, sizeof (struct tstamp));\n#ifdef __OpenBSD__\n\tcp->phys.header.stamp.start = mono_time;\n#else\n\tgettime(&cp->phys.header.stamp.start);\n#endif\n\n\t/*----------------------------------------------------\n\t**\n\t**\tGet device quirks from a speciality table.\n\t**\n\t**\t@GENSCSI@\n\t**\tThis should be a part of the device table\n\t**\tin \"scsi_conf.c\".\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif (tp->quirks & QUIRK_UPDATE) {\n#ifdef __OpenBSD__\n\t\ttp->quirks = ncr_lookup ((char*) &tp->inqdata[0]);\n#else\n\t\tint q = xp->sc_link->quirks;\n\t\ttp->quirks = QUIRK_NOMSG;\n\t\tif (q & SD_Q_NO_TAGS)\n\t\t\ttp->quirks |= QUIRK_NOTAGS;\n\t\tif (q & SD_Q_NO_SYNC)\n\t\t\ttp->quirks |= QUIRK_NOSYNC;\n\t\tif (q & SD_Q_NO_WIDE)\n\t\t\ttp->quirks |= QUIRK_NOWIDE16;\n#endif\n\t\tif (bootverbose && (tp->quirks & ~QUIRK_NOMSG)) {\n\t\t\tPRINT_ADDR(xp);\n\t\t\tprintf (\"NCR quirks=0x%x\\n\", tp->quirks);\n\t\t};\n\t\t/*\n\t\t**\tset number of tags\n\t\t*/\n\t\tncr_setmaxtags (tp, tp->usrtags);\n\t};\n\n\t/*---------------------------------------------------\n\t**\n\t**\tnegotiation required?\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tnego = 0;\n\n\tif (!tp->nego_cp && tp->inqdata[7]) {\n\t\t/*\n\t\t**\tnegotiate wide transfers ?\n\t\t*/\n\n\t\tif (!tp->widedone) {\n\t\t\tif (tp->inqdata[7] & INQ7_WIDE16) {\n\t\t\t\tnego = NS_WIDE;\n\t\t\t} else\n\t\t\t\ttp->widedone=1;\n\t\t};\n\n\t\t/*\n\t\t**\tnegotiate synchronous transfers?\n\t\t*/\n\n\t\tif (!nego && !tp->period) {\n\t\t\tif (SCSI_NCR_DFLT_SYNC\n#ifdef NCR_CDROM_ASYNC\n\t\t\t    && ((tp->inqdata[0] & 0x1f) != 5)\n#endif /* NCR_CDROM_ASYNC */\n\t\t\t    && (tp->inqdata[7] & INQ7_SYNC)) {\n\t\t\t\tnego = NS_SYNC;\n\t\t\t} else {\n\t\t\t\ttp->period  =0xffff;\n\t\t\t\ttp->sval = 0xe0;\n\t\t\t\tPRINT_ADDR(xp);\n\t\t\t\tprintf (\"asynchronous.\\n\");\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t**\tremember nego is pending for the target.\n\t\t**\tAvoid to start a nego for all queued commands\n\t\t**\twhen tagged command queuing is enabled.\n\t\t*/\n\n\t\tif (nego)\n\t\t\ttp->nego_cp = cp;\n\t};\n\n\t/*---------------------------------------------------\n\t**\n\t**\tchoose a new tag ...\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif ((lp = tp->lp[xp->sc_link->lun]) && (lp->usetags)) {\n\t\t/*\n\t\t**\tassign a tag to this ccb!\n\t\t*/\n\t\twhile (!cp->tag) {\n\t\t\tccb_p cp2 = lp->next_ccb;\n\t\t\tlp->lasttag = lp->lasttag % 255 + 1;\n\t\t\twhile (cp2 && cp2->tag != lp->lasttag)\n\t\t\t\tcp2 = cp2->next_ccb;\n\t\t\tif (cp2) continue;\n\t\t\tcp->tag=lp->lasttag;\n\t\t\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\t\t\tPRINT_ADDR(xp);\n\t\t\t\tprintf (\"using tag #%d.\\n\", cp->tag);\n\t\t\t};\n\t\t};\n\t} else {\n\t\tcp->tag=0;\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the identify / tag / sdtr message\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tidmsg = M_IDENTIFY | xp->sc_link->lun;\n\tif ((cp!=np->ccb) && (np->disc))\n\t\tidmsg |= 0x40;\n\n\tmsgptr = cp->scsi_smsg;\n\tmsglen = 0;\n\tmsgptr[msglen++] = idmsg;\n\n\tif (cp->tag) {\n\t    char tag;\n\n\t    tag = np->order;\n\t    if (tag == 0) {\n\t\t/*\n\t\t**\tOrdered write ops, unordered read ops.\n\t\t*/\n\t\tswitch (cmd->opcode) {\n\t\tcase 0x08:  /* READ_SMALL (6) */\n\t\tcase 0x28:  /* READ_BIG  (10) */\n\t\tcase 0xa8:  /* READ_HUGE (12) */\n\t\t    tag = M_SIMPLE_TAG;\n\t\t    break;\n\t\tdefault:\n\t\t    tag = M_ORDERED_TAG;\n\t\t}\n\t    }\n\t    msgptr[msglen++] = tag;\n\t    msgptr[msglen++] = cp -> tag;\n\t}\n\n\tswitch (nego) {\n\tcase NS_SYNC:\n\t\tmsgptr[msglen++] = M_EXTENDED;\n\t\tmsgptr[msglen++] = 3;\n\t\tmsgptr[msglen++] = M_X_SYNC_REQ;\n\t\tmsgptr[msglen++] = tp->minsync;\n\t\tmsgptr[msglen++] = tp->maxoffs;\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync msgout: \");\n\t\t\tncr_show_msg (&cp->scsi_smsg [msglen-5]);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\t\tbreak;\n\tcase NS_WIDE:\n\t\tmsgptr[msglen++] = M_EXTENDED;\n\t\tmsgptr[msglen++] = 2;\n\t\tmsgptr[msglen++] = M_X_WIDE_REQ;\n\t\tmsgptr[msglen++] = tp->usrwide;\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide msgout: \");\n\t\t\tncr_show_msg (&cp->scsi_smsg [msglen-4]);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\t\tbreak;\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the identify message for getcc.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tcp -> scsi_smsg2 [0] = idmsg;\n\tmsglen2 = 1;\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the data descriptors\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tsegments = ncr_scatter (np, &cp->phys, (vm_offset_t) xp->data,\n\t\t\t\t\t(vm_size_t) xp->datalen);\n\n\tif (segments < 0) {\n\t\txp->error = XS_DRIVER_STUFFUP;\n\t\tncr_free_ccb(np, cp, flags);\n\t\tsplx(oldspl);\n\t\treturn(COMPLETE);\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tSet the SAVED_POINTER.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif (flags & SCSI_DATA_IN) {\n\t\tu_long sp;\n\t\tsp = NCB_SCRIPT_PHYS (np, data_in);\n\t\tcp->phys.header.savep = SCR_BO(sp);\n\t\tcp->phys.header.goalp = SCR_BO(sp + 20 + segments * 16);\n\t} else if (flags & SCSI_DATA_OUT) {\n\t\tu_long sp;\n\t\tsp = NCB_SCRIPT_PHYS (np, data_out);\n\t\tcp->phys.header.savep = SCR_BO(sp);\n\t\tcp->phys.header.goalp = SCR_BO(sp + 20 + segments * 16);\n\t} else {\n\t\tcp->phys.header.savep = SCR_BO(NCB_SCRIPT_PHYS (np, no_data));\n\t\tcp->phys.header.goalp = cp->phys.header.savep;\n\t};\n\tcp->phys.header.lastp = cp->phys.header.savep;\n\n\n\t/*----------------------------------------------------\n\t**\n\t**\tfill in ccb\n\t**\n\t**----------------------------------------------------\n\t**\n\t**\n\t**\tphysical -> virtual backlink\n\t**\tGeneric SCSI command\n\t*/\n\tcp->phys.header.cp\t\t= cp;\n\t/*\n\t**\tStartqueue\n\t*/\n\tcp->phys.header.launch.l_paddr\t= SCR_BO(NCB_SCRIPT_PHYS (np, select));\n\tcp->phys.header.launch.l_cmd\t= SCR_BO(SCR_JUMP);\n\t/*\n\t**\tselect\n\t*/\n\tcp->phys.select.sel_id\t\t= xp->sc_link->target;\n\tcp->phys.select.sel_scntl3\t= tp->wval;\n\tcp->phys.select.sel_sxfer\t= tp->sval;\n\t/*\n\t**\tmessage\n\t*/\n\tcp->phys.smsg.addr\t\t= SCR_BO(CCB_PHYS (cp, scsi_smsg));\n\tcp->phys.smsg.size\t\t= SCR_BO(msglen);\n\n\tcp->phys.smsg2.addr\t\t= SCR_BO(CCB_PHYS (cp, scsi_smsg2));\n\tcp->phys.smsg2.size\t\t= SCR_BO(msglen2);\n\t/*\n\t**\tcommand\n\t*/\n\tcp->phys.cmd.addr\t\t= SCR_BO(NCR_KVATOPHYS (np, cmd));\n\tcp->phys.cmd.size\t\t= SCR_BO(xp->cmdlen);\n\t/*\n\t**\tsense command\n\t*/\n\tcp->phys.scmd.addr\t\t= SCR_BO(CCB_PHYS (cp, sensecmd));\n\tcp->phys.scmd.size\t\t= SCR_BO(6);\n\t/*\n\t**\tpatch requested size into sense command\n\t*/\n\tcp->sensecmd[0]\t\t\t= 0x03;\n\tcp->sensecmd[1]\t\t\t= xp->sc_link->lun << 5;\n\tcp->sensecmd[4]\t\t\t= sizeof(struct scsi_sense_data);\n\tif (xp->req_sense_length)\n\t\tcp->sensecmd[4]\t\t= xp->req_sense_length;\n\t/*\n\t**\tsense data\n\t*/\n#if defined(__mips__)\n\tcp->phys.sense.addr\t\t= SCR_BO(NCR_KVATOPHYS (np, &cp->local_sense));\n#else\n\tcp->phys.sense.addr\t\t= SCR_BO(NCR_KVATOPHYS (np, &cp->xfer->sense));\n#endif\n\tcp->phys.sense.size\t\t= SCR_BO(sizeof(struct scsi_sense_data));\n\t/*\n\t**\tstatus\n\t*/\n\tcp->actualquirks\t\t= tp->quirks;\n\tcp->host_status\t\t\t= nego ? HS_NEGOTIATE : HS_BUSY;\n\tcp->scsi_status\t\t\t= S_ILLEGAL;\n\tcp->parity_status\t\t= 0;\n\n\tcp->xerr_status\t\t\t= XE_OK;\n\tcp->sync_status\t\t\t= tp->sval;\n\tcp->nego_status\t\t\t= nego;\n\tcp->wide_status\t\t\t= tp->wval;\n\n\t/*----------------------------------------------------\n\t**\n\t**\tCritical region: start this job.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\t/*\n\t**\treselect pattern and activate this job.\n\t*/\n\n\tcp->jump_ccb.l_cmd\t= SCR_BO((SCR_JUMP ^ IFFALSE (DATA (cp->tag))));\n#ifdef __OpenBSD__\n\tcp->tlimit\t\t= mono_time.tv_sec + xp->timeout / 1000 + 2;\n#else\n\tcp->tlimit\t\t= time.tv_sec + xp->timeout / 1000 + 2;\n#endif\n\tcp->magic\t\t= CCB_MAGIC;\n\n\t/*\n\t**\tinsert into start queue.\n\t*/\n\n\tqidx = np->squeueput + 1;\n\tif (qidx >= MAX_START) qidx=0;\n\tnp->squeue [qidx\t ] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\tnp->squeue [np->squeueput] = SCR_BO(CCB_PHYS (cp, phys));\n\tnp->squeueput = qidx;\n\n\tif(DEBUG_FLAGS & DEBUG_QUEUE)\n\t\tprintf (\"%s: queuepos=%d tryoffset=%d.\\n\", ncr_name (np),\n\t\tnp->squeueput,\n\t\t(unsigned)(READSCRIPT(startpos[0])-\n\t\t\t   (NCB_SCRIPTH_PHYS (np, tryloop))));\n\n\t/*\n\t**\tScript processor may be waiting for reselect.\n\t**\tWake it up.\n\t*/\n\tOUTB (nc_istat, SIGP);\n\n\t/*\n\t**\tand reenable interrupts\n\t*/\n#ifdef __OpenBSD__\n\tpollmode = flags & SCSI_POLL;\n#else\n\tpollmode = flags & SCSI_NOMASK;\n#endif\n\tsplx (oldspl);\n\n\t/*\n\t**\tIf interrupts are enabled, return now.\n\t**\tCommand is successfully queued.\n\t*/\n\n\tif (!pollmode) {\n\t\tif(DEBUG_FLAGS & DEBUG_TINY) printf (\"Q\");\n\t\treturn(SUCCESSFULLY_QUEUED);\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tInterrupts not yet enabled - have to poll.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif (DEBUG_FLAGS & DEBUG_POLL) printf(\"P\");\n\n\tfor (i=xp->timeout; i && !(xp->flags & ITSDONE);i--) {\n\t\tif ((DEBUG_FLAGS & DEBUG_POLL) && (cp->host_status))\n\t\t\tprintf (\"%c\", (cp->host_status & 0xf) + '0');\n\t\tDELAY (1000);\n\t\tncr_exception (np);\n\t};\n\n\t/*\n\t**\tAbort if command not done.\n\t*/\n\tif (!(xp->flags & ITSDONE)) {\n\t\tprintf (\"%s: aborting job ...\\n\", ncr_name (np));\n\t\tOUTB (nc_istat, CABRT);\n\t\tDELAY (100000);\n\t\tOUTB (nc_istat, SIGP);\n\t\tncr_exception (np);\n\t};\n\n\tif (!(xp->flags & ITSDONE)) {\n\t\tprintf (\"%s: abortion failed at %x.\\n\",\n\t\t\tncr_name (np), (unsigned) INL(nc_dsp));\n\t\tncr_init (np, \"timeout\", HS_TIMEOUT);\n\t};\n\n\tif (!(xp->flags & ITSDONE)) {\n\t\tcp-> host_status = HS_SEL_TIMEOUT;\n\t\tncr_complete (np, cp);\n\t};\n\n\tif (DEBUG_FLAGS & DEBUG_RESULT) {\n\t\tprintf (\"%s: result: %x %x.\\n\",\n\t\t\tncr_name (np), cp->host_status, cp->scsi_status);\n\t};\n\tswitch (xp->error) {\n\tcase  0     : return (COMPLETE);\n\tcase XS_BUSY: return (TRY_AGAIN_LATER);\n\t};\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define  wide_status   phys.wide_st",
      "#define  nego_status   phys.nego_st",
      "#define  sync_status   phys.sync_st",
      "#define  xerr_status   phys.xerr_st",
      "#define  parity_status phys.header.status[3]",
      "#define  scsi_status   phys.header.status[2]",
      "#define  host_status   phys.header.status[1]",
      "#define  actualquirks  phys.header.status[0]",
      "#define CCB_MAGIC\t(0xf2691ad2)",
      "#define\tINQ7_WIDE16\t(0x20)",
      "#define\tINQ7_SYNC\t(0x10)",
      "#define\tQUIRK_UPDATE\t(0x80)",
      "#define QUIRK_NOTAGS\t(0x40)",
      "#define QUIRK_NOWIDE16\t(0x20)",
      "#define QUIRK_NOSYNC\t(0x10)",
      "#define\tQUIRK_NOMSG\t(0x02)",
      "#define NS_WIDE\t\t(2)",
      "#define NS_SYNC\t\t(1)",
      "#define\tXE_OK\t\t(0)",
      "#define HS_TIMEOUT\t(8)\t/* Software timeout       */",
      "#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */",
      "#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/",
      "#define HS_BUSY\t\t(1)",
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TAGS     (0x0400)",
      "#define DEBUG_NEGO     (0x0200)",
      "#define DEBUG_TINY     (0x0080)",
      "#define DEBUG_RESULT   (0x0010)",
      "#define DEBUG_QUEUE    (0x0008)",
      "#define DEBUG_POLL     (0x0004)",
      "#define bootverbose\t0",
      "#define bootverbose\tNCR_VERBOSE",
      "#define MAX_START   (256)",
      "#define MAX_LUN     (8)",
      "#define MAX_TARGET  (16)",
      "#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)",
      "#define\tSCSI_NCR_DFLT_SYNC 0",
      "#define SCSI_NCR_DFLT_SYNC   (10)",
      "#define\tNCR_CDROM_ASYNC"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "u_long\tperiod;",
      "int\ti;",
      "ncb_p np = (struct ncb*) 0;",
      "u_long\tperiod;",
      "int\ti;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: result: %x %x.\\n\"",
            "ncr_name (np)",
            "cp->host_status",
            "cp->scsi_status"
          ],
          "line": 4873
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_complete",
          "args": [
            "np",
            "cp"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "4893-5151",
          "snippet": "void ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  xerr_status   phys.xerr_st",
            "#define  parity_status phys.header.status[3]",
            "#define  scsi_status   phys.header.status[2]",
            "#define  host_status   phys.header.status[1]",
            "#define\tUF_TRACE\t(0x01)",
            "#define CCB_MAGIC\t(0xf2691ad2)",
            "#define\tQUIRK_UPDATE\t(0x80)",
            "#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */",
            "#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */",
            "#define\tXE_OK\t\t(0)",
            "#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */",
            "#define HS_TIMEOUT\t(8)\t/* Software timeout       */",
            "#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */",
            "#define HS_COMPLETE\t(4)",
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_TINY     (0x0080)",
            "#define DEBUG_RESULT   (0x0010)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "u_long\tperiod;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "u_long\tperiod;",
            "int\ti;",
            "register volatile u_int32_t data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  xerr_status   phys.xerr_st\n#define  parity_status phys.header.status[3]\n#define  scsi_status   phys.header.status[2]\n#define  host_status   phys.header.status[1]\n#define\tUF_TRACE\t(0x01)\n#define CCB_MAGIC\t(0xf2691ad2)\n#define\tQUIRK_UPDATE\t(0x80)\n#define\tXE_BAD_PHASE\t(2)\t/* illegal phase (4/5)   */\n#define\tXE_EXTRA_DATA\t(1)\t/* unexpected data phase */\n#define\tXE_OK\t\t(0)\n#define HS_FAIL\t\t(9)\t/* SCSI or PCI bus errors */\n#define HS_TIMEOUT\t(8)\t/* Software timeout       */\n#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */\n#define HS_COMPLETE\t(4)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_RESULT   (0x0010)\n\nncb_p np = (void *)self;\nu_long\tperiod;\nint\ti;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\nint\ti;\nregister volatile u_int32_t data;\n\nvoid ncr_complete (ncb_p np, ccb_p cp)\n{\n\tstruct scsi_xfer * xp;\n\ttcb_p tp;\n\tlcb_p lp;\n\n\t/*\n\t**\tSanity check\n\t*/\n\n\tif (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;\n\tcp->magic = 1;\n\tcp->tlimit= 0;\n\n\t/*\n\t**\tNo Reselect anymore.\n\t*/\n\tcp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));\n\n\t/*\n\t**\tNo starting.\n\t*/\n\tcp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\ttimestamp\n\t*/\n\tncb_profile (np, cp);\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintf (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp & 0xfff,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\txp = cp->xfer;\n\tcp->xfer = NULL;\n\ttp = &np->target[xp->sc_link->target];\n\tlp = tp->lp[xp->sc_link->lun];\n\n#if defined(__mips__)\n\t/*\n\t**\tMove sense data back to request struct.\n\t*/\n\t{\n\t\tint i;\n\t\tu_char *p = (u_char *)&xp->sense;\n\t\tfor(i = 0; i < sizeof(struct scsi_sense_data); i++) {\n\t\t\t*p++ = cp->local_sense[i];\n\t\t}\n\t}\n#endif\n\t/*\n\t**\tWe do not queue more than 1 ccb per target\n\t**\twith negotiation at any time. If this ccb was\n\t**\tused for negotiation, clear this info in the tcb.\n\t*/\n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = 0;\n\n\t/*\n\t**\tCheck for parity errors.\n\t*/\n\n\tif (cp->parity_status) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"%d parity error(s), fallback.\\n\", cp->parity_status);\n\t\t/*\n\t\t**\tfallback to asynch transfer.\n\t\t*/\n\t\ttp->usrsync=255;\n\t\ttp->period =  0;\n\t};\n\n\t/*\n\t**\tCheck for extended errors.\n\t*/\n\n\tif (cp->xerr_status != XE_OK) {\n\t\tPRINT_ADDR(xp);\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tprintf (\"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tprintf (\"illegal scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"extended error %d.\\n\", cp->xerr_status);\n\t\t\tbreak;\n\t\t};\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t};\n\n\t/*\n\t**\tCheck the status.\n\t*/\n#ifdef __OpenBSD__\n\tif (xp->error != XS_NOERROR) {\n\n                /*\n                **      Don't override the error value.\n                */\n\t} else\n#endif /* __OpenBSD__ */\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == S_GOOD)) {\n\n\t\t/*\n\t\t**\tAll went well.\n\t\t*/\n\n\t\txp->resid = 0;\n\n\t\t/*\n\t\t** if (cp->phys.header.lastp != cp->phys.header.goalp)...\n\t\t**\n\t\t**\t@RESID@\n\t\t**\tCould dig out the correct value for resid,\n\t\t**\tbut it would be quite complicated.\n\t\t**\n\t\t**\tThe ah1542.c driver sets it to 0 too ...\n\t\t*/\n\n\t\t/*\n\t\t**\tTry to assign a ccb to this nexus\n\t\t*/\n\t\tncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);\n\n\t\t/*\n\t\t**\tOn inquire cmd (0x12) save some data.\n\t\t*/\n\t\tif (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {\n\t\t\tbcopy (\txp->data,\n\t\t\t\t&tp->inqdata,\n\t\t\t\tsizeof (tp->inqdata));\n\t\t\t/*\n\t\t\t**\tprepare negotiation of synch and wide.\n\t\t\t*/\n\t\t\tncr_negotiate (np, tp);\n\n\t\t\t/*\n\t\t\t**\tforce quirks update before next command start\n\t\t\t*/\n\t\t\ttp->quirks |= QUIRK_UPDATE;\n\t\t};\n\n\t\t/*\n\t\t**\tAnnounce changes to the generic driver\n\t\t*/\n\t\tif (lp) {\n\t\t\tif (lp->reqlink != lp->actlink)\n\t\t\t\tncr_opennings (np, lp, xp);\n\t\t};\n\n\t\ttp->bytes     += xp->datalen;\n\t\ttp->transfers ++;\n#ifndef __OpenBSD__\n\t} else if (xp->flags & SCSI_ERR_OK) {\n\n\t\t/*\n\t\t**   Not correct, but errors expected.\n\t\t*/\n\t\txp->resid = 0;\n#endif /* !__OpenBSD__ */\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == (S_SENSE|S_GOOD))) {\n\n\t\t/*\n\t\t**   Check condition code\n\t\t*/\n\t\txp->error = XS_SENSE;\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char * p = (u_char*) & xp->sense;\n\t\t\tint i;\n\t\t\tprintf (\"\\n%s: sense data:\", ncr_name (np));\n\t\t\tfor (i=0; i<14; i++) printf (\" %x\", *p++);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t   && ((cp->scsi_status == S_BUSY)\n\t\t       || (cp->scsi_status == S_CONFLICT))) {\n\n\t\t/*\n\t\t**   Target is busy, or reservation conflict\n\t\t*/\n\t\txp->error = XS_BUSY;\n\n\t} else if (cp->host_status == HS_SEL_TIMEOUT) {\n\n\t\t/*\n\t\t**   Device failed selection\n\t\t*/\n\t\txp->error = XS_SELTIMEOUT;\n\n\t} else if(cp->host_status == HS_TIMEOUT) {\n\n\t\t/*\n\t\t**   No response\n\t\t*/\n\t\txp->error = XS_TIMEOUT;\n\n\t} else {\n\n\t\t/*\n\t\t**  Other protocol messes\n\t\t*/\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\txp->error = XS_TIMEOUT;\n\t}\n\n\txp->flags |= ITSDONE;\n\n\t/*\n\t**\ttrace output\n\t*/\n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\" CMD:\");\n\t\tp = (u_char*) &xp->cmd->opcode;\n\t\tfor (i=0; i<xp->cmdlen; i++) printf (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase S_GOOD:\n\t\t\t\tprintf (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase S_CHECK_COND:\n\t\t\t\tprintf (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &xp->sense;\n\t\t\t\tfor (i=0; i<xp->req_sense_length; i++)\n\t\t\t\t\tprintf (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t};\n\t\t} else printf (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintf (\"\\n\");\n\t};\n\n\t/*\n\t**\tFree this ccb\n\t*/\n\tncr_free_ccb (np, cp, xp->flags);\n\n\t/*\n\t**\tsignal completion to generic driver.\n\t*/\n\tscsi_done (xp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_init",
          "args": [
            "np",
            "\"timeout\"",
            "HS_TIMEOUT"
          ],
          "line": 4864
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5208-5340",
          "snippet": "void ncr_init (ncb_p np, char * msg, u_long code)\n{\n\tint\ti;\n\tu_long\tusrsync;\n\tu_char\tusrwide;\n\n\t/*\n\t**\tReset chip.\n\t*/\n\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat, 0);\n\n\t/*\n\t**\tMessage.\n\t*/\n\n\tif (msg) printf (\"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t/*\n\t**\tClear Start Queue\n\t*/\n\n\tfor (i=0;i<MAX_START;i++)\n\t\tnp -> squeue [i] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\n\tnp->squeueput = 0;\n\tWRITESCRIPT(startpos[0], NCB_SCRIPTH_PHYS (np, tryloop));\n\tWRITESCRIPT(start0  [0], SCR_INT ^ IFFALSE (0));\n\n\t/*\n\t**\tWakeup all pending jobs.\n\t*/\n\n\tncr_wakeup (np, code);\n\n\t/*\n\t**\tInit chip.\n\t*/\n\n\tOUTB (nc_istat,  0x00   );      /*  Remove Reset, abort ...\t     */\n\tOUTB (nc_scntl0, 0xca   );      /*  full arb., ena parity, par->ATN  */\n\tOUTB (nc_scntl1, 0x00\t);\t/*  odd parity, and remove CRST!!    */\n\tncr_selectclock(np, np->rv_scntl3); /* Select SCSI clock             */\n\tOUTB (nc_scid  , RRE|np->myaddr);/*  host adapter SCSI address       */\n\tOUTW (nc_respid, 1ul<<np->myaddr);/*  id to respond to\t\t     */\n\tOUTB (nc_istat , SIGP\t);\t/*  Signal Process\t\t     */\n\tOUTB (nc_dmode , np->rv_dmode);\t/* XXX modify burstlen ??? */\n\tOUTB (nc_dcntl , np->rv_dcntl);\n\tOUTB (nc_ctest3, np->rv_ctest3);\n\tOUTB (nc_ctest5, np->rv_ctest5);\n\tOUTB (nc_ctest4, np->rv_ctest4);/*  enable master parity checking    */\n\tOUTB (nc_stest2, np->rv_stest2|EXT); /* Extended Sreq/Sack filtering */\n\tOUTB (nc_stest3, TE     );\t/*  TolerANT enable\t\t     */\n\tOUTB (nc_stime0, 0x0b\t);\t/*  HTH = disabled, STO = 0.1 sec.   */\n\n\tif (bootverbose >= 2) {\n\t\tprintf (\"\\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\\n\",\n\t\t\tnp->rv_scntl3, np->rv_dmode, np->rv_dcntl);\n\t\tprintf (\"\\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\\n\",\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\t/*\n\t**    Enable GPIO0 pin for writing if LED support.\n\t*/\n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t/*\n\t**\tReinitialize usrsync.\n\t**\tHave to renegotiate synch mode.\n\t*/\n\n\tusrsync = 255;\n\tif (SCSI_NCR_DFLT_SYNC) {\n\t\tusrsync = SCSI_NCR_DFLT_SYNC;\n\t\tif (usrsync > np->maxsync)\n\t\t\tusrsync = np->maxsync;\n\t\tif (usrsync < np->minsync)\n\t\t\tusrsync = np->minsync;\n\t};\n\n\t/*\n\t**\tReinitialize usrwide.\n\t**\tHave to renegotiate wide mode.\n\t*/\n\n\tusrwide = (SCSI_NCR_MAX_WIDE);\n\tif (usrwide > np->maxwide) usrwide=np->maxwide;\n\n\t/*\n\t**\tDisable disconnects.\n\t*/\n\n\tnp->disc = 0;\n\n\t/*\n\t**\tFill in target structure.\n\t*/\n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\ttcb_p tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\ttp->usrsync = usrsync;\n\t\ttp->usrwide = usrwide;\n\n\t\tncr_negotiate (np, tp);\n\t}\n\n\t/*\n\t**      enable ints\n\t*/\n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t/*\n\t**    Start script processor.\n\t*/\n\n\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define bootverbose\t0",
            "#define bootverbose\tNCR_VERBOSE",
            "#define MAX_START   (256)",
            "#define MAX_TARGET  (16)",
            "#define SCSI_NCR_MAX_WIDE   (1)",
            "#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)",
            "#define\tSCSI_NCR_DFLT_SYNC 0",
            "#define SCSI_NCR_DFLT_SYNC   (10)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n#define MAX_START   (256)\n#define MAX_TARGET  (16)\n#define SCSI_NCR_MAX_WIDE   (1)\n#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)\n#define\tSCSI_NCR_DFLT_SYNC 0\n#define SCSI_NCR_DFLT_SYNC   (10)\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\n\nvoid ncr_init (ncb_p np, char * msg, u_long code)\n{\n\tint\ti;\n\tu_long\tusrsync;\n\tu_char\tusrwide;\n\n\t/*\n\t**\tReset chip.\n\t*/\n\n\tOUTB (nc_istat,  SRST);\n\tDELAY (1000);\n\tOUTB (nc_istat, 0);\n\n\t/*\n\t**\tMessage.\n\t*/\n\n\tif (msg) printf (\"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t/*\n\t**\tClear Start Queue\n\t*/\n\n\tfor (i=0;i<MAX_START;i++)\n\t\tnp -> squeue [i] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\n\t/*\n\t**\tStart at first entry.\n\t*/\n\n\tnp->squeueput = 0;\n\tWRITESCRIPT(startpos[0], NCB_SCRIPTH_PHYS (np, tryloop));\n\tWRITESCRIPT(start0  [0], SCR_INT ^ IFFALSE (0));\n\n\t/*\n\t**\tWakeup all pending jobs.\n\t*/\n\n\tncr_wakeup (np, code);\n\n\t/*\n\t**\tInit chip.\n\t*/\n\n\tOUTB (nc_istat,  0x00   );      /*  Remove Reset, abort ...\t     */\n\tOUTB (nc_scntl0, 0xca   );      /*  full arb., ena parity, par->ATN  */\n\tOUTB (nc_scntl1, 0x00\t);\t/*  odd parity, and remove CRST!!    */\n\tncr_selectclock(np, np->rv_scntl3); /* Select SCSI clock             */\n\tOUTB (nc_scid  , RRE|np->myaddr);/*  host adapter SCSI address       */\n\tOUTW (nc_respid, 1ul<<np->myaddr);/*  id to respond to\t\t     */\n\tOUTB (nc_istat , SIGP\t);\t/*  Signal Process\t\t     */\n\tOUTB (nc_dmode , np->rv_dmode);\t/* XXX modify burstlen ??? */\n\tOUTB (nc_dcntl , np->rv_dcntl);\n\tOUTB (nc_ctest3, np->rv_ctest3);\n\tOUTB (nc_ctest5, np->rv_ctest5);\n\tOUTB (nc_ctest4, np->rv_ctest4);/*  enable master parity checking    */\n\tOUTB (nc_stest2, np->rv_stest2|EXT); /* Extended Sreq/Sack filtering */\n\tOUTB (nc_stest3, TE     );\t/*  TolerANT enable\t\t     */\n\tOUTB (nc_stime0, 0x0b\t);\t/*  HTH = disabled, STO = 0.1 sec.   */\n\n\tif (bootverbose >= 2) {\n\t\tprintf (\"\\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\\n\",\n\t\t\tnp->rv_scntl3, np->rv_dmode, np->rv_dcntl);\n\t\tprintf (\"\\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\\n\",\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\t/*\n\t**    Enable GPIO0 pin for writing if LED support.\n\t*/\n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t/*\n\t**\tReinitialize usrsync.\n\t**\tHave to renegotiate synch mode.\n\t*/\n\n\tusrsync = 255;\n\tif (SCSI_NCR_DFLT_SYNC) {\n\t\tusrsync = SCSI_NCR_DFLT_SYNC;\n\t\tif (usrsync > np->maxsync)\n\t\t\tusrsync = np->maxsync;\n\t\tif (usrsync < np->minsync)\n\t\t\tusrsync = np->minsync;\n\t};\n\n\t/*\n\t**\tReinitialize usrwide.\n\t**\tHave to renegotiate wide mode.\n\t*/\n\n\tusrwide = (SCSI_NCR_MAX_WIDE);\n\tif (usrwide > np->maxwide) usrwide=np->maxwide;\n\n\t/*\n\t**\tDisable disconnects.\n\t*/\n\n\tnp->disc = 0;\n\n\t/*\n\t**\tFill in target structure.\n\t*/\n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\ttcb_p tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\ttp->usrsync = usrsync;\n\t\ttp->usrwide = usrwide;\n\n\t\tncr_negotiate (np, tp);\n\t}\n\n\t/*\n\t**      enable ints\n\t*/\n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t/*\n\t**    Start script processor.\n\t*/\n\n\tOUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INL",
          "args": [
            "nc_dsp"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_exception",
          "args": [
            "np"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "SIGP"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100000"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "CABRT"
          ],
          "line": 4855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_exception",
          "args": [
            "np"
          ],
          "line": 4847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 4846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_istat",
            "SIGP"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPTH_PHYS",
          "args": [
            "np",
            "tryloop"
          ],
          "line": 4806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READSCRIPT",
          "args": [
            "startpos[0]"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "CCB_PHYS (cp, phys)"
          ],
          "line": 4799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "phys"
          ],
          "line": 4799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, idle)"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "idle"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "(SCR_JUMP ^ IFFALSE (DATA (cp->tag)))"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "DATA (cp->tag)"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATA",
          "args": [
            "cp->tag"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "sizeof(struct scsi_sense_data)"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, &cp->xfer->sense)"
          ],
          "line": 4757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&cp->xfer->sense"
          ],
          "line": 4757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, &cp->local_sense)"
          ],
          "line": 4755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "&cp->local_sense"
          ],
          "line": 4755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "6"
          ],
          "line": 4742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "CCB_PHYS (cp, sensecmd)"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "sensecmd"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "xp->cmdlen"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCR_KVATOPHYS (np, cmd)"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "cmd"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "msglen2"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "CCB_PHYS (cp, scsi_smsg2)"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "scsi_smsg2"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "msglen"
          ],
          "line": 4729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "CCB_PHYS (cp, scsi_smsg)"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_PHYS",
          "args": [
            "cp",
            "scsi_smsg"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "SCR_JUMP"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, select)"
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "select"
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "NCB_SCRIPT_PHYS (np, no_data)"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "no_data"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "sp + 20 + segments * 16"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "sp"
          ],
          "line": 4694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "data_out"
          ],
          "line": 4693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "sp + 20 + segments * 16"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_BO",
          "args": [
            "sp"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCB_SCRIPT_PHYS",
          "args": [
            "np",
            "data_in"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_free_ccb",
          "args": [
            "np",
            "cp",
            "flags"
          ],
          "line": 4674
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7197-7209",
          "snippet": "void ncr_free_ccb (ncb_p np, ccb_p cp, int flags)\n{\n\t/*\n\t**    sanity\n\t*/\n\n\tassert (cp != NULL);\n\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define  host_status   phys.header.status[1]",
            "#define HS_IDLE\t\t(0)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  host_status   phys.header.status[1]\n#define HS_IDLE\t\t(0)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nvoid ncr_free_ccb (ncb_p np, ccb_p cp, int flags)\n{\n\t/*\n\t**    sanity\n\t*/\n\n\tassert (cp != NULL);\n\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_scatter",
          "args": [
            "np",
            "&cp->phys",
            "(vm_offset_t) xp->data",
            "(vm_size_t) xp->datalen"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_scatter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7445-7547",
          "snippet": "static\tint\tncr_scatter\n\t(ncb_p np, struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)\n{\n\tu_long\tpaddr, pnext;\n\n\tu_short\tsegment  = 0;\n\tu_long\tsegsize, segaddr;\n\tu_long\tsize, csize    = 0;\n\tu_long\tchunk = MAX_SIZE;\n\tint\tfree;\n\n\tbzero (&phys->data, sizeof (phys->data));\n\tif (!datalen) return (0);\n\n\tpaddr = NCR_KVATOPHYS (np, (void *)vaddr);\n\n\t/*\n\t**\tinsert extra break points at a distance of chunk.\n\t**\tWe try to reduce the number of interrupts caused\n\t**\tby unexpected phase changes due to disconnects.\n\t**\tA typical harddisk may disconnect before ANY block.\n\t**\tIf we wanted to avoid unexpected phase changes at all\n\t**\twe had to use a break point every 512 bytes.\n\t**\tOf course the number of scatter/gather blocks is\n\t**\tlimited.\n\t*/\n\n\tfree = MAX_SCATTER - 1;\n\n#ifdef __OpenBSD__\n\tif (vaddr & (NBPG-1)) free -= datalen / NBPG;\n#else\n\tif (vaddr & PAGE_MASK) free -= datalen / PAGE_SIZE;\n#endif\n\n\tif (free>1)\n\t\twhile ((chunk * free >= 2 * datalen) && (chunk>=1024))\n\t\t\tchunk /= 2;\n\n\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\tprintf(\"ncr?:\\tscattering virtual=0x%x size=%d chunk=%d.\\n\",\n\t\t\t(unsigned) vaddr, (unsigned) datalen, (unsigned) chunk);\n\n\t/*\n\t**   Build data descriptors.\n\t*/\n\twhile (datalen && (segment < MAX_SCATTER)) {\n\n\t\t/*\n\t\t**\tthis segment is empty\n\t\t*/\n\t\tsegsize = 0;\n\t\tsegaddr = paddr;\n\t\tpnext   = paddr;\n\n\t\tif (!csize) csize = chunk;\n\n\t\twhile ((datalen) && (paddr == pnext) && (csize)) {\n\n\t\t\t/*\n\t\t\t**\tcontinue this segment\n\t\t\t*/\n#ifdef __OpenBSD__\n\t\t\tpnext = (paddr & (~(NBPG - 1))) + NBPG;\n#else\n\t\t\tpnext = (paddr & (~PAGE_MASK)) + PAGE_SIZE;\n#endif\n\n\t\t\t/*\n\t\t\t**\tCompute max size\n\t\t\t*/\n\n\t\t\tsize = pnext - paddr;\t\t/* page size */\n\t\t\tif (size > datalen) size = datalen;  /* data size */\n\t\t\tif (size > csize  ) size = csize  ;  /* chunksize */\n\n\t\t\tsegsize += size;\n\t\t\tvaddr   += size;\n\t\t\tcsize   -= size;\n\t\t\tdatalen -= size;\n\t\t\tpaddr    = NCR_KVATOPHYS (np, (void *)vaddr);\n\t\t};\n\n\t\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\t\tprintf (\"\\tseg #%d  addr=%x  size=%d  (rest=%d).\\n\",\n\t\t\tsegment,\n\t\t\t(unsigned) segaddr,\n\t\t\t(unsigned) segsize,\n\t\t\t(unsigned) datalen);\n\n\t\tphys->data[segment].addr = SCR_BO(segaddr);\n\t\tphys->data[segment].size = SCR_BO(segsize);\n\t\tsegment++;\n\t}\n\n\tif (datalen) {\n\t\tprintf(\"ncr?: scatter/gather failed (residue=%d).\\n\",\n\t\t\t(unsigned) datalen);\n\t\treturn (-1);\n\t};\n\n\treturn (segment);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define DEBUG_FLAGS\t0",
            "#define DEBUG_FLAGS ncr_debug",
            "#define DEBUG_SCATTER  (0x0020)",
            "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)",
            "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)",
            "#define MAX_SCATTER (33)"
          ],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;",
            "register volatile u_int32_t data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_SCATTER  (0x0020)\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)\n#define MAX_SCATTER (33)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\nregister volatile u_int32_t data;\n\nstatic\tint\tncr_scatter\n\t(ncb_p np, struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)\n{\n\tu_long\tpaddr, pnext;\n\n\tu_short\tsegment  = 0;\n\tu_long\tsegsize, segaddr;\n\tu_long\tsize, csize    = 0;\n\tu_long\tchunk = MAX_SIZE;\n\tint\tfree;\n\n\tbzero (&phys->data, sizeof (phys->data));\n\tif (!datalen) return (0);\n\n\tpaddr = NCR_KVATOPHYS (np, (void *)vaddr);\n\n\t/*\n\t**\tinsert extra break points at a distance of chunk.\n\t**\tWe try to reduce the number of interrupts caused\n\t**\tby unexpected phase changes due to disconnects.\n\t**\tA typical harddisk may disconnect before ANY block.\n\t**\tIf we wanted to avoid unexpected phase changes at all\n\t**\twe had to use a break point every 512 bytes.\n\t**\tOf course the number of scatter/gather blocks is\n\t**\tlimited.\n\t*/\n\n\tfree = MAX_SCATTER - 1;\n\n#ifdef __OpenBSD__\n\tif (vaddr & (NBPG-1)) free -= datalen / NBPG;\n#else\n\tif (vaddr & PAGE_MASK) free -= datalen / PAGE_SIZE;\n#endif\n\n\tif (free>1)\n\t\twhile ((chunk * free >= 2 * datalen) && (chunk>=1024))\n\t\t\tchunk /= 2;\n\n\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\tprintf(\"ncr?:\\tscattering virtual=0x%x size=%d chunk=%d.\\n\",\n\t\t\t(unsigned) vaddr, (unsigned) datalen, (unsigned) chunk);\n\n\t/*\n\t**   Build data descriptors.\n\t*/\n\twhile (datalen && (segment < MAX_SCATTER)) {\n\n\t\t/*\n\t\t**\tthis segment is empty\n\t\t*/\n\t\tsegsize = 0;\n\t\tsegaddr = paddr;\n\t\tpnext   = paddr;\n\n\t\tif (!csize) csize = chunk;\n\n\t\twhile ((datalen) && (paddr == pnext) && (csize)) {\n\n\t\t\t/*\n\t\t\t**\tcontinue this segment\n\t\t\t*/\n#ifdef __OpenBSD__\n\t\t\tpnext = (paddr & (~(NBPG - 1))) + NBPG;\n#else\n\t\t\tpnext = (paddr & (~PAGE_MASK)) + PAGE_SIZE;\n#endif\n\n\t\t\t/*\n\t\t\t**\tCompute max size\n\t\t\t*/\n\n\t\t\tsize = pnext - paddr;\t\t/* page size */\n\t\t\tif (size > datalen) size = datalen;  /* data size */\n\t\t\tif (size > csize  ) size = csize  ;  /* chunksize */\n\n\t\t\tsegsize += size;\n\t\t\tvaddr   += size;\n\t\t\tcsize   -= size;\n\t\t\tdatalen -= size;\n\t\t\tpaddr    = NCR_KVATOPHYS (np, (void *)vaddr);\n\t\t};\n\n\t\tif(DEBUG_FLAGS & DEBUG_SCATTER)\n\t\t\tprintf (\"\\tseg #%d  addr=%x  size=%d  (rest=%d).\\n\",\n\t\t\tsegment,\n\t\t\t(unsigned) segaddr,\n\t\t\t(unsigned) segsize,\n\t\t\t(unsigned) datalen);\n\n\t\tphys->data[segment].addr = SCR_BO(segaddr);\n\t\tphys->data[segment].size = SCR_BO(segsize);\n\t\tsegment++;\n\t}\n\n\tif (datalen) {\n\t\tprintf(\"ncr?: scatter/gather failed (residue=%d).\\n\",\n\t\t\t(unsigned) datalen);\n\t\treturn (-1);\n\t};\n\n\treturn (segment);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_show_msg",
          "args": [
            "&cp->scsi_smsg [msglen-4]"
          ],
          "line": 4646
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_show_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "6525-6540",
          "snippet": "static int ncr_show_msg (u_char * msg)\n{\n\tu_char i;\n\tprintf (\"%x\",*msg);\n\tif (*msg==M_EXTENDED) {\n\t\tfor (i=1;i<8;i++) {\n\t\t\tif (i-1>msg[1]) break;\n\t\t\tprintf (\"-%x\",msg[i]);\n\t\t};\n\t\treturn (i+1);\n\t} else if ((*msg & 0xf0) == 0x20) {\n\t\tprintf (\"-%x\",msg[1]);\n\t\treturn (2);\n\t};\n\treturn (1);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti;",
            "int\ti;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nint\ti;\nint\ti;\n\nstatic int ncr_show_msg (u_char * msg)\n{\n\tu_char i;\n\tprintf (\"%x\",*msg);\n\tif (*msg==M_EXTENDED) {\n\t\tfor (i=1;i<8;i++) {\n\t\t\tif (i-1>msg[1]) break;\n\t\t\tprintf (\"-%x\",msg[i]);\n\t\t};\n\t\treturn (i+1);\n\t} else if ((*msg & 0xf0) == 0x20) {\n\t\tprintf (\"-%x\",msg[1]);\n\t\treturn (2);\n\t};\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 4644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "cp->xfer"
          ],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_setmaxtags",
          "args": [
            "tp",
            "tp->usrtags"
          ],
          "line": 4507
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_lookup",
          "args": [
            "(char*) &tp->inqdata[0]"
          ],
          "line": 4489
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7778-7802",
          "snippet": "static u_long ncr_lookup(char * id)\n{\n\tstruct table_entry * p = device_tab;\n\tchar *d, *r, c;\n\n\tfor (;;p++) {\n\n\t\td = id+8;\n\t\tr = p->manufacturer;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+16;\n\t\tr = p->model;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+32;\n\t\tr = p->version;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\treturn (p->info);\n\t}\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic u_long ncr_lookup(char * id)\n{\n\tstruct table_entry * p = device_tab;\n\tchar *d, *r, c;\n\n\tfor (;;p++) {\n\n\t\td = id+8;\n\t\tr = p->manufacturer;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+16;\n\t\tr = p->model;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\td = id+32;\n\t\tr = p->version;\n\t\twhile ((c=*r++)) if (c!=*d++) break;\n\t\tif (c) continue;\n\n\t\treturn (p->info);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettime",
          "args": [
            "&cp->phys.header.stamp.start"
          ],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&cp->phys.header.stamp",
            "sizeof (struct tstamp)"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_get_ccb",
          "args": [
            "np",
            "flags",
            "xp->sc_link->target",
            "xp->sc_link->lun"
          ],
          "line": 4453
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_get_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "7137-7186",
          "snippet": "static\tccb_p ncr_get_ccb\n\t(ncb_p np, u_long flags, u_long target, u_long lun)\n{\n\tlcb_p lp;\n\tccb_p cp = (ccb_p) 0;\n\tint oldspl;\n\n\toldspl = splbio();\n\t/*\n\t**\tLun structure available ?\n\t*/\n\n\tlp = np->target[target].lp[lun];\n\tif (lp) {\n\t\tcp = lp->next_ccb;\n\n\t\t/*\n\t\t**\tLook for free CCB\n\t\t*/\n\n\t\twhile (cp && cp->magic) {\n\t\t\tcp = cp->next_ccb;\n\t\t}\n\t}\n\n\t/*\n\t**\tif nothing available, take the default.\n\t*/\n\n\tif (!cp) cp = np->ccb;\n\n\t/*\n\t**\tWait until available.\n\t*/\n\n\twhile (cp->magic) {\n\t\tif (flags & SCSI_NOSLEEP) break;\n\t\tif (tsleep ((caddr_t)cp, PRIBIO|PCATCH, \"ncr\", 0))\n\t\t\tbreak;\n\t};\n\n\tif (cp->magic) {\n\t\tsplx(oldspl);\n\t\treturn ((ccb_p) 0);\n\t}\n\n\tcp->magic = 1;\n\tsplx(oldspl);\n\treturn (cp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic\tccb_p ncr_get_ccb\n\t(ncb_p np, u_long flags, u_long target, u_long lun)\n{\n\tlcb_p lp;\n\tccb_p cp = (ccb_p) 0;\n\tint oldspl;\n\n\toldspl = splbio();\n\t/*\n\t**\tLun structure available ?\n\t*/\n\n\tlp = np->target[target].lp[lun];\n\tif (lp) {\n\t\tcp = lp->next_ccb;\n\n\t\t/*\n\t\t**\tLook for free CCB\n\t\t*/\n\n\t\twhile (cp && cp->magic) {\n\t\t\tcp = cp->next_ccb;\n\t\t}\n\t}\n\n\t/*\n\t**\tif nothing available, take the default.\n\t*/\n\n\tif (!cp) cp = np->ccb;\n\n\t/*\n\t**\tWait until available.\n\t*/\n\n\twhile (cp->magic) {\n\t\tif (flags & SCSI_NOSLEEP) break;\n\t\tif (tsleep ((caddr_t)cp, PRIBIO|PCATCH, \"ncr\", 0))\n\t\t\tbreak;\n\t};\n\n\tif (cp->magic) {\n\t\tsplx(oldspl);\n\t\treturn ((ccb_p) 0);\n\t}\n\n\tcp->magic = 1;\n\tsplx(oldspl);\n\treturn (cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 4451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "np->sc_pc",
            "(vm_offset_t)&xp->sense",
            "sizeof(struct scsi_sense_data)"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "np->sc_pc",
            "(vm_offset_t)xp->cmd",
            "xp->cmdlen"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "np->sc_pc",
            "(vm_offset_t)xp->data",
            "xp->datalen"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ADDR",
          "args": [
            "xp"
          ],
          "line": 4386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTB",
          "args": [
            "nc_scntl1",
            "CRST"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define  wide_status   phys.wide_st\n#define  nego_status   phys.nego_st\n#define  sync_status   phys.sync_st\n#define  xerr_status   phys.xerr_st\n#define  parity_status phys.header.status[3]\n#define  scsi_status   phys.header.status[2]\n#define  host_status   phys.header.status[1]\n#define  actualquirks  phys.header.status[0]\n#define CCB_MAGIC\t(0xf2691ad2)\n#define\tINQ7_WIDE16\t(0x20)\n#define\tINQ7_SYNC\t(0x10)\n#define\tQUIRK_UPDATE\t(0x80)\n#define QUIRK_NOTAGS\t(0x40)\n#define QUIRK_NOWIDE16\t(0x20)\n#define QUIRK_NOSYNC\t(0x10)\n#define\tQUIRK_NOMSG\t(0x02)\n#define NS_WIDE\t\t(2)\n#define NS_SYNC\t\t(1)\n#define\tXE_OK\t\t(0)\n#define HS_TIMEOUT\t(8)\t/* Software timeout       */\n#define HS_SEL_TIMEOUT\t(5)\t/* Selection timeout      */\n#define HS_NEGOTIATE\t(2)\t/* sync/wide data transfer*/\n#define HS_BUSY\t\t(1)\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TAGS     (0x0400)\n#define DEBUG_NEGO     (0x0200)\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_RESULT   (0x0010)\n#define DEBUG_QUEUE    (0x0008)\n#define DEBUG_POLL     (0x0004)\n#define bootverbose\t0\n#define bootverbose\tNCR_VERBOSE\n#define MAX_START   (256)\n#define MAX_LUN     (8)\n#define MAX_TARGET  (16)\n#define\tSCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)\n#define\tSCSI_NCR_DFLT_SYNC 0\n#define SCSI_NCR_DFLT_SYNC   (10)\n#define\tNCR_CDROM_ASYNC\n\nncb_p np = (void *)self;\nu_long\tperiod;\nint\ti;\nncb_p np = (struct ncb*) 0;\nu_long\tperiod;\nint\ti;\nregister volatile u_int32_t data;\n\nstatic int32_t ncr_start (struct scsi_xfer * xp)\n{\n\tncb_p np  = (ncb_p) xp->sc_link->adapter_softc;\n\n\tstruct scsi_generic * cmd = (struct scsi_generic *)xp->cmd;\n\tccb_p cp;\n\tlcb_p lp;\n\ttcb_p tp = &np->target[xp->sc_link->target];\n\n\tint\ti, oldspl, segments, flags = xp->flags, pollmode;\n\tu_char\tqidx, nego, idmsg, *msgptr;\n\tu_long  msglen, msglen2;\n\n\t/*---------------------------------------------\n\t**\n\t**   Reset SCSI bus\n\t**\n\t**\tInterrupt handler does the real work.\n\t**\n\t**---------------------------------------------\n\t*/\n\n\tif (flags & SCSI_RESET) {\n\t\tOUTB (nc_scntl1, CRST);\n\t\tDELAY (1000);\n\t\treturn(COMPLETE);\n\t};\n\n\t/*---------------------------------------------\n\t**\n\t**      Some shortcuts ...\n\t**\n\t**---------------------------------------------\n\t*/\n\n\tif ((xp->sc_link->target == np->myaddr\t  ) ||\n\t\t(xp->sc_link->target >= MAX_TARGET) ||\n\t\t(xp->sc_link->lun    >= MAX_LUN   ) ||\n\t\t(flags    & SCSI_DATA_UIO)) {\n\t\txp->error = XS_DRIVER_STUFFUP;\n\t\treturn(COMPLETE);\n\t};\n\n\t/*---------------------------------------------\n\t**\n\t**      Diskaccess to partial blocks?\n\t**\n\t**---------------------------------------------\n\t*/\n\n\tif ((xp->datalen & 0x1ff) && !(tp->inqdata[0] & 0x1f)) {\n\t\tswitch (cmd->opcode) {\n\t\tcase 0x28:  /* READ_BIG  (10) */\n\t\tcase 0xa8:  /* READ_HUGE (12) */\n\t\tcase 0x2a:  /* WRITE_BIG (10) */\n\t\tcase 0xaa:  /* WRITE_HUGE(12) */\n\t\t\tPRINT_ADDR(xp);\n\t\t\tprintf (\"access to partial disk block refused.\\n\");\n\t\t\txp->error = XS_DRIVER_STUFFUP;\n\t\t\treturn(COMPLETE);\n\t\t};\n\t};\n\n\tif ((unsigned)xp->datalen > 128*1024*1024) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"trying to transfer %8x bytes, mem addr = %p\\n\",\n\t\t\txp->datalen, xp->data);\n\t\t{\n\t\t\tint j;\n\t\t\tPRINT_ADDR(xp);\n\t\t\tprintf (\"command: %2x (\", cmd->opcode);\n\t\t\tfor (j = 0; j<11; j++)\n\t\t\t\tprintf (\" %2x\", cmd->bytes[j]);\n\t\t\tprintf (\")\\n\");\n\t\t}\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) {\n\t\tPRINT_ADDR(xp);\n\t\tprintf (\"CMD=%x F=%x A=%p L=%x \",\n\t\t\tcmd->opcode, (unsigned)xp->flags, xp->data,\n\t\t\t(unsigned)xp->datalen);\n\t}\n\n\t/*--------------------------------------------\n\t**\n\t**   Sanity checks ...\n\t**\tcopied from Elischer's Adaptec driver.\n\t**\n\t**--------------------------------------------\n\t*/\n\n\tflags = xp->flags;\n\tif (!(flags & INUSE)) {\n\t\tprintf(\"%s: ?INUSE?\\n\", ncr_name (np));\n\t\txp->flags |= INUSE;\n\t};\n\n\tif(flags & ITSDONE) {\n\t\tprintf(\"%s: ?ITSDONE?\\n\", ncr_name (np));\n\t\txp->flags &= ~ITSDONE;\n\t};\n\n\tif (xp->bp)\n\t\tflags |= (SCSI_NOSLEEP); /* just to be sure */\n\n\t/*---------------------------------------------------\n\t**\n\t**\tAssign a ccb / bind xp\n\t**\n\t**----------------------------------------------------\n\t*/\n\n#if defined(__mips__)\n\tif (xp->data && xp->datalen) {\n\t\tpci_sync_cache(np->sc_pc, (vm_offset_t)xp->data, xp->datalen);\n\t} \n\tpci_sync_cache(np->sc_pc, (vm_offset_t)xp->cmd, xp->cmdlen);\n\tpci_sync_cache(np->sc_pc, (vm_offset_t)&xp->sense, sizeof(struct scsi_sense_data));\n#endif /* __mips__ */\n\n\toldspl = splbio();\n\n\tif (!(cp=ncr_get_ccb (np, flags, xp->sc_link->target,\n\t\txp->sc_link->lun))) {\n\t\tprintf (\"%s: no ccb.\\n\", ncr_name (np));\n\t\txp->error = XS_DRIVER_STUFFUP;\n\t\tsplx(oldspl);\n\t\treturn(TRY_AGAIN_LATER);\n\t};\n\tcp->xfer = xp;\n\n\t/*---------------------------------------------------\n\t**\n\t**\ttimestamp\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tbzero (&cp->phys.header.stamp, sizeof (struct tstamp));\n#ifdef __OpenBSD__\n\tcp->phys.header.stamp.start = mono_time;\n#else\n\tgettime(&cp->phys.header.stamp.start);\n#endif\n\n\t/*----------------------------------------------------\n\t**\n\t**\tGet device quirks from a speciality table.\n\t**\n\t**\t@GENSCSI@\n\t**\tThis should be a part of the device table\n\t**\tin \"scsi_conf.c\".\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif (tp->quirks & QUIRK_UPDATE) {\n#ifdef __OpenBSD__\n\t\ttp->quirks = ncr_lookup ((char*) &tp->inqdata[0]);\n#else\n\t\tint q = xp->sc_link->quirks;\n\t\ttp->quirks = QUIRK_NOMSG;\n\t\tif (q & SD_Q_NO_TAGS)\n\t\t\ttp->quirks |= QUIRK_NOTAGS;\n\t\tif (q & SD_Q_NO_SYNC)\n\t\t\ttp->quirks |= QUIRK_NOSYNC;\n\t\tif (q & SD_Q_NO_WIDE)\n\t\t\ttp->quirks |= QUIRK_NOWIDE16;\n#endif\n\t\tif (bootverbose && (tp->quirks & ~QUIRK_NOMSG)) {\n\t\t\tPRINT_ADDR(xp);\n\t\t\tprintf (\"NCR quirks=0x%x\\n\", tp->quirks);\n\t\t};\n\t\t/*\n\t\t**\tset number of tags\n\t\t*/\n\t\tncr_setmaxtags (tp, tp->usrtags);\n\t};\n\n\t/*---------------------------------------------------\n\t**\n\t**\tnegotiation required?\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tnego = 0;\n\n\tif (!tp->nego_cp && tp->inqdata[7]) {\n\t\t/*\n\t\t**\tnegotiate wide transfers ?\n\t\t*/\n\n\t\tif (!tp->widedone) {\n\t\t\tif (tp->inqdata[7] & INQ7_WIDE16) {\n\t\t\t\tnego = NS_WIDE;\n\t\t\t} else\n\t\t\t\ttp->widedone=1;\n\t\t};\n\n\t\t/*\n\t\t**\tnegotiate synchronous transfers?\n\t\t*/\n\n\t\tif (!nego && !tp->period) {\n\t\t\tif (SCSI_NCR_DFLT_SYNC\n#ifdef NCR_CDROM_ASYNC\n\t\t\t    && ((tp->inqdata[0] & 0x1f) != 5)\n#endif /* NCR_CDROM_ASYNC */\n\t\t\t    && (tp->inqdata[7] & INQ7_SYNC)) {\n\t\t\t\tnego = NS_SYNC;\n\t\t\t} else {\n\t\t\t\ttp->period  =0xffff;\n\t\t\t\ttp->sval = 0xe0;\n\t\t\t\tPRINT_ADDR(xp);\n\t\t\t\tprintf (\"asynchronous.\\n\");\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t**\tremember nego is pending for the target.\n\t\t**\tAvoid to start a nego for all queued commands\n\t\t**\twhen tagged command queuing is enabled.\n\t\t*/\n\n\t\tif (nego)\n\t\t\ttp->nego_cp = cp;\n\t};\n\n\t/*---------------------------------------------------\n\t**\n\t**\tchoose a new tag ...\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif ((lp = tp->lp[xp->sc_link->lun]) && (lp->usetags)) {\n\t\t/*\n\t\t**\tassign a tag to this ccb!\n\t\t*/\n\t\twhile (!cp->tag) {\n\t\t\tccb_p cp2 = lp->next_ccb;\n\t\t\tlp->lasttag = lp->lasttag % 255 + 1;\n\t\t\twhile (cp2 && cp2->tag != lp->lasttag)\n\t\t\t\tcp2 = cp2->next_ccb;\n\t\t\tif (cp2) continue;\n\t\t\tcp->tag=lp->lasttag;\n\t\t\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\t\t\tPRINT_ADDR(xp);\n\t\t\t\tprintf (\"using tag #%d.\\n\", cp->tag);\n\t\t\t};\n\t\t};\n\t} else {\n\t\tcp->tag=0;\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the identify / tag / sdtr message\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tidmsg = M_IDENTIFY | xp->sc_link->lun;\n\tif ((cp!=np->ccb) && (np->disc))\n\t\tidmsg |= 0x40;\n\n\tmsgptr = cp->scsi_smsg;\n\tmsglen = 0;\n\tmsgptr[msglen++] = idmsg;\n\n\tif (cp->tag) {\n\t    char tag;\n\n\t    tag = np->order;\n\t    if (tag == 0) {\n\t\t/*\n\t\t**\tOrdered write ops, unordered read ops.\n\t\t*/\n\t\tswitch (cmd->opcode) {\n\t\tcase 0x08:  /* READ_SMALL (6) */\n\t\tcase 0x28:  /* READ_BIG  (10) */\n\t\tcase 0xa8:  /* READ_HUGE (12) */\n\t\t    tag = M_SIMPLE_TAG;\n\t\t    break;\n\t\tdefault:\n\t\t    tag = M_ORDERED_TAG;\n\t\t}\n\t    }\n\t    msgptr[msglen++] = tag;\n\t    msgptr[msglen++] = cp -> tag;\n\t}\n\n\tswitch (nego) {\n\tcase NS_SYNC:\n\t\tmsgptr[msglen++] = M_EXTENDED;\n\t\tmsgptr[msglen++] = 3;\n\t\tmsgptr[msglen++] = M_X_SYNC_REQ;\n\t\tmsgptr[msglen++] = tp->minsync;\n\t\tmsgptr[msglen++] = tp->maxoffs;\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"sync msgout: \");\n\t\t\tncr_show_msg (&cp->scsi_smsg [msglen-5]);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\t\tbreak;\n\tcase NS_WIDE:\n\t\tmsgptr[msglen++] = M_EXTENDED;\n\t\tmsgptr[msglen++] = 2;\n\t\tmsgptr[msglen++] = M_X_WIDE_REQ;\n\t\tmsgptr[msglen++] = tp->usrwide;\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->xfer);\n\t\t\tprintf (\"wide msgout: \");\n\t\t\tncr_show_msg (&cp->scsi_smsg [msglen-4]);\n\t\t\tprintf (\".\\n\");\n\t\t};\n\t\tbreak;\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the identify message for getcc.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tcp -> scsi_smsg2 [0] = idmsg;\n\tmsglen2 = 1;\n\n\t/*----------------------------------------------------\n\t**\n\t**\tBuild the data descriptors\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tsegments = ncr_scatter (np, &cp->phys, (vm_offset_t) xp->data,\n\t\t\t\t\t(vm_size_t) xp->datalen);\n\n\tif (segments < 0) {\n\t\txp->error = XS_DRIVER_STUFFUP;\n\t\tncr_free_ccb(np, cp, flags);\n\t\tsplx(oldspl);\n\t\treturn(COMPLETE);\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tSet the SAVED_POINTER.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif (flags & SCSI_DATA_IN) {\n\t\tu_long sp;\n\t\tsp = NCB_SCRIPT_PHYS (np, data_in);\n\t\tcp->phys.header.savep = SCR_BO(sp);\n\t\tcp->phys.header.goalp = SCR_BO(sp + 20 + segments * 16);\n\t} else if (flags & SCSI_DATA_OUT) {\n\t\tu_long sp;\n\t\tsp = NCB_SCRIPT_PHYS (np, data_out);\n\t\tcp->phys.header.savep = SCR_BO(sp);\n\t\tcp->phys.header.goalp = SCR_BO(sp + 20 + segments * 16);\n\t} else {\n\t\tcp->phys.header.savep = SCR_BO(NCB_SCRIPT_PHYS (np, no_data));\n\t\tcp->phys.header.goalp = cp->phys.header.savep;\n\t};\n\tcp->phys.header.lastp = cp->phys.header.savep;\n\n\n\t/*----------------------------------------------------\n\t**\n\t**\tfill in ccb\n\t**\n\t**----------------------------------------------------\n\t**\n\t**\n\t**\tphysical -> virtual backlink\n\t**\tGeneric SCSI command\n\t*/\n\tcp->phys.header.cp\t\t= cp;\n\t/*\n\t**\tStartqueue\n\t*/\n\tcp->phys.header.launch.l_paddr\t= SCR_BO(NCB_SCRIPT_PHYS (np, select));\n\tcp->phys.header.launch.l_cmd\t= SCR_BO(SCR_JUMP);\n\t/*\n\t**\tselect\n\t*/\n\tcp->phys.select.sel_id\t\t= xp->sc_link->target;\n\tcp->phys.select.sel_scntl3\t= tp->wval;\n\tcp->phys.select.sel_sxfer\t= tp->sval;\n\t/*\n\t**\tmessage\n\t*/\n\tcp->phys.smsg.addr\t\t= SCR_BO(CCB_PHYS (cp, scsi_smsg));\n\tcp->phys.smsg.size\t\t= SCR_BO(msglen);\n\n\tcp->phys.smsg2.addr\t\t= SCR_BO(CCB_PHYS (cp, scsi_smsg2));\n\tcp->phys.smsg2.size\t\t= SCR_BO(msglen2);\n\t/*\n\t**\tcommand\n\t*/\n\tcp->phys.cmd.addr\t\t= SCR_BO(NCR_KVATOPHYS (np, cmd));\n\tcp->phys.cmd.size\t\t= SCR_BO(xp->cmdlen);\n\t/*\n\t**\tsense command\n\t*/\n\tcp->phys.scmd.addr\t\t= SCR_BO(CCB_PHYS (cp, sensecmd));\n\tcp->phys.scmd.size\t\t= SCR_BO(6);\n\t/*\n\t**\tpatch requested size into sense command\n\t*/\n\tcp->sensecmd[0]\t\t\t= 0x03;\n\tcp->sensecmd[1]\t\t\t= xp->sc_link->lun << 5;\n\tcp->sensecmd[4]\t\t\t= sizeof(struct scsi_sense_data);\n\tif (xp->req_sense_length)\n\t\tcp->sensecmd[4]\t\t= xp->req_sense_length;\n\t/*\n\t**\tsense data\n\t*/\n#if defined(__mips__)\n\tcp->phys.sense.addr\t\t= SCR_BO(NCR_KVATOPHYS (np, &cp->local_sense));\n#else\n\tcp->phys.sense.addr\t\t= SCR_BO(NCR_KVATOPHYS (np, &cp->xfer->sense));\n#endif\n\tcp->phys.sense.size\t\t= SCR_BO(sizeof(struct scsi_sense_data));\n\t/*\n\t**\tstatus\n\t*/\n\tcp->actualquirks\t\t= tp->quirks;\n\tcp->host_status\t\t\t= nego ? HS_NEGOTIATE : HS_BUSY;\n\tcp->scsi_status\t\t\t= S_ILLEGAL;\n\tcp->parity_status\t\t= 0;\n\n\tcp->xerr_status\t\t\t= XE_OK;\n\tcp->sync_status\t\t\t= tp->sval;\n\tcp->nego_status\t\t\t= nego;\n\tcp->wide_status\t\t\t= tp->wval;\n\n\t/*----------------------------------------------------\n\t**\n\t**\tCritical region: start this job.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\t/*\n\t**\treselect pattern and activate this job.\n\t*/\n\n\tcp->jump_ccb.l_cmd\t= SCR_BO((SCR_JUMP ^ IFFALSE (DATA (cp->tag))));\n#ifdef __OpenBSD__\n\tcp->tlimit\t\t= mono_time.tv_sec + xp->timeout / 1000 + 2;\n#else\n\tcp->tlimit\t\t= time.tv_sec + xp->timeout / 1000 + 2;\n#endif\n\tcp->magic\t\t= CCB_MAGIC;\n\n\t/*\n\t**\tinsert into start queue.\n\t*/\n\n\tqidx = np->squeueput + 1;\n\tif (qidx >= MAX_START) qidx=0;\n\tnp->squeue [qidx\t ] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));\n\tnp->squeue [np->squeueput] = SCR_BO(CCB_PHYS (cp, phys));\n\tnp->squeueput = qidx;\n\n\tif(DEBUG_FLAGS & DEBUG_QUEUE)\n\t\tprintf (\"%s: queuepos=%d tryoffset=%d.\\n\", ncr_name (np),\n\t\tnp->squeueput,\n\t\t(unsigned)(READSCRIPT(startpos[0])-\n\t\t\t   (NCB_SCRIPTH_PHYS (np, tryloop))));\n\n\t/*\n\t**\tScript processor may be waiting for reselect.\n\t**\tWake it up.\n\t*/\n\tOUTB (nc_istat, SIGP);\n\n\t/*\n\t**\tand reenable interrupts\n\t*/\n#ifdef __OpenBSD__\n\tpollmode = flags & SCSI_POLL;\n#else\n\tpollmode = flags & SCSI_NOMASK;\n#endif\n\tsplx (oldspl);\n\n\t/*\n\t**\tIf interrupts are enabled, return now.\n\t**\tCommand is successfully queued.\n\t*/\n\n\tif (!pollmode) {\n\t\tif(DEBUG_FLAGS & DEBUG_TINY) printf (\"Q\");\n\t\treturn(SUCCESSFULLY_QUEUED);\n\t};\n\n\t/*----------------------------------------------------\n\t**\n\t**\tInterrupts not yet enabled - have to poll.\n\t**\n\t**----------------------------------------------------\n\t*/\n\n\tif (DEBUG_FLAGS & DEBUG_POLL) printf(\"P\");\n\n\tfor (i=xp->timeout; i && !(xp->flags & ITSDONE);i--) {\n\t\tif ((DEBUG_FLAGS & DEBUG_POLL) && (cp->host_status))\n\t\t\tprintf (\"%c\", (cp->host_status & 0xf) + '0');\n\t\tDELAY (1000);\n\t\tncr_exception (np);\n\t};\n\n\t/*\n\t**\tAbort if command not done.\n\t*/\n\tif (!(xp->flags & ITSDONE)) {\n\t\tprintf (\"%s: aborting job ...\\n\", ncr_name (np));\n\t\tOUTB (nc_istat, CABRT);\n\t\tDELAY (100000);\n\t\tOUTB (nc_istat, SIGP);\n\t\tncr_exception (np);\n\t};\n\n\tif (!(xp->flags & ITSDONE)) {\n\t\tprintf (\"%s: abortion failed at %x.\\n\",\n\t\t\tncr_name (np), (unsigned) INL(nc_dsp));\n\t\tncr_init (np, \"timeout\", HS_TIMEOUT);\n\t};\n\n\tif (!(xp->flags & ITSDONE)) {\n\t\tcp-> host_status = HS_SEL_TIMEOUT;\n\t\tncr_complete (np, cp);\n\t};\n\n\tif (DEBUG_FLAGS & DEBUG_RESULT) {\n\t\tprintf (\"%s: result: %x %x.\\n\",\n\t\t\tncr_name (np), cp->host_status, cp->scsi_status);\n\t};\n\tswitch (xp->error) {\n\tcase  0     : return (COMPLETE);\n\tcase XS_BUSY: return (TRY_AGAIN_LATER);\n\t};\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "ncr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "4283-4318",
    "snippet": "static int\n#else /* !__OpenBSD__ */\nstatic void\n#endif /* __OpenBSD__ */\nncr_intr(vnp)\n\tvoid *vnp;\n{\n#ifdef __OpenBSD__\n\tint n = 0;\n#endif\n\tncb_p np = vnp;\n\tint oldspl = splbio();\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"[\");\n\n\tif (INB(nc_istat) & (INTF|SIP|DIP)) {\n\t\t/*\n\t\t**\tRepeat until no outstanding ints\n\t\t*/\n\t\tdo {\n\t\t\tncr_exception (np);\n\t\t} while (INB(nc_istat) & (INTF|SIP|DIP));\n\n#ifdef __OpenBSD__\n\t\tn=1;\n#endif\n\t\tnp->ticks = 100;\n\t};\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"]\\n\");\n\n\tsplx (oldspl);\n#ifdef __OpenBSD__\n\treturn (n);\n#endif\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_TINY     (0x0080)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "oldspl"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"]\\n\""
          ],
          "line": 4312
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_istat"
          ],
          "line": 4304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_exception",
          "args": [
            "np"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INB",
          "args": [
            "nc_istat"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_TINY     (0x0080)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic int\n#else /* !__OpenBSD__ */\nstatic void\n#endif /* __OpenBSD__ */\nncr_intr(vnp)\n\tvoid *vnp;\n{\n#ifdef __OpenBSD__\n\tint n = 0;\n#endif\n\tncb_p np = vnp;\n\tint oldspl = splbio();\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"[\");\n\n\tif (INB(nc_istat) & (INTF|SIP|DIP)) {\n\t\t/*\n\t\t**\tRepeat until no outstanding ints\n\t\t*/\n\t\tdo {\n\t\t\tncr_exception (np);\n\t\t} while (INB(nc_istat) & (INTF|SIP|DIP));\n\n#ifdef __OpenBSD__\n\t\tn=1;\n#endif\n\t\tnp->ticks = 100;\n\t};\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printf (\"]\\n\");\n\n\tsplx (oldspl);\n#ifdef __OpenBSD__\n\treturn (n);\n#endif\n}"
  },
  {
    "function_name": "ncr_init_burst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3602-3616",
    "snippet": "static void ncr_init_burst(ncb_p np, u_char bc)\n{\n\tnp->rv_ctest4\t&= ~0x80;\n\tnp->rv_dmode\t&= ~(0x3 << 6);\n\tnp->rv_ctest5\t&= ~0x4;\n\n\tif (!bc) {\n\t\tnp->rv_ctest4\t|= 0x80;\n\t}\n\telse {\n\t\t--bc;\n\t\tnp->rv_dmode\t|= ((bc & 0x3) << 6);\n\t\tnp->rv_ctest5\t|= (bc & 0x4);\n\t}\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void ncr_init_burst(ncb_p np, u_char bc)\n{\n\tnp->rv_ctest4\t&= ~0x80;\n\tnp->rv_dmode\t&= ~(0x3 << 6);\n\tnp->rv_ctest5\t&= ~0x4;\n\n\tif (!bc) {\n\t\tnp->rv_ctest4\t|= 0x80;\n\t}\n\telse {\n\t\t--bc;\n\t\tnp->rv_dmode\t|= ((bc & 0x3) << 6);\n\t\tnp->rv_ctest5\t|= (bc & 0x4);\n\t}\n}"
  },
  {
    "function_name": "ncr_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3550-3560",
    "snippet": "static\tchar* ncr_probe (pcici_t tag, pcidi_t type)\n{\n\tu_char rev = PCI_REVISION(pa->pa_class);\n\tint i;\n\n\ti = ncr_chip_lookup(type, rev);\n\tif (i >= 0)\n\t\treturn ncr_chip_table[i].name;\n\n\treturn (NULL);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ncr_chip ncr_chip_table[] = {\n {NCR_810_ID, 0x00,\t4,  8, 4,\n FE_ERL}\n ,\n {NCR_810_ID, 0x10,\t4,  8, 4,\n FE_ERL|FE_LDSTR|FE_PFEN|FE_BOF}\n ,\n {NCR_815_ID, 0x00,\t4,  8, 4,\n FE_ERL|FE_BOF}\n ,\n {NCR_820_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL}\n ,\n {NCR_825_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL|FE_BOF}\n ,\n {NCR_825_ID, 0x10,\t7,  8, 4,\n FE_WIDE|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_860_ID, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_LDSTR|FE_PFEN}\n ,\n {NCR_875_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_875_ID, 0x02,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n#ifdef NCR_NARROW_875J\n {NCR_875_ID2, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#else\n {NCR_875_ID2, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#endif\n ,\n {NCR_885_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_895_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_896_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n};",
      "struct pci_attach_args *pa = aux;",
      "int\ti;",
      "u_char rev = PCI_REVISION(pa->pa_class);",
      "char *type;",
      "u_char\trev = 0;",
      "int\ti;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_chip_lookup",
          "args": [
            "type",
            "rev"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_chip_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "3496-3512",
          "snippet": "static int ncr_chip_lookup(u_long device_id, u_char revision_id)\n{\n\tint i, found;\n\t\n\tfound = -1;\n\tfor (i = 0; i < sizeof(ncr_chip_table)/sizeof(ncr_chip_table[0]); i++) {\n\t\tif (device_id\t== ncr_chip_table[i].device_id &&\n\t\t    ncr_chip_table[i].minrevid <= revision_id) {\n\t\t\tif (found < 0 ||\n\t\t\t    ncr_chip_table[found].minrevid\n\t\t\t      < ncr_chip_table[i].minrevid) {\n\t\t\t\tfound = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ncr_chip ncr_chip_table[] = {\n {NCR_810_ID, 0x00,\t4,  8, 4,\n FE_ERL}\n ,\n {NCR_810_ID, 0x10,\t4,  8, 4,\n FE_ERL|FE_LDSTR|FE_PFEN|FE_BOF}\n ,\n {NCR_815_ID, 0x00,\t4,  8, 4,\n FE_ERL|FE_BOF}\n ,\n {NCR_820_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL}\n ,\n {NCR_825_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL|FE_BOF}\n ,\n {NCR_825_ID, 0x10,\t7,  8, 4,\n FE_WIDE|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_860_ID, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_LDSTR|FE_PFEN}\n ,\n {NCR_875_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_875_ID, 0x02,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n#ifdef NCR_NARROW_875J\n {NCR_875_ID2, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#else\n {NCR_875_ID2, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#endif\n ,\n {NCR_885_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_895_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_896_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n};",
            "int\ti;",
            "int\ti;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic ncr_chip ncr_chip_table[] = {\n {NCR_810_ID, 0x00,\t4,  8, 4,\n FE_ERL}\n ,\n {NCR_810_ID, 0x10,\t4,  8, 4,\n FE_ERL|FE_LDSTR|FE_PFEN|FE_BOF}\n ,\n {NCR_815_ID, 0x00,\t4,  8, 4,\n FE_ERL|FE_BOF}\n ,\n {NCR_820_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL}\n ,\n {NCR_825_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL|FE_BOF}\n ,\n {NCR_825_ID, 0x10,\t7,  8, 4,\n FE_WIDE|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_860_ID, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_LDSTR|FE_PFEN}\n ,\n {NCR_875_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_875_ID, 0x02,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n#ifdef NCR_NARROW_875J\n {NCR_875_ID2, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#else\n {NCR_875_ID2, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#endif\n ,\n {NCR_885_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_895_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_896_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n};\nint\ti;\nint\ti;\n\nstatic int ncr_chip_lookup(u_long device_id, u_char revision_id)\n{\n\tint i, found;\n\t\n\tfound = -1;\n\tfor (i = 0; i < sizeof(ncr_chip_table)/sizeof(ncr_chip_table[0]); i++) {\n\t\tif (device_id\t== ncr_chip_table[i].device_id &&\n\t\t    ncr_chip_table[i].minrevid <= revision_id) {\n\t\t\tif (found < 0 ||\n\t\t\t    ncr_chip_table[found].minrevid\n\t\t\t      < ncr_chip_table[i].minrevid) {\n\t\t\t\tfound = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_REVISION",
          "args": [
            "pa->pa_class"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic ncr_chip ncr_chip_table[] = {\n {NCR_810_ID, 0x00,\t4,  8, 4,\n FE_ERL}\n ,\n {NCR_810_ID, 0x10,\t4,  8, 4,\n FE_ERL|FE_LDSTR|FE_PFEN|FE_BOF}\n ,\n {NCR_815_ID, 0x00,\t4,  8, 4,\n FE_ERL|FE_BOF}\n ,\n {NCR_820_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL}\n ,\n {NCR_825_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL|FE_BOF}\n ,\n {NCR_825_ID, 0x10,\t7,  8, 4,\n FE_WIDE|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_860_ID, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_LDSTR|FE_PFEN}\n ,\n {NCR_875_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_875_ID, 0x02,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n#ifdef NCR_NARROW_875J\n {NCR_875_ID2, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#else\n {NCR_875_ID2, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#endif\n ,\n {NCR_885_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_895_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_896_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n};\nstruct pci_attach_args *pa = aux;\nint\ti;\nu_char rev = PCI_REVISION(pa->pa_class);\nchar *type;\nu_char\trev = 0;\nint\ti;\n\nstatic\tchar* ncr_probe (pcici_t tag, pcidi_t type)\n{\n\tu_char rev = PCI_REVISION(pa->pa_class);\n\tint i;\n\n\ti = ncr_chip_lookup(type, rev);\n\tif (i >= 0)\n\t\treturn ncr_chip_table[i].name;\n\n\treturn (NULL);\n}"
  },
  {
    "function_name": "ncr_chip_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3496-3512",
    "snippet": "static int ncr_chip_lookup(u_long device_id, u_char revision_id)\n{\n\tint i, found;\n\t\n\tfound = -1;\n\tfor (i = 0; i < sizeof(ncr_chip_table)/sizeof(ncr_chip_table[0]); i++) {\n\t\tif (device_id\t== ncr_chip_table[i].device_id &&\n\t\t    ncr_chip_table[i].minrevid <= revision_id) {\n\t\t\tif (found < 0 ||\n\t\t\t    ncr_chip_table[found].minrevid\n\t\t\t      < ncr_chip_table[i].minrevid) {\n\t\t\t\tfound = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ncr_chip ncr_chip_table[] = {\n {NCR_810_ID, 0x00,\t4,  8, 4,\n FE_ERL}\n ,\n {NCR_810_ID, 0x10,\t4,  8, 4,\n FE_ERL|FE_LDSTR|FE_PFEN|FE_BOF}\n ,\n {NCR_815_ID, 0x00,\t4,  8, 4,\n FE_ERL|FE_BOF}\n ,\n {NCR_820_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL}\n ,\n {NCR_825_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL|FE_BOF}\n ,\n {NCR_825_ID, 0x10,\t7,  8, 4,\n FE_WIDE|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_860_ID, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_LDSTR|FE_PFEN}\n ,\n {NCR_875_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_875_ID, 0x02,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n#ifdef NCR_NARROW_875J\n {NCR_875_ID2, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#else\n {NCR_875_ID2, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#endif\n ,\n {NCR_885_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_895_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_896_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n};",
      "int\ti;",
      "int\ti;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nstatic ncr_chip ncr_chip_table[] = {\n {NCR_810_ID, 0x00,\t4,  8, 4,\n FE_ERL}\n ,\n {NCR_810_ID, 0x10,\t4,  8, 4,\n FE_ERL|FE_LDSTR|FE_PFEN|FE_BOF}\n ,\n {NCR_815_ID, 0x00,\t4,  8, 4,\n FE_ERL|FE_BOF}\n ,\n {NCR_820_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL}\n ,\n {NCR_825_ID, 0x00,\t4,  8, 4,\n FE_WIDE|FE_ERL|FE_BOF}\n ,\n {NCR_825_ID, 0x10,\t7,  8, 4,\n FE_WIDE|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_860_ID, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_LDSTR|FE_PFEN}\n ,\n {NCR_875_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_875_ID, 0x02,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n#ifdef NCR_NARROW_875J\n {NCR_875_ID2, 0x00,\t4,  8, 5,\n FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#else\n {NCR_875_ID2, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n#endif\n ,\n {NCR_885_ID, 0x00,\t7, 16, 5,\n FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_895_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n ,\n {NCR_896_ID, 0x00,\t7, 31, 7,\n FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}\n};\nint\ti;\nint\ti;\n\nstatic int ncr_chip_lookup(u_long device_id, u_char revision_id)\n{\n\tint i, found;\n\t\n\tfound = -1;\n\tfor (i = 0; i < sizeof(ncr_chip_table)/sizeof(ncr_chip_table[0]); i++) {\n\t\tif (device_id\t== ncr_chip_table[i].device_id &&\n\t\t    ncr_chip_table[i].minrevid <= revision_id) {\n\t\t\tif (found < 0 ||\n\t\t\t    ncr_chip_table[found].minrevid\n\t\t\t      < ncr_chip_table[i].minrevid) {\n\t\t\t\tfound = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "ncr_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3427-3430",
    "snippet": "u_int32_t ncr_info (int unit)\n{\n\treturn (1);   /* may be changed later */\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nu_int32_t ncr_info (int unit)\n{\n\treturn (1);   /* may be changed later */\n}"
  },
  {
    "function_name": "ncr_min_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3411-3416",
    "snippet": "void ncr_min_phys (struct buf *bp)\n{\n\tif (bp->b_bcount > MAX_SIZE)\n\t\tbp->b_bcount = MAX_SIZE;\n\tminphys(bp);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)",
      "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "321-327",
          "snippet": "void\nwdc_atapi_minphys (struct buf *bp)\n{\n\tif(bp->b_bcount > MAX_SIZE)\n\t\tbp->b_bcount = MAX_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MAX_SIZE MAXPHYS"
          ],
          "globals_used": [
            "void  wdc_atapi_minphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAX_SIZE MAXPHYS\n\nvoid  wdc_atapi_minphys;\n\nvoid\nwdc_atapi_minphys (struct buf *bp)\n{\n\tif(bp->b_bcount > MAX_SIZE)\n\t\tbp->b_bcount = MAX_SIZE;\n\tminphys(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)\n\nvoid ncr_min_phys (struct buf *bp)\n{\n\tif (bp->b_bcount > MAX_SIZE)\n\t\tbp->b_bcount = MAX_SIZE;\n\tminphys(bp);\n}"
  },
  {
    "function_name": "ncr_min_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3406-3409",
    "snippet": "void ncr_min_phys (struct  buf *bp)\n{\n\tif ((unsigned long)bp->b_bcount > MAX_SIZE) bp->b_bcount = MAX_SIZE;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)",
      "#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)\n#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)\n\nvoid ncr_min_phys (struct  buf *bp)\n{\n\tif ((unsigned long)bp->b_bcount > MAX_SIZE) bp->b_bcount = MAX_SIZE;\n}"
  },
  {
    "function_name": "ncr_script_copy_and_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3238-3379",
    "snippet": "static void ncr_script_copy_and_bind (ncb_p np, ncrcmd *src, ncrcmd *dst, int len)\n{\n\tncrcmd  opcode, new, old, tmp1, tmp2;\n\tncrcmd\t*start, *end;\n\tint relocs, offset;\n\n\tstart = src;\n\tend = src + len/4;\n\toffset = 0;\n\n\twhile (src < end) {\n\n\t\topcode = *src++;\n\t\tWRITESCRIPT_OFF(dst, offset, opcode);\n\t\toffset += 4;\n\n\t\t/*\n\t\t**\tIf we forget to change the length\n\t\t**\tin struct script, a field will be\n\t\t**\tpadded with 0. This is an illegal\n\t\t**\tcommand.\n\t\t*/\n\n\t\tif (opcode == 0) {\n\t\t\tprintf (\"%s: ERROR0 IN SCRIPT at %ld.\\n\",\n\t\t\t\tncr_name(np), (long)(src-start-1));\n\t\t\tDELAY (1000000);\n\t\t};\n\n\t\tif (DEBUG_FLAGS & DEBUG_SCRIPT)\n\t\t\tprintf (\"%p:  <%x>\\n\",\n\t\t\t\t(src-1), (unsigned)opcode);\n\n\t\t/*\n\t\t**\tWe don't have to decode ALL commands\n\t\t*/\n\t\tswitch (opcode >> 28) {\n\n\t\tcase 0xc:\n\t\t\t/*\n\t\t\t**\tCOPY has TWO arguments.\n\t\t\t*/\n\t\t\trelocs = 2;\n\t\t\ttmp1 = src[0];\n\t\t\tif ((tmp1 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp1 = 0;\n\t\t\ttmp2 = src[1];\n\t\t\tif ((tmp2 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp2 = 0;\n\t\t\tif ((tmp1 ^ tmp2) & 3) {\n\t\t\t\tprintf (\"%s: ERROR1 IN SCRIPT at %ld.\\n\",\n\t\t\t\t\tncr_name(np), (long)(src-start-1));\n\t\t\t\tDELAY (1000000);\n\t\t\t}\n\t\t\t/*\n\t\t\t**\tIf PREFETCH feature not enabled, remove\n\t\t\t**\tthe NO FLUSH bit if present.\n\t\t\t*/\n\t\t\tif ((opcode & SCR_NO_FLUSH) && !(np->features&FE_PFEN))\n\t\t\t\tWRITESCRIPT_OFF(dst, offset - 4,\n\t\t\t\t    (opcode & ~SCR_NO_FLUSH));\n\t\t\tbreak;\n\n\t\tcase 0x0:\n\t\t\t/*\n\t\t\t**\tMOVE (absolute address)\n\t\t\t*/\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x8:\n\t\t\t/*\n\t\t\t**\tJUMP / CALL\n\t\t\t**\tdont't relocate if relative :-)\n\t\t\t*/\n\t\t\tif (opcode & 0x00800000)\n\t\t\t\trelocs = 0;\n\t\t\telse\n\t\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x4:\n\t\tcase 0x5:\n\t\tcase 0x6:\n\t\tcase 0x7:\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trelocs = 0;\n\t\t\tbreak;\n\t\t};\n\n\t\tif (relocs) {\n\t\t\twhile (relocs--) {\n\t\t\t\told = *src++;\n\n\t\t\t\tswitch (old & RELOC_MASK) {\n\t\t\t\tcase RELOC_REGISTER:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->paddr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABEL:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_script;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABELH:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_scripth;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_SOFTC:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + NCR_KVATOPHYS(np, np);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_KVAR:\n\t\t\t\t\tif (((old & ~RELOC_MASK) <\n\t\t\t\t\t     SCRIPT_KVAR_FIRST) ||\n\t\t\t\t\t    ((old & ~RELOC_MASK) >\n\t\t\t\t\t     SCRIPT_KVAR_LAST))\n\t\t\t\t\t\tpanic(\"ncr KVAR out of range\");\n\t\t\t\t\tnew = NCR_KVATOPHYS(np, (void *)script_kvars[old &\n\t\t\t\t\t    ~RELOC_MASK]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\t/* Don't relocate a 0 address. */\n\t\t\t\t\tif (old == 0) {\n\t\t\t\t\t\tnew = old;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through */\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"ncr_script_copy_and_bind: weird relocation %x @ %ld\", old, (long)(src - start));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tWRITESCRIPT_OFF(dst, offset, new);\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t} else {\n\t\t\tWRITESCRIPT_OFF(dst, offset, *src);\n\t\t\toffset += 4;\n\t\t\tsrc++;\n\t\t}\n\n\t};\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define\tSCRIPT_KVAR_LAST\t\t(3)",
      "#define\tSCRIPT_KVAR_FIRST\t\t(0)",
      "#define\tRELOC_MASK\t0xf0000000",
      "#define\tRELOC_LABELH\t0x80000000",
      "#define\tRELOC_KVAR\t0x70000000",
      "#define\tRELOC_REGISTER\t0x60000000",
      "#define\tRELOC_LABEL\t0x50000000",
      "#define\tRELOC_SOFTC\t0x40000000",
      "#define DEBUG_FLAGS\t0",
      "#define DEBUG_FLAGS ncr_debug",
      "#define DEBUG_SCRIPT   (0x0040)"
    ],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITESCRIPT_OFF",
          "args": [
            "dst",
            "offset",
            "*src"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT_OFF",
          "args": [
            "dst",
            "offset",
            "new"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr_script_copy_and_bind: weird relocation %x @ %ld\"",
            "old",
            "(long)(src - start)"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "(void *)script_kvars[old &\n\t\t\t\t\t    ~RELOC_MASK]"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr KVAR out of range\""
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_KVATOPHYS",
          "args": [
            "np",
            "np"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT_OFF",
          "args": [
            "dst",
            "offset - 4",
            "(opcode & ~SCR_NO_FLUSH)"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000000"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ERROR1 IN SCRIPT at %ld.\\n\"",
            "ncr_name(np)",
            "(long)(src-start-1)"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_name",
          "args": [
            "np"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "1567-1572",
          "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "ncb_p np = (struct ncb*) 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000000"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITESCRIPT_OFF",
          "args": [
            "dst",
            "offset",
            "opcode"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define\tSCRIPT_KVAR_LAST\t\t(3)\n#define\tSCRIPT_KVAR_FIRST\t\t(0)\n#define\tRELOC_MASK\t0xf0000000\n#define\tRELOC_LABELH\t0x80000000\n#define\tRELOC_KVAR\t0x70000000\n#define\tRELOC_REGISTER\t0x60000000\n#define\tRELOC_LABEL\t0x50000000\n#define\tRELOC_SOFTC\t0x40000000\n#define DEBUG_FLAGS\t0\n#define DEBUG_FLAGS ncr_debug\n#define DEBUG_SCRIPT   (0x0040)\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic void ncr_script_copy_and_bind (ncb_p np, ncrcmd *src, ncrcmd *dst, int len)\n{\n\tncrcmd  opcode, new, old, tmp1, tmp2;\n\tncrcmd\t*start, *end;\n\tint relocs, offset;\n\n\tstart = src;\n\tend = src + len/4;\n\toffset = 0;\n\n\twhile (src < end) {\n\n\t\topcode = *src++;\n\t\tWRITESCRIPT_OFF(dst, offset, opcode);\n\t\toffset += 4;\n\n\t\t/*\n\t\t**\tIf we forget to change the length\n\t\t**\tin struct script, a field will be\n\t\t**\tpadded with 0. This is an illegal\n\t\t**\tcommand.\n\t\t*/\n\n\t\tif (opcode == 0) {\n\t\t\tprintf (\"%s: ERROR0 IN SCRIPT at %ld.\\n\",\n\t\t\t\tncr_name(np), (long)(src-start-1));\n\t\t\tDELAY (1000000);\n\t\t};\n\n\t\tif (DEBUG_FLAGS & DEBUG_SCRIPT)\n\t\t\tprintf (\"%p:  <%x>\\n\",\n\t\t\t\t(src-1), (unsigned)opcode);\n\n\t\t/*\n\t\t**\tWe don't have to decode ALL commands\n\t\t*/\n\t\tswitch (opcode >> 28) {\n\n\t\tcase 0xc:\n\t\t\t/*\n\t\t\t**\tCOPY has TWO arguments.\n\t\t\t*/\n\t\t\trelocs = 2;\n\t\t\ttmp1 = src[0];\n\t\t\tif ((tmp1 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp1 = 0;\n\t\t\ttmp2 = src[1];\n\t\t\tif ((tmp2 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp2 = 0;\n\t\t\tif ((tmp1 ^ tmp2) & 3) {\n\t\t\t\tprintf (\"%s: ERROR1 IN SCRIPT at %ld.\\n\",\n\t\t\t\t\tncr_name(np), (long)(src-start-1));\n\t\t\t\tDELAY (1000000);\n\t\t\t}\n\t\t\t/*\n\t\t\t**\tIf PREFETCH feature not enabled, remove\n\t\t\t**\tthe NO FLUSH bit if present.\n\t\t\t*/\n\t\t\tif ((opcode & SCR_NO_FLUSH) && !(np->features&FE_PFEN))\n\t\t\t\tWRITESCRIPT_OFF(dst, offset - 4,\n\t\t\t\t    (opcode & ~SCR_NO_FLUSH));\n\t\t\tbreak;\n\n\t\tcase 0x0:\n\t\t\t/*\n\t\t\t**\tMOVE (absolute address)\n\t\t\t*/\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x8:\n\t\t\t/*\n\t\t\t**\tJUMP / CALL\n\t\t\t**\tdont't relocate if relative :-)\n\t\t\t*/\n\t\t\tif (opcode & 0x00800000)\n\t\t\t\trelocs = 0;\n\t\t\telse\n\t\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x4:\n\t\tcase 0x5:\n\t\tcase 0x6:\n\t\tcase 0x7:\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trelocs = 0;\n\t\t\tbreak;\n\t\t};\n\n\t\tif (relocs) {\n\t\t\twhile (relocs--) {\n\t\t\t\told = *src++;\n\n\t\t\t\tswitch (old & RELOC_MASK) {\n\t\t\t\tcase RELOC_REGISTER:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->paddr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABEL:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_script;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABELH:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_scripth;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_SOFTC:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + NCR_KVATOPHYS(np, np);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_KVAR:\n\t\t\t\t\tif (((old & ~RELOC_MASK) <\n\t\t\t\t\t     SCRIPT_KVAR_FIRST) ||\n\t\t\t\t\t    ((old & ~RELOC_MASK) >\n\t\t\t\t\t     SCRIPT_KVAR_LAST))\n\t\t\t\t\t\tpanic(\"ncr KVAR out of range\");\n\t\t\t\t\tnew = NCR_KVATOPHYS(np, (void *)script_kvars[old &\n\t\t\t\t\t    ~RELOC_MASK]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\t/* Don't relocate a 0 address. */\n\t\t\t\t\tif (old == 0) {\n\t\t\t\t\t\tnew = old;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through */\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"ncr_script_copy_and_bind: weird relocation %x @ %ld\", old, (long)(src - start));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tWRITESCRIPT_OFF(dst, offset, new);\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t} else {\n\t\t\tWRITESCRIPT_OFF(dst, offset, *src);\n\t\t\toffset += 4;\n\t\t\tsrc++;\n\t\t}\n\n\t};\n}"
  },
  {
    "function_name": "ncr_script_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "3162-3227",
    "snippet": "void ncr_script_fill (struct script * scr, struct scripth * scrh)\n{\n\tint\ti;\n\tncrcmd\t*p;\n\n\tp = scrh->tryloop;\n\tfor (i=0; i<MAX_START; i++) {\n\t\t*p++ =SCR_COPY (4);\n\t\t*p++ =NADDR (squeue[i]);\n\t\t*p++ =RADDR (dsa);\n\t\t*p++ =SCR_CALL;\n\t\t*p++ =PADDR (trysel);\n\t};\n\t*p++ =SCR_JUMP;\n\t*p++ =PADDRH(tryloop);\n\n\tassert ((u_long)p == (u_long)&scrh->tryloop + sizeof (scrh->tryloop));\n\n\tp = scr->data_in;\n\n\t*p++ =SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t*p++ =PADDR (no_data);\n\t*p++ =SCR_COPY (sizeof (struct timeval));\n\t*p++ =(ncrcmd) KVAR (KVAR_TIME);\n\t*p++ =NADDR (header.stamp.data);\n\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t*p++ =offsetof (struct dsb, data[ 0]);\n\n\tfor (i=1; i<MAX_SCATTER; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t\t*p++ =PADDR (checkatn);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t};\n\n\t*p++ =SCR_CALL;\n\t*p++ =PADDR (checkatn);\n\t*p++ =SCR_JUMP;\n\t*p++ =PADDR (no_data);\n\n\tassert ((u_long)p == (u_long)&scr->data_in + sizeof (scr->data_in));\n\n\tp = scr->data_out;\n\n\t*p++ =SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t*p++ =PADDR (no_data);\n\t*p++ =SCR_COPY (sizeof (struct timeval));\n\t*p++ =(ncrcmd) KVAR (KVAR_TIME);\n\t*p++ =NADDR (header.stamp.data);\n\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t*p++ =offsetof (struct dsb, data[ 0]);\n\n\tfor (i=1; i<MAX_SCATTER; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t};\n\n\t*p++ =SCR_CALL;\n\t*p++ =PADDR (dispatch);\n\t*p++ =SCR_JUMP;\n\t*p++ =PADDR (no_data);\n\n\tassert ((u_long)p == (u_long)&scr->data_out + sizeof (scr->data_out));\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [
      "#define KVAR_TIME\t\t\t(1)",
      "#define MAX_SCATTER (33)",
      "#define MAX_START   (256)"
    ],
    "globals_used": [
      "int\ti;",
      "int\ti;",
      "register volatile u_int32_t data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(u_long)p == (u_long)&scr->data_out + sizeof (scr->data_out)"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "no_data"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "dispatch"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "dispatch"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "WHEN (SCR_DATA_OUT)"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WHEN",
          "args": [
            "SCR_DATA_OUT"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NADDR",
          "args": [
            "header.stamp.data"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVAR",
          "args": [
            "KVAR_TIME"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_COPY",
          "args": [
            "sizeof (struct timeval)"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "no_data"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "WHEN (SCR_DATA_OUT)"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WHEN",
          "args": [
            "SCR_DATA_OUT"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(u_long)p == (u_long)&scr->data_in + sizeof (scr->data_in)"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "no_data"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "checkatn"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "checkatn"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "WHEN (SCR_DATA_IN)"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WHEN",
          "args": [
            "SCR_DATA_IN"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NADDR",
          "args": [
            "header.stamp.data"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVAR",
          "args": [
            "KVAR_TIME"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_COPY",
          "args": [
            "sizeof (struct timeval)"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "no_data"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFFALSE",
          "args": [
            "WHEN (SCR_DATA_IN)"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WHEN",
          "args": [
            "SCR_DATA_IN"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(u_long)p == (u_long)&scrh->tryloop + sizeof (scrh->tryloop)"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDRH",
          "args": [
            "tryloop"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PADDR",
          "args": [
            "trysel"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RADDR",
          "args": [
            "dsa"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NADDR",
          "args": [
            "squeue[i]"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCR_COPY",
          "args": [
            "4"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define KVAR_TIME\t\t\t(1)\n#define MAX_SCATTER (33)\n#define MAX_START   (256)\n\nint\ti;\nint\ti;\nregister volatile u_int32_t data;\n\nvoid ncr_script_fill (struct script * scr, struct scripth * scrh)\n{\n\tint\ti;\n\tncrcmd\t*p;\n\n\tp = scrh->tryloop;\n\tfor (i=0; i<MAX_START; i++) {\n\t\t*p++ =SCR_COPY (4);\n\t\t*p++ =NADDR (squeue[i]);\n\t\t*p++ =RADDR (dsa);\n\t\t*p++ =SCR_CALL;\n\t\t*p++ =PADDR (trysel);\n\t};\n\t*p++ =SCR_JUMP;\n\t*p++ =PADDRH(tryloop);\n\n\tassert ((u_long)p == (u_long)&scrh->tryloop + sizeof (scrh->tryloop));\n\n\tp = scr->data_in;\n\n\t*p++ =SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t*p++ =PADDR (no_data);\n\t*p++ =SCR_COPY (sizeof (struct timeval));\n\t*p++ =(ncrcmd) KVAR (KVAR_TIME);\n\t*p++ =NADDR (header.stamp.data);\n\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t*p++ =offsetof (struct dsb, data[ 0]);\n\n\tfor (i=1; i<MAX_SCATTER; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t\t*p++ =PADDR (checkatn);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t};\n\n\t*p++ =SCR_CALL;\n\t*p++ =PADDR (checkatn);\n\t*p++ =SCR_JUMP;\n\t*p++ =PADDR (no_data);\n\n\tassert ((u_long)p == (u_long)&scr->data_in + sizeof (scr->data_in));\n\n\tp = scr->data_out;\n\n\t*p++ =SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t*p++ =PADDR (no_data);\n\t*p++ =SCR_COPY (sizeof (struct timeval));\n\t*p++ =(ncrcmd) KVAR (KVAR_TIME);\n\t*p++ =NADDR (header.stamp.data);\n\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t*p++ =offsetof (struct dsb, data[ 0]);\n\n\tfor (i=1; i<MAX_SCATTER; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t};\n\n\t*p++ =SCR_CALL;\n\t*p++ =PADDR (dispatch);\n\t*p++ =SCR_JUMP;\n\t*p++ =PADDR (no_data);\n\n\tassert ((u_long)p == (u_long)&scr->data_out + sizeof (scr->data_out));\n}"
  },
  {
    "function_name": "ncr_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
    "lines": "1567-1572",
    "snippet": "static char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/ncrreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <pci/ncrreg.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/clock.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/systm.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <stddef.h>",
      "#include \"opt_ncr.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ncb_p np = (void *)self;",
      "ncb_p np = (struct ncb*) 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"ncr%d\"",
            "np->unit"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nncb_p np = (struct ncb*) 0;\n\nstatic char *ncr_name (ncb_p np)\n{\n\tstatic char name[10];\n\tsprintf(name, \"ncr%d\", np->unit);\n\treturn (name);\n}"
  }
]