[
  {
    "function_name": "ec_set_media",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "794-819",
    "snippet": "int\nec_set_media(esc, media)\n\tstruct ec_softc *esc;\n\tint media;\n{\n\tu_int8_t new;\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_2:\n\t\tnew = ELINK2_CR_XSEL;\n\t\tbreak;\n\n\tcase IFM_10_5:\n\t\tnew = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tbus_space_write_1(esc->sc_asict, esc->sc_asich, ELINK2_CR, new);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tec_set_media"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "esc->sc_asict",
            "esc->sc_asich",
            "ELINK2_CR",
            "new"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "media"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_set_media;\n\nint\nec_set_media(esc, media)\n\tstruct ec_softc *esc;\n\tint media;\n{\n\tu_int8_t new;\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_2:\n\t\tnew = ELINK2_CR_XSEL;\n\t\tbreak;\n\n\tcase IFM_10_5:\n\t\tnew = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tbus_space_write_1(esc->sc_asict, esc->sc_asich, ELINK2_CR, new);\n\treturn (0);\n}"
  },
  {
    "function_name": "ec_init_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "784-792",
    "snippet": "void\nec_init_card(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\t(void) ec_set_media(esc, ifm->ifm_cur->ifm_media);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tec_set_media",
      "void\tec_init_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ec_set_media",
          "args": [
            "esc",
            "ifm->ifm_cur->ifm_media"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ec_set_media",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
          "lines": "794-819",
          "snippet": "int\nec_set_media(esc, media)\n\tstruct ec_softc *esc;\n\tint media;\n{\n\tu_int8_t new;\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_2:\n\t\tnew = ELINK2_CR_XSEL;\n\t\tbreak;\n\n\tcase IFM_10_5:\n\t\tnew = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tbus_space_write_1(esc->sc_asict, esc->sc_asich, ELINK2_CR, new);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/if_ecreg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tec_set_media"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_set_media;\n\nint\nec_set_media(esc, media)\n\tstruct ec_softc *esc;\n\tint media;\n{\n\tu_int8_t new;\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_2:\n\t\tnew = ELINK2_CR_XSEL;\n\t\tbreak;\n\n\tcase IFM_10_5:\n\t\tnew = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tbus_space_write_1(esc->sc_asict, esc->sc_asich, ELINK2_CR, new);\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_set_media;\nvoid\tec_init_card;\n\nvoid\nec_init_card(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\t(void) ec_set_media(esc, ifm->ifm_cur->ifm_media);\n}"
  },
  {
    "function_name": "ec_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "771-782",
    "snippet": "void\nec_mediastatus(sc, ifmr)\n\tstruct dp8390_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\t/*\n\t * The currently selected media is always the active media.\n\t */\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tec_mediastatus"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tec_mediastatus;\n\nvoid\nec_mediastatus(sc, ifmr)\n\tstruct dp8390_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\t/*\n\t * The currently selected media is always the active media.\n\t */\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}"
  },
  {
    "function_name": "ec_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "761-769",
    "snippet": "int\nec_mediachange(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\treturn (ec_set_media(esc, ifm->ifm_media));\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tec_set_media",
      "int\tec_mediachange"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ec_set_media",
          "args": [
            "esc",
            "ifm->ifm_media"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ec_set_media",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
          "lines": "794-819",
          "snippet": "int\nec_set_media(esc, media)\n\tstruct ec_softc *esc;\n\tint media;\n{\n\tu_int8_t new;\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_2:\n\t\tnew = ELINK2_CR_XSEL;\n\t\tbreak;\n\n\tcase IFM_10_5:\n\t\tnew = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tbus_space_write_1(esc->sc_asict, esc->sc_asich, ELINK2_CR, new);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/if_ecreg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tec_set_media"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_set_media;\n\nint\nec_set_media(esc, media)\n\tstruct ec_softc *esc;\n\tint media;\n{\n\tu_int8_t new;\n\n\tif (IFM_TYPE(media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\n\tswitch (IFM_SUBTYPE(media)) {\n\tcase IFM_10_2:\n\t\tnew = ELINK2_CR_XSEL;\n\t\tbreak;\n\n\tcase IFM_10_5:\n\t\tnew = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tbus_space_write_1(esc->sc_asict, esc->sc_asich, ELINK2_CR, new);\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_set_media;\nint\tec_mediachange;\n\nint\nec_mediachange(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\treturn (ec_set_media(esc, ifm->ifm_media));\n}"
  },
  {
    "function_name": "ec_read_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "746-759",
    "snippet": "void\nec_read_hdr(sc, packet_ptr, packet_hdrp)\n\tstruct dp8390_softc *sc;\n\tint packet_ptr;\n\tstruct dp8390_ring *packet_hdrp;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\n\tec_readmem(esc, packet_ptr, (u_int8_t *)packet_hdrp,\n\t    sizeof(struct dp8390_ring));\n#if BYTE_ORDER == BIG_ENDIAN\n\tpacket_hdrp->count = swap16(packet_hdrp->count);\n#endif\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tec_read_hdr",
      "__inline void ec_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap16",
          "args": [
            "packet_hdrp->count"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec_readmem",
          "args": [
            "esc",
            "packet_ptr",
            "(u_int8_t *)packet_hdrp",
            "sizeof(struct dp8390_ring)"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ec_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
          "lines": "584-602",
          "snippet": "__inline void\nec_readmem(esc, from, to, len)\n\tstruct ec_softc *esc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_read_region_2(memt, memh, from, (u_int16_t *)to,\n\t\t    len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from, to, len);\n}",
          "includes": [
            "#include <dev/isa/if_ecreg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__inline void ec_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__inline void ec_readmem;\n\n__inline void\nec_readmem(esc, from, to, len)\n\tstruct ec_softc *esc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_read_region_2(memt, memh, from, (u_int16_t *)to,\n\t\t    len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from, to, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tec_read_hdr;\n__inline void ec_readmem;\n\nvoid\nec_read_hdr(sc, packet_ptr, packet_hdrp)\n\tstruct dp8390_softc *sc;\n\tint packet_ptr;\n\tstruct dp8390_ring *packet_hdrp;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\n\tec_readmem(esc, packet_ptr, (u_int8_t *)packet_hdrp,\n\t    sizeof(struct dp8390_ring));\n#if BYTE_ORDER == BIG_ENDIAN\n\tpacket_hdrp->count = swap16(packet_hdrp->count);\n#endif\n}"
  },
  {
    "function_name": "ec_ring_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "719-744",
    "snippet": "int\nec_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tu_short tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tec_readmem(esc, src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\tec_readmem(esc, src, dst, amount);\n\n\treturn (src + amount);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tec_ring_copy",
      "__inline void ec_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ec_readmem",
          "args": [
            "esc",
            "src",
            "dst",
            "amount"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "ec_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
          "lines": "584-602",
          "snippet": "__inline void\nec_readmem(esc, from, to, len)\n\tstruct ec_softc *esc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_read_region_2(memt, memh, from, (u_int16_t *)to,\n\t\t    len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from, to, len);\n}",
          "includes": [
            "#include <dev/isa/if_ecreg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__inline void ec_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__inline void ec_readmem;\n\n__inline void\nec_readmem(esc, from, to, len)\n\tstruct ec_softc *esc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_read_region_2(memt, memh, from, (u_int16_t *)to,\n\t\t    len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from, to, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_ring_copy;\n__inline void ec_readmem;\n\nint\nec_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tu_short tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tec_readmem(esc, src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\tec_readmem(esc, src, dst, amount);\n\n\treturn (src + amount);\n}"
  },
  {
    "function_name": "ec_write_mbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "604-717",
    "snippet": "int\nec_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tbus_space_tag_t asict = esc->sc_asict;\n\tbus_space_handle_t asich = esc->sc_asich;\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\tu_int8_t *data, savebyte[2];\n\tint savelen, len, leftover;\n#ifdef DIAGNOSTIC\n\tu_int8_t *lim;\n#endif\n\n\tsavelen = m->m_pkthdr.len;\n\n\t/*\n\t * 8-bit boards are simple: we're already in the correct\n\t * page, and no alignment tricks are necessary.\n\t */\n\tif (esc->sc_16bitp == 0) {\n\t\tfor (; m != NULL; buf += m->m_len, m = m->m_next)\n\t\t\tbus_space_write_region_1(memt, memh, buf,\n\t\t\t    mtod(m, u_int8_t *), m->m_len);\n\t\treturn (savelen);\n\t}\n\n\t/*\n\t * If it's a 16-bit board, we have transmit buffers\n\t * in a different page; switch to it.\n\t */\n\tif (esc->sc_16bitp)\n\t\tbus_space_write_1(asict, asich, ELINK2_GACFR,\n\t\t    ELINK2_GACFR_RSEL);\n\n\t/* Start out with no leftover data. */\n\tleftover = 0;\n\tsavebyte[0] = savebyte[1] = 0;\n\n\tfor (; m != NULL; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tdata = mtod(m, u_int8_t *);\n#ifdef DIAGNOSTIC\n\t\tlim = data + len;\n#endif\n\t\twhile (len > 0) {\n\t\t\tif (leftover) {\n\t\t\t\t/*\n\t\t\t\t * Data left over (from mbuf or realignment).\n\t\t\t\t * Buffer the next byte, and write it and\n\t\t\t\t * the leftover data out.\n\t\t\t\t */\n\t\t\t\tsavebyte[1] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tbus_space_write_2(memt, memh, buf,\n\t\t\t\t    *(u_int16_t *)savebyte);\n\t\t\t\tbuf += 2;\n\t\t\t\tleftover = 0;\n#ifdef i386\n#define ALIGNED_POINTER(p,t)\t1\n#endif\n#ifdef alpha\n#define ALIGNED_POINTER(p,t)\t((((u_long)(p)) & (sizeof(t)-1)) == 0)\n#endif\n\t\t\t} else if (ALIGNED_POINTER(data, u_int16_t) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Unaligned data; buffer the next byte.\n\t\t\t\t */\n\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tleftover = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Aligned data; output contiguous words as\n\t\t\t\t * much as we can, then buffer the remaining\n\t\t\t\t * byte, if any.\n\t\t\t\t */\n\t\t\t\tleftover = len & 1;\n\t\t\t\tlen &= ~1;\n\t\t\t\tbus_space_write_region_2(memt, memh, buf,\n\t\t\t\t    (u_int16_t *)data, len >> 1);\n\t\t\t\tdata += len;\n\t\t\t\tbuf += len;\n\t\t\t\tif (leftover)\n\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t}\n\t\tif (len < 0)\n\t\t\tpanic(\"ec_write_mbuf: negative len\");\n#ifdef DIAGNOSTIC\n\t\tif (data != lim)\n\t\t\tpanic(\"ec_write_mbuf: data != lim\");\n#endif\n\t}\n\tif (leftover) {\n\t\tsavebyte[1] = 0;\n\t\tbus_space_write_2(memt, memh, buf, *(u_int16_t *)savebyte);\n\t}\n\n\t/*\n\t * Switch back to receive page.\n\t */\n\tif (esc->sc_16bitp)\n\t\tbus_space_write_1(asict, asich, ELINK2_GACFR,\n\t\t    ELINK2_GACFR_RSEL | ELINK2_GACFR_MBS0);\n\t\n\treturn (savelen);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tec_write_mbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_GACFR",
            "ELINK2_GACFR_RSEL | ELINK2_GACFR_MBS0"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "memt",
            "memh",
            "buf",
            "*(u_int16_t *)savebyte"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ec_write_mbuf: data != lim\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ec_write_mbuf: negative len\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_2",
          "args": [
            "memt",
            "memh",
            "buf",
            "(u_int16_t *)data",
            "len >> 1"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGNED_POINTER",
          "args": [
            "data",
            "u_int16_t"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "memt",
            "memh",
            "buf",
            "*(u_int16_t *)savebyte"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_GACFR",
            "ELINK2_GACFR_RSEL"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "memt",
            "memh",
            "buf",
            "mtod(m, u_int8_t *)",
            "m->m_len"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_write_mbuf;\n\nint\nec_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tbus_space_tag_t asict = esc->sc_asict;\n\tbus_space_handle_t asich = esc->sc_asich;\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\tu_int8_t *data, savebyte[2];\n\tint savelen, len, leftover;\n#ifdef DIAGNOSTIC\n\tu_int8_t *lim;\n#endif\n\n\tsavelen = m->m_pkthdr.len;\n\n\t/*\n\t * 8-bit boards are simple: we're already in the correct\n\t * page, and no alignment tricks are necessary.\n\t */\n\tif (esc->sc_16bitp == 0) {\n\t\tfor (; m != NULL; buf += m->m_len, m = m->m_next)\n\t\t\tbus_space_write_region_1(memt, memh, buf,\n\t\t\t    mtod(m, u_int8_t *), m->m_len);\n\t\treturn (savelen);\n\t}\n\n\t/*\n\t * If it's a 16-bit board, we have transmit buffers\n\t * in a different page; switch to it.\n\t */\n\tif (esc->sc_16bitp)\n\t\tbus_space_write_1(asict, asich, ELINK2_GACFR,\n\t\t    ELINK2_GACFR_RSEL);\n\n\t/* Start out with no leftover data. */\n\tleftover = 0;\n\tsavebyte[0] = savebyte[1] = 0;\n\n\tfor (; m != NULL; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tdata = mtod(m, u_int8_t *);\n#ifdef DIAGNOSTIC\n\t\tlim = data + len;\n#endif\n\t\twhile (len > 0) {\n\t\t\tif (leftover) {\n\t\t\t\t/*\n\t\t\t\t * Data left over (from mbuf or realignment).\n\t\t\t\t * Buffer the next byte, and write it and\n\t\t\t\t * the leftover data out.\n\t\t\t\t */\n\t\t\t\tsavebyte[1] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tbus_space_write_2(memt, memh, buf,\n\t\t\t\t    *(u_int16_t *)savebyte);\n\t\t\t\tbuf += 2;\n\t\t\t\tleftover = 0;\n#ifdef i386\n#define ALIGNED_POINTER(p,t)\t1\n#endif\n#ifdef alpha\n#define ALIGNED_POINTER(p,t)\t((((u_long)(p)) & (sizeof(t)-1)) == 0)\n#endif\n\t\t\t} else if (ALIGNED_POINTER(data, u_int16_t) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Unaligned data; buffer the next byte.\n\t\t\t\t */\n\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tleftover = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Aligned data; output contiguous words as\n\t\t\t\t * much as we can, then buffer the remaining\n\t\t\t\t * byte, if any.\n\t\t\t\t */\n\t\t\t\tleftover = len & 1;\n\t\t\t\tlen &= ~1;\n\t\t\t\tbus_space_write_region_2(memt, memh, buf,\n\t\t\t\t    (u_int16_t *)data, len >> 1);\n\t\t\t\tdata += len;\n\t\t\t\tbuf += len;\n\t\t\t\tif (leftover)\n\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t}\n\t\tif (len < 0)\n\t\t\tpanic(\"ec_write_mbuf: negative len\");\n#ifdef DIAGNOSTIC\n\t\tif (data != lim)\n\t\t\tpanic(\"ec_write_mbuf: data != lim\");\n#endif\n\t}\n\tif (leftover) {\n\t\tsavebyte[1] = 0;\n\t\tbus_space_write_2(memt, memh, buf, *(u_int16_t *)savebyte);\n\t}\n\n\t/*\n\t * Switch back to receive page.\n\t */\n\tif (esc->sc_16bitp)\n\t\tbus_space_write_1(asict, asich, ELINK2_GACFR,\n\t\t    ELINK2_GACFR_RSEL | ELINK2_GACFR_MBS0);\n\t\n\treturn (savelen);\n}"
  },
  {
    "function_name": "ec_readmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "584-602",
    "snippet": "__inline void\nec_readmem(esc, from, to, len)\n\tstruct ec_softc *esc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_read_region_2(memt, memh, from, (u_int16_t *)to,\n\t\t    len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from, to, len);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "__inline void ec_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "memt",
            "memh",
            "from",
            "to",
            "len"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_2",
          "args": [
            "memt",
            "memh",
            "from",
            "(u_int16_t *)to",
            "len >> 1"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__inline void ec_readmem;\n\n__inline void\nec_readmem(esc, from, to, len)\n\tstruct ec_softc *esc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = esc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = esc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_read_region_2(memt, memh, from, (u_int16_t *)to,\n\t\t    len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from, to, len);\n}"
  },
  {
    "function_name": "ec_test_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "544-577",
    "snippet": "int\nec_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tbus_space_tag_t memt = sc->sc_buft;\n\tbus_space_handle_t memh = sc->sc_bufh;\n\tbus_size_t memsize = sc->mem_size;\n\tint i;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_set_region_2(memt, memh, 0, 0, memsize >> 1);\n\telse\n\t\tbus_space_set_region_1(memt, memh, 0, 0, memsize);\n\n\tif (esc->sc_16bitp) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; i++) {\n\t\t\tif (bus_space_read_1(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: failed to clear shared memory at offset 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, i);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tec_test_mem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to clear shared memory at offset 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "i"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "i"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "memt",
            "memh",
            "i"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_1",
          "args": [
            "memt",
            "memh",
            "0",
            "0",
            "memsize"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_2",
          "args": [
            "memt",
            "memh",
            "0",
            "0",
            "memsize >> 1"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_test_mem;\n\nint\nec_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tbus_space_tag_t memt = sc->sc_buft;\n\tbus_space_handle_t memh = sc->sc_bufh;\n\tbus_size_t memsize = sc->mem_size;\n\tint i;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_set_region_2(memt, memh, 0, 0, memsize >> 1);\n\telse\n\t\tbus_space_set_region_1(memt, memh, 0, 0, memsize);\n\n\tif (esc->sc_16bitp) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; i++) {\n\t\t\tif (bus_space_read_1(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: failed to clear shared memory at offset 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, i);\n\treturn (1);\n}"
  },
  {
    "function_name": "ec_fake_test_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "530-542",
    "snippet": "int\nec_fake_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\t/*\n\t * We have to do this after we initialize the GA, but we\n\t * have to do that after calling dp8390_config(), which\n\t * wants to test memory.  Put this noop here, and then\n\t * actually test memory later.\n\t */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tec_fake_test_mem"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_fake_test_mem;\n\nint\nec_fake_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\t/*\n\t * We have to do this after we initialize the GA, but we\n\t * have to do that after calling dp8390_config(), which\n\t * wants to test memory.  Put this noop here, and then\n\t * actually test memory later.\n\t */\n\treturn (0);\n}"
  },
  {
    "function_name": "ec_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "270-528",
    "snippet": "void\nec_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)self;\n\tstruct dp8390_softc *sc = &esc->sc_dp8390;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t nict, asict, memt;\n\tbus_space_handle_t nich, asich, memh;\n\tbus_size_t memsize;\n\tu_int8_t tmp;\n\tint i;\n\n\tprintf(\"\\n\");\n\n\tnict = asict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\t/*\n\t * Hmm, a 16-bit card has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\t/* Map the NIC space. */\n\tif (bus_space_map(nict, ia->ia_iobase + ELINK2_NIC_OFFSET,\n\t    ELINK2_NIC_PORTS, 0, &nich)) {\n\t\tprintf(\"%s: can't map nic i/o space\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Map the ASIC space. */\n\tif (bus_space_map(asict, ia->ia_iobase + ELINK2_ASIC_OFFSET,\n\t    ELINK2_ASIC_PORTS, 0, &asich)) {\n\t\tprintf(\"%s: can't map asic i/o space\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Map the memory space. */\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh)) {\n\t\tprintf(\"%s: can't map shared memory\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tesc->sc_asict = asict;\n\tesc->sc_asich = asich;\n\n\tsc->sc_regt = nict;\n\tsc->sc_regh = nich;\n\n\tsc->sc_buft = memt;\n\tsc->sc_bufh = memh;\n\n\t/* Interface is always enabled. */\n\tsc->sc_enabled = 1;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tsc->sc_reg_map[i] = i;\n\n\t/* Now we can use the NIC_{GET,PUT}() macros. */\n\n\t/*\n\t * Reset NIC and ASIC.  Enable on-board transeiver throughout\n\t * reset sequence since it will lock up if the cable isn't\n\t * connected if we don't.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR,\n\t    ELINK2_CR_RST | ELINK2_CR_XSEL);\n\n\t/* Wait for a while, then un-reset it. */\n\tdelay(50);\n\n\t/*\n\t * The 3Com ASIC defaults to rather strange settings for the CR\n\t * after a reset.  It's important to set it again after the\n\t * following write (this is done when we map the PROM below).\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR, ELINK2_CR_XSEL);\n\n\t/* Wait a bit for the NIC to recover from the reset. */\n\tdelay(5000);\n\n\t/*\n\t * Get the station address from on-board ROM.\n\t *\n\t * First, map Ethernet address PROM over the top of where the NIC\n\t * registers normally appear.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR,\n\t    ELINK2_CR_XSEL | ELINK2_CR_EALO);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\tsc->sc_enaddr[i] = NIC_GET(nict, nich, i);\n#else\n\t\tsc->sc_arpcom.ac_enaddr[i] = NIC_GET(nict, nich, i);\n#endif\n\n\t/*\n\t * Unmap PROM - select NIC registers.  The proper setting of the\n\t * transciever is set in later in ec_init_card() via dp8390_init().\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR, ELINK2_CR_XSEL);\n\n\t/* Determine if this is an 8-bit or 16-bit board. */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(nict, nich, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Attempt to clear WTS.  If it doesn't clear, then this is a\n\t * 16-bit board.\n\t */\n\tNIC_PUT(nict, nich, ED_P0_DCR, 0);\n\n\t/* Select page 2 registers. */\n\tNIC_PUT(nict, nich, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);\n\n\t/* The 3c503 forces the WTS bit to a one if this is a 16-bit board. */\n\tif (NIC_GET(nict, nich, ED_P2_DCR) & ED_DCR_WTS)\n\t\tesc->sc_16bitp = 1;\n\telse\n\t\tesc->sc_16bitp = 0;\n\n\tprintf(\"%s: 3Com 3c503 Ethernet (%s-bit)\\n\",\n\t    sc->sc_dev.dv_xname, esc->sc_16bitp ? \"16\" : \"8\");\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(nict, nich, ED_P2_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * 16-bit cards also get word-wide DMA transfers.\n\t */\n\tsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (esc->sc_16bitp ? ED_DCR_WTS : 0);\n\n\tsc->test_mem = ec_fake_test_mem;\n\tsc->ring_copy = ec_ring_copy;\n\tsc->write_mbuf = ec_write_mbuf;\n\tsc->read_hdr = ec_read_hdr;\n\n\tsc->sc_mediachange = ec_mediachange;\n\tsc->sc_mediastatus = ec_mediastatus;\n\n\tsc->mem_start = 0;\n\tsc->mem_size = memsize;\n\n\t/* Do generic parts of attach. */\n\tif (dp8390_config(sc, ec_media, NEC_MEDIA, EC_DEFMEDIA)) {\n\t\tprintf(\"%s: configuration failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to override the way dp8390_config() set up our\n\t * shared memory.\n\t *\n\t * We have an entire 8k window to put the transmit buffers on the\n\t * 16-bit boards.  But since the 16bit 3c503's shared memory is only\n\t * fast enough to overlap the loading of one full-size packet, trying\n\t * to load more than 2 buffers can actually leave the transmitter idle\n\t * during the load.  So 2 seems the best value.  (Although a mix of\n\t * variable-sized packets might change this assumption.  Nonetheless,\n\t * we optimize for linear transfers of same-size packets.)\n\t */\n\tif (esc->sc_16bitp) {\n\t\tif (sc->sc_dev.dv_cfdata->cf_flags & DP8390_NO_MULTI_BUFFERING)\n\t\t\tsc->txb_cnt = 1;\n\t\telse\n\t\t\tsc->txb_cnt = 2;\n\n\t\tsc->tx_page_start = ELINK2_TX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_start = ELINK2_RX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_stop = (memsize >> ED_PAGE_SHIFT) + \n\t\t    sc->rec_page_start;\n\t\tsc->mem_ring = sc->mem_start;\n\t} else {\n\t\tsc->txb_cnt = 1;\n\t\tsc->tx_page_start = ELINK2_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_start = sc->tx_page_start + ED_TXBUF_SIZE;\n\t\tsc->rec_page_stop = (memsize >> ED_PAGE_SHIFT) +\n\t\t    sc->tx_page_start;\n\t\tsc->mem_ring = sc->mem_start +\n\t\t    (ED_TXBUF_SIZE << ED_PAGE_SHIFT);\n\t}\n\n\t/*\n\t * Initialize CA page start/stop registers.  Probably only needed\n\t * if doing DMA, but what the Hell.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_PSTR, sc->rec_page_start);\n\tbus_space_write_1(asict, asich, ELINK2_PSPR, sc->rec_page_stop);\n\n\t/*\n\t * Program the IRQ.\n\t */\n\tswitch (ia->ia_irq) {\n\tcase 9:\ttmp = ELINK2_IDCFR_IRQ2; break;\n\tcase 3:\ttmp = ELINK2_IDCFR_IRQ3; break;\n\tcase 4:\ttmp = ELINK2_IDCFR_IRQ4; break;\n\tcase 5:\ttmp = ELINK2_IDCFR_IRQ5; break;\n\t\tbreak;\n\n\tcase IRQUNK:\n\t\tprintf(\"%s: wildcarded IRQ is not allowed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\n\tdefault:\n\t\tprintf(\"%s: invalid IRQ %d, must be 3, 4, 5, or 9\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_irq);\n\t\treturn;\n\t}\n\n\tbus_space_write_1(asict, asich, ELINK2_IDCFR, tmp);\n\n\t/*\n\t * Initialize the GA configuration register.  Set bank and enable\n\t * shared memory.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_GACFR,\n\t    ELINK2_GACFR_RSEL | ELINK2_GACFR_MBS0);\n\n\t/*\n\t * Intialize \"Vector Pointer\" registers.  These gawd-awful things\n\t * are compared to 20 bits of the address on the ISA, and if they\n\t * match, the shared memory is disabled.  We se them to 0xffff0...\n\t * allegedly the reset vector.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_VPTR2, 0xff);\n\tbus_space_write_1(asict, asich, ELINK2_VPTR1, 0xff);\n\tbus_space_write_1(asict, asich, ELINK2_VPTR0, 0x00);\n\n\t/*\n\t * Now run the real memory test.\n\t */\n\tif (ec_test_mem(sc)) {\n\t\tprintf(\"%s: memory test failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Establish interrupt handler. */\n\tesc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, dp8390_intr, sc, sc->sc_dev.dv_xname);\n\tif (esc->sc_ih == NULL)\n\t\tprintf(\"%s: can't establish interrupt\\n\", sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tEC_DEFMEDIA\t(IFM_ETHER|IFM_10_2)",
      "#define\tNEC_MEDIA\t(sizeof(ec_media) / sizeof(ec_media[0]))"
    ],
    "globals_used": [
      "void\tec_attach",
      "int\tec_mediachange",
      "void\tec_mediastatus",
      "void\tec_init_card",
      "int\tec_write_mbuf",
      "int\tec_ring_copy",
      "void\tec_read_hdr",
      "int\tec_fake_test_mem",
      "int\tec_test_mem",
      "int ec_media[] = {\n\tIFM_ETHER|IFM_10_2,\n\tIFM_ETHER|IFM_10_5,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't establish interrupt\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "dp8390_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec_test_mem",
          "args": [
            "sc"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ec_test_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
          "lines": "544-577",
          "snippet": "int\nec_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tbus_space_tag_t memt = sc->sc_buft;\n\tbus_space_handle_t memh = sc->sc_bufh;\n\tbus_size_t memsize = sc->mem_size;\n\tint i;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_set_region_2(memt, memh, 0, 0, memsize >> 1);\n\telse\n\t\tbus_space_set_region_1(memt, memh, 0, 0, memsize);\n\n\tif (esc->sc_16bitp) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; i++) {\n\t\t\tif (bus_space_read_1(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: failed to clear shared memory at offset 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, i);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/if_ecreg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tec_test_mem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tec_test_mem;\n\nint\nec_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)sc;\n\tbus_space_tag_t memt = sc->sc_buft;\n\tbus_space_handle_t memh = sc->sc_bufh;\n\tbus_size_t memsize = sc->mem_size;\n\tint i;\n\n\tif (esc->sc_16bitp)\n\t\tbus_space_set_region_2(memt, memh, 0, 0, memsize >> 1);\n\telse\n\t\tbus_space_set_region_1(memt, memh, 0, 0, memsize);\n\n\tif (esc->sc_16bitp) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; i++) {\n\t\t\tif (bus_space_read_1(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: failed to clear shared memory at offset 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, i);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_VPTR0",
            "0x00"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_VPTR1",
            "0xff"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_VPTR2",
            "0xff"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_GACFR",
            "ELINK2_GACFR_RSEL | ELINK2_GACFR_MBS0"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_IDCFR",
            "tmp"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_PSPR",
            "sc->rec_page_stop"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_PSTR",
            "sc->rec_page_start"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_config",
          "args": [
            "sc",
            "ec_media",
            "NEC_MEDIA",
            "EC_DEFMEDIA"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "86-158",
          "snippet": "int\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tdp8390_test_mem",
            "int\tdp8390_mediachange",
            "void\tdp8390_mediastatus",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int\t\tdp8390_test_mem;\nint\tdp8390_mediachange;\nvoid\tdp8390_mediastatus;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "nict",
            "nich",
            "ED_P2_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "nict",
            "nich",
            "ED_P2_DCR"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "nict",
            "nich",
            "ED_P0_DCR",
            "0"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "nict",
            "nich",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_CR",
            "ELINK2_CR_XSEL"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "nict",
            "nich",
            "i"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "nict",
            "nich",
            "i"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_CR",
            "ELINK2_CR_XSEL | ELINK2_CR_EALO"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "5000"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_CR",
            "ELINK2_CR_XSEL"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_CR",
            "ELINK2_CR_RST | ELINK2_CR_XSEL"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "memsize",
            "0",
            "&memh"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "asict",
            "ia->ia_iobase + ELINK2_ASIC_OFFSET",
            "ELINK2_ASIC_PORTS",
            "0",
            "&asich"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "nict",
            "ia->ia_iobase + ELINK2_NIC_OFFSET",
            "ELINK2_NIC_PORTS",
            "0",
            "&nich"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tEC_DEFMEDIA\t(IFM_ETHER|IFM_10_2)\n#define\tNEC_MEDIA\t(sizeof(ec_media) / sizeof(ec_media[0]))\n\nvoid\tec_attach;\nint\tec_mediachange;\nvoid\tec_mediastatus;\nvoid\tec_init_card;\nint\tec_write_mbuf;\nint\tec_ring_copy;\nvoid\tec_read_hdr;\nint\tec_fake_test_mem;\nint\tec_test_mem;\nint ec_media[] = {\n\tIFM_ETHER|IFM_10_2,\n\tIFM_ETHER|IFM_10_5,\n};\n\nvoid\nec_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ec_softc *esc = (struct ec_softc *)self;\n\tstruct dp8390_softc *sc = &esc->sc_dp8390;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t nict, asict, memt;\n\tbus_space_handle_t nich, asich, memh;\n\tbus_size_t memsize;\n\tu_int8_t tmp;\n\tint i;\n\n\tprintf(\"\\n\");\n\n\tnict = asict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\t/*\n\t * Hmm, a 16-bit card has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\t/* Map the NIC space. */\n\tif (bus_space_map(nict, ia->ia_iobase + ELINK2_NIC_OFFSET,\n\t    ELINK2_NIC_PORTS, 0, &nich)) {\n\t\tprintf(\"%s: can't map nic i/o space\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Map the ASIC space. */\n\tif (bus_space_map(asict, ia->ia_iobase + ELINK2_ASIC_OFFSET,\n\t    ELINK2_ASIC_PORTS, 0, &asich)) {\n\t\tprintf(\"%s: can't map asic i/o space\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Map the memory space. */\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh)) {\n\t\tprintf(\"%s: can't map shared memory\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tesc->sc_asict = asict;\n\tesc->sc_asich = asich;\n\n\tsc->sc_regt = nict;\n\tsc->sc_regh = nich;\n\n\tsc->sc_buft = memt;\n\tsc->sc_bufh = memh;\n\n\t/* Interface is always enabled. */\n\tsc->sc_enabled = 1;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tsc->sc_reg_map[i] = i;\n\n\t/* Now we can use the NIC_{GET,PUT}() macros. */\n\n\t/*\n\t * Reset NIC and ASIC.  Enable on-board transeiver throughout\n\t * reset sequence since it will lock up if the cable isn't\n\t * connected if we don't.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR,\n\t    ELINK2_CR_RST | ELINK2_CR_XSEL);\n\n\t/* Wait for a while, then un-reset it. */\n\tdelay(50);\n\n\t/*\n\t * The 3Com ASIC defaults to rather strange settings for the CR\n\t * after a reset.  It's important to set it again after the\n\t * following write (this is done when we map the PROM below).\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR, ELINK2_CR_XSEL);\n\n\t/* Wait a bit for the NIC to recover from the reset. */\n\tdelay(5000);\n\n\t/*\n\t * Get the station address from on-board ROM.\n\t *\n\t * First, map Ethernet address PROM over the top of where the NIC\n\t * registers normally appear.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR,\n\t    ELINK2_CR_XSEL | ELINK2_CR_EALO);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\tsc->sc_enaddr[i] = NIC_GET(nict, nich, i);\n#else\n\t\tsc->sc_arpcom.ac_enaddr[i] = NIC_GET(nict, nich, i);\n#endif\n\n\t/*\n\t * Unmap PROM - select NIC registers.  The proper setting of the\n\t * transciever is set in later in ec_init_card() via dp8390_init().\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_CR, ELINK2_CR_XSEL);\n\n\t/* Determine if this is an 8-bit or 16-bit board. */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(nict, nich, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Attempt to clear WTS.  If it doesn't clear, then this is a\n\t * 16-bit board.\n\t */\n\tNIC_PUT(nict, nich, ED_P0_DCR, 0);\n\n\t/* Select page 2 registers. */\n\tNIC_PUT(nict, nich, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);\n\n\t/* The 3c503 forces the WTS bit to a one if this is a 16-bit board. */\n\tif (NIC_GET(nict, nich, ED_P2_DCR) & ED_DCR_WTS)\n\t\tesc->sc_16bitp = 1;\n\telse\n\t\tesc->sc_16bitp = 0;\n\n\tprintf(\"%s: 3Com 3c503 Ethernet (%s-bit)\\n\",\n\t    sc->sc_dev.dv_xname, esc->sc_16bitp ? \"16\" : \"8\");\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(nict, nich, ED_P2_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * 16-bit cards also get word-wide DMA transfers.\n\t */\n\tsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (esc->sc_16bitp ? ED_DCR_WTS : 0);\n\n\tsc->test_mem = ec_fake_test_mem;\n\tsc->ring_copy = ec_ring_copy;\n\tsc->write_mbuf = ec_write_mbuf;\n\tsc->read_hdr = ec_read_hdr;\n\n\tsc->sc_mediachange = ec_mediachange;\n\tsc->sc_mediastatus = ec_mediastatus;\n\n\tsc->mem_start = 0;\n\tsc->mem_size = memsize;\n\n\t/* Do generic parts of attach. */\n\tif (dp8390_config(sc, ec_media, NEC_MEDIA, EC_DEFMEDIA)) {\n\t\tprintf(\"%s: configuration failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to override the way dp8390_config() set up our\n\t * shared memory.\n\t *\n\t * We have an entire 8k window to put the transmit buffers on the\n\t * 16-bit boards.  But since the 16bit 3c503's shared memory is only\n\t * fast enough to overlap the loading of one full-size packet, trying\n\t * to load more than 2 buffers can actually leave the transmitter idle\n\t * during the load.  So 2 seems the best value.  (Although a mix of\n\t * variable-sized packets might change this assumption.  Nonetheless,\n\t * we optimize for linear transfers of same-size packets.)\n\t */\n\tif (esc->sc_16bitp) {\n\t\tif (sc->sc_dev.dv_cfdata->cf_flags & DP8390_NO_MULTI_BUFFERING)\n\t\t\tsc->txb_cnt = 1;\n\t\telse\n\t\t\tsc->txb_cnt = 2;\n\n\t\tsc->tx_page_start = ELINK2_TX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_start = ELINK2_RX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_stop = (memsize >> ED_PAGE_SHIFT) + \n\t\t    sc->rec_page_start;\n\t\tsc->mem_ring = sc->mem_start;\n\t} else {\n\t\tsc->txb_cnt = 1;\n\t\tsc->tx_page_start = ELINK2_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_start = sc->tx_page_start + ED_TXBUF_SIZE;\n\t\tsc->rec_page_stop = (memsize >> ED_PAGE_SHIFT) +\n\t\t    sc->tx_page_start;\n\t\tsc->mem_ring = sc->mem_start +\n\t\t    (ED_TXBUF_SIZE << ED_PAGE_SHIFT);\n\t}\n\n\t/*\n\t * Initialize CA page start/stop registers.  Probably only needed\n\t * if doing DMA, but what the Hell.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_PSTR, sc->rec_page_start);\n\tbus_space_write_1(asict, asich, ELINK2_PSPR, sc->rec_page_stop);\n\n\t/*\n\t * Program the IRQ.\n\t */\n\tswitch (ia->ia_irq) {\n\tcase 9:\ttmp = ELINK2_IDCFR_IRQ2; break;\n\tcase 3:\ttmp = ELINK2_IDCFR_IRQ3; break;\n\tcase 4:\ttmp = ELINK2_IDCFR_IRQ4; break;\n\tcase 5:\ttmp = ELINK2_IDCFR_IRQ5; break;\n\t\tbreak;\n\n\tcase IRQUNK:\n\t\tprintf(\"%s: wildcarded IRQ is not allowed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\n\tdefault:\n\t\tprintf(\"%s: invalid IRQ %d, must be 3, 4, 5, or 9\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_irq);\n\t\treturn;\n\t}\n\n\tbus_space_write_1(asict, asich, ELINK2_IDCFR, tmp);\n\n\t/*\n\t * Initialize the GA configuration register.  Set bank and enable\n\t * shared memory.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_GACFR,\n\t    ELINK2_GACFR_RSEL | ELINK2_GACFR_MBS0);\n\n\t/*\n\t * Intialize \"Vector Pointer\" registers.  These gawd-awful things\n\t * are compared to 20 bits of the address on the ISA, and if they\n\t * match, the shared memory is disabled.  We se them to 0xffff0...\n\t * allegedly the reset vector.\n\t */\n\tbus_space_write_1(asict, asich, ELINK2_VPTR2, 0xff);\n\tbus_space_write_1(asict, asich, ELINK2_VPTR1, 0xff);\n\tbus_space_write_1(asict, asich, ELINK2_VPTR0, 0x00);\n\n\t/*\n\t * Now run the real memory test.\n\t */\n\tif (ec_test_mem(sc)) {\n\t\tprintf(\"%s: memory test failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* Establish interrupt handler. */\n\tesc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, dp8390_intr, sc, sc->sc_dev.dv_xname);\n\tif (esc->sc_ih == NULL)\n\t\tprintf(\"%s: can't establish interrupt\\n\", sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "ec_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ec.c",
    "lines": "163-268",
    "snippet": "int\nec_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t nict, asict, memt;\n\tbus_space_handle_t nich, asich, memh;\n\tbus_size_t memsize;\n\tint nich_valid, asich_valid, memh_valid;\n\tint i, rv = 0;\n\tu_int8_t x;\n\n\tnict = asict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tnich_valid = asich_valid = memh_valid = 0;\n\n\t/*\n\t * Hmm, a 16-bit card has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\t/* Disallow wildcarded i/o addresses. */\n\tif (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)\n\t\treturn (0);\n\n\t/* Disallow wildcarded mem address. */\n\tif (ia->ia_maddr == -1 /* ISACF_IOMEM_DEFAULT */)\n\t\treturn (0);\n\n\t/* Validate the i/o base. */\n\tfor (i = 0; i < NEC_IOBASE; i++)\n\t\tif (ia->ia_iobase == ec_iobase[i])\n\t\t\tbreak;\n\tif (i == NEC_IOBASE)\n\t\treturn (0);\n\n\t/* Validate the mem base. */\n\tfor (i = 0; i < NEC_MEMBASE; i++) {\n\t\tif (ec_membase[i] == MADDRUNK)\n\t\t\tcontinue;\n\t\tif (ia->ia_maddr == ec_membase[i])\n\t\t\tbreak;\n\t}\n\tif (i == NEC_MEMBASE)\n\t\treturn (0);\n\n\t/* Attempt to map the NIC space. */\n\tif (bus_space_map(nict, ia->ia_iobase + ELINK2_NIC_OFFSET,\n\t    ELINK2_NIC_PORTS, 0, &nich))\n\t\tgoto out;\n\tnich_valid = 1;\n\n\t/* Attempt to map the ASIC space. */\n\tif (bus_space_map(asict, ia->ia_iobase + ELINK2_ASIC_OFFSET,\n\t    ELINK2_ASIC_PORTS, 0, &asich))\n\t\tgoto out;\n\tasich_valid = 1;\n\n\t/* Attempt to map the memory space. */\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto out;\n\tmemh_valid = 1;\n\n\t/*\n\t * Verify that the kernel configured I/O address matches the\n\t * board configured I/O address.\n\t *\n\t * This is really only useful to see if something that looks like\n\t * the board is there; after all, we're already talking to it at\n\t * this point.\n\t */\n\tx = bus_space_read_1(asict, asich, ELINK2_BCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\ti = ffs(x) - 1;\n\tif (ia->ia_iobase != ec_iobase[i])\n\t\tgoto out;\n\n\t/*\n\t * ...and for the memory address.  Note we do not support\n\t * cards configured with shared memory disabled.\n\t */\n\tx = bus_space_read_1(asict, asich, ELINK2_PCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\ti = ffs(x) - 1;\n\tif (ia->ia_maddr != ec_membase[i])\n\t\tgoto out;\n\n\t/* So, we say we've found it! */\n\tia->ia_iosize = ELINK2_NIC_PORTS;\n\tia->ia_msize = memsize;\n\trv = 1;\n\n out:\n\tif (nich_valid)\n\t\tbus_space_unmap(nict, nich, ELINK2_NIC_PORTS);\n\tif (asich_valid)\n\t\tbus_space_unmap(asict, asich, ELINK2_ASIC_PORTS);\n\tif (memh_valid)\n\t\tbus_space_unmap(memt, memh, memsize);\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/isa/if_ecreg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNEC_MEMBASE\t(sizeof(ec_membase) / sizeof(ec_membase[0]))",
      "#define\tNEC_IOBASE\t(sizeof(ec_iobase) / sizeof(ec_iobase[0]))"
    ],
    "globals_used": [
      "int\tec_probe",
      "static const int ec_iobase[] = {\n\t0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300,\n};",
      "static const int ec_membase[] = {\n\tMADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000,\n\t0xd8000, 0xdc000,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "memsize"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "asict",
            "asich",
            "ELINK2_ASIC_PORTS"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "nict",
            "nich",
            "ELINK2_NIC_PORTS"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "x"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_PCFR"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "ELINK2_BCFR"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "memsize",
            "0",
            "&memh"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "asict",
            "ia->ia_iobase + ELINK2_ASIC_OFFSET",
            "ELINK2_ASIC_PORTS",
            "0",
            "&asich"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "nict",
            "ia->ia_iobase + ELINK2_NIC_OFFSET",
            "ELINK2_NIC_PORTS",
            "0",
            "&nich"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_ecreg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNEC_MEMBASE\t(sizeof(ec_membase) / sizeof(ec_membase[0]))\n#define\tNEC_IOBASE\t(sizeof(ec_iobase) / sizeof(ec_iobase[0]))\n\nint\tec_probe;\nstatic const int ec_iobase[] = {\n\t0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300,\n};\nstatic const int ec_membase[] = {\n\tMADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000,\n\t0xd8000, 0xdc000,\n};\n\nint\nec_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t nict, asict, memt;\n\tbus_space_handle_t nich, asich, memh;\n\tbus_size_t memsize;\n\tint nich_valid, asich_valid, memh_valid;\n\tint i, rv = 0;\n\tu_int8_t x;\n\n\tnict = asict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tnich_valid = asich_valid = memh_valid = 0;\n\n\t/*\n\t * Hmm, a 16-bit card has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\t/* Disallow wildcarded i/o addresses. */\n\tif (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)\n\t\treturn (0);\n\n\t/* Disallow wildcarded mem address. */\n\tif (ia->ia_maddr == -1 /* ISACF_IOMEM_DEFAULT */)\n\t\treturn (0);\n\n\t/* Validate the i/o base. */\n\tfor (i = 0; i < NEC_IOBASE; i++)\n\t\tif (ia->ia_iobase == ec_iobase[i])\n\t\t\tbreak;\n\tif (i == NEC_IOBASE)\n\t\treturn (0);\n\n\t/* Validate the mem base. */\n\tfor (i = 0; i < NEC_MEMBASE; i++) {\n\t\tif (ec_membase[i] == MADDRUNK)\n\t\t\tcontinue;\n\t\tif (ia->ia_maddr == ec_membase[i])\n\t\t\tbreak;\n\t}\n\tif (i == NEC_MEMBASE)\n\t\treturn (0);\n\n\t/* Attempt to map the NIC space. */\n\tif (bus_space_map(nict, ia->ia_iobase + ELINK2_NIC_OFFSET,\n\t    ELINK2_NIC_PORTS, 0, &nich))\n\t\tgoto out;\n\tnich_valid = 1;\n\n\t/* Attempt to map the ASIC space. */\n\tif (bus_space_map(asict, ia->ia_iobase + ELINK2_ASIC_OFFSET,\n\t    ELINK2_ASIC_PORTS, 0, &asich))\n\t\tgoto out;\n\tasich_valid = 1;\n\n\t/* Attempt to map the memory space. */\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto out;\n\tmemh_valid = 1;\n\n\t/*\n\t * Verify that the kernel configured I/O address matches the\n\t * board configured I/O address.\n\t *\n\t * This is really only useful to see if something that looks like\n\t * the board is there; after all, we're already talking to it at\n\t * this point.\n\t */\n\tx = bus_space_read_1(asict, asich, ELINK2_BCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\ti = ffs(x) - 1;\n\tif (ia->ia_iobase != ec_iobase[i])\n\t\tgoto out;\n\n\t/*\n\t * ...and for the memory address.  Note we do not support\n\t * cards configured with shared memory disabled.\n\t */\n\tx = bus_space_read_1(asict, asich, ELINK2_PCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\ti = ffs(x) - 1;\n\tif (ia->ia_maddr != ec_membase[i])\n\t\tgoto out;\n\n\t/* So, we say we've found it! */\n\tia->ia_iosize = ELINK2_NIC_PORTS;\n\tia->ia_msize = memsize;\n\trv = 1;\n\n out:\n\tif (nich_valid)\n\t\tbus_space_unmap(nict, nich, ELINK2_NIC_PORTS);\n\tif (asich_valid)\n\t\tbus_space_unmap(asict, asich, ELINK2_ASIC_PORTS);\n\tif (memh_valid)\n\t\tbus_space_unmap(memt, memh, memsize);\n\treturn (rv);\n}"
  }
]