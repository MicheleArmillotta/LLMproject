[
  {
    "function_name": "cardbus_restore_bar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
    "lines": "425-442",
    "snippet": "int cardbus_restore_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, ct->ct_bar[0]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, ct->ct_bar[1]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, ct->ct_bar[2]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, ct->ct_bar[3]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, ct->ct_bar[4]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, ct->ct_bar[5]);\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Cardbus_free_tag",
          "args": [
            "ct",
            "tag"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE5_REG",
            "ct->ct_bar[5]"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE4_REG",
            "ct->ct_bar[4]"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE3_REG",
            "ct->ct_bar[3]"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE2_REG",
            "ct->ct_bar[2]"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE1_REG",
            "ct->ct_bar[1]"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE0_REG",
            "ct->ct_bar[0]"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Cardbus_make_tag",
          "args": [
            "ct"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint cardbus_restore_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, ct->ct_bar[0]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, ct->ct_bar[1]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, ct->ct_bar[2]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, ct->ct_bar[3]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, ct->ct_bar[4]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, ct->ct_bar[5]);\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cardbus_save_bar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
    "lines": "396-415",
    "snippet": "int cardbus_save_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tct->ct_bar[0] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE0_REG);\n\tct->ct_bar[1] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE1_REG);\n\tct->ct_bar[2] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE2_REG);\n\tct->ct_bar[3] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE3_REG);\n\tct->ct_bar[4] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE4_REG);\n\tct->ct_bar[5] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE5_REG);\n\n\tDPRINTF((\"cardbus_save_bar: %x %x\\n\", ct->ct_bar[0], ct->ct_bar[1]));\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Cardbus_free_tag",
          "args": [
            "ct",
            "tag"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbus_save_bar: %x %x\\n\", ct->ct_bar[0], ct->ct_bar[1])"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE5_REG"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE4_REG"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE3_REG"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE2_REG"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE1_REG"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "CARDBUS_BASE0_REG"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Cardbus_make_tag",
          "args": [
            "ct"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint cardbus_save_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tct->ct_bar[0] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE0_REG);\n\tct->ct_bar[1] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE1_REG);\n\tct->ct_bar[2] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE2_REG);\n\tct->ct_bar[3] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE3_REG);\n\tct->ct_bar[4] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE4_REG);\n\tct->ct_bar[5] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE5_REG);\n\n\tDPRINTF((\"cardbus_save_bar: %x %x\\n\", ct->ct_bar[0], ct->ct_bar[1]));\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cardbus_mapreg_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
    "lines": "345-384",
    "snippet": "int\ncardbus_mapreg_unmap(sc, func, reg, tag, handle, size)\n\tstruct cardbus_softc *sc;\n\tint func, reg;\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_size_t size;\n{\n\tcardbus_chipset_tag_t cc = sc->sc_cc;\n\tcardbus_function_tag_t cf = sc->sc_cf;\n\tint st = 1;\n\tcardbustag_t cardbustag;\n#if rbus\n\trbus_tag_t rbustag;\n\n\tif (sc->sc_iot == tag) {\n\t\t/* bus space is io space */\n\t\tDPRINTF((\"%s: unmap i/o space\\n\", sc->sc_dev.dv_xname));\n\t\trbustag = sc->sc_rbus_iot;\n\t} else if (sc->sc_memt == tag) {\n\t\t/* bus space is memory space */\n\t\tDPRINTF((\"%s: unmap mem space\\n\", sc->sc_dev.dv_xname));\n\t\trbustag = sc->sc_rbus_memt;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\n\n\tcardbustag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);\n\n\tcardbus_conf_write(cc, cf, cardbustag, reg, 0);\n\n#if rbus\n\t(*cf->cardbus_space_free)(cc, rbustag, handle, size);\n#endif\n\n\tcardbus_free_tag(cc, cf, cardbustag);\n\n\treturn st;\n}",
    "includes": [
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cardbus_free_tag",
          "args": [
            "cc",
            "cf",
            "cardbustag"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "rbustag",
            "handle",
            "size"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "cardbustag",
            "reg",
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_make_tag",
          "args": [
            "cc",
            "cf",
            "sc->sc_bus",
            "sc->sc_device",
            "func"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: unmap mem space\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: unmap i/o space\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ncardbus_mapreg_unmap(sc, func, reg, tag, handle, size)\n\tstruct cardbus_softc *sc;\n\tint func, reg;\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_size_t size;\n{\n\tcardbus_chipset_tag_t cc = sc->sc_cc;\n\tcardbus_function_tag_t cf = sc->sc_cf;\n\tint st = 1;\n\tcardbustag_t cardbustag;\n#if rbus\n\trbus_tag_t rbustag;\n\n\tif (sc->sc_iot == tag) {\n\t\t/* bus space is io space */\n\t\tDPRINTF((\"%s: unmap i/o space\\n\", sc->sc_dev.dv_xname));\n\t\trbustag = sc->sc_rbus_iot;\n\t} else if (sc->sc_memt == tag) {\n\t\t/* bus space is memory space */\n\t\tDPRINTF((\"%s: unmap mem space\\n\", sc->sc_dev.dv_xname));\n\t\trbustag = sc->sc_rbus_memt;\n\t} else {\n\t\treturn 1;\n\t}\n#endif\n\n\tcardbustag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);\n\n\tcardbus_conf_write(cc, cf, cardbustag, reg, 0);\n\n#if rbus\n\t(*cf->cardbus_space_free)(cc, rbustag, handle, size);\n#endif\n\n\tcardbus_free_tag(cc, cf, cardbustag);\n\n\treturn st;\n}"
  },
  {
    "function_name": "cardbus_mapreg_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
    "lines": "241-326",
    "snippet": "int\ncardbus_mapreg_map(sc, func, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct cardbus_softc *sc;\n\tint func, reg, busflags;\n\tcardbusreg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tcardbus_chipset_tag_t cc = sc->sc_cc;\n\tcardbus_function_tag_t cf = sc->sc_cf;\n\tbus_space_tag_t bustag;\n#if rbus\n\trbus_tag_t rbustag;\n#endif\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\tint status = 0;\n\n\tcardbustag_t tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);\n\n\tDPRINTF((\"cardbus_mapreg_map called: %s %x\\n\", sc->sc_dev.dv_xname,\n\t   type));\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif (cardbus_io_find(cc, cf, tag, reg, type, &base, &size, &flags)) {\n\t\t\tstatus = 1;\n\t\t}\n\t\tbustag = sc->sc_iot;\n#if rbus\n\t\trbustag = sc->sc_rbus_iot;\n#endif\n\t} else {\n\t\tif (cardbus_mem_find(cc, cf, tag, reg, type, &base, &size, &flags)){\n\t\t\tstatus = 1;\n\t\t}\n\t\tbustag = sc->sc_memt;\n#if rbus\n\t\trbustag = sc->sc_rbus_memt;\n#endif\n\t}\n\tif (status == 0) {\n#if rbus\n\t\tbus_addr_t mask = size - 1;\n\t\tif (base != 0) {\n\t\t\tmask = 0xffffffff;\n\t\t}\n\t\tif ((*cf->cardbus_space_alloc)(cc, rbustag, base, size, mask,\n\t\t    size, busflags | flags, &base, &handle)) {\n\t\t\tpanic(\"io alloc\");\n\t\t}\n#else\n\t\tbus_addr_t start = 0x8300;\n\t\tbus_addr_t end = 0x8400;\n\t\tif (base != 0) {\n\t\t\tbus_addr_t start = base;\n\t\t\tbus_addr_t end = base + size;\n\t\t}\n\t\tif (bus_space_alloc(bustag, start, end, size, size, 0, 0, &base, &handle)) {\n\t\t\tpanic(\"io alloc\");\n\t\t}\n#endif\n\t}\n\tcardbus_conf_write(cc, cf, tag, reg, base);\n\n\tDPRINTF((\"cardbus_mapreg_map: physaddr %lx\\n\", base));\n\n\tif (tagp != 0) {\n\t\t*tagp = bustag;\n\t}\n\tif (handlep != 0) {\n\t\t*handlep = handle;\n\t}\n\tif (basep != 0) {\n\t\t*basep = base;\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = size;\n\t}\n\tcardbus_free_tag(cc, cf, tag);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cardbus_io_find",
      "static int cardbus_mem_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cardbus_free_tag",
          "args": [
            "cc",
            "cf",
            "tag"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbus_mapreg_map: physaddr %lx\\n\", base)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "base"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"io alloc\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_alloc",
          "args": [
            "bustag",
            "start",
            "end",
            "size",
            "size",
            "0",
            "0",
            "&base",
            "&handle"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_alloc_subregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "82-173",
          "snippet": "int\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));\n\nint\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"io alloc\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "rbustag",
            "base",
            "size",
            "mask",
            "size",
            "busflags | flags",
            "&base",
            "&handle"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_mem_find",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "type",
            "&base",
            "&size",
            "&flags"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
          "lines": "147-226",
          "snippet": "static int\ncardbus_mem_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\tif (reg != CARDBUS_ROM_REG && \n\t    (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))) {\n\t\tpanic(\"cardbus_mem_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (reg != CARDBUS_ROM_REG) {\n\t\t/* memory space BAR */\n\n\t\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_MEM) {\n\t\t\tprintf(\"cardbus_mem_find: expected type mem, found i/o\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (PCI_MAPREG_MEM_TYPE(address) != PCI_MAPREG_MEM_TYPE(type)) {\n\t\t\tprintf(\"cardbus_mem_find: expected mem type %08x, found %08x\\n\",\n\t\t\t    PCI_MAPREG_MEM_TYPE(type),\n\t\t\t    PCI_MAPREG_MEM_TYPE(address));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (PCI_MAPREG_MEM_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_mem_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tswitch (PCI_MAPREG_MEM_TYPE(address)) {\n\tcase PCI_MAPREG_MEM_TYPE_32BIT:\n\tcase PCI_MAPREG_MEM_TYPE_32BIT_1M:\n\t\tbreak;\n\tcase PCI_MAPREG_MEM_TYPE_64BIT:\n\t\tprintf(\"cardbus_mem_find: 64-bit memory mapping register\\n\");\n\t\treturn 1;\n\tdefault:\n\t\tprintf(\"cardbus_mem_find: reserved mapping register type\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_MEM_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_MEM_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = PCI_MAPREG_MEM_CACHEABLE(address);\n\t}\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cardbus_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbus_mem_find;\n\nstatic int\ncardbus_mem_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\tif (reg != CARDBUS_ROM_REG && \n\t    (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))) {\n\t\tpanic(\"cardbus_mem_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (reg != CARDBUS_ROM_REG) {\n\t\t/* memory space BAR */\n\n\t\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_MEM) {\n\t\t\tprintf(\"cardbus_mem_find: expected type mem, found i/o\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (PCI_MAPREG_MEM_TYPE(address) != PCI_MAPREG_MEM_TYPE(type)) {\n\t\t\tprintf(\"cardbus_mem_find: expected mem type %08x, found %08x\\n\",\n\t\t\t    PCI_MAPREG_MEM_TYPE(type),\n\t\t\t    PCI_MAPREG_MEM_TYPE(address));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (PCI_MAPREG_MEM_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_mem_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tswitch (PCI_MAPREG_MEM_TYPE(address)) {\n\tcase PCI_MAPREG_MEM_TYPE_32BIT:\n\tcase PCI_MAPREG_MEM_TYPE_32BIT_1M:\n\t\tbreak;\n\tcase PCI_MAPREG_MEM_TYPE_64BIT:\n\t\tprintf(\"cardbus_mem_find: 64-bit memory mapping register\\n\");\n\t\treturn 1;\n\tdefault:\n\t\tprintf(\"cardbus_mem_find: reserved mapping register type\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_MEM_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_MEM_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = PCI_MAPREG_MEM_CACHEABLE(address);\n\t}\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardbus_io_find",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "type",
            "&base",
            "&size",
            "&flags"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
          "lines": "75-136",
          "snippet": "static int\ncardbus_io_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\t/* EXT ROM is able to map on memory space ONLY. */\n\tif (reg == CARDBUS_ROM_REG) {\n\t\treturn 1;\n\t}\n\n\tif(reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3)) {\n\t\tpanic(\"cardbus_io_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_IO) {\n\t\tprintf(\"cardbus_io_find: expected type i/o, found mem\\n\");\n\t\treturn 1;\n\t}\n\n\tif (PCI_MAPREG_IO_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_io_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_IO_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_IO_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cardbus_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbus_io_find;\n\nstatic int\ncardbus_io_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\t/* EXT ROM is able to map on memory space ONLY. */\n\tif (reg == CARDBUS_ROM_REG) {\n\t\treturn 1;\n\t}\n\n\tif(reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3)) {\n\t\tpanic(\"cardbus_io_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_IO) {\n\t\tprintf(\"cardbus_io_find: expected type i/o, found mem\\n\");\n\t\treturn 1;\n\t}\n\n\tif (PCI_MAPREG_IO_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_io_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_IO_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_IO_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_TYPE",
          "args": [
            "type"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbus_mapreg_map called: %s %x\\n\", sc->sc_dev.dv_xname,\n\t   type)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_make_tag",
          "args": [
            "cc",
            "cf",
            "sc->sc_bus",
            "sc->sc_device",
            "func"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbus_io_find;\nstatic int cardbus_mem_find;\n\nint\ncardbus_mapreg_map(sc, func, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct cardbus_softc *sc;\n\tint func, reg, busflags;\n\tcardbusreg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tcardbus_chipset_tag_t cc = sc->sc_cc;\n\tcardbus_function_tag_t cf = sc->sc_cf;\n\tbus_space_tag_t bustag;\n#if rbus\n\trbus_tag_t rbustag;\n#endif\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\tint status = 0;\n\n\tcardbustag_t tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);\n\n\tDPRINTF((\"cardbus_mapreg_map called: %s %x\\n\", sc->sc_dev.dv_xname,\n\t   type));\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif (cardbus_io_find(cc, cf, tag, reg, type, &base, &size, &flags)) {\n\t\t\tstatus = 1;\n\t\t}\n\t\tbustag = sc->sc_iot;\n#if rbus\n\t\trbustag = sc->sc_rbus_iot;\n#endif\n\t} else {\n\t\tif (cardbus_mem_find(cc, cf, tag, reg, type, &base, &size, &flags)){\n\t\t\tstatus = 1;\n\t\t}\n\t\tbustag = sc->sc_memt;\n#if rbus\n\t\trbustag = sc->sc_rbus_memt;\n#endif\n\t}\n\tif (status == 0) {\n#if rbus\n\t\tbus_addr_t mask = size - 1;\n\t\tif (base != 0) {\n\t\t\tmask = 0xffffffff;\n\t\t}\n\t\tif ((*cf->cardbus_space_alloc)(cc, rbustag, base, size, mask,\n\t\t    size, busflags | flags, &base, &handle)) {\n\t\t\tpanic(\"io alloc\");\n\t\t}\n#else\n\t\tbus_addr_t start = 0x8300;\n\t\tbus_addr_t end = 0x8400;\n\t\tif (base != 0) {\n\t\t\tbus_addr_t start = base;\n\t\t\tbus_addr_t end = base + size;\n\t\t}\n\t\tif (bus_space_alloc(bustag, start, end, size, size, 0, 0, &base, &handle)) {\n\t\t\tpanic(\"io alloc\");\n\t\t}\n#endif\n\t}\n\tcardbus_conf_write(cc, cf, tag, reg, base);\n\n\tDPRINTF((\"cardbus_mapreg_map: physaddr %lx\\n\", base));\n\n\tif (tagp != 0) {\n\t\t*tagp = bustag;\n\t}\n\tif (handlep != 0) {\n\t\t*handlep = handle;\n\t}\n\tif (basep != 0) {\n\t\t*basep = base;\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = size;\n\t}\n\tcardbus_free_tag(cc, cf, tag);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cardbus_mem_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
    "lines": "147-226",
    "snippet": "static int\ncardbus_mem_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\tif (reg != CARDBUS_ROM_REG && \n\t    (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))) {\n\t\tpanic(\"cardbus_mem_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (reg != CARDBUS_ROM_REG) {\n\t\t/* memory space BAR */\n\n\t\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_MEM) {\n\t\t\tprintf(\"cardbus_mem_find: expected type mem, found i/o\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (PCI_MAPREG_MEM_TYPE(address) != PCI_MAPREG_MEM_TYPE(type)) {\n\t\t\tprintf(\"cardbus_mem_find: expected mem type %08x, found %08x\\n\",\n\t\t\t    PCI_MAPREG_MEM_TYPE(type),\n\t\t\t    PCI_MAPREG_MEM_TYPE(address));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (PCI_MAPREG_MEM_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_mem_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tswitch (PCI_MAPREG_MEM_TYPE(address)) {\n\tcase PCI_MAPREG_MEM_TYPE_32BIT:\n\tcase PCI_MAPREG_MEM_TYPE_32BIT_1M:\n\t\tbreak;\n\tcase PCI_MAPREG_MEM_TYPE_64BIT:\n\t\tprintf(\"cardbus_mem_find: 64-bit memory mapping register\\n\");\n\t\treturn 1;\n\tdefault:\n\t\tprintf(\"cardbus_mem_find: reserved mapping register type\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_MEM_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_MEM_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = PCI_MAPREG_MEM_CACHEABLE(address);\n\t}\n\t\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cardbus_mem_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_CACHEABLE",
          "args": [
            "address"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_SIZE",
          "args": [
            "mask"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_ADDR",
          "args": [
            "address"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus_mem_find: reserved mapping register type\\n\""
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_TYPE",
          "args": [
            "address"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_SIZE",
          "args": [
            "mask"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_TYPE",
          "args": [
            "address"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_TYPE",
          "args": [
            "type"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_TYPE",
          "args": [
            "type"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_TYPE",
          "args": [
            "address"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_TYPE",
          "args": [
            "address"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "address"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "0xffffffff"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cardbus_mem_find: bad request\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbus_mem_find;\n\nstatic int\ncardbus_mem_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\tif (reg != CARDBUS_ROM_REG && \n\t    (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))) {\n\t\tpanic(\"cardbus_mem_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (reg != CARDBUS_ROM_REG) {\n\t\t/* memory space BAR */\n\n\t\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_MEM) {\n\t\t\tprintf(\"cardbus_mem_find: expected type mem, found i/o\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (PCI_MAPREG_MEM_TYPE(address) != PCI_MAPREG_MEM_TYPE(type)) {\n\t\t\tprintf(\"cardbus_mem_find: expected mem type %08x, found %08x\\n\",\n\t\t\t    PCI_MAPREG_MEM_TYPE(type),\n\t\t\t    PCI_MAPREG_MEM_TYPE(address));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (PCI_MAPREG_MEM_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_mem_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tswitch (PCI_MAPREG_MEM_TYPE(address)) {\n\tcase PCI_MAPREG_MEM_TYPE_32BIT:\n\tcase PCI_MAPREG_MEM_TYPE_32BIT_1M:\n\t\tbreak;\n\tcase PCI_MAPREG_MEM_TYPE_64BIT:\n\t\tprintf(\"cardbus_mem_find: 64-bit memory mapping register\\n\");\n\t\treturn 1;\n\tdefault:\n\t\tprintf(\"cardbus_mem_find: reserved mapping register type\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_MEM_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_MEM_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = PCI_MAPREG_MEM_CACHEABLE(address);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "function_name": "cardbus_io_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
    "lines": "75-136",
    "snippet": "static int\ncardbus_io_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\t/* EXT ROM is able to map on memory space ONLY. */\n\tif (reg == CARDBUS_ROM_REG) {\n\t\treturn 1;\n\t}\n\n\tif(reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3)) {\n\t\tpanic(\"cardbus_io_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_IO) {\n\t\tprintf(\"cardbus_io_find: expected type i/o, found mem\\n\");\n\t\treturn 1;\n\t}\n\n\tif (PCI_MAPREG_IO_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_io_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_IO_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_IO_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pcireg.h>\t/* XXX */",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cardbus_io_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_MAPREG_IO_SIZE",
          "args": [
            "mask"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_IO_ADDR",
          "args": [
            "address"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus_io_find: void region\\n\""
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_IO_SIZE",
          "args": [
            "mask"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_TYPE",
          "args": [
            "address"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "address"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg",
            "0xffffffff"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "tag",
            "reg"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cardbus_io_find: bad request\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardbus_io_find;\n\nstatic int\ncardbus_io_find(cc, cf, tag, reg, type, basep, sizep, flagsp)\n\tcardbus_chipset_tag_t cc;\n\tcardbus_function_tag_t cf;\n\tcardbustag_t tag;\n\tint reg;\n\tcardbusreg_t type;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n\tint *flagsp;\n{\n\tcardbusreg_t address, mask;\n\tint s;\n\n\t/* EXT ROM is able to map on memory space ONLY. */\n\tif (reg == CARDBUS_ROM_REG) {\n\t\treturn 1;\n\t}\n\n\tif(reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3)) {\n\t\tpanic(\"cardbus_io_find: bad request\");\n\t}\n\n\t/*\n\t * Section 6.2.5.1, `Address Maps', tells us that:\n\t *\n\t * 1) The builtin software should have already mapped the device in a\n\t * reasonable way.\n\t *\n\t * 2) A device which wants 2^n bytes of memory will hardwire the bottom\n\t * n bits of the address to 0.  As recommended, we write all 1s and see\n\t * what we get back.\n\t */\n\ts = splhigh();\n\taddress = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, 0xffffffff);\n\tmask = cardbus_conf_read(cc, cf, tag, reg);\n\tcardbus_conf_write(cc, cf, tag, reg, address);\n\tsplx(s);\n\n\tif (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_IO) {\n\t\tprintf(\"cardbus_io_find: expected type i/o, found mem\\n\");\n\t\treturn 1;\n\t}\n\n\tif (PCI_MAPREG_IO_SIZE(mask) == 0) {\n\t\tprintf(\"cardbus_io_find: void region\\n\");\n\t\treturn 1;\n\t}\n\n\tif (basep != 0) {\n\t\t*basep = PCI_MAPREG_IO_ADDR(address);\n\t}\n\tif (sizep != 0) {\n\t\t*sizep = PCI_MAPREG_IO_SIZE(mask);\n\t}\n\tif (flagsp != 0) {\n\t\t*flagsp = 0;\n\t}\n\n\treturn 0;\n}"
  }
]