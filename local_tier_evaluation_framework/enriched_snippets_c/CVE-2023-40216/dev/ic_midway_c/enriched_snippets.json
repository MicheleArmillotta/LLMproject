[
  {
    "function_name": "en_dumpmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "3158-3183",
    "snippet": "int en_dumpmem(unit, addr, len)\n\nint unit, addr, len;\n\n{\n  struct en_softc *sc;\n  u_int32_t reg;\n\n  if (unit < 0 || unit > en_cd.cd_ndevs ||\n\t(sc = (struct en_softc *) en_cd.cd_devs[unit]) == NULL) {\n    printf(\"invalid unit number: %d\\n\", unit);\n    return(0);\n  }\n  addr = addr & ~3;\n  if (addr < MID_RAMOFF || addr + len*4 > MID_MAXOFF || len <= 0) {\n    printf(\"invalid addr/len number: %d, %d\\n\", addr, len);\n    return(0);\n  }\n  printf(\"dumping %d words starting at offset 0x%x\\n\", len, addr);\n  while (len--) {\n    reg = EN_READ(sc, addr);\n    printf(\"mem[0x%x] = 0x%x\\n\", addr, reg);\n    addr += 4;\n  }\n  return(0);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"mem[0x%x] = 0x%x\\n\"",
            "addr",
            "reg"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "addr"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_dumpmem(unit, addr, len)\n\nint unit, addr, len;\n\n{\n  struct en_softc *sc;\n  u_int32_t reg;\n\n  if (unit < 0 || unit > en_cd.cd_ndevs ||\n\t(sc = (struct en_softc *) en_cd.cd_devs[unit]) == NULL) {\n    printf(\"invalid unit number: %d\\n\", unit);\n    return(0);\n  }\n  addr = addr & ~3;\n  if (addr < MID_RAMOFF || addr + len*4 > MID_MAXOFF || len <= 0) {\n    printf(\"invalid addr/len number: %d, %d\\n\", addr, len);\n    return(0);\n  }\n  printf(\"dumping %d words starting at offset 0x%x\\n\", len, addr);\n  while (len--) {\n    reg = EN_READ(sc, addr);\n    printf(\"mem[0x%x] = 0x%x\\n\", addr, reg);\n    addr += 4;\n  }\n  return(0);\n}"
  },
  {
    "function_name": "en_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "2996-3152",
    "snippet": "int en_dump(unit, level)\n\nint unit, level;\n\n{\n  struct en_softc *sc;\n  int lcv, cnt, slot;\n  u_int32_t ptr, reg;\n\n  for (lcv = 0 ; lcv < en_cd.cd_ndevs ; lcv++) {\n    sc = (struct en_softc *) en_cd.cd_devs[lcv];\n    if (sc == NULL) continue;\n    if (unit != -1 && unit != lcv)\n      continue;\n\n    printf(\"dumping device %s at level 0x%b\\n\", sc->sc_dev.dv_xname, level,\n\t\t\tEND_BITS);\n\n    if (sc->dtq_us == 0) {\n      printf(\"<hasn't been en_init'd yet>\\n\");\n      continue;\n    }\n\n    if (level & END_STATS) {\n      printf(\"  en_stats:\\n\");\n      printf(\"    %d mfix (%d failed); %d/%d head/tail byte DMAs, %d flushes\\n\",\n\t   sc->mfix, sc->mfixfail, sc->headbyte, sc->tailbyte, sc->tailflush);\n      printf(\"    %d rx dma overflow interrupts\\n\", sc->dmaovr);\n      printf(\"    %d times we ran out of TX space and stalled\\n\", \n\t\t\t\t\t\t\tsc->txoutspace);\n      printf(\"    %d times we ran out of DTQs\\n\", sc->txdtqout);\n      printf(\"    %d times we launched a packet\\n\", sc->launch);\n      printf(\"    %d times we launched without on-board header\\n\", sc->lheader);\n      printf(\"    %d times we launched without on-board tail\\n\", sc->ltail);\n      printf(\"    %d times we pulled the hw service list\\n\", sc->hwpull);\n      printf(\"    %d times we pushed a vci on the sw service list\\n\", \n\t\t\t\t\t\t\t\tsc->swadd);\n      printf(\"    %d times RX pulled an mbuf from Q that wasn't ours\\n\", \n\t\t\t\t\t\t\t sc->rxqnotus);\n      printf(\"    %d times RX pulled a good mbuf from Q\\n\", sc->rxqus);\n      printf(\"    %d times we ran out of mbufs *and* DRQs\\n\", sc->rxoutboth);\n      printf(\"    %d times we ran out of DRQs\\n\", sc->rxdrqout);\n\n      printf(\"    %d trasmit packets dropped due to mbsize\\n\", sc->txmbovr);\n      printf(\"    %d cells trashed due to turned off rxvc\\n\", sc->vtrash);\n      printf(\"    %d cells trashed due to totally full buffer\\n\", sc->otrash);\n      printf(\"    %d cells trashed due almost full buffer\\n\", sc->ttrash);\n      printf(\"    %d rx mbuf allocation failures\\n\", sc->rxmbufout);\n#ifdef NATM\n      printf(\"    %d drops at natmintrq\\n\", natmintrq.ifq_drops);\n#ifdef NATM_STAT\n      printf(\"    natmintr so_rcv: ok/drop cnt: %d/%d, ok/drop bytes: %d/%d\\n\",\n\tnatm_sookcnt, natm_sodropcnt, natm_sookbytes, natm_sodropbytes);\n#endif\n#endif\n    }\n\n    if (level & END_MREGS) {\n      printf(\"mregs:\\n\");\n      printf(\"resid = 0x%x\\n\", EN_READ(sc, MID_RESID));\n      printf(\"interrupt status = 0x%b\\n\", \n\t\t\t\tEN_READ(sc, MID_INTSTAT), MID_INTBITS);\n      printf(\"interrupt enable = 0x%b\\n\", \n\t\t\t\tEN_READ(sc, MID_INTENA), MID_INTBITS);\n      printf(\"mcsr = 0x%b\\n\", EN_READ(sc, MID_MAST_CSR), MID_MCSRBITS);\n      printf(\"serv_write = [chip=%d] [us=%d]\\n\", EN_READ(sc, MID_SERV_WRITE),\n\t\t\tMID_SL_A2REG(sc->hwslistp));\n      printf(\"dma addr = 0x%x\\n\", EN_READ(sc, MID_DMA_ADDR));\n      printf(\"DRQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\\n\",\n\tMID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX)), \n\tMID_DRQ_REG2A(EN_READ(sc, MID_DMA_WRRX)), sc->drq_chip, sc->drq_us);\n      printf(\"DTQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\\n\",\n\tMID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX)), \n\tMID_DTQ_REG2A(EN_READ(sc, MID_DMA_WRTX)), sc->dtq_chip, sc->dtq_us);\n\n      printf(\"  unusal txspeeds: \");\n      for (cnt = 0 ; cnt < MID_N_VC ; cnt++)\n\tif (sc->txspeed[cnt])\n\t  printf(\" vci%d=0x%x\", cnt, sc->txspeed[cnt]);\n      printf(\"\\n\");\n\n      printf(\"  rxvc slot mappings: \");\n      for (cnt = 0 ; cnt < MID_N_VC ; cnt++)\n\tif (sc->rxvc2slot[cnt] != RX_NONE)\n\t  printf(\"  %d->%d\", cnt, sc->rxvc2slot[cnt]);\n      printf(\"\\n\");\n\n    }\n\n    if (level & END_TX) {\n      printf(\"tx:\\n\");\n      for (slot = 0 ; slot < EN_NTX; slot++) {\n\tprintf(\"tx%d: start/stop/cur=0x%x/0x%x/0x%x [%d]  \", slot,\n\t  sc->txslot[slot].start, sc->txslot[slot].stop, sc->txslot[slot].cur,\n\t\t(sc->txslot[slot].cur - sc->txslot[slot].start)/4);\n\tprintf(\"mbsize=%d, bfree=%d\\n\", sc->txslot[slot].mbsize,\n\t\tsc->txslot[slot].bfree);\n        printf(\"txhw: base_address=0x%x, size=%d, read=%d, descstart=%d\\n\",\n\t  MIDX_BASE(EN_READ(sc, MIDX_PLACE(slot))), \n\t  MIDX_SZ(EN_READ(sc, MIDX_PLACE(slot))),\n\t  EN_READ(sc, MIDX_READPTR(slot)), EN_READ(sc, MIDX_DESCSTART(slot)));\n      }\n    }\n\n    if (level & END_RX) {\n      printf(\"  recv slots:\\n\");\n      for (slot = 0 ; slot < sc->en_nrx; slot++) {\n\tprintf(\"rx%d: vci=%d: start/stop/cur=0x%x/0x%x/0x%x \", slot,\n\t  sc->rxslot[slot].atm_vci, sc->rxslot[slot].start, \n\t  sc->rxslot[slot].stop, sc->rxslot[slot].cur);\n\tprintf(\"mode=0x%x, atm_flags=0x%x, oth_flags=0x%x\\n\", \n\tsc->rxslot[slot].mode, sc->rxslot[slot].atm_flags, \n\t\tsc->rxslot[slot].oth_flags);\n        printf(\"RXHW: mode=0x%x, DST_RP=0x%x, WP_ST_CNT=0x%x\\n\",\n\t  EN_READ(sc, MID_VC(sc->rxslot[slot].atm_vci)),\n\t  EN_READ(sc, MID_DST_RP(sc->rxslot[slot].atm_vci)),\n\t  EN_READ(sc, MID_WP_ST_CNT(sc->rxslot[slot].atm_vci)));\n      }\n    }\n\n    if (level & END_DTQ) {\n      printf(\"  dtq [need_dtqs=%d,dtq_free=%d]:\\n\", \n\t\t\t\t\tsc->need_dtqs, sc->dtq_free);\n      ptr = sc->dtq_chip;\n      while (ptr != sc->dtq_us) {\n        reg = EN_READ(sc, ptr);\n        printf(\"\\t0x%x=[cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\\n\", \n\t    sc->dtq[MID_DTQ_A2REG(ptr)], MID_DMA_CNT(reg), MID_DMA_TXCHAN(reg),\n\t    (reg & MID_DMA_END) != 0, MID_DMA_TYPE(reg), EN_READ(sc, ptr+4));\n        EN_WRAPADD(MID_DTQOFF, MID_DTQEND, ptr, 8);\n      }\n    }\n\n    if (level & END_DRQ) {\n      printf(\"  drq [need_drqs=%d,drq_free=%d]:\\n\", \n\t\t\t\t\tsc->need_drqs, sc->drq_free);\n      ptr = sc->drq_chip;\n      while (ptr != sc->drq_us) {\n        reg = EN_READ(sc, ptr);\n\tprintf(\"\\t0x%x=[cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\\n\", \n\t  sc->drq[MID_DRQ_A2REG(ptr)], MID_DMA_CNT(reg), MID_DMA_RXVCI(reg),\n\t  (reg & MID_DMA_END) != 0, MID_DMA_TYPE(reg), EN_READ(sc, ptr+4));\n\tEN_WRAPADD(MID_DRQOFF, MID_DRQEND, ptr, 8);\n      }\n    }\n\n    if (level & END_SWSL) {\n      printf(\" swslist [size=%d]: \", sc->swsl_size);\n      for (cnt = sc->swsl_head ; cnt != sc->swsl_tail ; \n\t\t\tcnt = (cnt + 1) % MID_SL_N)\n        printf(\"0x%x \", sc->swslist[cnt]);\n      printf(\"\\n\");\n    }\n\n  }\n  return(0);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define END_BITS \"\\20\\7SWSL\\6DRQ\\5DTQ\\4RX\\3TX\\2MREGS\\1STATS\"",
      "#define END_STATS\t0x00000001\t\t/* dump stats */",
      "#define END_MREGS\t0x00000002\t\t/* registers */",
      "#define END_TX\t\t0x00000004\t\t/* tx state */",
      "#define END_RX\t\t0x00000008\t\t/* rx state */",
      "#define END_DTQ\t\t0x00000010\t\t/* dtq state */",
      "#define END_DRQ\t\t0x00000020\t\t/* drq state */",
      "#define END_SWSL\t0x00000040\t\t/* swsl state */",
      "#define RX_NONE\t\t0xffff\t/* recv VC not in use */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "MID_DRQOFF",
            "MID_DRQEND",
            "ptr",
            "8"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "ptr+4"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DMA_TYPE",
          "args": [
            "reg"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DMA_RXVCI",
          "args": [
            "reg"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DMA_CNT",
          "args": [
            "reg"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_A2REG",
          "args": [
            "ptr"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "ptr"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "MID_DTQOFF",
            "MID_DTQEND",
            "ptr",
            "8"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "ptr+4"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DMA_TYPE",
          "args": [
            "reg"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DMA_TXCHAN",
          "args": [
            "reg"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DMA_CNT",
          "args": [
            "reg"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_A2REG",
          "args": [
            "ptr"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "ptr"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_WP_ST_CNT(sc->rxslot[slot].atm_vci)"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_WP_ST_CNT",
          "args": [
            "sc->rxslot[slot].atm_vci"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DST_RP(sc->rxslot[slot].atm_vci)"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DST_RP",
          "args": [
            "sc->rxslot[slot].atm_vci"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_VC(sc->rxslot[slot].atm_vci)"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "sc->rxslot[slot].atm_vci"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_DESCSTART(slot)"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_DESCSTART",
          "args": [
            "slot"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_READPTR(slot)"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_READPTR",
          "args": [
            "slot"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_SZ",
          "args": [
            "EN_READ(sc, MIDX_PLACE(slot))"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_PLACE(slot)"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_PLACE",
          "args": [
            "slot"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_BASE",
          "args": [
            "EN_READ(sc, MIDX_PLACE(slot))"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_PLACE(slot)"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_PLACE",
          "args": [
            "slot"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_WRTX)"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_WRTX"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_RDTX)"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDTX"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_WRRX)"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_WRRX"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_RDRX)"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDRX"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_ADDR"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_SL_A2REG",
          "args": [
            "sc->hwslistp"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_SERV_WRITE"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_MAST_CSR"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_INTENA"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_INTSTAT"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_RESID"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define END_BITS \"\\20\\7SWSL\\6DRQ\\5DTQ\\4RX\\3TX\\2MREGS\\1STATS\"\n#define END_STATS\t0x00000001\t\t/* dump stats */\n#define END_MREGS\t0x00000002\t\t/* registers */\n#define END_TX\t\t0x00000004\t\t/* tx state */\n#define END_RX\t\t0x00000008\t\t/* rx state */\n#define END_DTQ\t\t0x00000010\t\t/* dtq state */\n#define END_DRQ\t\t0x00000020\t\t/* drq state */\n#define END_SWSL\t0x00000040\t\t/* swsl state */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n\nint en_dump(unit, level)\n\nint unit, level;\n\n{\n  struct en_softc *sc;\n  int lcv, cnt, slot;\n  u_int32_t ptr, reg;\n\n  for (lcv = 0 ; lcv < en_cd.cd_ndevs ; lcv++) {\n    sc = (struct en_softc *) en_cd.cd_devs[lcv];\n    if (sc == NULL) continue;\n    if (unit != -1 && unit != lcv)\n      continue;\n\n    printf(\"dumping device %s at level 0x%b\\n\", sc->sc_dev.dv_xname, level,\n\t\t\tEND_BITS);\n\n    if (sc->dtq_us == 0) {\n      printf(\"<hasn't been en_init'd yet>\\n\");\n      continue;\n    }\n\n    if (level & END_STATS) {\n      printf(\"  en_stats:\\n\");\n      printf(\"    %d mfix (%d failed); %d/%d head/tail byte DMAs, %d flushes\\n\",\n\t   sc->mfix, sc->mfixfail, sc->headbyte, sc->tailbyte, sc->tailflush);\n      printf(\"    %d rx dma overflow interrupts\\n\", sc->dmaovr);\n      printf(\"    %d times we ran out of TX space and stalled\\n\", \n\t\t\t\t\t\t\tsc->txoutspace);\n      printf(\"    %d times we ran out of DTQs\\n\", sc->txdtqout);\n      printf(\"    %d times we launched a packet\\n\", sc->launch);\n      printf(\"    %d times we launched without on-board header\\n\", sc->lheader);\n      printf(\"    %d times we launched without on-board tail\\n\", sc->ltail);\n      printf(\"    %d times we pulled the hw service list\\n\", sc->hwpull);\n      printf(\"    %d times we pushed a vci on the sw service list\\n\", \n\t\t\t\t\t\t\t\tsc->swadd);\n      printf(\"    %d times RX pulled an mbuf from Q that wasn't ours\\n\", \n\t\t\t\t\t\t\t sc->rxqnotus);\n      printf(\"    %d times RX pulled a good mbuf from Q\\n\", sc->rxqus);\n      printf(\"    %d times we ran out of mbufs *and* DRQs\\n\", sc->rxoutboth);\n      printf(\"    %d times we ran out of DRQs\\n\", sc->rxdrqout);\n\n      printf(\"    %d trasmit packets dropped due to mbsize\\n\", sc->txmbovr);\n      printf(\"    %d cells trashed due to turned off rxvc\\n\", sc->vtrash);\n      printf(\"    %d cells trashed due to totally full buffer\\n\", sc->otrash);\n      printf(\"    %d cells trashed due almost full buffer\\n\", sc->ttrash);\n      printf(\"    %d rx mbuf allocation failures\\n\", sc->rxmbufout);\n#ifdef NATM\n      printf(\"    %d drops at natmintrq\\n\", natmintrq.ifq_drops);\n#ifdef NATM_STAT\n      printf(\"    natmintr so_rcv: ok/drop cnt: %d/%d, ok/drop bytes: %d/%d\\n\",\n\tnatm_sookcnt, natm_sodropcnt, natm_sookbytes, natm_sodropbytes);\n#endif\n#endif\n    }\n\n    if (level & END_MREGS) {\n      printf(\"mregs:\\n\");\n      printf(\"resid = 0x%x\\n\", EN_READ(sc, MID_RESID));\n      printf(\"interrupt status = 0x%b\\n\", \n\t\t\t\tEN_READ(sc, MID_INTSTAT), MID_INTBITS);\n      printf(\"interrupt enable = 0x%b\\n\", \n\t\t\t\tEN_READ(sc, MID_INTENA), MID_INTBITS);\n      printf(\"mcsr = 0x%b\\n\", EN_READ(sc, MID_MAST_CSR), MID_MCSRBITS);\n      printf(\"serv_write = [chip=%d] [us=%d]\\n\", EN_READ(sc, MID_SERV_WRITE),\n\t\t\tMID_SL_A2REG(sc->hwslistp));\n      printf(\"dma addr = 0x%x\\n\", EN_READ(sc, MID_DMA_ADDR));\n      printf(\"DRQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\\n\",\n\tMID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX)), \n\tMID_DRQ_REG2A(EN_READ(sc, MID_DMA_WRRX)), sc->drq_chip, sc->drq_us);\n      printf(\"DTQ: chip[rd=0x%x,wr=0x%x], sc[chip=0x%x,us=0x%x]\\n\",\n\tMID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX)), \n\tMID_DTQ_REG2A(EN_READ(sc, MID_DMA_WRTX)), sc->dtq_chip, sc->dtq_us);\n\n      printf(\"  unusal txspeeds: \");\n      for (cnt = 0 ; cnt < MID_N_VC ; cnt++)\n\tif (sc->txspeed[cnt])\n\t  printf(\" vci%d=0x%x\", cnt, sc->txspeed[cnt]);\n      printf(\"\\n\");\n\n      printf(\"  rxvc slot mappings: \");\n      for (cnt = 0 ; cnt < MID_N_VC ; cnt++)\n\tif (sc->rxvc2slot[cnt] != RX_NONE)\n\t  printf(\"  %d->%d\", cnt, sc->rxvc2slot[cnt]);\n      printf(\"\\n\");\n\n    }\n\n    if (level & END_TX) {\n      printf(\"tx:\\n\");\n      for (slot = 0 ; slot < EN_NTX; slot++) {\n\tprintf(\"tx%d: start/stop/cur=0x%x/0x%x/0x%x [%d]  \", slot,\n\t  sc->txslot[slot].start, sc->txslot[slot].stop, sc->txslot[slot].cur,\n\t\t(sc->txslot[slot].cur - sc->txslot[slot].start)/4);\n\tprintf(\"mbsize=%d, bfree=%d\\n\", sc->txslot[slot].mbsize,\n\t\tsc->txslot[slot].bfree);\n        printf(\"txhw: base_address=0x%x, size=%d, read=%d, descstart=%d\\n\",\n\t  MIDX_BASE(EN_READ(sc, MIDX_PLACE(slot))), \n\t  MIDX_SZ(EN_READ(sc, MIDX_PLACE(slot))),\n\t  EN_READ(sc, MIDX_READPTR(slot)), EN_READ(sc, MIDX_DESCSTART(slot)));\n      }\n    }\n\n    if (level & END_RX) {\n      printf(\"  recv slots:\\n\");\n      for (slot = 0 ; slot < sc->en_nrx; slot++) {\n\tprintf(\"rx%d: vci=%d: start/stop/cur=0x%x/0x%x/0x%x \", slot,\n\t  sc->rxslot[slot].atm_vci, sc->rxslot[slot].start, \n\t  sc->rxslot[slot].stop, sc->rxslot[slot].cur);\n\tprintf(\"mode=0x%x, atm_flags=0x%x, oth_flags=0x%x\\n\", \n\tsc->rxslot[slot].mode, sc->rxslot[slot].atm_flags, \n\t\tsc->rxslot[slot].oth_flags);\n        printf(\"RXHW: mode=0x%x, DST_RP=0x%x, WP_ST_CNT=0x%x\\n\",\n\t  EN_READ(sc, MID_VC(sc->rxslot[slot].atm_vci)),\n\t  EN_READ(sc, MID_DST_RP(sc->rxslot[slot].atm_vci)),\n\t  EN_READ(sc, MID_WP_ST_CNT(sc->rxslot[slot].atm_vci)));\n      }\n    }\n\n    if (level & END_DTQ) {\n      printf(\"  dtq [need_dtqs=%d,dtq_free=%d]:\\n\", \n\t\t\t\t\tsc->need_dtqs, sc->dtq_free);\n      ptr = sc->dtq_chip;\n      while (ptr != sc->dtq_us) {\n        reg = EN_READ(sc, ptr);\n        printf(\"\\t0x%x=[cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\\n\", \n\t    sc->dtq[MID_DTQ_A2REG(ptr)], MID_DMA_CNT(reg), MID_DMA_TXCHAN(reg),\n\t    (reg & MID_DMA_END) != 0, MID_DMA_TYPE(reg), EN_READ(sc, ptr+4));\n        EN_WRAPADD(MID_DTQOFF, MID_DTQEND, ptr, 8);\n      }\n    }\n\n    if (level & END_DRQ) {\n      printf(\"  drq [need_drqs=%d,drq_free=%d]:\\n\", \n\t\t\t\t\tsc->need_drqs, sc->drq_free);\n      ptr = sc->drq_chip;\n      while (ptr != sc->drq_us) {\n        reg = EN_READ(sc, ptr);\n\tprintf(\"\\t0x%x=[cnt=%d, chan=%d, end=%d, type=%d @ 0x%x]\\n\", \n\t  sc->drq[MID_DRQ_A2REG(ptr)], MID_DMA_CNT(reg), MID_DMA_RXVCI(reg),\n\t  (reg & MID_DMA_END) != 0, MID_DMA_TYPE(reg), EN_READ(sc, ptr+4));\n\tEN_WRAPADD(MID_DRQOFF, MID_DRQEND, ptr, 8);\n      }\n    }\n\n    if (level & END_SWSL) {\n      printf(\" swslist [size=%d]: \", sc->swsl_size);\n      for (cnt = sc->swsl_head ; cnt != sc->swsl_tail ; \n\t\t\tcnt = (cnt + 1) % MID_SL_N)\n        printf(\"0x%x \", sc->swslist[cnt]);\n      printf(\"\\n\");\n    }\n\n  }\n  return(0);\n}"
  },
  {
    "function_name": "en_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "2584-2974",
    "snippet": "STATIC void en_service(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m, *tmp;\n  u_int32_t cur, dstart, rbd, pdu, *sav, dma, bcode, count, *data, *datastop;\n  u_int32_t start, stop, cnt, needalign;\n  int slot, raw, aal5, llc, vci, fill, mlen, tlen, drqneed, need, needfill, end;\n\n  aal5 = 0;\t\t/* Silence gcc */\nnext_vci:\n  if (sc->swsl_size == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: en_service done\\n\", sc->sc_dev.dv_xname);\n#endif\n    return;\t\t/* >>> exit here if swsl now empty <<< */\n  }\n\n  /*\n   * get slot/vci to service\n   */\n\n  slot = sc->swslist[sc->swsl_head];\n  vci = sc->rxslot[slot].atm_vci;\n#ifdef EN_DIAG\n  if (sc->rxvc2slot[vci] != slot) panic(\"en_service rx slot/vci sync\");\n#endif\n\n  /*\n   * determine our mode and if we've got any work to do\n   */\n\n  raw = sc->rxslot[slot].oth_flags & ENOTHER_RAW;\n  start= sc->rxslot[slot].start;\n  stop= sc->rxslot[slot].stop;\n  cur = sc->rxslot[slot].cur;\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: service vci=%d raw=%d start/stop/cur=0x%x 0x%x 0x%x\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, raw, start, stop, cur);\n#endif\n\nsame_vci:\n  dstart = MIDV_DSTART(EN_READ(sc, MID_DST_RP(vci)));\n  dstart = (dstart * sizeof(u_int32_t)) + start;\n\n  /* check to see if there is any data at all */\n  if (dstart == cur) {\ndefer:\t\t\t\t\t/* defer processing */\n    EN_WRAPADD(0, MID_SL_N, sc->swsl_head, 1); \n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    sc->swsl_size--;\n\t\t\t\t\t/* >>> remove from swslist <<< */\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: remove vci %d from swslist\\n\", \n\t\tsc->sc_dev.dv_xname, slot, vci);\n#endif\n    goto next_vci;\n  }\n\n  /*\n   * figure out how many bytes we need\n   * [mlen = # bytes to go in mbufs, fill = # bytes to dump (MIDDMA_JK)]\n   */\n\n  if (raw) {\n\n    /* raw mode (aka boodi mode) */\n    fill = 0;\n    if (dstart > cur)\n      mlen = dstart - cur;\n    else\n      mlen = (dstart + (EN_RXSZ*1024)) - cur;\n\n    if (mlen < sc->rxslot[slot].raw_threshold)\n      goto defer; \t\t/* too little data to deal with */\n\n  } else {\n\n    /* normal mode */\n    aal5 = (sc->rxslot[slot].atm_flags & ATM_PH_AAL5);\n    llc = (aal5 && (sc->rxslot[slot].atm_flags & ATM_PH_LLCSNAP)) ? 1 : 0;\n    rbd = EN_READ(sc, cur);\n    if (MID_RBD_ID(rbd) != MID_RBD_STDID) \n      panic(\"en_service: id mismatch\");\n\n    if (rbd & MID_RBD_T) {\n      mlen = 0;\t\t\t/* we've got trash */\n      fill = MID_RBD_SIZE;\n      EN_COUNT(sc->ttrash);\n    } else if (!aal5) {\n      mlen = MID_RBD_SIZE + MID_CHDR_SIZE + MID_ATMDATASZ; /* 1 cell (ick!) */\n      fill = 0;\n    } else {\n      tlen = (MID_RBD_CNT(rbd) * MID_ATMDATASZ) + MID_RBD_SIZE;\n      pdu = cur + tlen - MID_PDU_SIZE;\n      if (pdu >= stop)\n\tpdu -= (EN_RXSZ*1024);\n      pdu = EN_READ(sc, pdu);\t/* get PDU in correct byte order */\n      fill = tlen - MID_RBD_SIZE - MID_PDU_LEN(pdu);\n      if (fill < 0 || (rbd & MID_RBD_CRCERR) != 0) {\n        printf(\"%s: %s, dropping frame\\n\", sc->sc_dev.dv_xname,\n\t    (rbd & MID_RBD_CRCERR) ? \"CRC error\" : \"invalid AAL5 PDU length\");\n        printf(\"%s: got %d cells (%d bytes), AAL5 len is %d bytes (pdu=0x%x)\\n\",\n\t  sc->sc_dev.dv_xname, MID_RBD_CNT(rbd), tlen - MID_RBD_SIZE,\n\t\tMID_PDU_LEN(pdu), pdu);\n\tfill = tlen;\n      }\n      mlen = tlen - fill;\n    }\n\n  }\n\n  /*\n   * now allocate mbufs for mlen bytes of data, if out of mbufs, trash all\n   *\n   * notes:\n   *  1. it is possible that we've already allocated an mbuf for this pkt\n   *\t but ran out of DRQs, in which case we saved the allocated mbuf on\n   *\t \"q\".\n   *  2. if we save an mbuf in \"q\" we store the \"cur\" (pointer) in the front \n   *     of the mbuf as an identity (that we can check later), and we also\n   *     store drqneed (so we don't have to recompute it).\n   *  3. after this block of code, if m is still NULL then we ran out of mbufs\n   */\n  \n  m = sc->rxslot[slot].q.ifq_head;\n  drqneed = 1;\n  if (m) {\n    sav = mtod(m, u_int32_t *);\n    if (sav[0] != cur) {\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: q'ed mbuf %p not ours\\n\", \n\t\tsc->sc_dev.dv_xname, slot, m);\n#endif\n      m = NULL;\t\t\t/* wasn't ours */\n      EN_COUNT(sc->rxqnotus);\n    } else {\n      EN_COUNT(sc->rxqus);\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      drqneed = sav[1];\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: recovered q'ed mbuf %p (drqneed=%d)\\n\", \n\tsc->sc_dev.dv_xname, slot, m, drqneed);\n#endif\n    }\n  }\n\n  if (mlen != 0 && m == NULL) {\n    m = en_mget(sc, mlen, &drqneed);\t\t/* allocate! */\n    if (m == NULL) {\n      fill += mlen;\n      mlen = 0;\n      EN_COUNT(sc->rxmbufout);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of mbufs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    }\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: allocate mbuf %p, mlen=%d, drqneed=%d\\n\", \n\tsc->sc_dev.dv_xname, slot, m, mlen, drqneed);\n#endif\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d, mbuf_chain %p, mlen %d, fill %d\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, m, mlen, fill);\n#endif\n\n  /*\n   * now check to see if we've got the DRQs needed.    if we are out of \n   * DRQs we must quit (saving our mbuf, if we've got one).\n   */\n\n  needfill = (fill) ? 1 : 0;\n  if (drqneed + needfill > sc->drq_free) {\n    sc->need_drqs = 1;\t/* flag condition */\n    if (m == NULL) {\n      EN_COUNT(sc->rxoutboth);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of DRQs *and* mbufs!\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n      return;\t\t/* >>> exit here if out of both mbufs and DRQs <<< */\n    }\n    sav = mtod(m, u_int32_t *);\n    sav[0] = cur;\n    sav[1] = drqneed;\n    IF_ENQUEUE(&sc->rxslot[slot].q, m);\n    EN_COUNT(sc->rxdrqout);\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: out of DRQs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    return;\t\t/* >>> exit here if out of DRQs <<< */\n  }\n\n  /*\n   * at this point all resources have been allocated and we are commited \n   * to servicing this slot.\n   *\n   * dma = last location we told chip about\n   * cur = current location\n   * mlen = space in the mbuf we want\n   * need = bytes to xfer in (decrs to zero)\n   * fill = how much fill we need\n   * tlen = how much data to transfer to this mbuf\n   * cnt/bcode/count = <same as xmit>\n   *\n   * 'needfill' not used after this point\n   */\n\n  dma = cur;\t\t/* dma = last location we told chip about */\n  need = roundup(mlen, sizeof(u_int32_t));\n  fill = fill - (need - mlen);  /* note: may invalidate 'needfill' */\n\n  for (tmp = m ; tmp != NULL && need > 0 ; tmp = tmp->m_next) {\n    tlen = roundup(tmp->m_len, sizeof(u_int32_t)); /* m_len set by en_mget */\n    data = mtod(tmp, u_int32_t *);\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: load mbuf %p, m_len=%d, m_data=%p, tlen=%d\\n\",\n\tsc->sc_dev.dv_xname, slot, tmp, tmp->m_len, tmp->m_data, tlen);\n#endif\n    \n    /* copy data */\n    if (EN_NORXDMA || !en_dma || tlen < EN_MINDMA) {\n      datastop = (u_int32_t *)((u_char *) data + tlen);\n      /* copy loop: preserve byte order!!!  use READDAT */\n      while (data != datastop) {\n\t*data = EN_READDAT(sc, cur);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= tlen;\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: copied %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      continue;\n    }\n\n    /* DMA data (check to see if we need to sync DRQ first) */\n    if (dma != cur) {\n      EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: drq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n    }\n\n#if !defined(MIDWAY_ENIONLY)\n     \n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */ \n  \n    if (sc->is_adaptec) {\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: adp_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, tlen, vci, 0, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst &&\n      (needalign = (((unsigned long) data) & sc->bestburstmask)) != 0) {\n      cnt = sc->bestburstlen - needalign;\n      if (cnt > tlen) {\n        cnt = tlen;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: al_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need a max-sized burst? */\n    if (tlen >= sc->bestburstlen) {\n      count = tlen >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: best_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need to do a cleanup burst? */\n    if (tlen) {\n      count = tlen / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = tlen >> en_dmaplan[count].divshift;\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: cleanup_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n\n#endif /* !MIDWAY_ADPONLY */\n\n  }\n\n  /* skip the end */\n  if (fill || dma != cur) {\n#ifdef EN_DEBUG\n      if (fill)\n        printf(\"%s: rx%d: vci%d: skipping %d bytes of fill\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, fill);\n      else\n        printf(\"%s: rx%d: vci%d: syncing chip from 0x%x to 0x%x [cur]\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, dma, cur);\n#endif\n    EN_WRAPADD(start, stop, cur, fill);\n    EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, mlen,\n\t\t\t\t\tslot, MID_DMA_END);\n    /* dma = cur; */\t/* not necessary since we are done */\n  }\n\n  /*\n   * done, remove stuff we don't want to pass up:\n   *   raw mode (boodi mode): pass everything up for later processing\n   *   aal5: remove RBD\n   *   aal0: remove RBD + cell header\n   */\n\ndone:\n  if (m) {\n    if (!raw) {\n      cnt = MID_RBD_SIZE;\n      if (!aal5) cnt += MID_CHDR_SIZE;\n      m->m_len -= cnt;\t\t\t\t/* chop! */\n      m->m_pkthdr.len -= cnt;\n      m->m_data += cnt;\n    }\n    IF_ENQUEUE(&sc->rxslot[slot].indma, m);\n  }\n  sc->rxslot[slot].cur = cur;\t\t/* update master copy of 'cur' */\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: vci%d: DONE!   cur now =0x%x\\n\", \n\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n\n  goto same_vci;\t/* get next packet in this slot */\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
      "#define ENOTHER_RAW\t0x04\t\t/* 'raw' access  (aka boodi mode) */",
      "#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */",
      "#define STATIC static",
      "#define STATIC /* nothing */",
      "#define EN_DIAG\t\t\t/* link in with master DIAG option */",
      "#define EN_NORXDMA\t0\t/* hook to disable rx dma only */",
      "#define\tEN_DIAG"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx%d: vci%d: DONE!   cur now =0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "slot",
            "vci",
            "cur"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&sc->rxslot[slot].indma",
            "m"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DRQADD",
          "args": [
            "sc",
            "WORD_IDX(start,cur)",
            "vci",
            "MIDDMA_JK",
            "0",
            "mlen",
            "slot",
            "MID_DMA_END"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_IDX",
          "args": [
            "start",
            "cur"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "fill"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DRQADD",
          "args": [
            "sc",
            "count",
            "vci",
            "bcode",
            "vtophys(data)",
            "mlen",
            "slot",
            "end"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "tlen"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DRQADD",
          "args": [
            "sc",
            "count",
            "vci",
            "bcode",
            "vtophys(data)",
            "mlen",
            "slot",
            "end"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "cnt"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DRQADD",
          "args": [
            "sc",
            "count",
            "vci",
            "bcode",
            "vtophys(data)",
            "mlen",
            "slot",
            "end"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "cnt"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DRQADD",
          "args": [
            "sc",
            "tlen",
            "vci",
            "0",
            "vtophys(data)",
            "mlen",
            "slot",
            "end"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "tlen"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DRQADD",
          "args": [
            "sc",
            "WORD_IDX(start,cur)",
            "vci",
            "MIDDMA_JK",
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_IDX",
          "args": [
            "start",
            "cur"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "4"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READDAT",
          "args": [
            "sc",
            "cur"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "tmp",
            "u_int32_t*"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "tmp->m_len",
            "sizeof(u_int32_t)"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "mlen",
            "sizeof(u_int32_t)"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->rxdrqout"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&sc->rxslot[slot].q",
            "m"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int32_t*"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->rxoutboth"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->rxmbufout"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_mget",
          "args": [
            "sc",
            "mlen",
            "&drqneed"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->rxslot[slot].q",
            "m"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->rxqus"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->rxqnotus"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int32_t*"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_PDU_LEN",
          "args": [
            "pdu"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_RBD_CNT",
          "args": [
            "rbd"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_PDU_LEN",
          "args": [
            "pdu"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "pdu"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_RBD_CNT",
          "args": [
            "rbd"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->ttrash"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_service: id mismatch\""
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_RBD_ID",
          "args": [
            "rbd"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "cur"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "0",
            "MID_SL_N",
            "sc->swsl_head",
            "1"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDV_DSTART",
          "args": [
            "EN_READ(sc, MID_DST_RP(vci))"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DST_RP(vci)"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DST_RP",
          "args": [
            "vci"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_service rx slot/vci sync\""
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_RAW\t0x04\t\t/* 'raw' access  (aka boodi mode) */\n#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_DIAG\t\t\t/* link in with master DIAG option */\n#define EN_NORXDMA\t0\t/* hook to disable rx dma only */\n#define\tEN_DIAG\n\nSTATIC void en_service(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m, *tmp;\n  u_int32_t cur, dstart, rbd, pdu, *sav, dma, bcode, count, *data, *datastop;\n  u_int32_t start, stop, cnt, needalign;\n  int slot, raw, aal5, llc, vci, fill, mlen, tlen, drqneed, need, needfill, end;\n\n  aal5 = 0;\t\t/* Silence gcc */\nnext_vci:\n  if (sc->swsl_size == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: en_service done\\n\", sc->sc_dev.dv_xname);\n#endif\n    return;\t\t/* >>> exit here if swsl now empty <<< */\n  }\n\n  /*\n   * get slot/vci to service\n   */\n\n  slot = sc->swslist[sc->swsl_head];\n  vci = sc->rxslot[slot].atm_vci;\n#ifdef EN_DIAG\n  if (sc->rxvc2slot[vci] != slot) panic(\"en_service rx slot/vci sync\");\n#endif\n\n  /*\n   * determine our mode and if we've got any work to do\n   */\n\n  raw = sc->rxslot[slot].oth_flags & ENOTHER_RAW;\n  start= sc->rxslot[slot].start;\n  stop= sc->rxslot[slot].stop;\n  cur = sc->rxslot[slot].cur;\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: service vci=%d raw=%d start/stop/cur=0x%x 0x%x 0x%x\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, raw, start, stop, cur);\n#endif\n\nsame_vci:\n  dstart = MIDV_DSTART(EN_READ(sc, MID_DST_RP(vci)));\n  dstart = (dstart * sizeof(u_int32_t)) + start;\n\n  /* check to see if there is any data at all */\n  if (dstart == cur) {\ndefer:\t\t\t\t\t/* defer processing */\n    EN_WRAPADD(0, MID_SL_N, sc->swsl_head, 1); \n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    sc->swsl_size--;\n\t\t\t\t\t/* >>> remove from swslist <<< */\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: remove vci %d from swslist\\n\", \n\t\tsc->sc_dev.dv_xname, slot, vci);\n#endif\n    goto next_vci;\n  }\n\n  /*\n   * figure out how many bytes we need\n   * [mlen = # bytes to go in mbufs, fill = # bytes to dump (MIDDMA_JK)]\n   */\n\n  if (raw) {\n\n    /* raw mode (aka boodi mode) */\n    fill = 0;\n    if (dstart > cur)\n      mlen = dstart - cur;\n    else\n      mlen = (dstart + (EN_RXSZ*1024)) - cur;\n\n    if (mlen < sc->rxslot[slot].raw_threshold)\n      goto defer; \t\t/* too little data to deal with */\n\n  } else {\n\n    /* normal mode */\n    aal5 = (sc->rxslot[slot].atm_flags & ATM_PH_AAL5);\n    llc = (aal5 && (sc->rxslot[slot].atm_flags & ATM_PH_LLCSNAP)) ? 1 : 0;\n    rbd = EN_READ(sc, cur);\n    if (MID_RBD_ID(rbd) != MID_RBD_STDID) \n      panic(\"en_service: id mismatch\");\n\n    if (rbd & MID_RBD_T) {\n      mlen = 0;\t\t\t/* we've got trash */\n      fill = MID_RBD_SIZE;\n      EN_COUNT(sc->ttrash);\n    } else if (!aal5) {\n      mlen = MID_RBD_SIZE + MID_CHDR_SIZE + MID_ATMDATASZ; /* 1 cell (ick!) */\n      fill = 0;\n    } else {\n      tlen = (MID_RBD_CNT(rbd) * MID_ATMDATASZ) + MID_RBD_SIZE;\n      pdu = cur + tlen - MID_PDU_SIZE;\n      if (pdu >= stop)\n\tpdu -= (EN_RXSZ*1024);\n      pdu = EN_READ(sc, pdu);\t/* get PDU in correct byte order */\n      fill = tlen - MID_RBD_SIZE - MID_PDU_LEN(pdu);\n      if (fill < 0 || (rbd & MID_RBD_CRCERR) != 0) {\n        printf(\"%s: %s, dropping frame\\n\", sc->sc_dev.dv_xname,\n\t    (rbd & MID_RBD_CRCERR) ? \"CRC error\" : \"invalid AAL5 PDU length\");\n        printf(\"%s: got %d cells (%d bytes), AAL5 len is %d bytes (pdu=0x%x)\\n\",\n\t  sc->sc_dev.dv_xname, MID_RBD_CNT(rbd), tlen - MID_RBD_SIZE,\n\t\tMID_PDU_LEN(pdu), pdu);\n\tfill = tlen;\n      }\n      mlen = tlen - fill;\n    }\n\n  }\n\n  /*\n   * now allocate mbufs for mlen bytes of data, if out of mbufs, trash all\n   *\n   * notes:\n   *  1. it is possible that we've already allocated an mbuf for this pkt\n   *\t but ran out of DRQs, in which case we saved the allocated mbuf on\n   *\t \"q\".\n   *  2. if we save an mbuf in \"q\" we store the \"cur\" (pointer) in the front \n   *     of the mbuf as an identity (that we can check later), and we also\n   *     store drqneed (so we don't have to recompute it).\n   *  3. after this block of code, if m is still NULL then we ran out of mbufs\n   */\n  \n  m = sc->rxslot[slot].q.ifq_head;\n  drqneed = 1;\n  if (m) {\n    sav = mtod(m, u_int32_t *);\n    if (sav[0] != cur) {\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: q'ed mbuf %p not ours\\n\", \n\t\tsc->sc_dev.dv_xname, slot, m);\n#endif\n      m = NULL;\t\t\t/* wasn't ours */\n      EN_COUNT(sc->rxqnotus);\n    } else {\n      EN_COUNT(sc->rxqus);\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      drqneed = sav[1];\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: recovered q'ed mbuf %p (drqneed=%d)\\n\", \n\tsc->sc_dev.dv_xname, slot, m, drqneed);\n#endif\n    }\n  }\n\n  if (mlen != 0 && m == NULL) {\n    m = en_mget(sc, mlen, &drqneed);\t\t/* allocate! */\n    if (m == NULL) {\n      fill += mlen;\n      mlen = 0;\n      EN_COUNT(sc->rxmbufout);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of mbufs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    }\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: allocate mbuf %p, mlen=%d, drqneed=%d\\n\", \n\tsc->sc_dev.dv_xname, slot, m, mlen, drqneed);\n#endif\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d, mbuf_chain %p, mlen %d, fill %d\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, m, mlen, fill);\n#endif\n\n  /*\n   * now check to see if we've got the DRQs needed.    if we are out of \n   * DRQs we must quit (saving our mbuf, if we've got one).\n   */\n\n  needfill = (fill) ? 1 : 0;\n  if (drqneed + needfill > sc->drq_free) {\n    sc->need_drqs = 1;\t/* flag condition */\n    if (m == NULL) {\n      EN_COUNT(sc->rxoutboth);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of DRQs *and* mbufs!\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n      return;\t\t/* >>> exit here if out of both mbufs and DRQs <<< */\n    }\n    sav = mtod(m, u_int32_t *);\n    sav[0] = cur;\n    sav[1] = drqneed;\n    IF_ENQUEUE(&sc->rxslot[slot].q, m);\n    EN_COUNT(sc->rxdrqout);\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: out of DRQs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    return;\t\t/* >>> exit here if out of DRQs <<< */\n  }\n\n  /*\n   * at this point all resources have been allocated and we are commited \n   * to servicing this slot.\n   *\n   * dma = last location we told chip about\n   * cur = current location\n   * mlen = space in the mbuf we want\n   * need = bytes to xfer in (decrs to zero)\n   * fill = how much fill we need\n   * tlen = how much data to transfer to this mbuf\n   * cnt/bcode/count = <same as xmit>\n   *\n   * 'needfill' not used after this point\n   */\n\n  dma = cur;\t\t/* dma = last location we told chip about */\n  need = roundup(mlen, sizeof(u_int32_t));\n  fill = fill - (need - mlen);  /* note: may invalidate 'needfill' */\n\n  for (tmp = m ; tmp != NULL && need > 0 ; tmp = tmp->m_next) {\n    tlen = roundup(tmp->m_len, sizeof(u_int32_t)); /* m_len set by en_mget */\n    data = mtod(tmp, u_int32_t *);\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: load mbuf %p, m_len=%d, m_data=%p, tlen=%d\\n\",\n\tsc->sc_dev.dv_xname, slot, tmp, tmp->m_len, tmp->m_data, tlen);\n#endif\n    \n    /* copy data */\n    if (EN_NORXDMA || !en_dma || tlen < EN_MINDMA) {\n      datastop = (u_int32_t *)((u_char *) data + tlen);\n      /* copy loop: preserve byte order!!!  use READDAT */\n      while (data != datastop) {\n\t*data = EN_READDAT(sc, cur);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= tlen;\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: copied %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      continue;\n    }\n\n    /* DMA data (check to see if we need to sync DRQ first) */\n    if (dma != cur) {\n      EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: drq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n    }\n\n#if !defined(MIDWAY_ENIONLY)\n     \n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */ \n  \n    if (sc->is_adaptec) {\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: adp_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, tlen, vci, 0, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst &&\n      (needalign = (((unsigned long) data) & sc->bestburstmask)) != 0) {\n      cnt = sc->bestburstlen - needalign;\n      if (cnt > tlen) {\n        cnt = tlen;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: al_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need a max-sized burst? */\n    if (tlen >= sc->bestburstlen) {\n      count = tlen >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: best_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need to do a cleanup burst? */\n    if (tlen) {\n      count = tlen / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = tlen >> en_dmaplan[count].divshift;\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: cleanup_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n\n#endif /* !MIDWAY_ADPONLY */\n\n  }\n\n  /* skip the end */\n  if (fill || dma != cur) {\n#ifdef EN_DEBUG\n      if (fill)\n        printf(\"%s: rx%d: vci%d: skipping %d bytes of fill\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, fill);\n      else\n        printf(\"%s: rx%d: vci%d: syncing chip from 0x%x to 0x%x [cur]\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, dma, cur);\n#endif\n    EN_WRAPADD(start, stop, cur, fill);\n    EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, mlen,\n\t\t\t\t\tslot, MID_DMA_END);\n    /* dma = cur; */\t/* not necessary since we are done */\n  }\n\n  /*\n   * done, remove stuff we don't want to pass up:\n   *   raw mode (boodi mode): pass everything up for later processing\n   *   aal5: remove RBD\n   *   aal0: remove RBD + cell header\n   */\n\ndone:\n  if (m) {\n    if (!raw) {\n      cnt = MID_RBD_SIZE;\n      if (!aal5) cnt += MID_CHDR_SIZE;\n      m->m_len -= cnt;\t\t\t\t/* chop! */\n      m->m_pkthdr.len -= cnt;\n      m->m_data += cnt;\n    }\n    IF_ENQUEUE(&sc->rxslot[slot].indma, m);\n  }\n  sc->rxslot[slot].cur = cur;\t\t/* update master copy of 'cur' */\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: vci%d: DONE!   cur now =0x%x\\n\", \n\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n\n  goto same_vci;\t/* get next packet in this slot */\n}"
  },
  {
    "function_name": "en_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "2304-2563",
    "snippet": "EN_INTR_TYPE en_intr(arg)\n\nvoid *arg;\n\n{\n  struct en_softc *sc = (struct en_softc *) arg;\n  struct mbuf *m;\n  struct atm_pseudohdr ah;\n  u_int32_t reg, kick, val, mask, chip, vci, slot, dtq, drq;\n  int lcv, idx, need_softserv = 0;\n\n  reg = EN_READ(sc, MID_INTACK);\n\n  if ((reg & MID_INT_ANY) == 0) \n    EN_INTR_RET(0); /* not us */\n\n#ifdef EN_DEBUG\n  printf(\"%s: interrupt=0x%b\\n\", sc->sc_dev.dv_xname, reg, MID_INTBITS);\n#endif\n\n  /*\n   * unexpected errors that need a reset\n   */\n\n  if ((reg & (MID_INT_IDENT|MID_INT_LERR|MID_INT_DMA_ERR|MID_INT_SUNI)) != 0) {\n    printf(\"%s: unexpected interrupt=0x%b, resetting card\\n\", \n\tsc->sc_dev.dv_xname, reg, MID_INTBITS);\n#ifdef EN_DEBUG\n#ifdef DDB\n    Debugger();\n#endif\t/* DDB */\n    sc->enif.if_flags &= ~IFF_RUNNING; /* FREEZE! */\n#else\n    en_reset(sc);\n    en_init(sc);\n#endif\n    EN_INTR_RET(1); /* for us */\n  }\n\n  /*******************\n   * xmit interrupts *\n   ******************/\n\n  kick = 0;\t\t\t\t/* bitmask of channels to kick */\n  if (reg & MID_INT_TX) {\t\t/* TX done! */\n\n    /*\n     * check for tx complete, if detected then this means that some space\n     * has come free on the card.   we must account for it and arrange to\n     * kick the channel to life (in case it is stalled waiting on the card).\n     */\n    for (mask = 1, lcv = 0 ; lcv < EN_NTX ; lcv++, mask = mask * 2) {\n      if (reg & MID_TXCHAN(lcv)) {\n\tkick = kick | mask;\t/* want to kick later */\n\tval = EN_READ(sc, MIDX_READPTR(lcv));\t/* current read pointer */\n\tval = (val * sizeof(u_int32_t)) + sc->txslot[lcv].start;\n\t\t\t\t\t\t/* convert to offset */\n\tif (val > sc->txslot[lcv].cur)\n\t  sc->txslot[lcv].bfree = val - sc->txslot[lcv].cur;\n\telse\n\t  sc->txslot[lcv].bfree = (val + (EN_TXSZ*1024)) - sc->txslot[lcv].cur;\n#ifdef EN_DEBUG\n\tprintf(\"%s: tx%d: trasmit done.   %d bytes now free in buffer\\n\",\n\t\tsc->sc_dev.dv_xname, lcv, sc->txslot[lcv].bfree);\n#endif\n      }\n    }\n  }\n\n  if (reg & MID_INT_DMA_TX) {\t\t/* TX DMA done! */\n\n  /*\n   * check for TX DMA complete, if detected then this means that some DTQs\n   * are now free.   it also means some indma mbufs can be freed.\n   * if we needed DTQs, kick all channels.\n   */\n    val = EN_READ(sc, MID_DMA_RDTX);\t/* chip's current location */\n    idx = MID_DTQ_A2REG(sc->dtq_chip);/* where we last saw chip */\n    if (sc->need_dtqs) {\n      kick = MID_NTX_CH - 1;\t\t/* assume power of 2, kick all! */\n      sc->need_dtqs = 0;\t\t/* recalculated in \"kick\" loop below */\n#ifdef EN_DEBUG\n      printf(\"%s: cleared need DTQ condition\\n\", sc->sc_dev.dv_xname);\n#endif\n    }\n    while (idx != val) {\n      sc->dtq_free++;\n      if ((dtq = sc->dtq[idx]) != 0) {\n        sc->dtq[idx] = 0;\t/* don't forget to zero it out when done */\n\tslot = EN_DQ_SLOT(dtq);\n\tIF_DEQUEUE(&sc->txslot[slot].indma, m);\n\tif (!m) panic(\"enintr: dtqsync\");\n\tsc->txslot[slot].mbsize -= EN_DQ_LEN(dtq);\n#ifdef EN_DEBUG\n\tprintf(\"%s: tx%d: free %d dma bytes, mbsize now %d\\n\",\n\t\tsc->sc_dev.dv_xname, slot, EN_DQ_LEN(dtq), \n\t\tsc->txslot[slot].mbsize);\n#endif\n\tm_freem(m);\n      }\n      EN_WRAPADD(0, MID_DTQ_N, idx, 1);\n    }\n    sc->dtq_chip = MID_DTQ_REG2A(val);\t/* sync softc */\n  }\n\n\n  /*\n   * kick xmit channels as needed\n   */\n\n  if (kick) {\n#ifdef EN_DEBUG\n  printf(\"%s: tx kick mask = 0x%x\\n\", sc->sc_dev.dv_xname, kick);\n#endif\n    for (mask = 1, lcv = 0 ; lcv < EN_NTX ; lcv++, mask = mask * 2) {\n      if ((kick & mask) && sc->txslot[lcv].q.ifq_head) {\n\ten_txdma(sc, lcv);\t\t/* kick it! */\n      }\n    }\t\t/* for each slot */\n  }\t\t/* if kick */\n\n\n  /*******************\n   * recv interrupts *\n   ******************/\n\n  /*\n   * check for RX DMA complete, and pass the data \"upstairs\"\n   */\n\n  if (reg & MID_INT_DMA_RX) {\n    val = EN_READ(sc, MID_DMA_RDRX); /* chip's current location */\n    idx = MID_DRQ_A2REG(sc->drq_chip);/* where we last saw chip */\n    while (idx != val) {\n      sc->drq_free++;\n      if ((drq = sc->drq[idx]) != 0) {\n        sc->drq[idx] = 0;\t/* don't forget to zero it out when done */\n\tslot = EN_DQ_SLOT(drq);\n        if (EN_DQ_LEN(drq) == 0) {  /* \"JK\" trash DMA? */\n          m = NULL;\n        } else {\n\t  IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n\t  if (!m) {\n\t    panic(\"enintr: drqsync: %s: lost mbuf in slot %d!\",\n\t\tsc->sc_dev.dv_xname, slot);\n\t  }\n        }\n\t/* do something with this mbuf */\n\tif (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {  /* drain? */\n          if (m)\n\t    m_freem(m);\n\t  vci = sc->rxslot[slot].atm_vci;\n\t  if (sc->rxslot[slot].indma.ifq_head == NULL &&\n\t\tsc->rxslot[slot].q.ifq_head == NULL &&\n\t\t(EN_READ(sc, MID_VC(vci)) & MIDV_INSERVICE) == 0 &&\n\t\t(sc->rxslot[slot].oth_flags & ENOTHER_SWSL) == 0) {\n\t    sc->rxslot[slot].oth_flags = ENOTHER_FREE; /* done drain */\n\t    sc->rxslot[slot].atm_vci = RX_NONE;\n\t    sc->rxvc2slot[vci] = RX_NONE;\n#ifdef EN_DEBUG\n\t    printf(\"%s: rx%d: VCI %d now free\\n\", sc->sc_dev.dv_xname,\n\t\t\tslot, vci);\n#endif\n\t  }\n\t} else if (m != NULL) {\n\t  ATM_PH_FLAGS(&ah) = sc->rxslot[slot].atm_flags;\n\t  ATM_PH_VPI(&ah) = 0;\n\t  ATM_PH_SETVCI(&ah, sc->rxslot[slot].atm_vci);\n#ifdef EN_DEBUG\n\t  printf(\"%s: rx%d: rxvci%d: atm_input, mbuf %p, len %d, hand %p\\n\",\n\t\tsc->sc_dev.dv_xname, slot, sc->rxslot[slot].atm_vci, m,\n\t\tEN_DQ_LEN(drq), sc->rxslot[slot].rxhand);\n#endif\n\t  sc->enif.if_ipackets++;\n\n\t  atm_input(&sc->enif, &ah, m, sc->rxslot[slot].rxhand);\n\t}\n\n      }\n      EN_WRAPADD(0, MID_DRQ_N, idx, 1);\n    }\n    sc->drq_chip = MID_DRQ_REG2A(val);\t/* sync softc */\n\n    if (sc->need_drqs) {\t/* true if we had a DRQ shortage */\n      need_softserv = 1;\n      sc->need_drqs = 0;\n#ifdef EN_DEBUG\n\tprintf(\"%s: cleared need DRQ condition\\n\", sc->sc_dev.dv_xname);\n#endif\n    }\n  }\n\n  /*\n   * handle service interrupts\n   */\n\n  if (reg & MID_INT_SERVICE) {\n    chip = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n\n    while (sc->hwslistp != chip) {\n\n      /* fetch and remove it from hardware service list */\n      vci = EN_READ(sc, sc->hwslistp);\n      EN_WRAPADD(MID_SLOFF, MID_SLEND, sc->hwslistp, 4);/* advance hw ptr */\n      slot = sc->rxvc2slot[vci];\n      if (slot == RX_NONE) {\n#ifdef EN_DEBUG\n\tprintf(\"%s: unexpected rx interrupt on VCI %d\\n\", \n\t\tsc->sc_dev.dv_xname, vci);\n#endif\n\tEN_WRITE(sc, MID_VC(vci), MIDV_TRASH);  /* rx off, damn it! */\n\tcontinue;\t\t\t\t/* next */\n      }\n      EN_WRITE(sc, MID_VC(vci), sc->rxslot[slot].mode); /* remove from hwsl */\n      EN_COUNT(sc->hwpull);\n\n#ifdef EN_DEBUG\n      printf(\"%s: pulled VCI %d off hwslist\\n\", sc->sc_dev.dv_xname, vci);\n#endif\n\n      /* add it to the software service list (if needed) */\n      if ((sc->rxslot[slot].oth_flags & ENOTHER_SWSL) == 0) {\n\tEN_COUNT(sc->swadd);\n\tneed_softserv = 1;\n\tsc->rxslot[slot].oth_flags |= ENOTHER_SWSL;\n\tsc->swslist[sc->swsl_tail] = slot;\n\tEN_WRAPADD(0, MID_SL_N, sc->swsl_tail, 1);\n\tsc->swsl_size++;\n#ifdef EN_DEBUG\n      printf(\"%s: added VCI %d to swslist\\n\", sc->sc_dev.dv_xname, vci);\n#endif\n      }\n    }\n  }\n\n  /*\n   * now service (function too big to include here)\n   */\n\n  if (need_softserv)\n    en_service(sc);\n\n  /*\n   * keep our stats\n   */\n\n  if (reg & MID_INT_DMA_OVR) {\n    EN_COUNT(sc->dmaovr);\n#ifdef EN_DEBUG\n    printf(\"%s: MID_INT_DMA_OVR\\n\", sc->sc_dev.dv_xname);\n#endif\n  }\n  reg = EN_READ(sc, MID_STAT);\n#ifdef EN_STAT\n  sc->otrash += MID_OTRASH(reg);\n  sc->vtrash += MID_VTRASH(reg);\n#endif\n\n  EN_INTR_RET(1); /* for us */\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
      "#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */",
      "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
      "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
      "#define\tEN_STAT"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EN_INTR_RET",
          "args": [
            "1"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VTRASH",
          "args": [
            "reg"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_OTRASH",
          "args": [
            "reg"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_STAT"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: MID_INT_DMA_OVR\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->dmaovr"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_service",
          "args": [
            "sc"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "en_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "2584-2974",
          "snippet": "STATIC void en_service(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m, *tmp;\n  u_int32_t cur, dstart, rbd, pdu, *sav, dma, bcode, count, *data, *datastop;\n  u_int32_t start, stop, cnt, needalign;\n  int slot, raw, aal5, llc, vci, fill, mlen, tlen, drqneed, need, needfill, end;\n\n  aal5 = 0;\t\t/* Silence gcc */\nnext_vci:\n  if (sc->swsl_size == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: en_service done\\n\", sc->sc_dev.dv_xname);\n#endif\n    return;\t\t/* >>> exit here if swsl now empty <<< */\n  }\n\n  /*\n   * get slot/vci to service\n   */\n\n  slot = sc->swslist[sc->swsl_head];\n  vci = sc->rxslot[slot].atm_vci;\n#ifdef EN_DIAG\n  if (sc->rxvc2slot[vci] != slot) panic(\"en_service rx slot/vci sync\");\n#endif\n\n  /*\n   * determine our mode and if we've got any work to do\n   */\n\n  raw = sc->rxslot[slot].oth_flags & ENOTHER_RAW;\n  start= sc->rxslot[slot].start;\n  stop= sc->rxslot[slot].stop;\n  cur = sc->rxslot[slot].cur;\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: service vci=%d raw=%d start/stop/cur=0x%x 0x%x 0x%x\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, raw, start, stop, cur);\n#endif\n\nsame_vci:\n  dstart = MIDV_DSTART(EN_READ(sc, MID_DST_RP(vci)));\n  dstart = (dstart * sizeof(u_int32_t)) + start;\n\n  /* check to see if there is any data at all */\n  if (dstart == cur) {\ndefer:\t\t\t\t\t/* defer processing */\n    EN_WRAPADD(0, MID_SL_N, sc->swsl_head, 1); \n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    sc->swsl_size--;\n\t\t\t\t\t/* >>> remove from swslist <<< */\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: remove vci %d from swslist\\n\", \n\t\tsc->sc_dev.dv_xname, slot, vci);\n#endif\n    goto next_vci;\n  }\n\n  /*\n   * figure out how many bytes we need\n   * [mlen = # bytes to go in mbufs, fill = # bytes to dump (MIDDMA_JK)]\n   */\n\n  if (raw) {\n\n    /* raw mode (aka boodi mode) */\n    fill = 0;\n    if (dstart > cur)\n      mlen = dstart - cur;\n    else\n      mlen = (dstart + (EN_RXSZ*1024)) - cur;\n\n    if (mlen < sc->rxslot[slot].raw_threshold)\n      goto defer; \t\t/* too little data to deal with */\n\n  } else {\n\n    /* normal mode */\n    aal5 = (sc->rxslot[slot].atm_flags & ATM_PH_AAL5);\n    llc = (aal5 && (sc->rxslot[slot].atm_flags & ATM_PH_LLCSNAP)) ? 1 : 0;\n    rbd = EN_READ(sc, cur);\n    if (MID_RBD_ID(rbd) != MID_RBD_STDID) \n      panic(\"en_service: id mismatch\");\n\n    if (rbd & MID_RBD_T) {\n      mlen = 0;\t\t\t/* we've got trash */\n      fill = MID_RBD_SIZE;\n      EN_COUNT(sc->ttrash);\n    } else if (!aal5) {\n      mlen = MID_RBD_SIZE + MID_CHDR_SIZE + MID_ATMDATASZ; /* 1 cell (ick!) */\n      fill = 0;\n    } else {\n      tlen = (MID_RBD_CNT(rbd) * MID_ATMDATASZ) + MID_RBD_SIZE;\n      pdu = cur + tlen - MID_PDU_SIZE;\n      if (pdu >= stop)\n\tpdu -= (EN_RXSZ*1024);\n      pdu = EN_READ(sc, pdu);\t/* get PDU in correct byte order */\n      fill = tlen - MID_RBD_SIZE - MID_PDU_LEN(pdu);\n      if (fill < 0 || (rbd & MID_RBD_CRCERR) != 0) {\n        printf(\"%s: %s, dropping frame\\n\", sc->sc_dev.dv_xname,\n\t    (rbd & MID_RBD_CRCERR) ? \"CRC error\" : \"invalid AAL5 PDU length\");\n        printf(\"%s: got %d cells (%d bytes), AAL5 len is %d bytes (pdu=0x%x)\\n\",\n\t  sc->sc_dev.dv_xname, MID_RBD_CNT(rbd), tlen - MID_RBD_SIZE,\n\t\tMID_PDU_LEN(pdu), pdu);\n\tfill = tlen;\n      }\n      mlen = tlen - fill;\n    }\n\n  }\n\n  /*\n   * now allocate mbufs for mlen bytes of data, if out of mbufs, trash all\n   *\n   * notes:\n   *  1. it is possible that we've already allocated an mbuf for this pkt\n   *\t but ran out of DRQs, in which case we saved the allocated mbuf on\n   *\t \"q\".\n   *  2. if we save an mbuf in \"q\" we store the \"cur\" (pointer) in the front \n   *     of the mbuf as an identity (that we can check later), and we also\n   *     store drqneed (so we don't have to recompute it).\n   *  3. after this block of code, if m is still NULL then we ran out of mbufs\n   */\n  \n  m = sc->rxslot[slot].q.ifq_head;\n  drqneed = 1;\n  if (m) {\n    sav = mtod(m, u_int32_t *);\n    if (sav[0] != cur) {\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: q'ed mbuf %p not ours\\n\", \n\t\tsc->sc_dev.dv_xname, slot, m);\n#endif\n      m = NULL;\t\t\t/* wasn't ours */\n      EN_COUNT(sc->rxqnotus);\n    } else {\n      EN_COUNT(sc->rxqus);\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      drqneed = sav[1];\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: recovered q'ed mbuf %p (drqneed=%d)\\n\", \n\tsc->sc_dev.dv_xname, slot, m, drqneed);\n#endif\n    }\n  }\n\n  if (mlen != 0 && m == NULL) {\n    m = en_mget(sc, mlen, &drqneed);\t\t/* allocate! */\n    if (m == NULL) {\n      fill += mlen;\n      mlen = 0;\n      EN_COUNT(sc->rxmbufout);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of mbufs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    }\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: allocate mbuf %p, mlen=%d, drqneed=%d\\n\", \n\tsc->sc_dev.dv_xname, slot, m, mlen, drqneed);\n#endif\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d, mbuf_chain %p, mlen %d, fill %d\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, m, mlen, fill);\n#endif\n\n  /*\n   * now check to see if we've got the DRQs needed.    if we are out of \n   * DRQs we must quit (saving our mbuf, if we've got one).\n   */\n\n  needfill = (fill) ? 1 : 0;\n  if (drqneed + needfill > sc->drq_free) {\n    sc->need_drqs = 1;\t/* flag condition */\n    if (m == NULL) {\n      EN_COUNT(sc->rxoutboth);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of DRQs *and* mbufs!\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n      return;\t\t/* >>> exit here if out of both mbufs and DRQs <<< */\n    }\n    sav = mtod(m, u_int32_t *);\n    sav[0] = cur;\n    sav[1] = drqneed;\n    IF_ENQUEUE(&sc->rxslot[slot].q, m);\n    EN_COUNT(sc->rxdrqout);\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: out of DRQs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    return;\t\t/* >>> exit here if out of DRQs <<< */\n  }\n\n  /*\n   * at this point all resources have been allocated and we are commited \n   * to servicing this slot.\n   *\n   * dma = last location we told chip about\n   * cur = current location\n   * mlen = space in the mbuf we want\n   * need = bytes to xfer in (decrs to zero)\n   * fill = how much fill we need\n   * tlen = how much data to transfer to this mbuf\n   * cnt/bcode/count = <same as xmit>\n   *\n   * 'needfill' not used after this point\n   */\n\n  dma = cur;\t\t/* dma = last location we told chip about */\n  need = roundup(mlen, sizeof(u_int32_t));\n  fill = fill - (need - mlen);  /* note: may invalidate 'needfill' */\n\n  for (tmp = m ; tmp != NULL && need > 0 ; tmp = tmp->m_next) {\n    tlen = roundup(tmp->m_len, sizeof(u_int32_t)); /* m_len set by en_mget */\n    data = mtod(tmp, u_int32_t *);\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: load mbuf %p, m_len=%d, m_data=%p, tlen=%d\\n\",\n\tsc->sc_dev.dv_xname, slot, tmp, tmp->m_len, tmp->m_data, tlen);\n#endif\n    \n    /* copy data */\n    if (EN_NORXDMA || !en_dma || tlen < EN_MINDMA) {\n      datastop = (u_int32_t *)((u_char *) data + tlen);\n      /* copy loop: preserve byte order!!!  use READDAT */\n      while (data != datastop) {\n\t*data = EN_READDAT(sc, cur);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= tlen;\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: copied %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      continue;\n    }\n\n    /* DMA data (check to see if we need to sync DRQ first) */\n    if (dma != cur) {\n      EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: drq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n    }\n\n#if !defined(MIDWAY_ENIONLY)\n     \n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */ \n  \n    if (sc->is_adaptec) {\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: adp_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, tlen, vci, 0, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst &&\n      (needalign = (((unsigned long) data) & sc->bestburstmask)) != 0) {\n      cnt = sc->bestburstlen - needalign;\n      if (cnt > tlen) {\n        cnt = tlen;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: al_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need a max-sized burst? */\n    if (tlen >= sc->bestburstlen) {\n      count = tlen >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: best_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need to do a cleanup burst? */\n    if (tlen) {\n      count = tlen / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = tlen >> en_dmaplan[count].divshift;\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: cleanup_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n\n#endif /* !MIDWAY_ADPONLY */\n\n  }\n\n  /* skip the end */\n  if (fill || dma != cur) {\n#ifdef EN_DEBUG\n      if (fill)\n        printf(\"%s: rx%d: vci%d: skipping %d bytes of fill\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, fill);\n      else\n        printf(\"%s: rx%d: vci%d: syncing chip from 0x%x to 0x%x [cur]\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, dma, cur);\n#endif\n    EN_WRAPADD(start, stop, cur, fill);\n    EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, mlen,\n\t\t\t\t\tslot, MID_DMA_END);\n    /* dma = cur; */\t/* not necessary since we are done */\n  }\n\n  /*\n   * done, remove stuff we don't want to pass up:\n   *   raw mode (boodi mode): pass everything up for later processing\n   *   aal5: remove RBD\n   *   aal0: remove RBD + cell header\n   */\n\ndone:\n  if (m) {\n    if (!raw) {\n      cnt = MID_RBD_SIZE;\n      if (!aal5) cnt += MID_CHDR_SIZE;\n      m->m_len -= cnt;\t\t\t\t/* chop! */\n      m->m_pkthdr.len -= cnt;\n      m->m_data += cnt;\n    }\n    IF_ENQUEUE(&sc->rxslot[slot].indma, m);\n  }\n  sc->rxslot[slot].cur = cur;\t\t/* update master copy of 'cur' */\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: vci%d: DONE!   cur now =0x%x\\n\", \n\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n\n  goto same_vci;\t/* get next packet in this slot */\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
            "#define ENOTHER_RAW\t0x04\t\t/* 'raw' access  (aka boodi mode) */",
            "#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */",
            "#define STATIC static",
            "#define STATIC /* nothing */",
            "#define EN_DIAG\t\t\t/* link in with master DIAG option */",
            "#define EN_NORXDMA\t0\t/* hook to disable rx dma only */",
            "#define\tEN_DIAG"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_RAW\t0x04\t\t/* 'raw' access  (aka boodi mode) */\n#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_DIAG\t\t\t/* link in with master DIAG option */\n#define EN_NORXDMA\t0\t/* hook to disable rx dma only */\n#define\tEN_DIAG\n\nSTATIC void en_service(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m, *tmp;\n  u_int32_t cur, dstart, rbd, pdu, *sav, dma, bcode, count, *data, *datastop;\n  u_int32_t start, stop, cnt, needalign;\n  int slot, raw, aal5, llc, vci, fill, mlen, tlen, drqneed, need, needfill, end;\n\n  aal5 = 0;\t\t/* Silence gcc */\nnext_vci:\n  if (sc->swsl_size == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: en_service done\\n\", sc->sc_dev.dv_xname);\n#endif\n    return;\t\t/* >>> exit here if swsl now empty <<< */\n  }\n\n  /*\n   * get slot/vci to service\n   */\n\n  slot = sc->swslist[sc->swsl_head];\n  vci = sc->rxslot[slot].atm_vci;\n#ifdef EN_DIAG\n  if (sc->rxvc2slot[vci] != slot) panic(\"en_service rx slot/vci sync\");\n#endif\n\n  /*\n   * determine our mode and if we've got any work to do\n   */\n\n  raw = sc->rxslot[slot].oth_flags & ENOTHER_RAW;\n  start= sc->rxslot[slot].start;\n  stop= sc->rxslot[slot].stop;\n  cur = sc->rxslot[slot].cur;\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: service vci=%d raw=%d start/stop/cur=0x%x 0x%x 0x%x\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, raw, start, stop, cur);\n#endif\n\nsame_vci:\n  dstart = MIDV_DSTART(EN_READ(sc, MID_DST_RP(vci)));\n  dstart = (dstart * sizeof(u_int32_t)) + start;\n\n  /* check to see if there is any data at all */\n  if (dstart == cur) {\ndefer:\t\t\t\t\t/* defer processing */\n    EN_WRAPADD(0, MID_SL_N, sc->swsl_head, 1); \n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    sc->swsl_size--;\n\t\t\t\t\t/* >>> remove from swslist <<< */\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: remove vci %d from swslist\\n\", \n\t\tsc->sc_dev.dv_xname, slot, vci);\n#endif\n    goto next_vci;\n  }\n\n  /*\n   * figure out how many bytes we need\n   * [mlen = # bytes to go in mbufs, fill = # bytes to dump (MIDDMA_JK)]\n   */\n\n  if (raw) {\n\n    /* raw mode (aka boodi mode) */\n    fill = 0;\n    if (dstart > cur)\n      mlen = dstart - cur;\n    else\n      mlen = (dstart + (EN_RXSZ*1024)) - cur;\n\n    if (mlen < sc->rxslot[slot].raw_threshold)\n      goto defer; \t\t/* too little data to deal with */\n\n  } else {\n\n    /* normal mode */\n    aal5 = (sc->rxslot[slot].atm_flags & ATM_PH_AAL5);\n    llc = (aal5 && (sc->rxslot[slot].atm_flags & ATM_PH_LLCSNAP)) ? 1 : 0;\n    rbd = EN_READ(sc, cur);\n    if (MID_RBD_ID(rbd) != MID_RBD_STDID) \n      panic(\"en_service: id mismatch\");\n\n    if (rbd & MID_RBD_T) {\n      mlen = 0;\t\t\t/* we've got trash */\n      fill = MID_RBD_SIZE;\n      EN_COUNT(sc->ttrash);\n    } else if (!aal5) {\n      mlen = MID_RBD_SIZE + MID_CHDR_SIZE + MID_ATMDATASZ; /* 1 cell (ick!) */\n      fill = 0;\n    } else {\n      tlen = (MID_RBD_CNT(rbd) * MID_ATMDATASZ) + MID_RBD_SIZE;\n      pdu = cur + tlen - MID_PDU_SIZE;\n      if (pdu >= stop)\n\tpdu -= (EN_RXSZ*1024);\n      pdu = EN_READ(sc, pdu);\t/* get PDU in correct byte order */\n      fill = tlen - MID_RBD_SIZE - MID_PDU_LEN(pdu);\n      if (fill < 0 || (rbd & MID_RBD_CRCERR) != 0) {\n        printf(\"%s: %s, dropping frame\\n\", sc->sc_dev.dv_xname,\n\t    (rbd & MID_RBD_CRCERR) ? \"CRC error\" : \"invalid AAL5 PDU length\");\n        printf(\"%s: got %d cells (%d bytes), AAL5 len is %d bytes (pdu=0x%x)\\n\",\n\t  sc->sc_dev.dv_xname, MID_RBD_CNT(rbd), tlen - MID_RBD_SIZE,\n\t\tMID_PDU_LEN(pdu), pdu);\n\tfill = tlen;\n      }\n      mlen = tlen - fill;\n    }\n\n  }\n\n  /*\n   * now allocate mbufs for mlen bytes of data, if out of mbufs, trash all\n   *\n   * notes:\n   *  1. it is possible that we've already allocated an mbuf for this pkt\n   *\t but ran out of DRQs, in which case we saved the allocated mbuf on\n   *\t \"q\".\n   *  2. if we save an mbuf in \"q\" we store the \"cur\" (pointer) in the front \n   *     of the mbuf as an identity (that we can check later), and we also\n   *     store drqneed (so we don't have to recompute it).\n   *  3. after this block of code, if m is still NULL then we ran out of mbufs\n   */\n  \n  m = sc->rxslot[slot].q.ifq_head;\n  drqneed = 1;\n  if (m) {\n    sav = mtod(m, u_int32_t *);\n    if (sav[0] != cur) {\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: q'ed mbuf %p not ours\\n\", \n\t\tsc->sc_dev.dv_xname, slot, m);\n#endif\n      m = NULL;\t\t\t/* wasn't ours */\n      EN_COUNT(sc->rxqnotus);\n    } else {\n      EN_COUNT(sc->rxqus);\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      drqneed = sav[1];\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: recovered q'ed mbuf %p (drqneed=%d)\\n\", \n\tsc->sc_dev.dv_xname, slot, m, drqneed);\n#endif\n    }\n  }\n\n  if (mlen != 0 && m == NULL) {\n    m = en_mget(sc, mlen, &drqneed);\t\t/* allocate! */\n    if (m == NULL) {\n      fill += mlen;\n      mlen = 0;\n      EN_COUNT(sc->rxmbufout);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of mbufs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    }\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: allocate mbuf %p, mlen=%d, drqneed=%d\\n\", \n\tsc->sc_dev.dv_xname, slot, m, mlen, drqneed);\n#endif\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d, mbuf_chain %p, mlen %d, fill %d\\n\",\n\tsc->sc_dev.dv_xname, slot, vci, m, mlen, fill);\n#endif\n\n  /*\n   * now check to see if we've got the DRQs needed.    if we are out of \n   * DRQs we must quit (saving our mbuf, if we've got one).\n   */\n\n  needfill = (fill) ? 1 : 0;\n  if (drqneed + needfill > sc->drq_free) {\n    sc->need_drqs = 1;\t/* flag condition */\n    if (m == NULL) {\n      EN_COUNT(sc->rxoutboth);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: out of DRQs *and* mbufs!\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n      return;\t\t/* >>> exit here if out of both mbufs and DRQs <<< */\n    }\n    sav = mtod(m, u_int32_t *);\n    sav[0] = cur;\n    sav[1] = drqneed;\n    IF_ENQUEUE(&sc->rxslot[slot].q, m);\n    EN_COUNT(sc->rxdrqout);\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: out of DRQs\\n\", sc->sc_dev.dv_xname, slot);\n#endif\n    return;\t\t/* >>> exit here if out of DRQs <<< */\n  }\n\n  /*\n   * at this point all resources have been allocated and we are commited \n   * to servicing this slot.\n   *\n   * dma = last location we told chip about\n   * cur = current location\n   * mlen = space in the mbuf we want\n   * need = bytes to xfer in (decrs to zero)\n   * fill = how much fill we need\n   * tlen = how much data to transfer to this mbuf\n   * cnt/bcode/count = <same as xmit>\n   *\n   * 'needfill' not used after this point\n   */\n\n  dma = cur;\t\t/* dma = last location we told chip about */\n  need = roundup(mlen, sizeof(u_int32_t));\n  fill = fill - (need - mlen);  /* note: may invalidate 'needfill' */\n\n  for (tmp = m ; tmp != NULL && need > 0 ; tmp = tmp->m_next) {\n    tlen = roundup(tmp->m_len, sizeof(u_int32_t)); /* m_len set by en_mget */\n    data = mtod(tmp, u_int32_t *);\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: load mbuf %p, m_len=%d, m_data=%p, tlen=%d\\n\",\n\tsc->sc_dev.dv_xname, slot, tmp, tmp->m_len, tmp->m_data, tlen);\n#endif\n    \n    /* copy data */\n    if (EN_NORXDMA || !en_dma || tlen < EN_MINDMA) {\n      datastop = (u_int32_t *)((u_char *) data + tlen);\n      /* copy loop: preserve byte order!!!  use READDAT */\n      while (data != datastop) {\n\t*data = EN_READDAT(sc, cur);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= tlen;\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: copied %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      continue;\n    }\n\n    /* DMA data (check to see if we need to sync DRQ first) */\n    if (dma != cur) {\n      EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: drq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n    }\n\n#if !defined(MIDWAY_ENIONLY)\n     \n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */ \n  \n    if (sc->is_adaptec) {\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: adp_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, tlen, vci, 0, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst &&\n      (needalign = (((unsigned long) data) & sc->bestburstmask)) != 0) {\n      cnt = sc->bestburstlen - needalign;\n      if (cnt > tlen) {\n        cnt = tlen;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: al_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need a max-sized burst? */\n    if (tlen >= sc->bestburstlen) {\n      count = tlen >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: best_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, cnt, need);\n#endif\n      tlen -= cnt;\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *)((u_char *) data + cnt);   \n    }\n\n    /* do we need to do a cleanup burst? */\n    if (tlen) {\n      count = tlen / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = tlen >> en_dmaplan[count].divshift;\n      need -= tlen;\n      EN_WRAPADD(start, stop, cur, tlen);\n#ifdef EN_DEBUG\n      printf(\"%s: rx%d: vci%d: cleanup_dma %d bytes (%d left)\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, tlen, need);\n#endif\n      end = (need == 0 && !fill) ? MID_DMA_END : 0;\n      EN_DRQADD(sc, count, vci, bcode, vtophys(data), mlen, slot, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n\n#endif /* !MIDWAY_ADPONLY */\n\n  }\n\n  /* skip the end */\n  if (fill || dma != cur) {\n#ifdef EN_DEBUG\n      if (fill)\n        printf(\"%s: rx%d: vci%d: skipping %d bytes of fill\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, fill);\n      else\n        printf(\"%s: rx%d: vci%d: syncing chip from 0x%x to 0x%x [cur]\\n\",\n\t\tsc->sc_dev.dv_xname, slot, vci, dma, cur);\n#endif\n    EN_WRAPADD(start, stop, cur, fill);\n    EN_DRQADD(sc, WORD_IDX(start,cur), vci, MIDDMA_JK, 0, mlen,\n\t\t\t\t\tslot, MID_DMA_END);\n    /* dma = cur; */\t/* not necessary since we are done */\n  }\n\n  /*\n   * done, remove stuff we don't want to pass up:\n   *   raw mode (boodi mode): pass everything up for later processing\n   *   aal5: remove RBD\n   *   aal0: remove RBD + cell header\n   */\n\ndone:\n  if (m) {\n    if (!raw) {\n      cnt = MID_RBD_SIZE;\n      if (!aal5) cnt += MID_CHDR_SIZE;\n      m->m_len -= cnt;\t\t\t\t/* chop! */\n      m->m_pkthdr.len -= cnt;\n      m->m_data += cnt;\n    }\n    IF_ENQUEUE(&sc->rxslot[slot].indma, m);\n  }\n  sc->rxslot[slot].cur = cur;\t\t/* update master copy of 'cur' */\n\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: vci%d: DONE!   cur now =0x%x\\n\", \n\tsc->sc_dev.dv_xname, slot, vci, cur);\n#endif\n\n  goto same_vci;\t/* get next packet in this slot */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "0",
            "MID_SL_N",
            "sc->swsl_tail",
            "1"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->swadd"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->hwpull"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_VC(vci)",
            "sc->rxslot[slot].mode"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vci"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_VC(vci)",
            "MIDV_TRASH"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vci"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "MID_SLOFF",
            "MID_SLEND",
            "sc->hwslistp",
            "4"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "sc->hwslistp"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_SL_REG2A",
          "args": [
            "EN_READ(sc, MID_SERV_WRITE)"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_SERV_WRITE"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_REG2A",
          "args": [
            "val"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "0",
            "MID_DRQ_N",
            "idx",
            "1"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atm_input",
          "args": [
            "&sc->enif",
            "&ah",
            "m",
            "sc->rxslot[slot].rxhand"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DQ_LEN",
          "args": [
            "drq"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_SETVCI",
          "args": [
            "&ah",
            "sc->rxslot[slot].atm_vci"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_VPI",
          "args": [
            "&ah"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_FLAGS",
          "args": [
            "&ah"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_VC(vci)"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vci"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"enintr: drqsync: %s: lost mbuf in slot %d!\"",
            "sc->sc_dev.dv_xname",
            "slot"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->rxslot[slot].indma",
            "m"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DQ_LEN",
          "args": [
            "drq"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DQ_SLOT",
          "args": [
            "drq"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_A2REG",
          "args": [
            "sc->drq_chip"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDRX"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_txdma",
          "args": [
            "sc",
            "lcv"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "en_txdma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1746-1940",
          "snippet": "STATIC void en_txdma(sc, chan)\n\nstruct en_softc *sc;\nint chan;\n\n{\n  struct mbuf *tmp;\n  struct atm_pseudohdr *ap;\n  struct en_launch launch;\n  int datalen = 0, dtqneed, len, ncells;\n  u_int8_t *cp;\n\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: starting...\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n\n  /*\n   * note: now that txlaunch handles non-word aligned/sized requests\n   * the only time you can safely set launch.nodma is if you've en_mfix()'d\n   * the mbuf chain.    this happens only if EN_NOTXDMA || !en_dma.\n   */\n\n  launch.nodma = (EN_NOTXDMA || !en_dma);\n\nagain:\n\n  /*\n   * get an mbuf waiting for DMA\n   */\n\n  launch.t = sc->txslot[chan].q.ifq_head; /* peek at head of queue */\n\n  if (launch.t == NULL) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: ...done!\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t/* >>> exit here if no data waiting for DMA <<< */\n  }\n\n  /*\n   * get flags, vci\n   * \n   * note: launch.need = # bytes we need to get on the card\n   *\t   dtqneed = # of DTQs we need for this packet\n   *       launch.mlen = # of bytes in in mbuf chain (<= launch.need)\n   */\n\n  ap = mtod(launch.t, struct atm_pseudohdr *);\n  launch.atm_vci = ATM_PH_VCI(ap);\n  launch.atm_flags = ATM_PH_FLAGS(ap);\n  launch.aal = ((launch.atm_flags & ATM_PH_AAL5) != 0) ? \n\t\tMID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n  /*\n   * XXX: have to recompute the length again, even though we already did\n   * it in en_start().   might as well compute dtqneed here as well, so \n   * this isn't that bad.\n   */\n\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    dtqneed = 1;\t\t/* header still needs to be added */\n    launch.need = MID_TBD_SIZE;\t/* not includeded with mbuf */\n  } else {\n    dtqneed = 0;\t\t/* header on-board, dma with mbuf */\n    launch.need = 0;\n  }\n\n  launch.mlen = 0;\n  for (tmp = launch.t ; tmp != NULL ; tmp = tmp->m_next) {\n    len = tmp->m_len;\n    launch.mlen += len;\n    cp = mtod(tmp, u_int8_t *);\n    if (tmp == launch.t) {\n      len -= sizeof(struct atm_pseudohdr); /* don't count this! */\n      cp += sizeof(struct atm_pseudohdr);\n    }\n    launch.need += len;\n    if (len == 0)\n      continue;\t\t\t/* atm_pseudohdr alone in first mbuf */\n\n    dtqneed += en_dqneed(sc, (caddr_t) cp, len, 1);\n  }\n\n  if ((launch.need % sizeof(u_int32_t)) != 0) \n    dtqneed++;\t\t\t/* need DTQ to FLUSH internal buffer */\n\n  if ((launch.atm_flags & EN_OBTRL) == 0) {\n    if (launch.aal == MID_TBD_AAL5) {\n      datalen = launch.need - MID_TBD_SIZE;\n      launch.need += MID_PDU_SIZE;\t\t/* AAL5: need PDU tail */\n    }\n    dtqneed++;\t\t\t/* need to work on the end a bit */\n  }\n\n  /*\n   * finish calculation of launch.need (need to figure out how much padding\n   * we will need).   launch.need includes MID_TBD_SIZE, but we need to\n   * remove that to so we can round off properly.     we have to add \n   * MID_TBD_SIZE back in after calculating ncells.\n   */\n\n  launch.need = roundup(launch.need - MID_TBD_SIZE, MID_ATMDATASZ);\n  ncells = launch.need / MID_ATMDATASZ;\n  launch.need += MID_TBD_SIZE;\n\n  if (launch.need > EN_TXSZ * 1024) {\n    printf(\"%s: tx%d: packet larger than xmit buffer (%d > %d)\\n\",\n      sc->sc_dev.dv_xname, chan, launch.need, EN_TXSZ * 1024);\n    goto dequeue_drop;\n  }\n\n  /*\n   * note: note that we cannot totally fill the circular buffer (i.e.\n   * we can't use up all of the remaining sc->txslot[chan].bfree free\n   * bytes) because that would cause the circular buffer read pointer\n   * to become equal to the write pointer, thus signaling 'empty buffer'\n   * to the hardware and stopping the transmitter.\n   */\n  if (launch.need >= sc->txslot[chan].bfree) {\n    EN_COUNT(sc->txoutspace);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit space\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of obmem buffer space <<< */\n  }\n  \n  /*\n   * ensure we have enough dtqs to go, if not, wait for more.\n   */\n\n  if (launch.nodma) {\n    dtqneed = 1;\n  }\n  if (dtqneed > sc->dtq_free) {\n    sc->need_dtqs = 1;\n    EN_COUNT(sc->txdtqout);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit DTQs\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of dtqs <<< */\n  }\n\n  /*\n   * it is a go, commit!  dequeue mbuf start working on the xfer.\n   */\n\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n#ifdef EN_DIAG\n  if (launch.t != tmp)\n    panic(\"en dequeue\");\n#endif /* EN_DIAG */\n\n  /*\n   * launch!\n   */\n\n  EN_COUNT(sc->launch);\n  sc->enif.if_opackets++;\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    EN_COUNT(sc->lheader);\n    /* store tbd1/tbd2 in host byte order */\n    launch.tbd1 = MID_TBD_MK1(launch.aal, sc->txspeed[launch.atm_vci], ncells);\n    launch.tbd2 = MID_TBD_MK2(launch.atm_vci, 0, 0);\n  }\n  if ((launch.atm_flags & EN_OBTRL) == 0 && launch.aal == MID_TBD_AAL5) {\n    EN_COUNT(sc->ltail);\n    launch.pdu1 = MID_PDU_MK1(0, 0, datalen);  /* host byte order */\n  }\n\n  en_txlaunch(sc, chan, &launch);\n  \n  /*\n   * do some housekeeping and get the next packet\n   */\n\n  sc->txslot[chan].bfree -= launch.need;\n  IF_ENQUEUE(&sc->txslot[chan].indma, launch.t);\n  goto again;\n\n  /*\n   * END of txdma loop!\n   */\n\n  /*\n   * error handles\n   */\n\ndequeue_drop:\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n  if (launch.t != tmp)\n    panic(\"en dequeue drop\");\n  m_freem(launch.t);\n  sc->txslot[chan].mbsize -= launch.mlen;\n  goto again;\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */",
            "#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */",
            "#define STATIC static",
            "#define STATIC /* nothing */",
            "#define EN_DIAG\t\t\t/* link in with master DIAG option */",
            "#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */",
            "#define\tEN_DIAG"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */\n#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_DIAG\t\t\t/* link in with master DIAG option */\n#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */\n#define\tEN_DIAG\n\nSTATIC void en_txdma(sc, chan)\n\nstruct en_softc *sc;\nint chan;\n\n{\n  struct mbuf *tmp;\n  struct atm_pseudohdr *ap;\n  struct en_launch launch;\n  int datalen = 0, dtqneed, len, ncells;\n  u_int8_t *cp;\n\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: starting...\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n\n  /*\n   * note: now that txlaunch handles non-word aligned/sized requests\n   * the only time you can safely set launch.nodma is if you've en_mfix()'d\n   * the mbuf chain.    this happens only if EN_NOTXDMA || !en_dma.\n   */\n\n  launch.nodma = (EN_NOTXDMA || !en_dma);\n\nagain:\n\n  /*\n   * get an mbuf waiting for DMA\n   */\n\n  launch.t = sc->txslot[chan].q.ifq_head; /* peek at head of queue */\n\n  if (launch.t == NULL) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: ...done!\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t/* >>> exit here if no data waiting for DMA <<< */\n  }\n\n  /*\n   * get flags, vci\n   * \n   * note: launch.need = # bytes we need to get on the card\n   *\t   dtqneed = # of DTQs we need for this packet\n   *       launch.mlen = # of bytes in in mbuf chain (<= launch.need)\n   */\n\n  ap = mtod(launch.t, struct atm_pseudohdr *);\n  launch.atm_vci = ATM_PH_VCI(ap);\n  launch.atm_flags = ATM_PH_FLAGS(ap);\n  launch.aal = ((launch.atm_flags & ATM_PH_AAL5) != 0) ? \n\t\tMID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n  /*\n   * XXX: have to recompute the length again, even though we already did\n   * it in en_start().   might as well compute dtqneed here as well, so \n   * this isn't that bad.\n   */\n\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    dtqneed = 1;\t\t/* header still needs to be added */\n    launch.need = MID_TBD_SIZE;\t/* not includeded with mbuf */\n  } else {\n    dtqneed = 0;\t\t/* header on-board, dma with mbuf */\n    launch.need = 0;\n  }\n\n  launch.mlen = 0;\n  for (tmp = launch.t ; tmp != NULL ; tmp = tmp->m_next) {\n    len = tmp->m_len;\n    launch.mlen += len;\n    cp = mtod(tmp, u_int8_t *);\n    if (tmp == launch.t) {\n      len -= sizeof(struct atm_pseudohdr); /* don't count this! */\n      cp += sizeof(struct atm_pseudohdr);\n    }\n    launch.need += len;\n    if (len == 0)\n      continue;\t\t\t/* atm_pseudohdr alone in first mbuf */\n\n    dtqneed += en_dqneed(sc, (caddr_t) cp, len, 1);\n  }\n\n  if ((launch.need % sizeof(u_int32_t)) != 0) \n    dtqneed++;\t\t\t/* need DTQ to FLUSH internal buffer */\n\n  if ((launch.atm_flags & EN_OBTRL) == 0) {\n    if (launch.aal == MID_TBD_AAL5) {\n      datalen = launch.need - MID_TBD_SIZE;\n      launch.need += MID_PDU_SIZE;\t\t/* AAL5: need PDU tail */\n    }\n    dtqneed++;\t\t\t/* need to work on the end a bit */\n  }\n\n  /*\n   * finish calculation of launch.need (need to figure out how much padding\n   * we will need).   launch.need includes MID_TBD_SIZE, but we need to\n   * remove that to so we can round off properly.     we have to add \n   * MID_TBD_SIZE back in after calculating ncells.\n   */\n\n  launch.need = roundup(launch.need - MID_TBD_SIZE, MID_ATMDATASZ);\n  ncells = launch.need / MID_ATMDATASZ;\n  launch.need += MID_TBD_SIZE;\n\n  if (launch.need > EN_TXSZ * 1024) {\n    printf(\"%s: tx%d: packet larger than xmit buffer (%d > %d)\\n\",\n      sc->sc_dev.dv_xname, chan, launch.need, EN_TXSZ * 1024);\n    goto dequeue_drop;\n  }\n\n  /*\n   * note: note that we cannot totally fill the circular buffer (i.e.\n   * we can't use up all of the remaining sc->txslot[chan].bfree free\n   * bytes) because that would cause the circular buffer read pointer\n   * to become equal to the write pointer, thus signaling 'empty buffer'\n   * to the hardware and stopping the transmitter.\n   */\n  if (launch.need >= sc->txslot[chan].bfree) {\n    EN_COUNT(sc->txoutspace);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit space\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of obmem buffer space <<< */\n  }\n  \n  /*\n   * ensure we have enough dtqs to go, if not, wait for more.\n   */\n\n  if (launch.nodma) {\n    dtqneed = 1;\n  }\n  if (dtqneed > sc->dtq_free) {\n    sc->need_dtqs = 1;\n    EN_COUNT(sc->txdtqout);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit DTQs\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of dtqs <<< */\n  }\n\n  /*\n   * it is a go, commit!  dequeue mbuf start working on the xfer.\n   */\n\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n#ifdef EN_DIAG\n  if (launch.t != tmp)\n    panic(\"en dequeue\");\n#endif /* EN_DIAG */\n\n  /*\n   * launch!\n   */\n\n  EN_COUNT(sc->launch);\n  sc->enif.if_opackets++;\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    EN_COUNT(sc->lheader);\n    /* store tbd1/tbd2 in host byte order */\n    launch.tbd1 = MID_TBD_MK1(launch.aal, sc->txspeed[launch.atm_vci], ncells);\n    launch.tbd2 = MID_TBD_MK2(launch.atm_vci, 0, 0);\n  }\n  if ((launch.atm_flags & EN_OBTRL) == 0 && launch.aal == MID_TBD_AAL5) {\n    EN_COUNT(sc->ltail);\n    launch.pdu1 = MID_PDU_MK1(0, 0, datalen);  /* host byte order */\n  }\n\n  en_txlaunch(sc, chan, &launch);\n  \n  /*\n   * do some housekeeping and get the next packet\n   */\n\n  sc->txslot[chan].bfree -= launch.need;\n  IF_ENQUEUE(&sc->txslot[chan].indma, launch.t);\n  goto again;\n\n  /*\n   * END of txdma loop!\n   */\n\n  /*\n   * error handles\n   */\n\ndequeue_drop:\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n  if (launch.t != tmp)\n    panic(\"en dequeue drop\");\n  m_freem(launch.t);\n  sc->txslot[chan].mbsize -= launch.mlen;\n  goto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MID_DTQ_REG2A",
          "args": [
            "val"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "0",
            "MID_DTQ_N",
            "idx",
            "1"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DQ_LEN",
          "args": [
            "dtq"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DQ_LEN",
          "args": [
            "dtq"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"enintr: dtqsync\""
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->txslot[slot].indma",
            "m"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DQ_SLOT",
          "args": [
            "dtq"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_A2REG",
          "args": [
            "sc->dtq_chip"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDTX"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_READPTR(lcv)"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_READPTR",
          "args": [
            "lcv"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_TXCHAN",
          "args": [
            "lcv"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_INTR_RET",
          "args": [
            "1"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_init",
          "args": [
            "sc"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "en_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1343-1434",
          "snippet": "STATIC void en_init(sc)\n\nstruct en_softc *sc;\n\n{\n  int vc, slot;\n  u_int32_t loc;\n\n  if ((sc->enif.if_flags & IFF_UP) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: going down\\n\", sc->sc_dev.dv_xname);\n#endif\n    en_reset(sc);\t\t\t/* to be safe */\n    sc->enif.if_flags &= ~IFF_RUNNING;\t/* disable */\n    return;\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: going up\\n\", sc->sc_dev.dv_xname);\n#endif\n  sc->enif.if_flags |= IFF_RUNNING;\t/* enable */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n\n  /*\n   * init obmem data structures: vc tab, dma q's, slist.\n   *\n   * note that we set drq_free/dtq_free to one less than the total number\n   * of DTQ/DRQs present.   we do this because the card uses the condition\n   * (drq_chip == drq_us) to mean \"list is empty\"... but if you allow the\n   * circular list to be completely full then (drq_chip == drq_us) [i.e.\n   * the drq_us pointer will wrap all the way around].   by restricting\n   * the number of active requests to (N - 1) we prevent the list from\n   * becoming completely full.    note that the card will sometimes give\n   * us an interrupt for a DTQ/DRQ we have already processes... this helps\n   * keep that interrupt from messing us up.\n   */\n\n  for (vc = 0 ; vc < MID_N_VC ; vc++) \n    en_loadvc(sc, vc);\n\n  bzero(&sc->drq, sizeof(sc->drq));\n  sc->drq_free = MID_DRQ_N - 1;\t\t/* N - 1 */\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->drq_us = sc->drq_chip;\n\n  bzero(&sc->dtq, sizeof(sc->dtq));\n  sc->dtq_free = MID_DTQ_N - 1;\t\t/* N - 1 */\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n  EN_WRITE(sc, MID_DMA_WRTX, MID_DRQ_A2REG(sc->dtq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->dtq_us = sc->dtq_chip;\n\n  sc->hwslistp = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n  sc->swsl_size = sc->swsl_head = sc->swsl_tail = 0;\n\n#ifdef EN_DEBUG\n  printf(\"%s: drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, hwslist: 0x%x\\n\", \n    sc->sc_dev.dv_xname, sc->drq_free, sc->drq_chip, \n    sc->dtq_free, sc->dtq_chip, sc->hwslistp);\n#endif\n\n  for (slot = 0 ; slot < EN_NTX ; slot++) {\n    sc->txslot[slot].bfree = EN_TXSZ * 1024;\n    EN_WRITE(sc, MIDX_READPTR(slot), 0);\n    EN_WRITE(sc, MIDX_DESCSTART(slot), 0);\n    loc = sc->txslot[slot].cur = sc->txslot[slot].start;\n    loc = loc - MID_RAMOFF;\n    loc = (loc & ~((EN_TXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    loc = loc >> MIDV_LOCTOPSHFT;\t/* top 11 bits */\n    EN_WRITE(sc, MIDX_PLACE(slot), MIDX_MKPLACE(en_k2sz(EN_TXSZ), loc));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: place 0x%x\\n\", sc->sc_dev.dv_xname,  slot,\n\tEN_READ(sc, MIDX_PLACE(slot)));\n#endif\n  }\n\n  /*\n   * enable!\n   */\n\n  EN_WRITE(sc, MID_INTENA, MID_INT_TX|MID_INT_DMA_OVR|MID_INT_IDENT|\n\tMID_INT_LERR|MID_INT_DMA_ERR|MID_INT_DMA_RX|MID_INT_DMA_TX|\n\tMID_INT_SERVICE| /* >>> MID_INT_SUNI| XXXCDC<<< */ MID_INT_STATS);\n  EN_WRITE(sc, MID_MAST_CSR, MID_SETIPL(sc->ipl)|MID_MCSR_ENDMA|\n\tMID_MCSR_ENTX|MID_MCSR_ENRX);\n\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC /* nothing */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC void en_init(sc)\n\nstruct en_softc *sc;\n\n{\n  int vc, slot;\n  u_int32_t loc;\n\n  if ((sc->enif.if_flags & IFF_UP) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: going down\\n\", sc->sc_dev.dv_xname);\n#endif\n    en_reset(sc);\t\t\t/* to be safe */\n    sc->enif.if_flags &= ~IFF_RUNNING;\t/* disable */\n    return;\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: going up\\n\", sc->sc_dev.dv_xname);\n#endif\n  sc->enif.if_flags |= IFF_RUNNING;\t/* enable */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n\n  /*\n   * init obmem data structures: vc tab, dma q's, slist.\n   *\n   * note that we set drq_free/dtq_free to one less than the total number\n   * of DTQ/DRQs present.   we do this because the card uses the condition\n   * (drq_chip == drq_us) to mean \"list is empty\"... but if you allow the\n   * circular list to be completely full then (drq_chip == drq_us) [i.e.\n   * the drq_us pointer will wrap all the way around].   by restricting\n   * the number of active requests to (N - 1) we prevent the list from\n   * becoming completely full.    note that the card will sometimes give\n   * us an interrupt for a DTQ/DRQ we have already processes... this helps\n   * keep that interrupt from messing us up.\n   */\n\n  for (vc = 0 ; vc < MID_N_VC ; vc++) \n    en_loadvc(sc, vc);\n\n  bzero(&sc->drq, sizeof(sc->drq));\n  sc->drq_free = MID_DRQ_N - 1;\t\t/* N - 1 */\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->drq_us = sc->drq_chip;\n\n  bzero(&sc->dtq, sizeof(sc->dtq));\n  sc->dtq_free = MID_DTQ_N - 1;\t\t/* N - 1 */\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n  EN_WRITE(sc, MID_DMA_WRTX, MID_DRQ_A2REG(sc->dtq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->dtq_us = sc->dtq_chip;\n\n  sc->hwslistp = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n  sc->swsl_size = sc->swsl_head = sc->swsl_tail = 0;\n\n#ifdef EN_DEBUG\n  printf(\"%s: drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, hwslist: 0x%x\\n\", \n    sc->sc_dev.dv_xname, sc->drq_free, sc->drq_chip, \n    sc->dtq_free, sc->dtq_chip, sc->hwslistp);\n#endif\n\n  for (slot = 0 ; slot < EN_NTX ; slot++) {\n    sc->txslot[slot].bfree = EN_TXSZ * 1024;\n    EN_WRITE(sc, MIDX_READPTR(slot), 0);\n    EN_WRITE(sc, MIDX_DESCSTART(slot), 0);\n    loc = sc->txslot[slot].cur = sc->txslot[slot].start;\n    loc = loc - MID_RAMOFF;\n    loc = (loc & ~((EN_TXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    loc = loc >> MIDV_LOCTOPSHFT;\t/* top 11 bits */\n    EN_WRITE(sc, MIDX_PLACE(slot), MIDX_MKPLACE(en_k2sz(EN_TXSZ), loc));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: place 0x%x\\n\", sc->sc_dev.dv_xname,  slot,\n\tEN_READ(sc, MIDX_PLACE(slot)));\n#endif\n  }\n\n  /*\n   * enable!\n   */\n\n  EN_WRITE(sc, MID_INTENA, MID_INT_TX|MID_INT_DMA_OVR|MID_INT_IDENT|\n\tMID_INT_LERR|MID_INT_DMA_ERR|MID_INT_DMA_RX|MID_INT_DMA_TX|\n\tMID_INT_SERVICE| /* >>> MID_INT_SUNI| XXXCDC<<< */ MID_INT_STATS);\n  EN_WRITE(sc, MID_MAST_CSR, MID_SETIPL(sc->ipl)|MID_MCSR_ENDMA|\n\tMID_MCSR_ENTX|MID_MCSR_ENRX);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "en_reset",
          "args": [
            "sc"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "en_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1268-1336",
          "snippet": "void en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
            "#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */",
            "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
            "#define RX_NONE\t\t0xffff\t/* recv VC not in use */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n\nvoid en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_INTR_RET",
          "args": [
            "0"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_INTACK"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define\tEN_STAT\n\nEN_INTR_TYPE en_intr(arg)\n\nvoid *arg;\n\n{\n  struct en_softc *sc = (struct en_softc *) arg;\n  struct mbuf *m;\n  struct atm_pseudohdr ah;\n  u_int32_t reg, kick, val, mask, chip, vci, slot, dtq, drq;\n  int lcv, idx, need_softserv = 0;\n\n  reg = EN_READ(sc, MID_INTACK);\n\n  if ((reg & MID_INT_ANY) == 0) \n    EN_INTR_RET(0); /* not us */\n\n#ifdef EN_DEBUG\n  printf(\"%s: interrupt=0x%b\\n\", sc->sc_dev.dv_xname, reg, MID_INTBITS);\n#endif\n\n  /*\n   * unexpected errors that need a reset\n   */\n\n  if ((reg & (MID_INT_IDENT|MID_INT_LERR|MID_INT_DMA_ERR|MID_INT_SUNI)) != 0) {\n    printf(\"%s: unexpected interrupt=0x%b, resetting card\\n\", \n\tsc->sc_dev.dv_xname, reg, MID_INTBITS);\n#ifdef EN_DEBUG\n#ifdef DDB\n    Debugger();\n#endif\t/* DDB */\n    sc->enif.if_flags &= ~IFF_RUNNING; /* FREEZE! */\n#else\n    en_reset(sc);\n    en_init(sc);\n#endif\n    EN_INTR_RET(1); /* for us */\n  }\n\n  /*******************\n   * xmit interrupts *\n   ******************/\n\n  kick = 0;\t\t\t\t/* bitmask of channels to kick */\n  if (reg & MID_INT_TX) {\t\t/* TX done! */\n\n    /*\n     * check for tx complete, if detected then this means that some space\n     * has come free on the card.   we must account for it and arrange to\n     * kick the channel to life (in case it is stalled waiting on the card).\n     */\n    for (mask = 1, lcv = 0 ; lcv < EN_NTX ; lcv++, mask = mask * 2) {\n      if (reg & MID_TXCHAN(lcv)) {\n\tkick = kick | mask;\t/* want to kick later */\n\tval = EN_READ(sc, MIDX_READPTR(lcv));\t/* current read pointer */\n\tval = (val * sizeof(u_int32_t)) + sc->txslot[lcv].start;\n\t\t\t\t\t\t/* convert to offset */\n\tif (val > sc->txslot[lcv].cur)\n\t  sc->txslot[lcv].bfree = val - sc->txslot[lcv].cur;\n\telse\n\t  sc->txslot[lcv].bfree = (val + (EN_TXSZ*1024)) - sc->txslot[lcv].cur;\n#ifdef EN_DEBUG\n\tprintf(\"%s: tx%d: trasmit done.   %d bytes now free in buffer\\n\",\n\t\tsc->sc_dev.dv_xname, lcv, sc->txslot[lcv].bfree);\n#endif\n      }\n    }\n  }\n\n  if (reg & MID_INT_DMA_TX) {\t\t/* TX DMA done! */\n\n  /*\n   * check for TX DMA complete, if detected then this means that some DTQs\n   * are now free.   it also means some indma mbufs can be freed.\n   * if we needed DTQs, kick all channels.\n   */\n    val = EN_READ(sc, MID_DMA_RDTX);\t/* chip's current location */\n    idx = MID_DTQ_A2REG(sc->dtq_chip);/* where we last saw chip */\n    if (sc->need_dtqs) {\n      kick = MID_NTX_CH - 1;\t\t/* assume power of 2, kick all! */\n      sc->need_dtqs = 0;\t\t/* recalculated in \"kick\" loop below */\n#ifdef EN_DEBUG\n      printf(\"%s: cleared need DTQ condition\\n\", sc->sc_dev.dv_xname);\n#endif\n    }\n    while (idx != val) {\n      sc->dtq_free++;\n      if ((dtq = sc->dtq[idx]) != 0) {\n        sc->dtq[idx] = 0;\t/* don't forget to zero it out when done */\n\tslot = EN_DQ_SLOT(dtq);\n\tIF_DEQUEUE(&sc->txslot[slot].indma, m);\n\tif (!m) panic(\"enintr: dtqsync\");\n\tsc->txslot[slot].mbsize -= EN_DQ_LEN(dtq);\n#ifdef EN_DEBUG\n\tprintf(\"%s: tx%d: free %d dma bytes, mbsize now %d\\n\",\n\t\tsc->sc_dev.dv_xname, slot, EN_DQ_LEN(dtq), \n\t\tsc->txslot[slot].mbsize);\n#endif\n\tm_freem(m);\n      }\n      EN_WRAPADD(0, MID_DTQ_N, idx, 1);\n    }\n    sc->dtq_chip = MID_DTQ_REG2A(val);\t/* sync softc */\n  }\n\n\n  /*\n   * kick xmit channels as needed\n   */\n\n  if (kick) {\n#ifdef EN_DEBUG\n  printf(\"%s: tx kick mask = 0x%x\\n\", sc->sc_dev.dv_xname, kick);\n#endif\n    for (mask = 1, lcv = 0 ; lcv < EN_NTX ; lcv++, mask = mask * 2) {\n      if ((kick & mask) && sc->txslot[lcv].q.ifq_head) {\n\ten_txdma(sc, lcv);\t\t/* kick it! */\n      }\n    }\t\t/* for each slot */\n  }\t\t/* if kick */\n\n\n  /*******************\n   * recv interrupts *\n   ******************/\n\n  /*\n   * check for RX DMA complete, and pass the data \"upstairs\"\n   */\n\n  if (reg & MID_INT_DMA_RX) {\n    val = EN_READ(sc, MID_DMA_RDRX); /* chip's current location */\n    idx = MID_DRQ_A2REG(sc->drq_chip);/* where we last saw chip */\n    while (idx != val) {\n      sc->drq_free++;\n      if ((drq = sc->drq[idx]) != 0) {\n        sc->drq[idx] = 0;\t/* don't forget to zero it out when done */\n\tslot = EN_DQ_SLOT(drq);\n        if (EN_DQ_LEN(drq) == 0) {  /* \"JK\" trash DMA? */\n          m = NULL;\n        } else {\n\t  IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n\t  if (!m) {\n\t    panic(\"enintr: drqsync: %s: lost mbuf in slot %d!\",\n\t\tsc->sc_dev.dv_xname, slot);\n\t  }\n        }\n\t/* do something with this mbuf */\n\tif (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {  /* drain? */\n          if (m)\n\t    m_freem(m);\n\t  vci = sc->rxslot[slot].atm_vci;\n\t  if (sc->rxslot[slot].indma.ifq_head == NULL &&\n\t\tsc->rxslot[slot].q.ifq_head == NULL &&\n\t\t(EN_READ(sc, MID_VC(vci)) & MIDV_INSERVICE) == 0 &&\n\t\t(sc->rxslot[slot].oth_flags & ENOTHER_SWSL) == 0) {\n\t    sc->rxslot[slot].oth_flags = ENOTHER_FREE; /* done drain */\n\t    sc->rxslot[slot].atm_vci = RX_NONE;\n\t    sc->rxvc2slot[vci] = RX_NONE;\n#ifdef EN_DEBUG\n\t    printf(\"%s: rx%d: VCI %d now free\\n\", sc->sc_dev.dv_xname,\n\t\t\tslot, vci);\n#endif\n\t  }\n\t} else if (m != NULL) {\n\t  ATM_PH_FLAGS(&ah) = sc->rxslot[slot].atm_flags;\n\t  ATM_PH_VPI(&ah) = 0;\n\t  ATM_PH_SETVCI(&ah, sc->rxslot[slot].atm_vci);\n#ifdef EN_DEBUG\n\t  printf(\"%s: rx%d: rxvci%d: atm_input, mbuf %p, len %d, hand %p\\n\",\n\t\tsc->sc_dev.dv_xname, slot, sc->rxslot[slot].atm_vci, m,\n\t\tEN_DQ_LEN(drq), sc->rxslot[slot].rxhand);\n#endif\n\t  sc->enif.if_ipackets++;\n\n\t  atm_input(&sc->enif, &ah, m, sc->rxslot[slot].rxhand);\n\t}\n\n      }\n      EN_WRAPADD(0, MID_DRQ_N, idx, 1);\n    }\n    sc->drq_chip = MID_DRQ_REG2A(val);\t/* sync softc */\n\n    if (sc->need_drqs) {\t/* true if we had a DRQ shortage */\n      need_softserv = 1;\n      sc->need_drqs = 0;\n#ifdef EN_DEBUG\n\tprintf(\"%s: cleared need DRQ condition\\n\", sc->sc_dev.dv_xname);\n#endif\n    }\n  }\n\n  /*\n   * handle service interrupts\n   */\n\n  if (reg & MID_INT_SERVICE) {\n    chip = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n\n    while (sc->hwslistp != chip) {\n\n      /* fetch and remove it from hardware service list */\n      vci = EN_READ(sc, sc->hwslistp);\n      EN_WRAPADD(MID_SLOFF, MID_SLEND, sc->hwslistp, 4);/* advance hw ptr */\n      slot = sc->rxvc2slot[vci];\n      if (slot == RX_NONE) {\n#ifdef EN_DEBUG\n\tprintf(\"%s: unexpected rx interrupt on VCI %d\\n\", \n\t\tsc->sc_dev.dv_xname, vci);\n#endif\n\tEN_WRITE(sc, MID_VC(vci), MIDV_TRASH);  /* rx off, damn it! */\n\tcontinue;\t\t\t\t/* next */\n      }\n      EN_WRITE(sc, MID_VC(vci), sc->rxslot[slot].mode); /* remove from hwsl */\n      EN_COUNT(sc->hwpull);\n\n#ifdef EN_DEBUG\n      printf(\"%s: pulled VCI %d off hwslist\\n\", sc->sc_dev.dv_xname, vci);\n#endif\n\n      /* add it to the software service list (if needed) */\n      if ((sc->rxslot[slot].oth_flags & ENOTHER_SWSL) == 0) {\n\tEN_COUNT(sc->swadd);\n\tneed_softserv = 1;\n\tsc->rxslot[slot].oth_flags |= ENOTHER_SWSL;\n\tsc->swslist[sc->swsl_tail] = slot;\n\tEN_WRAPADD(0, MID_SL_N, sc->swsl_tail, 1);\n\tsc->swsl_size++;\n#ifdef EN_DEBUG\n      printf(\"%s: added VCI %d to swslist\\n\", sc->sc_dev.dv_xname, vci);\n#endif\n      }\n    }\n  }\n\n  /*\n   * now service (function too big to include here)\n   */\n\n  if (need_softserv)\n    en_service(sc);\n\n  /*\n   * keep our stats\n   */\n\n  if (reg & MID_INT_DMA_OVR) {\n    EN_COUNT(sc->dmaovr);\n#ifdef EN_DEBUG\n    printf(\"%s: MID_INT_DMA_OVR\\n\", sc->sc_dev.dv_xname);\n#endif\n  }\n  reg = EN_READ(sc, MID_STAT);\n#ifdef EN_STAT\n  sc->otrash += MID_OTRASH(reg);\n  sc->vtrash += MID_VTRASH(reg);\n#endif\n\n  EN_INTR_RET(1); /* for us */\n}"
  },
  {
    "function_name": "en_txlaunch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1947-2297",
    "snippet": "STATIC void en_txlaunch(sc, chan, l)\n\nstruct en_softc *sc;\nint chan;\nstruct en_launch *l;\n\n{\n  struct mbuf *tmp;\n  u_int32_t cur = sc->txslot[chan].cur,\n\t    start = sc->txslot[chan].start,\n\t    stop = sc->txslot[chan].stop,\n\t    dma, *data, *datastop, count, bcode;\n  int pad, addtail, need, len, needalign, cnt, end, mx;\n\n\n /*\n  * vars:\n  *   need = # bytes card still needs (decr. to zero)\n  *   len = # of bytes left in current mbuf\n  *   cur = our current pointer\n  *   dma = last place we programmed into the DMA\n  *   data = pointer into data area of mbuf that needs to go next\n  *   cnt = # of bytes to transfer in this DTQ\n  *   bcode/count = DMA burst code, and chip's version of cnt\n  *\n  *   a single buffer can require up to 5 DTQs depending on its size\n  *   and alignment requirements.   the 5 possible requests are:\n  *   [1] 1, 2, or 3 byte DMA to align src data pointer to word boundary\n  *   [2] alburst DMA to align src data pointer to bestburstlen\n  *   [3] 1 or more bestburstlen DMAs\n  *   [4] clean up burst (to last word boundary)\n  *   [5] 1, 2, or 3 byte final clean up DMA\n  */\n\n need = l->need;\n dma = cur;\n addtail = (l->atm_flags & EN_OBTRL) == 0;\t/* add a tail? */\n\n#ifdef EN_DIAG\n  if ((need - MID_TBD_SIZE) % MID_ATMDATASZ) \n    printf(\"%s: tx%d: bogus trasmit needs (%d)\\n\", sc->sc_dev.dv_xname, chan,\n\t\tneed);\n#endif\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: launch mbuf %p!   cur=0x%x[%d], need=%d, addtail=%d\\n\",\n\tsc->sc_dev.dv_xname, chan, l->t, cur, (cur-start)/4, need, addtail);\n  count = EN_READ(sc, MIDX_PLACE(chan));\n  printf(\"     HW: base_address=0x%x, size=%d, read=%d, descstart=%d\\n\",\n\tMIDX_BASE(count), MIDX_SZ(count), EN_READ(sc, MIDX_READPTR(chan)), \n\tEN_READ(sc, MIDX_DESCSTART(chan)));\n#endif\n\n /*\n  * do we need to insert the TBD by hand?\n  * note that tbd1/tbd2/pdu1 are in host byte order.\n  */\n\n  if ((l->atm_flags & EN_OBHDR) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: insert header 0x%x 0x%x\\n\", sc->sc_dev.dv_xname,\n\tchan, l->tbd1, l->tbd2);\n#endif\n    EN_WRITE(sc, cur, l->tbd1);\n    EN_WRAPADD(start, stop, cur, 4);\n    EN_WRITE(sc, cur, l->tbd2);\n    EN_WRAPADD(start, stop, cur, 4);\n    need -= 8;\n  }\n\n  /*\n   * now do the mbufs...\n   */\n\n  for (tmp = l->t ; tmp != NULL ; tmp = tmp->m_next) {\n\n    /* get pointer to data and length */\n    data = mtod(tmp, u_int32_t *);\n    len = tmp->m_len;\n    if (tmp == l->t) {\n      data += sizeof(struct atm_pseudohdr)/sizeof(u_int32_t);\n      len -= sizeof(struct atm_pseudohdr);\n    }\n\n    /* now, determine if we should copy it */\n    if (l->nodma || (len < EN_MINDMA &&\n       (len % 4) == 0 && ((unsigned long) data % 4) == 0 && (cur % 4) == 0)) {\n\n      /* \n       * roundup len: the only time this will change the value of len\n       * is when l->nodma is true, tmp is the last mbuf, and there is\n       * a non-word number of bytes to transmit.   in this case it is\n       * safe to round up because we've en_mfix'd the mbuf (so the first\n       * byte is word aligned there must be enough free bytes at the end\n       * to round off to the next word boundary)...\n       */\n      len = roundup(len, sizeof(u_int32_t));\n      datastop = data + (len / sizeof(u_int32_t));\n      /* copy loop: preserve byte order!!!  use WRITEDAT */\n      while (data != datastop) {\n\tEN_WRITEDAT(sc, cur, *data);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= len;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: copied %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      continue;\t\t/* continue on to next mbuf */\n    }\n\n    /* going to do DMA, first make sure the dtq is in sync. */\n    if (dma != cur) {\n      EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: dtq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n    }\n\n    /*\n     * if this is the last buffer, and it looks like we are going to need to\n     * flush the internal buffer, can we extend the length of this mbuf to\n     * avoid the FLUSH?\n     */\n\n    if (tmp->m_next == NULL) {\n      cnt = (need - len) % sizeof(u_int32_t);\n      if (cnt && M_TRAILINGSPACE(tmp) >= cnt)\n        len += cnt;\t\t\t/* pad for FLUSH */\n    }\n      \n#if !defined(MIDWAY_ENIONLY)\n\n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */\n\n    if (sc->is_adaptec) {\n      /* need to DMA \"len\" bytes out to card */\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: adp_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, len, chan, 0, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align to word boundary? */\n    needalign = (unsigned long) data % sizeof(u_int32_t);\n    if (needalign) {\n      EN_COUNT(sc->headbyte);\n      cnt = sizeof(u_int32_t) - needalign;\n      if (cnt == 2 && len >= cnt) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;\n      } else {\n        cnt = min(cnt, len);\t\t/* prevent overflow */\n        count = cnt;\n        bcode = MIDDMA_BYTE;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: small al_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst && \n\t(needalign = (((unsigned long) data) & sc->bestburstmask)) != 0\n\t&& len >= sizeof(u_int32_t)) {\n      cnt = sc->bestburstlen - needalign;\n      mx = len & ~(sizeof(u_int32_t)-1);\t/* don't go past end */\n      if (cnt > mx) {\n        cnt = mx;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: al_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a max-sized burst? */\n    if (len >= sc->bestburstlen) {\n      count = len >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: best_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a cleanup burst? */\n    cnt = len & ~(sizeof(u_int32_t)-1);\n    if (cnt) {\n      count = cnt / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = cnt >> en_dmaplan[count].divshift;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* any word fragments left? */\n    if (len) {\n      EN_COUNT(sc->tailbyte);\n      if (len == 2) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;                 /* use 2byte mode */\n      } else {\n        count = len;\n        bcode = MIDDMA_BYTE;                  /* use 1 byte mode */\n      }\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: byte cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n#endif /* !MIDWAY_ADPONLY */\n\n  } /* next mbuf, please */\n\n  /*\n   * all mbuf data has been copied out to the obmem (or set up to be DMAd).\n   * if the trailer or padding needs to be put in, do it now.  \n   *\n   * NOTE: experimental results reveal the following fact:\n   *   if you DMA \"X\" bytes to the card, where X is not a multiple of 4,\n   *   then the card will internally buffer the last (X % 4) bytes (in\n   *   hopes of getting (4 - (X % 4)) more bytes to make a complete word).\n   *   it is imporant to make sure we don't leave any important data in\n   *   this internal buffer because it is discarded on the last (end) DTQ.\n   *   one way to do this is to DMA in (4 - (X % 4)) more bytes to flush\n   *   the darn thing out.\n   */\n\n  if (addtail) {\n\n    pad = need % sizeof(u_int32_t);\n    if (pad) {\n      /*\n       * FLUSH internal data buffer.  pad out with random data from the front\n       * of the mbuf chain...\n       */\n      bcode = (sc->is_adaptec) ? 0 : MIDDMA_BYTE;\n      EN_COUNT(sc->tailflush);\n      EN_WRAPADD(start, stop, cur, pad);\n      EN_DTQADD(sc, pad, chan, bcode, vtophys(l->t->m_data), 0, 0);\n      need -= pad;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: pad/FLUSH dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad, need, cur);\n#endif\n    }\n\n    /* copy data */\n    pad = need / sizeof(u_int32_t);\t/* round *down* */\n    if (l->aal == MID_TBD_AAL5)\n      pad -= 2;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: padding %d bytes (cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad * sizeof(u_int32_t), cur);\n#endif\n    while (pad--) {\n      EN_WRITEDAT(sc, cur, 0);\t/* no byte order issues with zero */\n      EN_WRAPADD(start, stop, cur, 4);\n    }\n    if (l->aal == MID_TBD_AAL5) {\n      EN_WRITE(sc, cur, l->pdu1); /* in host byte order */\n      EN_WRAPADD(start, stop, cur, 8);\n    }\n  }\n\n  if (addtail || dma != cur) {\n   /* write final descritor  */\n    EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, \n\t\t\t\tl->mlen, MID_DMA_END);\n    /* dma = cur; */ \t/* not necessary since we are done */\n  }\n\ndone:\n  /* update current pointer */\n  sc->txslot[chan].cur = cur;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: DONE!   cur now = 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n\n  return;\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */",
      "#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */",
      "#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */",
      "#define STATIC static",
      "#define STATIC /* nothing */",
      "#define EN_DIAG\t\t\t/* link in with master DIAG option */",
      "#define\tEN_DIAG"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: tx%d: DONE!   cur now = 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "chan",
            "cur"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "WORD_IDX(start,cur)",
            "chan",
            "MIDDMA_JK",
            "0",
            "l->mlen",
            "MID_DMA_END"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_IDX",
          "args": [
            "start",
            "cur"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "8"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "cur",
            "l->pdu1"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "4"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITEDAT",
          "args": [
            "sc",
            "cur",
            "0"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "pad",
            "chan",
            "bcode",
            "vtophys(l->t->m_data)",
            "0",
            "0"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "l->t->m_data"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "pad"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->tailflush"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "count",
            "chan",
            "bcode",
            "vtophys(data)",
            "l->mlen",
            "end"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "len"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->tailbyte"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "count",
            "chan",
            "bcode",
            "vtophys(data)",
            "l->mlen",
            "end"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "cnt"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "count",
            "chan",
            "bcode",
            "vtophys(data)",
            "l->mlen",
            "end"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "cnt"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "count",
            "chan",
            "bcode",
            "vtophys(data)",
            "l->mlen",
            "end"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "cnt"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "count",
            "chan",
            "bcode",
            "vtophys(data)",
            "l->mlen",
            "end"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "cnt"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cnt",
            "len"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->headbyte"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "len",
            "chan",
            "0",
            "vtophys(data)",
            "l->mlen",
            "end"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "data"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "len"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_TRAILINGSPACE",
          "args": [
            "tmp"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_DTQADD",
          "args": [
            "sc",
            "WORD_IDX(start,cur)",
            "chan",
            "MIDDMA_JK",
            "0",
            "0",
            "0"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_IDX",
          "args": [
            "start",
            "cur"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "4"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITEDAT",
          "args": [
            "sc",
            "cur",
            "*data"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "len",
            "sizeof(u_int32_t)"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "tmp",
            "u_int32_t*"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "4"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "cur",
            "l->tbd2"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "start",
            "stop",
            "cur",
            "4"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "cur",
            "l->tbd1"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_DESCSTART(chan)"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_DESCSTART",
          "args": [
            "chan"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_READPTR(chan)"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_READPTR",
          "args": [
            "chan"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_SZ",
          "args": [
            "count"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_BASE",
          "args": [
            "count"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_PLACE(chan)"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_PLACE",
          "args": [
            "chan"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */\n#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */\n#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_DIAG\t\t\t/* link in with master DIAG option */\n#define\tEN_DIAG\n\nSTATIC void en_txlaunch(sc, chan, l)\n\nstruct en_softc *sc;\nint chan;\nstruct en_launch *l;\n\n{\n  struct mbuf *tmp;\n  u_int32_t cur = sc->txslot[chan].cur,\n\t    start = sc->txslot[chan].start,\n\t    stop = sc->txslot[chan].stop,\n\t    dma, *data, *datastop, count, bcode;\n  int pad, addtail, need, len, needalign, cnt, end, mx;\n\n\n /*\n  * vars:\n  *   need = # bytes card still needs (decr. to zero)\n  *   len = # of bytes left in current mbuf\n  *   cur = our current pointer\n  *   dma = last place we programmed into the DMA\n  *   data = pointer into data area of mbuf that needs to go next\n  *   cnt = # of bytes to transfer in this DTQ\n  *   bcode/count = DMA burst code, and chip's version of cnt\n  *\n  *   a single buffer can require up to 5 DTQs depending on its size\n  *   and alignment requirements.   the 5 possible requests are:\n  *   [1] 1, 2, or 3 byte DMA to align src data pointer to word boundary\n  *   [2] alburst DMA to align src data pointer to bestburstlen\n  *   [3] 1 or more bestburstlen DMAs\n  *   [4] clean up burst (to last word boundary)\n  *   [5] 1, 2, or 3 byte final clean up DMA\n  */\n\n need = l->need;\n dma = cur;\n addtail = (l->atm_flags & EN_OBTRL) == 0;\t/* add a tail? */\n\n#ifdef EN_DIAG\n  if ((need - MID_TBD_SIZE) % MID_ATMDATASZ) \n    printf(\"%s: tx%d: bogus trasmit needs (%d)\\n\", sc->sc_dev.dv_xname, chan,\n\t\tneed);\n#endif\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: launch mbuf %p!   cur=0x%x[%d], need=%d, addtail=%d\\n\",\n\tsc->sc_dev.dv_xname, chan, l->t, cur, (cur-start)/4, need, addtail);\n  count = EN_READ(sc, MIDX_PLACE(chan));\n  printf(\"     HW: base_address=0x%x, size=%d, read=%d, descstart=%d\\n\",\n\tMIDX_BASE(count), MIDX_SZ(count), EN_READ(sc, MIDX_READPTR(chan)), \n\tEN_READ(sc, MIDX_DESCSTART(chan)));\n#endif\n\n /*\n  * do we need to insert the TBD by hand?\n  * note that tbd1/tbd2/pdu1 are in host byte order.\n  */\n\n  if ((l->atm_flags & EN_OBHDR) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: insert header 0x%x 0x%x\\n\", sc->sc_dev.dv_xname,\n\tchan, l->tbd1, l->tbd2);\n#endif\n    EN_WRITE(sc, cur, l->tbd1);\n    EN_WRAPADD(start, stop, cur, 4);\n    EN_WRITE(sc, cur, l->tbd2);\n    EN_WRAPADD(start, stop, cur, 4);\n    need -= 8;\n  }\n\n  /*\n   * now do the mbufs...\n   */\n\n  for (tmp = l->t ; tmp != NULL ; tmp = tmp->m_next) {\n\n    /* get pointer to data and length */\n    data = mtod(tmp, u_int32_t *);\n    len = tmp->m_len;\n    if (tmp == l->t) {\n      data += sizeof(struct atm_pseudohdr)/sizeof(u_int32_t);\n      len -= sizeof(struct atm_pseudohdr);\n    }\n\n    /* now, determine if we should copy it */\n    if (l->nodma || (len < EN_MINDMA &&\n       (len % 4) == 0 && ((unsigned long) data % 4) == 0 && (cur % 4) == 0)) {\n\n      /* \n       * roundup len: the only time this will change the value of len\n       * is when l->nodma is true, tmp is the last mbuf, and there is\n       * a non-word number of bytes to transmit.   in this case it is\n       * safe to round up because we've en_mfix'd the mbuf (so the first\n       * byte is word aligned there must be enough free bytes at the end\n       * to round off to the next word boundary)...\n       */\n      len = roundup(len, sizeof(u_int32_t));\n      datastop = data + (len / sizeof(u_int32_t));\n      /* copy loop: preserve byte order!!!  use WRITEDAT */\n      while (data != datastop) {\n\tEN_WRITEDAT(sc, cur, *data);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= len;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: copied %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      continue;\t\t/* continue on to next mbuf */\n    }\n\n    /* going to do DMA, first make sure the dtq is in sync. */\n    if (dma != cur) {\n      EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: dtq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n    }\n\n    /*\n     * if this is the last buffer, and it looks like we are going to need to\n     * flush the internal buffer, can we extend the length of this mbuf to\n     * avoid the FLUSH?\n     */\n\n    if (tmp->m_next == NULL) {\n      cnt = (need - len) % sizeof(u_int32_t);\n      if (cnt && M_TRAILINGSPACE(tmp) >= cnt)\n        len += cnt;\t\t\t/* pad for FLUSH */\n    }\n      \n#if !defined(MIDWAY_ENIONLY)\n\n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */\n\n    if (sc->is_adaptec) {\n      /* need to DMA \"len\" bytes out to card */\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: adp_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, len, chan, 0, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align to word boundary? */\n    needalign = (unsigned long) data % sizeof(u_int32_t);\n    if (needalign) {\n      EN_COUNT(sc->headbyte);\n      cnt = sizeof(u_int32_t) - needalign;\n      if (cnt == 2 && len >= cnt) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;\n      } else {\n        cnt = min(cnt, len);\t\t/* prevent overflow */\n        count = cnt;\n        bcode = MIDDMA_BYTE;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: small al_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst && \n\t(needalign = (((unsigned long) data) & sc->bestburstmask)) != 0\n\t&& len >= sizeof(u_int32_t)) {\n      cnt = sc->bestburstlen - needalign;\n      mx = len & ~(sizeof(u_int32_t)-1);\t/* don't go past end */\n      if (cnt > mx) {\n        cnt = mx;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: al_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a max-sized burst? */\n    if (len >= sc->bestburstlen) {\n      count = len >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: best_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a cleanup burst? */\n    cnt = len & ~(sizeof(u_int32_t)-1);\n    if (cnt) {\n      count = cnt / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = cnt >> en_dmaplan[count].divshift;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* any word fragments left? */\n    if (len) {\n      EN_COUNT(sc->tailbyte);\n      if (len == 2) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;                 /* use 2byte mode */\n      } else {\n        count = len;\n        bcode = MIDDMA_BYTE;                  /* use 1 byte mode */\n      }\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: byte cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n#endif /* !MIDWAY_ADPONLY */\n\n  } /* next mbuf, please */\n\n  /*\n   * all mbuf data has been copied out to the obmem (or set up to be DMAd).\n   * if the trailer or padding needs to be put in, do it now.  \n   *\n   * NOTE: experimental results reveal the following fact:\n   *   if you DMA \"X\" bytes to the card, where X is not a multiple of 4,\n   *   then the card will internally buffer the last (X % 4) bytes (in\n   *   hopes of getting (4 - (X % 4)) more bytes to make a complete word).\n   *   it is imporant to make sure we don't leave any important data in\n   *   this internal buffer because it is discarded on the last (end) DTQ.\n   *   one way to do this is to DMA in (4 - (X % 4)) more bytes to flush\n   *   the darn thing out.\n   */\n\n  if (addtail) {\n\n    pad = need % sizeof(u_int32_t);\n    if (pad) {\n      /*\n       * FLUSH internal data buffer.  pad out with random data from the front\n       * of the mbuf chain...\n       */\n      bcode = (sc->is_adaptec) ? 0 : MIDDMA_BYTE;\n      EN_COUNT(sc->tailflush);\n      EN_WRAPADD(start, stop, cur, pad);\n      EN_DTQADD(sc, pad, chan, bcode, vtophys(l->t->m_data), 0, 0);\n      need -= pad;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: pad/FLUSH dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad, need, cur);\n#endif\n    }\n\n    /* copy data */\n    pad = need / sizeof(u_int32_t);\t/* round *down* */\n    if (l->aal == MID_TBD_AAL5)\n      pad -= 2;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: padding %d bytes (cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad * sizeof(u_int32_t), cur);\n#endif\n    while (pad--) {\n      EN_WRITEDAT(sc, cur, 0);\t/* no byte order issues with zero */\n      EN_WRAPADD(start, stop, cur, 4);\n    }\n    if (l->aal == MID_TBD_AAL5) {\n      EN_WRITE(sc, cur, l->pdu1); /* in host byte order */\n      EN_WRAPADD(start, stop, cur, 8);\n    }\n  }\n\n  if (addtail || dma != cur) {\n   /* write final descritor  */\n    EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, \n\t\t\t\tl->mlen, MID_DMA_END);\n    /* dma = cur; */ \t/* not necessary since we are done */\n  }\n\ndone:\n  /* update current pointer */\n  sc->txslot[chan].cur = cur;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: DONE!   cur now = 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n\n  return;\n}"
  },
  {
    "function_name": "en_txdma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1746-1940",
    "snippet": "STATIC void en_txdma(sc, chan)\n\nstruct en_softc *sc;\nint chan;\n\n{\n  struct mbuf *tmp;\n  struct atm_pseudohdr *ap;\n  struct en_launch launch;\n  int datalen = 0, dtqneed, len, ncells;\n  u_int8_t *cp;\n\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: starting...\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n\n  /*\n   * note: now that txlaunch handles non-word aligned/sized requests\n   * the only time you can safely set launch.nodma is if you've en_mfix()'d\n   * the mbuf chain.    this happens only if EN_NOTXDMA || !en_dma.\n   */\n\n  launch.nodma = (EN_NOTXDMA || !en_dma);\n\nagain:\n\n  /*\n   * get an mbuf waiting for DMA\n   */\n\n  launch.t = sc->txslot[chan].q.ifq_head; /* peek at head of queue */\n\n  if (launch.t == NULL) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: ...done!\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t/* >>> exit here if no data waiting for DMA <<< */\n  }\n\n  /*\n   * get flags, vci\n   * \n   * note: launch.need = # bytes we need to get on the card\n   *\t   dtqneed = # of DTQs we need for this packet\n   *       launch.mlen = # of bytes in in mbuf chain (<= launch.need)\n   */\n\n  ap = mtod(launch.t, struct atm_pseudohdr *);\n  launch.atm_vci = ATM_PH_VCI(ap);\n  launch.atm_flags = ATM_PH_FLAGS(ap);\n  launch.aal = ((launch.atm_flags & ATM_PH_AAL5) != 0) ? \n\t\tMID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n  /*\n   * XXX: have to recompute the length again, even though we already did\n   * it in en_start().   might as well compute dtqneed here as well, so \n   * this isn't that bad.\n   */\n\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    dtqneed = 1;\t\t/* header still needs to be added */\n    launch.need = MID_TBD_SIZE;\t/* not includeded with mbuf */\n  } else {\n    dtqneed = 0;\t\t/* header on-board, dma with mbuf */\n    launch.need = 0;\n  }\n\n  launch.mlen = 0;\n  for (tmp = launch.t ; tmp != NULL ; tmp = tmp->m_next) {\n    len = tmp->m_len;\n    launch.mlen += len;\n    cp = mtod(tmp, u_int8_t *);\n    if (tmp == launch.t) {\n      len -= sizeof(struct atm_pseudohdr); /* don't count this! */\n      cp += sizeof(struct atm_pseudohdr);\n    }\n    launch.need += len;\n    if (len == 0)\n      continue;\t\t\t/* atm_pseudohdr alone in first mbuf */\n\n    dtqneed += en_dqneed(sc, (caddr_t) cp, len, 1);\n  }\n\n  if ((launch.need % sizeof(u_int32_t)) != 0) \n    dtqneed++;\t\t\t/* need DTQ to FLUSH internal buffer */\n\n  if ((launch.atm_flags & EN_OBTRL) == 0) {\n    if (launch.aal == MID_TBD_AAL5) {\n      datalen = launch.need - MID_TBD_SIZE;\n      launch.need += MID_PDU_SIZE;\t\t/* AAL5: need PDU tail */\n    }\n    dtqneed++;\t\t\t/* need to work on the end a bit */\n  }\n\n  /*\n   * finish calculation of launch.need (need to figure out how much padding\n   * we will need).   launch.need includes MID_TBD_SIZE, but we need to\n   * remove that to so we can round off properly.     we have to add \n   * MID_TBD_SIZE back in after calculating ncells.\n   */\n\n  launch.need = roundup(launch.need - MID_TBD_SIZE, MID_ATMDATASZ);\n  ncells = launch.need / MID_ATMDATASZ;\n  launch.need += MID_TBD_SIZE;\n\n  if (launch.need > EN_TXSZ * 1024) {\n    printf(\"%s: tx%d: packet larger than xmit buffer (%d > %d)\\n\",\n      sc->sc_dev.dv_xname, chan, launch.need, EN_TXSZ * 1024);\n    goto dequeue_drop;\n  }\n\n  /*\n   * note: note that we cannot totally fill the circular buffer (i.e.\n   * we can't use up all of the remaining sc->txslot[chan].bfree free\n   * bytes) because that would cause the circular buffer read pointer\n   * to become equal to the write pointer, thus signaling 'empty buffer'\n   * to the hardware and stopping the transmitter.\n   */\n  if (launch.need >= sc->txslot[chan].bfree) {\n    EN_COUNT(sc->txoutspace);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit space\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of obmem buffer space <<< */\n  }\n  \n  /*\n   * ensure we have enough dtqs to go, if not, wait for more.\n   */\n\n  if (launch.nodma) {\n    dtqneed = 1;\n  }\n  if (dtqneed > sc->dtq_free) {\n    sc->need_dtqs = 1;\n    EN_COUNT(sc->txdtqout);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit DTQs\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of dtqs <<< */\n  }\n\n  /*\n   * it is a go, commit!  dequeue mbuf start working on the xfer.\n   */\n\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n#ifdef EN_DIAG\n  if (launch.t != tmp)\n    panic(\"en dequeue\");\n#endif /* EN_DIAG */\n\n  /*\n   * launch!\n   */\n\n  EN_COUNT(sc->launch);\n  sc->enif.if_opackets++;\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    EN_COUNT(sc->lheader);\n    /* store tbd1/tbd2 in host byte order */\n    launch.tbd1 = MID_TBD_MK1(launch.aal, sc->txspeed[launch.atm_vci], ncells);\n    launch.tbd2 = MID_TBD_MK2(launch.atm_vci, 0, 0);\n  }\n  if ((launch.atm_flags & EN_OBTRL) == 0 && launch.aal == MID_TBD_AAL5) {\n    EN_COUNT(sc->ltail);\n    launch.pdu1 = MID_PDU_MK1(0, 0, datalen);  /* host byte order */\n  }\n\n  en_txlaunch(sc, chan, &launch);\n  \n  /*\n   * do some housekeeping and get the next packet\n   */\n\n  sc->txslot[chan].bfree -= launch.need;\n  IF_ENQUEUE(&sc->txslot[chan].indma, launch.t);\n  goto again;\n\n  /*\n   * END of txdma loop!\n   */\n\n  /*\n   * error handles\n   */\n\ndequeue_drop:\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n  if (launch.t != tmp)\n    panic(\"en dequeue drop\");\n  m_freem(launch.t);\n  sc->txslot[chan].mbsize -= launch.mlen;\n  goto again;\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */",
      "#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */",
      "#define STATIC static",
      "#define STATIC /* nothing */",
      "#define EN_DIAG\t\t\t/* link in with master DIAG option */",
      "#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */",
      "#define\tEN_DIAG"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "launch.t"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en dequeue drop\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->txslot[chan].q",
            "tmp"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&sc->txslot[chan].indma",
            "launch.t"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_txlaunch",
          "args": [
            "sc",
            "chan",
            "&launch"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "en_txlaunch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1947-2297",
          "snippet": "STATIC void en_txlaunch(sc, chan, l)\n\nstruct en_softc *sc;\nint chan;\nstruct en_launch *l;\n\n{\n  struct mbuf *tmp;\n  u_int32_t cur = sc->txslot[chan].cur,\n\t    start = sc->txslot[chan].start,\n\t    stop = sc->txslot[chan].stop,\n\t    dma, *data, *datastop, count, bcode;\n  int pad, addtail, need, len, needalign, cnt, end, mx;\n\n\n /*\n  * vars:\n  *   need = # bytes card still needs (decr. to zero)\n  *   len = # of bytes left in current mbuf\n  *   cur = our current pointer\n  *   dma = last place we programmed into the DMA\n  *   data = pointer into data area of mbuf that needs to go next\n  *   cnt = # of bytes to transfer in this DTQ\n  *   bcode/count = DMA burst code, and chip's version of cnt\n  *\n  *   a single buffer can require up to 5 DTQs depending on its size\n  *   and alignment requirements.   the 5 possible requests are:\n  *   [1] 1, 2, or 3 byte DMA to align src data pointer to word boundary\n  *   [2] alburst DMA to align src data pointer to bestburstlen\n  *   [3] 1 or more bestburstlen DMAs\n  *   [4] clean up burst (to last word boundary)\n  *   [5] 1, 2, or 3 byte final clean up DMA\n  */\n\n need = l->need;\n dma = cur;\n addtail = (l->atm_flags & EN_OBTRL) == 0;\t/* add a tail? */\n\n#ifdef EN_DIAG\n  if ((need - MID_TBD_SIZE) % MID_ATMDATASZ) \n    printf(\"%s: tx%d: bogus trasmit needs (%d)\\n\", sc->sc_dev.dv_xname, chan,\n\t\tneed);\n#endif\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: launch mbuf %p!   cur=0x%x[%d], need=%d, addtail=%d\\n\",\n\tsc->sc_dev.dv_xname, chan, l->t, cur, (cur-start)/4, need, addtail);\n  count = EN_READ(sc, MIDX_PLACE(chan));\n  printf(\"     HW: base_address=0x%x, size=%d, read=%d, descstart=%d\\n\",\n\tMIDX_BASE(count), MIDX_SZ(count), EN_READ(sc, MIDX_READPTR(chan)), \n\tEN_READ(sc, MIDX_DESCSTART(chan)));\n#endif\n\n /*\n  * do we need to insert the TBD by hand?\n  * note that tbd1/tbd2/pdu1 are in host byte order.\n  */\n\n  if ((l->atm_flags & EN_OBHDR) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: insert header 0x%x 0x%x\\n\", sc->sc_dev.dv_xname,\n\tchan, l->tbd1, l->tbd2);\n#endif\n    EN_WRITE(sc, cur, l->tbd1);\n    EN_WRAPADD(start, stop, cur, 4);\n    EN_WRITE(sc, cur, l->tbd2);\n    EN_WRAPADD(start, stop, cur, 4);\n    need -= 8;\n  }\n\n  /*\n   * now do the mbufs...\n   */\n\n  for (tmp = l->t ; tmp != NULL ; tmp = tmp->m_next) {\n\n    /* get pointer to data and length */\n    data = mtod(tmp, u_int32_t *);\n    len = tmp->m_len;\n    if (tmp == l->t) {\n      data += sizeof(struct atm_pseudohdr)/sizeof(u_int32_t);\n      len -= sizeof(struct atm_pseudohdr);\n    }\n\n    /* now, determine if we should copy it */\n    if (l->nodma || (len < EN_MINDMA &&\n       (len % 4) == 0 && ((unsigned long) data % 4) == 0 && (cur % 4) == 0)) {\n\n      /* \n       * roundup len: the only time this will change the value of len\n       * is when l->nodma is true, tmp is the last mbuf, and there is\n       * a non-word number of bytes to transmit.   in this case it is\n       * safe to round up because we've en_mfix'd the mbuf (so the first\n       * byte is word aligned there must be enough free bytes at the end\n       * to round off to the next word boundary)...\n       */\n      len = roundup(len, sizeof(u_int32_t));\n      datastop = data + (len / sizeof(u_int32_t));\n      /* copy loop: preserve byte order!!!  use WRITEDAT */\n      while (data != datastop) {\n\tEN_WRITEDAT(sc, cur, *data);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= len;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: copied %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      continue;\t\t/* continue on to next mbuf */\n    }\n\n    /* going to do DMA, first make sure the dtq is in sync. */\n    if (dma != cur) {\n      EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: dtq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n    }\n\n    /*\n     * if this is the last buffer, and it looks like we are going to need to\n     * flush the internal buffer, can we extend the length of this mbuf to\n     * avoid the FLUSH?\n     */\n\n    if (tmp->m_next == NULL) {\n      cnt = (need - len) % sizeof(u_int32_t);\n      if (cnt && M_TRAILINGSPACE(tmp) >= cnt)\n        len += cnt;\t\t\t/* pad for FLUSH */\n    }\n      \n#if !defined(MIDWAY_ENIONLY)\n\n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */\n\n    if (sc->is_adaptec) {\n      /* need to DMA \"len\" bytes out to card */\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: adp_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, len, chan, 0, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align to word boundary? */\n    needalign = (unsigned long) data % sizeof(u_int32_t);\n    if (needalign) {\n      EN_COUNT(sc->headbyte);\n      cnt = sizeof(u_int32_t) - needalign;\n      if (cnt == 2 && len >= cnt) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;\n      } else {\n        cnt = min(cnt, len);\t\t/* prevent overflow */\n        count = cnt;\n        bcode = MIDDMA_BYTE;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: small al_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst && \n\t(needalign = (((unsigned long) data) & sc->bestburstmask)) != 0\n\t&& len >= sizeof(u_int32_t)) {\n      cnt = sc->bestburstlen - needalign;\n      mx = len & ~(sizeof(u_int32_t)-1);\t/* don't go past end */\n      if (cnt > mx) {\n        cnt = mx;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: al_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a max-sized burst? */\n    if (len >= sc->bestburstlen) {\n      count = len >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: best_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a cleanup burst? */\n    cnt = len & ~(sizeof(u_int32_t)-1);\n    if (cnt) {\n      count = cnt / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = cnt >> en_dmaplan[count].divshift;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* any word fragments left? */\n    if (len) {\n      EN_COUNT(sc->tailbyte);\n      if (len == 2) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;                 /* use 2byte mode */\n      } else {\n        count = len;\n        bcode = MIDDMA_BYTE;                  /* use 1 byte mode */\n      }\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: byte cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n#endif /* !MIDWAY_ADPONLY */\n\n  } /* next mbuf, please */\n\n  /*\n   * all mbuf data has been copied out to the obmem (or set up to be DMAd).\n   * if the trailer or padding needs to be put in, do it now.  \n   *\n   * NOTE: experimental results reveal the following fact:\n   *   if you DMA \"X\" bytes to the card, where X is not a multiple of 4,\n   *   then the card will internally buffer the last (X % 4) bytes (in\n   *   hopes of getting (4 - (X % 4)) more bytes to make a complete word).\n   *   it is imporant to make sure we don't leave any important data in\n   *   this internal buffer because it is discarded on the last (end) DTQ.\n   *   one way to do this is to DMA in (4 - (X % 4)) more bytes to flush\n   *   the darn thing out.\n   */\n\n  if (addtail) {\n\n    pad = need % sizeof(u_int32_t);\n    if (pad) {\n      /*\n       * FLUSH internal data buffer.  pad out with random data from the front\n       * of the mbuf chain...\n       */\n      bcode = (sc->is_adaptec) ? 0 : MIDDMA_BYTE;\n      EN_COUNT(sc->tailflush);\n      EN_WRAPADD(start, stop, cur, pad);\n      EN_DTQADD(sc, pad, chan, bcode, vtophys(l->t->m_data), 0, 0);\n      need -= pad;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: pad/FLUSH dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad, need, cur);\n#endif\n    }\n\n    /* copy data */\n    pad = need / sizeof(u_int32_t);\t/* round *down* */\n    if (l->aal == MID_TBD_AAL5)\n      pad -= 2;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: padding %d bytes (cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad * sizeof(u_int32_t), cur);\n#endif\n    while (pad--) {\n      EN_WRITEDAT(sc, cur, 0);\t/* no byte order issues with zero */\n      EN_WRAPADD(start, stop, cur, 4);\n    }\n    if (l->aal == MID_TBD_AAL5) {\n      EN_WRITE(sc, cur, l->pdu1); /* in host byte order */\n      EN_WRAPADD(start, stop, cur, 8);\n    }\n  }\n\n  if (addtail || dma != cur) {\n   /* write final descritor  */\n    EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, \n\t\t\t\tl->mlen, MID_DMA_END);\n    /* dma = cur; */ \t/* not necessary since we are done */\n  }\n\ndone:\n  /* update current pointer */\n  sc->txslot[chan].cur = cur;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: DONE!   cur now = 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n\n  return;\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */",
            "#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */",
            "#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */",
            "#define STATIC static",
            "#define STATIC /* nothing */",
            "#define EN_DIAG\t\t\t/* link in with master DIAG option */",
            "#define\tEN_DIAG"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */\n#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */\n#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_DIAG\t\t\t/* link in with master DIAG option */\n#define\tEN_DIAG\n\nSTATIC void en_txlaunch(sc, chan, l)\n\nstruct en_softc *sc;\nint chan;\nstruct en_launch *l;\n\n{\n  struct mbuf *tmp;\n  u_int32_t cur = sc->txslot[chan].cur,\n\t    start = sc->txslot[chan].start,\n\t    stop = sc->txslot[chan].stop,\n\t    dma, *data, *datastop, count, bcode;\n  int pad, addtail, need, len, needalign, cnt, end, mx;\n\n\n /*\n  * vars:\n  *   need = # bytes card still needs (decr. to zero)\n  *   len = # of bytes left in current mbuf\n  *   cur = our current pointer\n  *   dma = last place we programmed into the DMA\n  *   data = pointer into data area of mbuf that needs to go next\n  *   cnt = # of bytes to transfer in this DTQ\n  *   bcode/count = DMA burst code, and chip's version of cnt\n  *\n  *   a single buffer can require up to 5 DTQs depending on its size\n  *   and alignment requirements.   the 5 possible requests are:\n  *   [1] 1, 2, or 3 byte DMA to align src data pointer to word boundary\n  *   [2] alburst DMA to align src data pointer to bestburstlen\n  *   [3] 1 or more bestburstlen DMAs\n  *   [4] clean up burst (to last word boundary)\n  *   [5] 1, 2, or 3 byte final clean up DMA\n  */\n\n need = l->need;\n dma = cur;\n addtail = (l->atm_flags & EN_OBTRL) == 0;\t/* add a tail? */\n\n#ifdef EN_DIAG\n  if ((need - MID_TBD_SIZE) % MID_ATMDATASZ) \n    printf(\"%s: tx%d: bogus trasmit needs (%d)\\n\", sc->sc_dev.dv_xname, chan,\n\t\tneed);\n#endif\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: launch mbuf %p!   cur=0x%x[%d], need=%d, addtail=%d\\n\",\n\tsc->sc_dev.dv_xname, chan, l->t, cur, (cur-start)/4, need, addtail);\n  count = EN_READ(sc, MIDX_PLACE(chan));\n  printf(\"     HW: base_address=0x%x, size=%d, read=%d, descstart=%d\\n\",\n\tMIDX_BASE(count), MIDX_SZ(count), EN_READ(sc, MIDX_READPTR(chan)), \n\tEN_READ(sc, MIDX_DESCSTART(chan)));\n#endif\n\n /*\n  * do we need to insert the TBD by hand?\n  * note that tbd1/tbd2/pdu1 are in host byte order.\n  */\n\n  if ((l->atm_flags & EN_OBHDR) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: insert header 0x%x 0x%x\\n\", sc->sc_dev.dv_xname,\n\tchan, l->tbd1, l->tbd2);\n#endif\n    EN_WRITE(sc, cur, l->tbd1);\n    EN_WRAPADD(start, stop, cur, 4);\n    EN_WRITE(sc, cur, l->tbd2);\n    EN_WRAPADD(start, stop, cur, 4);\n    need -= 8;\n  }\n\n  /*\n   * now do the mbufs...\n   */\n\n  for (tmp = l->t ; tmp != NULL ; tmp = tmp->m_next) {\n\n    /* get pointer to data and length */\n    data = mtod(tmp, u_int32_t *);\n    len = tmp->m_len;\n    if (tmp == l->t) {\n      data += sizeof(struct atm_pseudohdr)/sizeof(u_int32_t);\n      len -= sizeof(struct atm_pseudohdr);\n    }\n\n    /* now, determine if we should copy it */\n    if (l->nodma || (len < EN_MINDMA &&\n       (len % 4) == 0 && ((unsigned long) data % 4) == 0 && (cur % 4) == 0)) {\n\n      /* \n       * roundup len: the only time this will change the value of len\n       * is when l->nodma is true, tmp is the last mbuf, and there is\n       * a non-word number of bytes to transmit.   in this case it is\n       * safe to round up because we've en_mfix'd the mbuf (so the first\n       * byte is word aligned there must be enough free bytes at the end\n       * to round off to the next word boundary)...\n       */\n      len = roundup(len, sizeof(u_int32_t));\n      datastop = data + (len / sizeof(u_int32_t));\n      /* copy loop: preserve byte order!!!  use WRITEDAT */\n      while (data != datastop) {\n\tEN_WRITEDAT(sc, cur, *data);\n\tdata++;\n\tEN_WRAPADD(start, stop, cur, 4);\n      }\n      need -= len;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: copied %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      continue;\t\t/* continue on to next mbuf */\n    }\n\n    /* going to do DMA, first make sure the dtq is in sync. */\n    if (dma != cur) {\n      EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, 0, 0);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: dtq_sync: advance pointer to %d\\n\",\n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n    }\n\n    /*\n     * if this is the last buffer, and it looks like we are going to need to\n     * flush the internal buffer, can we extend the length of this mbuf to\n     * avoid the FLUSH?\n     */\n\n    if (tmp->m_next == NULL) {\n      cnt = (need - len) % sizeof(u_int32_t);\n      if (cnt && M_TRAILINGSPACE(tmp) >= cnt)\n        len += cnt;\t\t\t/* pad for FLUSH */\n    }\n      \n#if !defined(MIDWAY_ENIONLY)\n\n    /*\n     * the adaptec DMA engine is smart and handles everything for us.\n     */\n\n    if (sc->is_adaptec) {\n      /* need to DMA \"len\" bytes out to card */\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: adp_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, len, chan, 0, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      dma = cur;\t/* update dma pointer */\n      continue;\n    }\n#endif /* !MIDWAY_ENIONLY */\n\n#if !defined(MIDWAY_ADPONLY)\n\n    /*\n     * the ENI DMA engine is not so smart and need more help from us\n     */\n\n    /* do we need to do a DMA op to align to word boundary? */\n    needalign = (unsigned long) data % sizeof(u_int32_t);\n    if (needalign) {\n      EN_COUNT(sc->headbyte);\n      cnt = sizeof(u_int32_t) - needalign;\n      if (cnt == 2 && len >= cnt) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;\n      } else {\n        cnt = min(cnt, len);\t\t/* prevent overflow */\n        count = cnt;\n        bcode = MIDDMA_BYTE;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: small al_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a DMA op to align? */\n    if (sc->alburst && \n\t(needalign = (((unsigned long) data) & sc->bestburstmask)) != 0\n\t&& len >= sizeof(u_int32_t)) {\n      cnt = sc->bestburstlen - needalign;\n      mx = len & ~(sizeof(u_int32_t)-1);\t/* don't go past end */\n      if (cnt > mx) {\n        cnt = mx;\n        count = cnt / sizeof(u_int32_t);\n        bcode = MIDDMA_WORD;\n      } else {\n        count = cnt / sizeof(u_int32_t);\n        bcode = en_dmaplan[count].bcode;\n        count = cnt >> en_dmaplan[count].divshift;\n      }\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: al_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a max-sized burst? */\n    if (len >= sc->bestburstlen) {\n      count = len >> sc->bestburstshift;\n      cnt = count << sc->bestburstshift;\n      bcode = sc->bestburstcode;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: best_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* do we need to do a cleanup burst? */\n    cnt = len & ~(sizeof(u_int32_t)-1);\n    if (cnt) {\n      count = cnt / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = cnt >> en_dmaplan[count].divshift;\n      need -= cnt;\n      EN_WRAPADD(start, stop, cur, cnt);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cnt, need, cur);\n#endif\n      len -= cnt;\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n      data = (u_int32_t *) ((u_char *)data + cnt);\n    }\n\n    /* any word fragments left? */\n    if (len) {\n      EN_COUNT(sc->tailbyte);\n      if (len == 2) {\n        count = 1;\n        bcode = MIDDMA_2BYTE;                 /* use 2byte mode */\n      } else {\n        count = len;\n        bcode = MIDDMA_BYTE;                  /* use 1 byte mode */\n      }\n      need -= len;\n      EN_WRAPADD(start, stop, cur, len);\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: byte cleanup_dma %d bytes (%d left, cur now 0x%x)\\n\",\n              sc->sc_dev.dv_xname, chan, len, need, cur);\n#endif\n      end = (need == 0) ? MID_DMA_END : 0;\n      EN_DTQADD(sc, count, chan, bcode, vtophys(data), l->mlen, end);\n      if (end)\n        goto done;\n    }\n\n    dma = cur;\t\t/* update dma pointer */\n#endif /* !MIDWAY_ADPONLY */\n\n  } /* next mbuf, please */\n\n  /*\n   * all mbuf data has been copied out to the obmem (or set up to be DMAd).\n   * if the trailer or padding needs to be put in, do it now.  \n   *\n   * NOTE: experimental results reveal the following fact:\n   *   if you DMA \"X\" bytes to the card, where X is not a multiple of 4,\n   *   then the card will internally buffer the last (X % 4) bytes (in\n   *   hopes of getting (4 - (X % 4)) more bytes to make a complete word).\n   *   it is imporant to make sure we don't leave any important data in\n   *   this internal buffer because it is discarded on the last (end) DTQ.\n   *   one way to do this is to DMA in (4 - (X % 4)) more bytes to flush\n   *   the darn thing out.\n   */\n\n  if (addtail) {\n\n    pad = need % sizeof(u_int32_t);\n    if (pad) {\n      /*\n       * FLUSH internal data buffer.  pad out with random data from the front\n       * of the mbuf chain...\n       */\n      bcode = (sc->is_adaptec) ? 0 : MIDDMA_BYTE;\n      EN_COUNT(sc->tailflush);\n      EN_WRAPADD(start, stop, cur, pad);\n      EN_DTQADD(sc, pad, chan, bcode, vtophys(l->t->m_data), 0, 0);\n      need -= pad;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: pad/FLUSH dma %d bytes (%d left, cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad, need, cur);\n#endif\n    }\n\n    /* copy data */\n    pad = need / sizeof(u_int32_t);\t/* round *down* */\n    if (l->aal == MID_TBD_AAL5)\n      pad -= 2;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: padding %d bytes (cur now 0x%x)\\n\", \n\t\tsc->sc_dev.dv_xname, chan, pad * sizeof(u_int32_t), cur);\n#endif\n    while (pad--) {\n      EN_WRITEDAT(sc, cur, 0);\t/* no byte order issues with zero */\n      EN_WRAPADD(start, stop, cur, 4);\n    }\n    if (l->aal == MID_TBD_AAL5) {\n      EN_WRITE(sc, cur, l->pdu1); /* in host byte order */\n      EN_WRAPADD(start, stop, cur, 8);\n    }\n  }\n\n  if (addtail || dma != cur) {\n   /* write final descritor  */\n    EN_DTQADD(sc, WORD_IDX(start,cur), chan, MIDDMA_JK, 0, \n\t\t\t\tl->mlen, MID_DMA_END);\n    /* dma = cur; */ \t/* not necessary since we are done */\n  }\n\ndone:\n  /* update current pointer */\n  sc->txslot[chan].cur = cur;\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: DONE!   cur now = 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, chan, cur);\n#endif\n\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MID_PDU_MK1",
          "args": [
            "0",
            "0",
            "datalen"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->ltail"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_TBD_MK2",
          "args": [
            "launch.atm_vci",
            "0",
            "0"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_TBD_MK1",
          "args": [
            "launch.aal",
            "sc->txspeed[launch.atm_vci]",
            "ncells"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->lheader"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->launch"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en dequeue\""
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->txslot[chan].q",
            "tmp"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: tx%d: out of transmit DTQs\\n\"",
            "sc->sc_dev.dv_xname",
            "chan"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->txdtqout"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->txoutspace"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "launch.need - MID_TBD_SIZE",
            "MID_ATMDATASZ"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_dqneed",
          "args": [
            "sc",
            "(caddr_t) cp",
            "len",
            "1"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "en_dqneed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "535-592",
          "snippet": "int en_dqneed(sc, data, len, tx)\n\nstruct en_softc *sc;\ncaddr_t data;\nu_int len, tx;\n\n{\n  int result, needalign, sz;\n\n#if !defined(MIDWAY_ENIONLY)\n#if !defined(MIDWAY_ADPONLY)\n    if (sc->is_adaptec)\n#endif /* !MIDWAY_ADPONLY */\n      return(1);\t/* adaptec can DMA anything in one go */\n#endif\n    \n#if !defined(MIDWAY_ADPONLY)\n    result = 0;\n    if (len < EN_MINDMA) {\n      if (!tx)\t\t\t/* XXX: conservative */\n        return(1);\t\t/* will copy/DMA_JK */\n    }\n\n    if (tx) {\t\t\t/* byte burst? */\n      needalign = (((unsigned long) data) % sizeof(u_int32_t));\n      if (needalign) {\n        result++;\n        sz = min(len, sizeof(u_int32_t) - needalign);\n        len -= sz;\n        data += sz;\n      }\n    }\n\n    if (sc->alburst && len) {\n      needalign = (((unsigned long) data) & sc->bestburstmask);\n      if (needalign) {\n\tresult++;\t\t/* alburst */\n        sz = min(len, sc->bestburstlen - needalign);\n        len -= sz;\n      }\n    }\n\n    if (len >= sc->bestburstlen) {\n      sz = len / sc->bestburstlen;\n      sz = sz * sc->bestburstlen;\n      len -= sz;\n      result++;\t\t\t/* best shot */\n    }\n    \n    if (len) {\n      result++;\t\t\t/* clean up */\n      if (tx && (len % sizeof(u_int32_t)) != 0)\n        result++;\t\t/* byte cleanup */\n    }\n\n    return(result);\n#endif\t/* !MIDWAY_ADPONLY */\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */\n\nint en_dqneed(sc, data, len, tx)\n\nstruct en_softc *sc;\ncaddr_t data;\nu_int len, tx;\n\n{\n  int result, needalign, sz;\n\n#if !defined(MIDWAY_ENIONLY)\n#if !defined(MIDWAY_ADPONLY)\n    if (sc->is_adaptec)\n#endif /* !MIDWAY_ADPONLY */\n      return(1);\t/* adaptec can DMA anything in one go */\n#endif\n    \n#if !defined(MIDWAY_ADPONLY)\n    result = 0;\n    if (len < EN_MINDMA) {\n      if (!tx)\t\t\t/* XXX: conservative */\n        return(1);\t\t/* will copy/DMA_JK */\n    }\n\n    if (tx) {\t\t\t/* byte burst? */\n      needalign = (((unsigned long) data) % sizeof(u_int32_t));\n      if (needalign) {\n        result++;\n        sz = min(len, sizeof(u_int32_t) - needalign);\n        len -= sz;\n        data += sz;\n      }\n    }\n\n    if (sc->alburst && len) {\n      needalign = (((unsigned long) data) & sc->bestburstmask);\n      if (needalign) {\n\tresult++;\t\t/* alburst */\n        sz = min(len, sc->bestburstlen - needalign);\n        len -= sz;\n      }\n    }\n\n    if (len >= sc->bestburstlen) {\n      sz = len / sc->bestburstlen;\n      sz = sz * sc->bestburstlen;\n      len -= sz;\n      result++;\t\t\t/* best shot */\n    }\n    \n    if (len) {\n      result++;\t\t\t/* clean up */\n      if (tx && (len % sizeof(u_int32_t)) != 0)\n        result++;\t\t/* byte cleanup */\n    }\n\n    return(result);\n#endif\t/* !MIDWAY_ADPONLY */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "tmp",
            "u_int8_t*"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_FLAGS",
          "args": [
            "ap"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_VCI",
          "args": [
            "ap"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "launch.t",
            "structatm_pseudohdr*"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */\n#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_DIAG\t\t\t/* link in with master DIAG option */\n#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */\n#define\tEN_DIAG\n\nSTATIC void en_txdma(sc, chan)\n\nstruct en_softc *sc;\nint chan;\n\n{\n  struct mbuf *tmp;\n  struct atm_pseudohdr *ap;\n  struct en_launch launch;\n  int datalen = 0, dtqneed, len, ncells;\n  u_int8_t *cp;\n\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: starting...\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n\n  /*\n   * note: now that txlaunch handles non-word aligned/sized requests\n   * the only time you can safely set launch.nodma is if you've en_mfix()'d\n   * the mbuf chain.    this happens only if EN_NOTXDMA || !en_dma.\n   */\n\n  launch.nodma = (EN_NOTXDMA || !en_dma);\n\nagain:\n\n  /*\n   * get an mbuf waiting for DMA\n   */\n\n  launch.t = sc->txslot[chan].q.ifq_head; /* peek at head of queue */\n\n  if (launch.t == NULL) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: ...done!\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t/* >>> exit here if no data waiting for DMA <<< */\n  }\n\n  /*\n   * get flags, vci\n   * \n   * note: launch.need = # bytes we need to get on the card\n   *\t   dtqneed = # of DTQs we need for this packet\n   *       launch.mlen = # of bytes in in mbuf chain (<= launch.need)\n   */\n\n  ap = mtod(launch.t, struct atm_pseudohdr *);\n  launch.atm_vci = ATM_PH_VCI(ap);\n  launch.atm_flags = ATM_PH_FLAGS(ap);\n  launch.aal = ((launch.atm_flags & ATM_PH_AAL5) != 0) ? \n\t\tMID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n  /*\n   * XXX: have to recompute the length again, even though we already did\n   * it in en_start().   might as well compute dtqneed here as well, so \n   * this isn't that bad.\n   */\n\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    dtqneed = 1;\t\t/* header still needs to be added */\n    launch.need = MID_TBD_SIZE;\t/* not includeded with mbuf */\n  } else {\n    dtqneed = 0;\t\t/* header on-board, dma with mbuf */\n    launch.need = 0;\n  }\n\n  launch.mlen = 0;\n  for (tmp = launch.t ; tmp != NULL ; tmp = tmp->m_next) {\n    len = tmp->m_len;\n    launch.mlen += len;\n    cp = mtod(tmp, u_int8_t *);\n    if (tmp == launch.t) {\n      len -= sizeof(struct atm_pseudohdr); /* don't count this! */\n      cp += sizeof(struct atm_pseudohdr);\n    }\n    launch.need += len;\n    if (len == 0)\n      continue;\t\t\t/* atm_pseudohdr alone in first mbuf */\n\n    dtqneed += en_dqneed(sc, (caddr_t) cp, len, 1);\n  }\n\n  if ((launch.need % sizeof(u_int32_t)) != 0) \n    dtqneed++;\t\t\t/* need DTQ to FLUSH internal buffer */\n\n  if ((launch.atm_flags & EN_OBTRL) == 0) {\n    if (launch.aal == MID_TBD_AAL5) {\n      datalen = launch.need - MID_TBD_SIZE;\n      launch.need += MID_PDU_SIZE;\t\t/* AAL5: need PDU tail */\n    }\n    dtqneed++;\t\t\t/* need to work on the end a bit */\n  }\n\n  /*\n   * finish calculation of launch.need (need to figure out how much padding\n   * we will need).   launch.need includes MID_TBD_SIZE, but we need to\n   * remove that to so we can round off properly.     we have to add \n   * MID_TBD_SIZE back in after calculating ncells.\n   */\n\n  launch.need = roundup(launch.need - MID_TBD_SIZE, MID_ATMDATASZ);\n  ncells = launch.need / MID_ATMDATASZ;\n  launch.need += MID_TBD_SIZE;\n\n  if (launch.need > EN_TXSZ * 1024) {\n    printf(\"%s: tx%d: packet larger than xmit buffer (%d > %d)\\n\",\n      sc->sc_dev.dv_xname, chan, launch.need, EN_TXSZ * 1024);\n    goto dequeue_drop;\n  }\n\n  /*\n   * note: note that we cannot totally fill the circular buffer (i.e.\n   * we can't use up all of the remaining sc->txslot[chan].bfree free\n   * bytes) because that would cause the circular buffer read pointer\n   * to become equal to the write pointer, thus signaling 'empty buffer'\n   * to the hardware and stopping the transmitter.\n   */\n  if (launch.need >= sc->txslot[chan].bfree) {\n    EN_COUNT(sc->txoutspace);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit space\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of obmem buffer space <<< */\n  }\n  \n  /*\n   * ensure we have enough dtqs to go, if not, wait for more.\n   */\n\n  if (launch.nodma) {\n    dtqneed = 1;\n  }\n  if (dtqneed > sc->dtq_free) {\n    sc->need_dtqs = 1;\n    EN_COUNT(sc->txdtqout);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit DTQs\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of dtqs <<< */\n  }\n\n  /*\n   * it is a go, commit!  dequeue mbuf start working on the xfer.\n   */\n\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n#ifdef EN_DIAG\n  if (launch.t != tmp)\n    panic(\"en dequeue\");\n#endif /* EN_DIAG */\n\n  /*\n   * launch!\n   */\n\n  EN_COUNT(sc->launch);\n  sc->enif.if_opackets++;\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    EN_COUNT(sc->lheader);\n    /* store tbd1/tbd2 in host byte order */\n    launch.tbd1 = MID_TBD_MK1(launch.aal, sc->txspeed[launch.atm_vci], ncells);\n    launch.tbd2 = MID_TBD_MK2(launch.atm_vci, 0, 0);\n  }\n  if ((launch.atm_flags & EN_OBTRL) == 0 && launch.aal == MID_TBD_AAL5) {\n    EN_COUNT(sc->ltail);\n    launch.pdu1 = MID_PDU_MK1(0, 0, datalen);  /* host byte order */\n  }\n\n  en_txlaunch(sc, chan, &launch);\n  \n  /*\n   * do some housekeeping and get the next packet\n   */\n\n  sc->txslot[chan].bfree -= launch.need;\n  IF_ENQUEUE(&sc->txslot[chan].indma, launch.t);\n  goto again;\n\n  /*\n   * END of txdma loop!\n   */\n\n  /*\n   * error handles\n   */\n\ndequeue_drop:\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n  if (launch.t != tmp)\n    panic(\"en dequeue drop\");\n  m_freem(launch.t);\n  sc->txslot[chan].mbsize -= launch.mlen;\n  goto again;\n}"
  },
  {
    "function_name": "en_mfix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1667-1739",
    "snippet": "STATIC int en_mfix(sc, mm, prev)\n\nstruct en_softc *sc;\nstruct mbuf **mm, *prev;\n\n{\n  struct mbuf *m, *new;\n  u_char *d, *cp;\n  int off;\n  struct mbuf *nxt;\n\n  m = *mm;\n\n  EN_COUNT(sc->mfix);\t\t\t/* count # of calls */\n#ifdef EN_DEBUG\n  printf(\"%s: mfix mbuf m_data=%p, m_len=%d\\n\", sc->sc_dev.dv_xname,\n\tm->m_data, m->m_len);\n#endif\n\n  d = mtod(m, u_char *);\n  off = ((unsigned long) d) % sizeof(u_int32_t);\n\n  if (off) {\n    if ((m->m_flags & M_EXT) == 0) {\n      bcopy(d, d - off, m->m_len);   /* ALIGN! (with costly data copy...) */\n      d -= off;\n      m->m_data = (caddr_t)d;\n    } else {\n      /* can't write to an M_EXT mbuf since it may be shared */\n      MGET(new, M_DONTWAIT, MT_DATA);\n      if (!new) {\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      MCLGET(new, M_DONTWAIT);\n      if ((new->m_flags & M_EXT) == 0) {\n        m_free(new);\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      bcopy(d, new->m_data, m->m_len);\t/* ALIGN! (with costly data copy...) */\n      new->m_len = m->m_len;\n      new->m_next = m->m_next;\n      if (prev)\n        prev->m_next = new;\n      m_free(m);\n      *mm = m = new;\t/* note: 'd' now invalid */\n    }\n  }\n\n  off = m->m_len % sizeof(u_int32_t);\n  if (off == 0)\n    return(1);\n\n  d = mtod(m, u_char *) + m->m_len;\n  off = sizeof(u_int32_t) - off;\n  \n  nxt = m->m_next;\n  while (off--) {\n    for ( ; nxt != NULL && nxt->m_len == 0 ; nxt = nxt->m_next)\n      /*null*/;\n    if (nxt == NULL) {\t\t/* out of data, zero fill */\n      *d++ = 0;\n      continue;\t\t\t/* next \"off\" */\n    }\n    cp = mtod(nxt, u_char *);\n    *d++ = *cp++;\n    m->m_len++;\n    nxt->m_len--; \n    nxt->m_data = (caddr_t)cp;\n  }\n  return(1);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC /* nothing */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "nxt",
            "u_char*"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_free",
          "args": [
            "m"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_chip_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "847-856",
          "snippet": "void \npcic_chip_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\tsc->subregionmask |= pcmhp->mhandle;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \npcic_chip_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\tsc->subregionmask |= pcmhp->mhandle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "d",
            "new->m_data",
            "m->m_len"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->mfixfail"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "new",
            "M_DONTWAIT"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->mfixfail"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: mfix mbuf m_data=%p, m_len=%d\\n\"",
            "sc->sc_dev.dv_xname",
            "m->m_data",
            "m->m_len"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->mfix"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC int en_mfix(sc, mm, prev)\n\nstruct en_softc *sc;\nstruct mbuf **mm, *prev;\n\n{\n  struct mbuf *m, *new;\n  u_char *d, *cp;\n  int off;\n  struct mbuf *nxt;\n\n  m = *mm;\n\n  EN_COUNT(sc->mfix);\t\t\t/* count # of calls */\n#ifdef EN_DEBUG\n  printf(\"%s: mfix mbuf m_data=%p, m_len=%d\\n\", sc->sc_dev.dv_xname,\n\tm->m_data, m->m_len);\n#endif\n\n  d = mtod(m, u_char *);\n  off = ((unsigned long) d) % sizeof(u_int32_t);\n\n  if (off) {\n    if ((m->m_flags & M_EXT) == 0) {\n      bcopy(d, d - off, m->m_len);   /* ALIGN! (with costly data copy...) */\n      d -= off;\n      m->m_data = (caddr_t)d;\n    } else {\n      /* can't write to an M_EXT mbuf since it may be shared */\n      MGET(new, M_DONTWAIT, MT_DATA);\n      if (!new) {\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      MCLGET(new, M_DONTWAIT);\n      if ((new->m_flags & M_EXT) == 0) {\n        m_free(new);\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      bcopy(d, new->m_data, m->m_len);\t/* ALIGN! (with costly data copy...) */\n      new->m_len = m->m_len;\n      new->m_next = m->m_next;\n      if (prev)\n        prev->m_next = new;\n      m_free(m);\n      *mm = m = new;\t/* note: 'd' now invalid */\n    }\n  }\n\n  off = m->m_len % sizeof(u_int32_t);\n  if (off == 0)\n    return(1);\n\n  d = mtod(m, u_char *) + m->m_len;\n  off = sizeof(u_int32_t) - off;\n  \n  nxt = m->m_next;\n  while (off--) {\n    for ( ; nxt != NULL && nxt->m_len == 0 ; nxt = nxt->m_next)\n      /*null*/;\n    if (nxt == NULL) {\t\t/* out of data, zero fill */\n      *d++ = 0;\n      continue;\t\t\t/* next \"off\" */\n    }\n    cp = mtod(nxt, u_char *);\n    *d++ = *cp++;\n    m->m_len++;\n    nxt->m_len--; \n    nxt->m_data = (caddr_t)cp;\n  }\n  return(1);\n}"
  },
  {
    "function_name": "en_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1474-1660",
    "snippet": "STATIC void en_start(ifp)\n\nstruct ifnet *ifp;\n\n{\n#ifdef MISSING_IF_SOFTC\n    struct en_softc *sc = (struct en_softc *) en_cd.cd_devs[ifp->if_unit];\n#else\n    struct en_softc *sc = (struct en_softc *) ifp->if_softc;\n#endif\n    struct ifqueue *ifq = &ifp->if_snd; /* if INPUT QUEUE */\n    struct mbuf *m, *lastm, *prev;\n    struct atm_pseudohdr *ap, *new_ap;\n    int txchan, mlen, got, need, toadd, cellcnt, first;\n    u_int32_t atm_vpi, atm_vci, atm_flags, *dat, aal;\n    u_int8_t *cp;\n\n    if ((ifp->if_flags & IFF_RUNNING) == 0)\n\treturn;\n\n    /*\n     * remove everything from interface queue since we handle all queueing\n     * locally ... \n     */\n\n    while (1) {\n\n      IF_DEQUEUE(ifq, m);\n      if (m == NULL)\n\treturn;\t\t/* EMPTY: >>> exit here <<< */\n    \n      /*\n       * calculate size of packet (in bytes)\n       * also, if we are not doing transmit DMA we eliminate all stupid\n       * (non-word) alignments here using en_mfix().   calls to en_mfix()\n       * seem to be due to tcp retransmits for the most part.\n       *\n       * after this loop mlen total length of mbuf chain (including atm_ph),\n       * and lastm is a pointer to the last mbuf on the chain.\n       */\n\n      lastm = m;\n      mlen = 0;\n      prev = NULL;\n      while (1) {\n\t/* no DMA? */\n        if ((!sc->is_adaptec && EN_ENIDMAFIX) || EN_NOTXDMA || !en_dma) {\n\t  if ( (mtod(lastm, unsigned long) % sizeof(u_int32_t)) != 0 ||\n\t    ((lastm->m_len % sizeof(u_int32_t)) != 0 && lastm->m_next)) {\n\t    first = (lastm == m);\n\t    if (en_mfix(sc, &lastm, prev) == 0) {\t/* failed? */\n\t      m_freem(m);\n\t      m = NULL;\n              break;\n            }\n\t    if (first)\n\t      m = lastm;\t\t/* update */\n          }\n          prev = lastm;\n        }\n\tmlen += lastm->m_len;\n\tif (lastm->m_next == NULL)\n\t  break;\n\tlastm = lastm->m_next;\n      }\n\n      if (m == NULL)\t\t/* happens only if mfix fails */\n        continue;\n\n      ap = mtod(m, struct atm_pseudohdr *);\n\n      atm_vpi = ATM_PH_VPI(ap);\n      atm_vci = ATM_PH_VCI(ap);\n      atm_flags = ATM_PH_FLAGS(ap) & ~(EN_OBHDR|EN_OBTRL);\n      aal = ((atm_flags & ATM_PH_AAL5) != 0) \n\t\t\t? MID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n      /*\n       * check that vpi/vci is one we can use\n       */\n\n      if (atm_vpi || atm_vci > MID_N_VC) {\n\tprintf(\"%s: output vpi=%d, vci=%d out of card range, dropping...\\n\", \n\t\tsc->sc_dev.dv_xname, atm_vpi, atm_vci);\n\tm_freem(m);\n\tcontinue;\n      }\n\n      /*\n       * computing how much padding we need on the end of the mbuf, then\n       * see if we can put the TBD at the front of the mbuf where the\n       * link header goes (well behaved protocols will reserve room for us).\n       * last, check if room for PDU tail.\n       *\n       * got = number of bytes of data we have\n       * cellcnt = number of cells in this mbuf\n       * need = number of bytes of data + padding we need (excludes TBD)\n       * toadd = number of bytes of data we need to add to end of mbuf,\n       *\t[including AAL5 PDU, if AAL5]\n       */\n\n      got = mlen - sizeof(struct atm_pseudohdr *);\n      toadd = (aal == MID_TBD_AAL5) ? MID_PDU_SIZE : 0;\t/* PDU */\n      cellcnt = (got + toadd + (MID_ATMDATASZ - 1)) / MID_ATMDATASZ;\n      need = cellcnt * MID_ATMDATASZ;\n      toadd = need - got;\t\t/* recompute, including zero padding */\n\n#ifdef EN_DEBUG\n      printf(\"%s: txvci%d: mlen=%d, got=%d, need=%d, toadd=%d, cell#=%d\\n\",\n\tsc->sc_dev.dv_xname, atm_vci, mlen, got, need, toadd, cellcnt);\n      printf(\"     leading_space=%d, trailing_space=%d\\n\", \n\tM_LEADINGSPACE(m), M_TRAILINGSPACE(lastm));\n#endif\n\n#ifdef EN_MBUF_OPT\n\n      /*\n       * note: external storage (M_EXT) can be shared between mbufs\n       * to avoid copying (see m_copym()).    this means that the same\n       * data buffer could be shared by several mbufs, and thus it isn't\n       * a good idea to try and write TBDs or PDUs to M_EXT data areas.\n       */\n\n      if (M_LEADINGSPACE(m) >= MID_TBD_SIZE && (m->m_flags & M_EXT) == 0) {\n\tm->m_data -= MID_TBD_SIZE;\n\tm->m_len += MID_TBD_SIZE;\n\tmlen += MID_TBD_SIZE;\n\tnew_ap = mtod(m, struct atm_pseudohdr *);\n\t*new_ap = *ap;\t\t\t/* move it back */\n\tap = new_ap;\n\tdat = ((u_int32_t *) ap) + 1;\n\t/* make sure the TBD is in proper byte order */\n\t*dat++ = htonl(MID_TBD_MK1(aal, sc->txspeed[atm_vci], cellcnt));\n\t*dat = htonl(MID_TBD_MK2(atm_vci, 0, 0));\n\tatm_flags |= EN_OBHDR;\n      }\n\n      if (toadd && (lastm->m_flags & M_EXT) == 0 && \n\t\t\t\t\tM_TRAILINGSPACE(lastm) >= toadd) {\n\tcp = mtod(lastm, u_int8_t *) + lastm->m_len;\n\tlastm->m_len += toadd;\n\tmlen += toadd;\n\tif (aal == MID_TBD_AAL5) {\n\t  bzero(cp, toadd - MID_PDU_SIZE);\n\t  dat = (u_int32_t *)(cp + toadd - MID_PDU_SIZE);\n\t  /* make sure the PDU is in proper byte order */\n\t  *dat = htonl(MID_PDU_MK1(0, 0, got));\n\t} else {\n\t  bzero(cp, toadd);\n\t}\n\tatm_flags |= EN_OBTRL;\n      }\n      ATM_PH_FLAGS(ap) = atm_flags;\t/* update EN_OBHDR/EN_OBTRL bits */\n#endif\t/* EN_MBUF_OPT */\n\n      /*\n       * get assigned channel (will be zero unless txspeed[atm_vci] is set)\n       */\n\n      txchan = sc->txvc2slot[atm_vci];\n\n      if (sc->txslot[txchan].mbsize > EN_TXHIWAT) {\n\tEN_COUNT(sc->txmbovr);\n\tm_freem(m);\n#ifdef EN_DEBUG\n\tprintf(\"%s: tx%d: buffer space shortage\\n\", sc->sc_dev.dv_xname,\n\t\ttxchan);\n#endif\n\tcontinue;\n      }\n\n      sc->txslot[txchan].mbsize += mlen;\n\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: VPI=%d, VCI=%d, FLAGS=0x%x, speed=0x%x\\n\",\n\tsc->sc_dev.dv_xname, txchan, atm_vpi, atm_vci, atm_flags, \n\tsc->txspeed[atm_vci]);\n      printf(\"     adjusted mlen=%d, mbsize=%d\\n\", mlen, \n\t\tsc->txslot[txchan].mbsize);\n#endif\n\n      IF_ENQUEUE(&sc->txslot[txchan].q, m);\n      en_txdma(sc, txchan);\n\n  }\n  /*NOTREACHED*/\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */",
      "#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */",
      "#define EN_TXHIWAT\t(64*1024)\t/* max 64 KB waiting to be DMAd out */",
      "#define MISSING_IF_SOFTC",
      "#define STATIC static",
      "#define STATIC /* nothing */",
      "#define EN_ENIDMAFIX\t1\t/* avoid byte DMA on the ENI card (see below) */",
      "#define EN_ENIDMAFIX\t0\t/* no ENI cards to worry about */",
      "#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */",
      "#define\tEN_MBUF_OPT\t\t/* try and put more stuff in mbuf? */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "en_txdma",
          "args": [
            "sc",
            "txchan"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "en_txdma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1746-1940",
          "snippet": "STATIC void en_txdma(sc, chan)\n\nstruct en_softc *sc;\nint chan;\n\n{\n  struct mbuf *tmp;\n  struct atm_pseudohdr *ap;\n  struct en_launch launch;\n  int datalen = 0, dtqneed, len, ncells;\n  u_int8_t *cp;\n\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: starting...\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n\n  /*\n   * note: now that txlaunch handles non-word aligned/sized requests\n   * the only time you can safely set launch.nodma is if you've en_mfix()'d\n   * the mbuf chain.    this happens only if EN_NOTXDMA || !en_dma.\n   */\n\n  launch.nodma = (EN_NOTXDMA || !en_dma);\n\nagain:\n\n  /*\n   * get an mbuf waiting for DMA\n   */\n\n  launch.t = sc->txslot[chan].q.ifq_head; /* peek at head of queue */\n\n  if (launch.t == NULL) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: ...done!\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t/* >>> exit here if no data waiting for DMA <<< */\n  }\n\n  /*\n   * get flags, vci\n   * \n   * note: launch.need = # bytes we need to get on the card\n   *\t   dtqneed = # of DTQs we need for this packet\n   *       launch.mlen = # of bytes in in mbuf chain (<= launch.need)\n   */\n\n  ap = mtod(launch.t, struct atm_pseudohdr *);\n  launch.atm_vci = ATM_PH_VCI(ap);\n  launch.atm_flags = ATM_PH_FLAGS(ap);\n  launch.aal = ((launch.atm_flags & ATM_PH_AAL5) != 0) ? \n\t\tMID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n  /*\n   * XXX: have to recompute the length again, even though we already did\n   * it in en_start().   might as well compute dtqneed here as well, so \n   * this isn't that bad.\n   */\n\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    dtqneed = 1;\t\t/* header still needs to be added */\n    launch.need = MID_TBD_SIZE;\t/* not includeded with mbuf */\n  } else {\n    dtqneed = 0;\t\t/* header on-board, dma with mbuf */\n    launch.need = 0;\n  }\n\n  launch.mlen = 0;\n  for (tmp = launch.t ; tmp != NULL ; tmp = tmp->m_next) {\n    len = tmp->m_len;\n    launch.mlen += len;\n    cp = mtod(tmp, u_int8_t *);\n    if (tmp == launch.t) {\n      len -= sizeof(struct atm_pseudohdr); /* don't count this! */\n      cp += sizeof(struct atm_pseudohdr);\n    }\n    launch.need += len;\n    if (len == 0)\n      continue;\t\t\t/* atm_pseudohdr alone in first mbuf */\n\n    dtqneed += en_dqneed(sc, (caddr_t) cp, len, 1);\n  }\n\n  if ((launch.need % sizeof(u_int32_t)) != 0) \n    dtqneed++;\t\t\t/* need DTQ to FLUSH internal buffer */\n\n  if ((launch.atm_flags & EN_OBTRL) == 0) {\n    if (launch.aal == MID_TBD_AAL5) {\n      datalen = launch.need - MID_TBD_SIZE;\n      launch.need += MID_PDU_SIZE;\t\t/* AAL5: need PDU tail */\n    }\n    dtqneed++;\t\t\t/* need to work on the end a bit */\n  }\n\n  /*\n   * finish calculation of launch.need (need to figure out how much padding\n   * we will need).   launch.need includes MID_TBD_SIZE, but we need to\n   * remove that to so we can round off properly.     we have to add \n   * MID_TBD_SIZE back in after calculating ncells.\n   */\n\n  launch.need = roundup(launch.need - MID_TBD_SIZE, MID_ATMDATASZ);\n  ncells = launch.need / MID_ATMDATASZ;\n  launch.need += MID_TBD_SIZE;\n\n  if (launch.need > EN_TXSZ * 1024) {\n    printf(\"%s: tx%d: packet larger than xmit buffer (%d > %d)\\n\",\n      sc->sc_dev.dv_xname, chan, launch.need, EN_TXSZ * 1024);\n    goto dequeue_drop;\n  }\n\n  /*\n   * note: note that we cannot totally fill the circular buffer (i.e.\n   * we can't use up all of the remaining sc->txslot[chan].bfree free\n   * bytes) because that would cause the circular buffer read pointer\n   * to become equal to the write pointer, thus signaling 'empty buffer'\n   * to the hardware and stopping the transmitter.\n   */\n  if (launch.need >= sc->txslot[chan].bfree) {\n    EN_COUNT(sc->txoutspace);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit space\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of obmem buffer space <<< */\n  }\n  \n  /*\n   * ensure we have enough dtqs to go, if not, wait for more.\n   */\n\n  if (launch.nodma) {\n    dtqneed = 1;\n  }\n  if (dtqneed > sc->dtq_free) {\n    sc->need_dtqs = 1;\n    EN_COUNT(sc->txdtqout);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit DTQs\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of dtqs <<< */\n  }\n\n  /*\n   * it is a go, commit!  dequeue mbuf start working on the xfer.\n   */\n\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n#ifdef EN_DIAG\n  if (launch.t != tmp)\n    panic(\"en dequeue\");\n#endif /* EN_DIAG */\n\n  /*\n   * launch!\n   */\n\n  EN_COUNT(sc->launch);\n  sc->enif.if_opackets++;\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    EN_COUNT(sc->lheader);\n    /* store tbd1/tbd2 in host byte order */\n    launch.tbd1 = MID_TBD_MK1(launch.aal, sc->txspeed[launch.atm_vci], ncells);\n    launch.tbd2 = MID_TBD_MK2(launch.atm_vci, 0, 0);\n  }\n  if ((launch.atm_flags & EN_OBTRL) == 0 && launch.aal == MID_TBD_AAL5) {\n    EN_COUNT(sc->ltail);\n    launch.pdu1 = MID_PDU_MK1(0, 0, datalen);  /* host byte order */\n  }\n\n  en_txlaunch(sc, chan, &launch);\n  \n  /*\n   * do some housekeeping and get the next packet\n   */\n\n  sc->txslot[chan].bfree -= launch.need;\n  IF_ENQUEUE(&sc->txslot[chan].indma, launch.t);\n  goto again;\n\n  /*\n   * END of txdma loop!\n   */\n\n  /*\n   * error handles\n   */\n\ndequeue_drop:\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n  if (launch.t != tmp)\n    panic(\"en dequeue drop\");\n  m_freem(launch.t);\n  sc->txslot[chan].mbsize -= launch.mlen;\n  goto again;\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */",
            "#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */",
            "#define STATIC static",
            "#define STATIC /* nothing */",
            "#define EN_DIAG\t\t\t/* link in with master DIAG option */",
            "#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */",
            "#define\tEN_DIAG"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */\n#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_DIAG\t\t\t/* link in with master DIAG option */\n#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */\n#define\tEN_DIAG\n\nSTATIC void en_txdma(sc, chan)\n\nstruct en_softc *sc;\nint chan;\n\n{\n  struct mbuf *tmp;\n  struct atm_pseudohdr *ap;\n  struct en_launch launch;\n  int datalen = 0, dtqneed, len, ncells;\n  u_int8_t *cp;\n\n#ifdef EN_DEBUG\n  printf(\"%s: tx%d: starting...\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n\n  /*\n   * note: now that txlaunch handles non-word aligned/sized requests\n   * the only time you can safely set launch.nodma is if you've en_mfix()'d\n   * the mbuf chain.    this happens only if EN_NOTXDMA || !en_dma.\n   */\n\n  launch.nodma = (EN_NOTXDMA || !en_dma);\n\nagain:\n\n  /*\n   * get an mbuf waiting for DMA\n   */\n\n  launch.t = sc->txslot[chan].q.ifq_head; /* peek at head of queue */\n\n  if (launch.t == NULL) {\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: ...done!\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t/* >>> exit here if no data waiting for DMA <<< */\n  }\n\n  /*\n   * get flags, vci\n   * \n   * note: launch.need = # bytes we need to get on the card\n   *\t   dtqneed = # of DTQs we need for this packet\n   *       launch.mlen = # of bytes in in mbuf chain (<= launch.need)\n   */\n\n  ap = mtod(launch.t, struct atm_pseudohdr *);\n  launch.atm_vci = ATM_PH_VCI(ap);\n  launch.atm_flags = ATM_PH_FLAGS(ap);\n  launch.aal = ((launch.atm_flags & ATM_PH_AAL5) != 0) ? \n\t\tMID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n  /*\n   * XXX: have to recompute the length again, even though we already did\n   * it in en_start().   might as well compute dtqneed here as well, so \n   * this isn't that bad.\n   */\n\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    dtqneed = 1;\t\t/* header still needs to be added */\n    launch.need = MID_TBD_SIZE;\t/* not includeded with mbuf */\n  } else {\n    dtqneed = 0;\t\t/* header on-board, dma with mbuf */\n    launch.need = 0;\n  }\n\n  launch.mlen = 0;\n  for (tmp = launch.t ; tmp != NULL ; tmp = tmp->m_next) {\n    len = tmp->m_len;\n    launch.mlen += len;\n    cp = mtod(tmp, u_int8_t *);\n    if (tmp == launch.t) {\n      len -= sizeof(struct atm_pseudohdr); /* don't count this! */\n      cp += sizeof(struct atm_pseudohdr);\n    }\n    launch.need += len;\n    if (len == 0)\n      continue;\t\t\t/* atm_pseudohdr alone in first mbuf */\n\n    dtqneed += en_dqneed(sc, (caddr_t) cp, len, 1);\n  }\n\n  if ((launch.need % sizeof(u_int32_t)) != 0) \n    dtqneed++;\t\t\t/* need DTQ to FLUSH internal buffer */\n\n  if ((launch.atm_flags & EN_OBTRL) == 0) {\n    if (launch.aal == MID_TBD_AAL5) {\n      datalen = launch.need - MID_TBD_SIZE;\n      launch.need += MID_PDU_SIZE;\t\t/* AAL5: need PDU tail */\n    }\n    dtqneed++;\t\t\t/* need to work on the end a bit */\n  }\n\n  /*\n   * finish calculation of launch.need (need to figure out how much padding\n   * we will need).   launch.need includes MID_TBD_SIZE, but we need to\n   * remove that to so we can round off properly.     we have to add \n   * MID_TBD_SIZE back in after calculating ncells.\n   */\n\n  launch.need = roundup(launch.need - MID_TBD_SIZE, MID_ATMDATASZ);\n  ncells = launch.need / MID_ATMDATASZ;\n  launch.need += MID_TBD_SIZE;\n\n  if (launch.need > EN_TXSZ * 1024) {\n    printf(\"%s: tx%d: packet larger than xmit buffer (%d > %d)\\n\",\n      sc->sc_dev.dv_xname, chan, launch.need, EN_TXSZ * 1024);\n    goto dequeue_drop;\n  }\n\n  /*\n   * note: note that we cannot totally fill the circular buffer (i.e.\n   * we can't use up all of the remaining sc->txslot[chan].bfree free\n   * bytes) because that would cause the circular buffer read pointer\n   * to become equal to the write pointer, thus signaling 'empty buffer'\n   * to the hardware and stopping the transmitter.\n   */\n  if (launch.need >= sc->txslot[chan].bfree) {\n    EN_COUNT(sc->txoutspace);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit space\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of obmem buffer space <<< */\n  }\n  \n  /*\n   * ensure we have enough dtqs to go, if not, wait for more.\n   */\n\n  if (launch.nodma) {\n    dtqneed = 1;\n  }\n  if (dtqneed > sc->dtq_free) {\n    sc->need_dtqs = 1;\n    EN_COUNT(sc->txdtqout);\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: out of transmit DTQs\\n\", sc->sc_dev.dv_xname, chan);\n#endif\n    return;\t\t/* >>> exit here if out of dtqs <<< */\n  }\n\n  /*\n   * it is a go, commit!  dequeue mbuf start working on the xfer.\n   */\n\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n#ifdef EN_DIAG\n  if (launch.t != tmp)\n    panic(\"en dequeue\");\n#endif /* EN_DIAG */\n\n  /*\n   * launch!\n   */\n\n  EN_COUNT(sc->launch);\n  sc->enif.if_opackets++;\n  if ((launch.atm_flags & EN_OBHDR) == 0) {\n    EN_COUNT(sc->lheader);\n    /* store tbd1/tbd2 in host byte order */\n    launch.tbd1 = MID_TBD_MK1(launch.aal, sc->txspeed[launch.atm_vci], ncells);\n    launch.tbd2 = MID_TBD_MK2(launch.atm_vci, 0, 0);\n  }\n  if ((launch.atm_flags & EN_OBTRL) == 0 && launch.aal == MID_TBD_AAL5) {\n    EN_COUNT(sc->ltail);\n    launch.pdu1 = MID_PDU_MK1(0, 0, datalen);  /* host byte order */\n  }\n\n  en_txlaunch(sc, chan, &launch);\n  \n  /*\n   * do some housekeeping and get the next packet\n   */\n\n  sc->txslot[chan].bfree -= launch.need;\n  IF_ENQUEUE(&sc->txslot[chan].indma, launch.t);\n  goto again;\n\n  /*\n   * END of txdma loop!\n   */\n\n  /*\n   * error handles\n   */\n\ndequeue_drop:\n  IF_DEQUEUE(&sc->txslot[chan].q, tmp);\n  if (launch.t != tmp)\n    panic(\"en dequeue drop\");\n  m_freem(launch.t);\n  sc->txslot[chan].mbsize -= launch.mlen;\n  goto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&sc->txslot[txchan].q",
            "m"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     adjusted mlen=%d, mbsize=%d\\n\"",
            "mlen",
            "sc->txslot[txchan].mbsize"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_COUNT",
          "args": [
            "sc->txmbovr"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_FLAGS",
          "args": [
            "ap"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cp",
            "toadd"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "MID_PDU_MK1(0, 0, got)"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_PDU_MK1",
          "args": [
            "0",
            "0",
            "got"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cp",
            "toadd - MID_PDU_SIZE"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "lastm",
            "u_int8_t*"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_TRAILINGSPACE",
          "args": [
            "lastm"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "MID_TBD_MK2(atm_vci, 0, 0)"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_TBD_MK2",
          "args": [
            "atm_vci",
            "0",
            "0"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "MID_TBD_MK1(aal, sc->txspeed[atm_vci], cellcnt)"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_TBD_MK1",
          "args": [
            "aal",
            "sc->txspeed[atm_vci]",
            "cellcnt"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structatm_pseudohdr*"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_LEADINGSPACE",
          "args": [
            "m"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_TRAILINGSPACE",
          "args": [
            "lastm"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_LEADINGSPACE",
          "args": [
            "m"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_FLAGS",
          "args": [
            "ap"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_VCI",
          "args": [
            "ap"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_VPI",
          "args": [
            "ap"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structatm_pseudohdr*"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_mfix",
          "args": [
            "sc",
            "&lastm",
            "prev"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "en_mfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1667-1739",
          "snippet": "STATIC int en_mfix(sc, mm, prev)\n\nstruct en_softc *sc;\nstruct mbuf **mm, *prev;\n\n{\n  struct mbuf *m, *new;\n  u_char *d, *cp;\n  int off;\n  struct mbuf *nxt;\n\n  m = *mm;\n\n  EN_COUNT(sc->mfix);\t\t\t/* count # of calls */\n#ifdef EN_DEBUG\n  printf(\"%s: mfix mbuf m_data=%p, m_len=%d\\n\", sc->sc_dev.dv_xname,\n\tm->m_data, m->m_len);\n#endif\n\n  d = mtod(m, u_char *);\n  off = ((unsigned long) d) % sizeof(u_int32_t);\n\n  if (off) {\n    if ((m->m_flags & M_EXT) == 0) {\n      bcopy(d, d - off, m->m_len);   /* ALIGN! (with costly data copy...) */\n      d -= off;\n      m->m_data = (caddr_t)d;\n    } else {\n      /* can't write to an M_EXT mbuf since it may be shared */\n      MGET(new, M_DONTWAIT, MT_DATA);\n      if (!new) {\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      MCLGET(new, M_DONTWAIT);\n      if ((new->m_flags & M_EXT) == 0) {\n        m_free(new);\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      bcopy(d, new->m_data, m->m_len);\t/* ALIGN! (with costly data copy...) */\n      new->m_len = m->m_len;\n      new->m_next = m->m_next;\n      if (prev)\n        prev->m_next = new;\n      m_free(m);\n      *mm = m = new;\t/* note: 'd' now invalid */\n    }\n  }\n\n  off = m->m_len % sizeof(u_int32_t);\n  if (off == 0)\n    return(1);\n\n  d = mtod(m, u_char *) + m->m_len;\n  off = sizeof(u_int32_t) - off;\n  \n  nxt = m->m_next;\n  while (off--) {\n    for ( ; nxt != NULL && nxt->m_len == 0 ; nxt = nxt->m_next)\n      /*null*/;\n    if (nxt == NULL) {\t\t/* out of data, zero fill */\n      *d++ = 0;\n      continue;\t\t\t/* next \"off\" */\n    }\n    cp = mtod(nxt, u_char *);\n    *d++ = *cp++;\n    m->m_len++;\n    nxt->m_len--; \n    nxt->m_data = (caddr_t)cp;\n  }\n  return(1);\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC /* nothing */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC int en_mfix(sc, mm, prev)\n\nstruct en_softc *sc;\nstruct mbuf **mm, *prev;\n\n{\n  struct mbuf *m, *new;\n  u_char *d, *cp;\n  int off;\n  struct mbuf *nxt;\n\n  m = *mm;\n\n  EN_COUNT(sc->mfix);\t\t\t/* count # of calls */\n#ifdef EN_DEBUG\n  printf(\"%s: mfix mbuf m_data=%p, m_len=%d\\n\", sc->sc_dev.dv_xname,\n\tm->m_data, m->m_len);\n#endif\n\n  d = mtod(m, u_char *);\n  off = ((unsigned long) d) % sizeof(u_int32_t);\n\n  if (off) {\n    if ((m->m_flags & M_EXT) == 0) {\n      bcopy(d, d - off, m->m_len);   /* ALIGN! (with costly data copy...) */\n      d -= off;\n      m->m_data = (caddr_t)d;\n    } else {\n      /* can't write to an M_EXT mbuf since it may be shared */\n      MGET(new, M_DONTWAIT, MT_DATA);\n      if (!new) {\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      MCLGET(new, M_DONTWAIT);\n      if ((new->m_flags & M_EXT) == 0) {\n        m_free(new);\n        EN_COUNT(sc->mfixfail);\n        return(0);\n      }\n      bcopy(d, new->m_data, m->m_len);\t/* ALIGN! (with costly data copy...) */\n      new->m_len = m->m_len;\n      new->m_next = m->m_next;\n      if (prev)\n        prev->m_next = new;\n      m_free(m);\n      *mm = m = new;\t/* note: 'd' now invalid */\n    }\n  }\n\n  off = m->m_len % sizeof(u_int32_t);\n  if (off == 0)\n    return(1);\n\n  d = mtod(m, u_char *) + m->m_len;\n  off = sizeof(u_int32_t) - off;\n  \n  nxt = m->m_next;\n  while (off--) {\n    for ( ; nxt != NULL && nxt->m_len == 0 ; nxt = nxt->m_next)\n      /*null*/;\n    if (nxt == NULL) {\t\t/* out of data, zero fill */\n      *d++ = 0;\n      continue;\t\t\t/* next \"off\" */\n    }\n    cp = mtod(nxt, u_char *);\n    *d++ = *cp++;\n    m->m_len++;\n    nxt->m_len--; \n    nxt->m_data = (caddr_t)cp;\n  }\n  return(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "ifq",
            "m"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_OBTRL\tATM_PH_DRIVER8  /* PDU trailier in last mbuf ! */\n#define EN_OBHDR\tATM_PH_DRIVER7  /* TBD in first mbuf ! */\n#define EN_TXHIWAT\t(64*1024)\t/* max 64 KB waiting to be DMAd out */\n#define MISSING_IF_SOFTC\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_ENIDMAFIX\t1\t/* avoid byte DMA on the ENI card (see below) */\n#define EN_ENIDMAFIX\t0\t/* no ENI cards to worry about */\n#define EN_NOTXDMA\t0\t/* hook to disable tx dma only */\n#define\tEN_MBUF_OPT\t\t/* try and put more stuff in mbuf? */\n\nSTATIC void en_start(ifp)\n\nstruct ifnet *ifp;\n\n{\n#ifdef MISSING_IF_SOFTC\n    struct en_softc *sc = (struct en_softc *) en_cd.cd_devs[ifp->if_unit];\n#else\n    struct en_softc *sc = (struct en_softc *) ifp->if_softc;\n#endif\n    struct ifqueue *ifq = &ifp->if_snd; /* if INPUT QUEUE */\n    struct mbuf *m, *lastm, *prev;\n    struct atm_pseudohdr *ap, *new_ap;\n    int txchan, mlen, got, need, toadd, cellcnt, first;\n    u_int32_t atm_vpi, atm_vci, atm_flags, *dat, aal;\n    u_int8_t *cp;\n\n    if ((ifp->if_flags & IFF_RUNNING) == 0)\n\treturn;\n\n    /*\n     * remove everything from interface queue since we handle all queueing\n     * locally ... \n     */\n\n    while (1) {\n\n      IF_DEQUEUE(ifq, m);\n      if (m == NULL)\n\treturn;\t\t/* EMPTY: >>> exit here <<< */\n    \n      /*\n       * calculate size of packet (in bytes)\n       * also, if we are not doing transmit DMA we eliminate all stupid\n       * (non-word) alignments here using en_mfix().   calls to en_mfix()\n       * seem to be due to tcp retransmits for the most part.\n       *\n       * after this loop mlen total length of mbuf chain (including atm_ph),\n       * and lastm is a pointer to the last mbuf on the chain.\n       */\n\n      lastm = m;\n      mlen = 0;\n      prev = NULL;\n      while (1) {\n\t/* no DMA? */\n        if ((!sc->is_adaptec && EN_ENIDMAFIX) || EN_NOTXDMA || !en_dma) {\n\t  if ( (mtod(lastm, unsigned long) % sizeof(u_int32_t)) != 0 ||\n\t    ((lastm->m_len % sizeof(u_int32_t)) != 0 && lastm->m_next)) {\n\t    first = (lastm == m);\n\t    if (en_mfix(sc, &lastm, prev) == 0) {\t/* failed? */\n\t      m_freem(m);\n\t      m = NULL;\n              break;\n            }\n\t    if (first)\n\t      m = lastm;\t\t/* update */\n          }\n          prev = lastm;\n        }\n\tmlen += lastm->m_len;\n\tif (lastm->m_next == NULL)\n\t  break;\n\tlastm = lastm->m_next;\n      }\n\n      if (m == NULL)\t\t/* happens only if mfix fails */\n        continue;\n\n      ap = mtod(m, struct atm_pseudohdr *);\n\n      atm_vpi = ATM_PH_VPI(ap);\n      atm_vci = ATM_PH_VCI(ap);\n      atm_flags = ATM_PH_FLAGS(ap) & ~(EN_OBHDR|EN_OBTRL);\n      aal = ((atm_flags & ATM_PH_AAL5) != 0) \n\t\t\t? MID_TBD_AAL5 : MID_TBD_NOAAL5;\n\n      /*\n       * check that vpi/vci is one we can use\n       */\n\n      if (atm_vpi || atm_vci > MID_N_VC) {\n\tprintf(\"%s: output vpi=%d, vci=%d out of card range, dropping...\\n\", \n\t\tsc->sc_dev.dv_xname, atm_vpi, atm_vci);\n\tm_freem(m);\n\tcontinue;\n      }\n\n      /*\n       * computing how much padding we need on the end of the mbuf, then\n       * see if we can put the TBD at the front of the mbuf where the\n       * link header goes (well behaved protocols will reserve room for us).\n       * last, check if room for PDU tail.\n       *\n       * got = number of bytes of data we have\n       * cellcnt = number of cells in this mbuf\n       * need = number of bytes of data + padding we need (excludes TBD)\n       * toadd = number of bytes of data we need to add to end of mbuf,\n       *\t[including AAL5 PDU, if AAL5]\n       */\n\n      got = mlen - sizeof(struct atm_pseudohdr *);\n      toadd = (aal == MID_TBD_AAL5) ? MID_PDU_SIZE : 0;\t/* PDU */\n      cellcnt = (got + toadd + (MID_ATMDATASZ - 1)) / MID_ATMDATASZ;\n      need = cellcnt * MID_ATMDATASZ;\n      toadd = need - got;\t\t/* recompute, including zero padding */\n\n#ifdef EN_DEBUG\n      printf(\"%s: txvci%d: mlen=%d, got=%d, need=%d, toadd=%d, cell#=%d\\n\",\n\tsc->sc_dev.dv_xname, atm_vci, mlen, got, need, toadd, cellcnt);\n      printf(\"     leading_space=%d, trailing_space=%d\\n\", \n\tM_LEADINGSPACE(m), M_TRAILINGSPACE(lastm));\n#endif\n\n#ifdef EN_MBUF_OPT\n\n      /*\n       * note: external storage (M_EXT) can be shared between mbufs\n       * to avoid copying (see m_copym()).    this means that the same\n       * data buffer could be shared by several mbufs, and thus it isn't\n       * a good idea to try and write TBDs or PDUs to M_EXT data areas.\n       */\n\n      if (M_LEADINGSPACE(m) >= MID_TBD_SIZE && (m->m_flags & M_EXT) == 0) {\n\tm->m_data -= MID_TBD_SIZE;\n\tm->m_len += MID_TBD_SIZE;\n\tmlen += MID_TBD_SIZE;\n\tnew_ap = mtod(m, struct atm_pseudohdr *);\n\t*new_ap = *ap;\t\t\t/* move it back */\n\tap = new_ap;\n\tdat = ((u_int32_t *) ap) + 1;\n\t/* make sure the TBD is in proper byte order */\n\t*dat++ = htonl(MID_TBD_MK1(aal, sc->txspeed[atm_vci], cellcnt));\n\t*dat = htonl(MID_TBD_MK2(atm_vci, 0, 0));\n\tatm_flags |= EN_OBHDR;\n      }\n\n      if (toadd && (lastm->m_flags & M_EXT) == 0 && \n\t\t\t\t\tM_TRAILINGSPACE(lastm) >= toadd) {\n\tcp = mtod(lastm, u_int8_t *) + lastm->m_len;\n\tlastm->m_len += toadd;\n\tmlen += toadd;\n\tif (aal == MID_TBD_AAL5) {\n\t  bzero(cp, toadd - MID_PDU_SIZE);\n\t  dat = (u_int32_t *)(cp + toadd - MID_PDU_SIZE);\n\t  /* make sure the PDU is in proper byte order */\n\t  *dat = htonl(MID_PDU_MK1(0, 0, got));\n\t} else {\n\t  bzero(cp, toadd);\n\t}\n\tatm_flags |= EN_OBTRL;\n      }\n      ATM_PH_FLAGS(ap) = atm_flags;\t/* update EN_OBHDR/EN_OBTRL bits */\n#endif\t/* EN_MBUF_OPT */\n\n      /*\n       * get assigned channel (will be zero unless txspeed[atm_vci] is set)\n       */\n\n      txchan = sc->txvc2slot[atm_vci];\n\n      if (sc->txslot[txchan].mbsize > EN_TXHIWAT) {\n\tEN_COUNT(sc->txmbovr);\n\tm_freem(m);\n#ifdef EN_DEBUG\n\tprintf(\"%s: tx%d: buffer space shortage\\n\", sc->sc_dev.dv_xname,\n\t\ttxchan);\n#endif\n\tcontinue;\n      }\n\n      sc->txslot[txchan].mbsize += mlen;\n\n#ifdef EN_DEBUG\n      printf(\"%s: tx%d: VPI=%d, VCI=%d, FLAGS=0x%x, speed=0x%x\\n\",\n\tsc->sc_dev.dv_xname, txchan, atm_vpi, atm_vci, atm_flags, \n\tsc->txspeed[atm_vci]);\n      printf(\"     adjusted mlen=%d, mbsize=%d\\n\", mlen, \n\t\tsc->txslot[txchan].mbsize);\n#endif\n\n      IF_ENQUEUE(&sc->txslot[txchan].q, m);\n      en_txdma(sc, txchan);\n\n  }\n  /*NOTREACHED*/\n}"
  },
  {
    "function_name": "en_loadvc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1441-1466",
    "snippet": "STATIC void en_loadvc(sc, vc)\n\nstruct en_softc *sc;\nint vc;\n\n{\n  int slot;\n  u_int32_t reg = EN_READ(sc, MID_VC(vc));\n  \n  reg = MIDV_SETMODE(reg, MIDV_TRASH);\n  EN_WRITE(sc, MID_VC(vc), reg);\n  DELAY(27);\n\n  if ((slot = sc->rxvc2slot[vc]) == RX_NONE)\n    return;\n\n  /* no need to set CRC */\n  EN_WRITE(sc, MID_DST_RP(vc), 0);\t/* read pointer = 0, desc. start = 0 */\n  EN_WRITE(sc, MID_WP_ST_CNT(vc), 0);\t/* write pointer = 0 */\n  EN_WRITE(sc, MID_VC(vc), sc->rxslot[slot].mode);  /* set mode, size, loc */\n  sc->rxslot[slot].cur = sc->rxslot[slot].start;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: assigned to VCI %d\\n\", sc->sc_dev.dv_xname, slot, vc);\n#endif\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
      "#define STATIC static",
      "#define STATIC /* nothing */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx%d: assigned to VCI %d\\n\"",
            "sc->sc_dev.dv_xname",
            "slot",
            "vc"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_VC(vc)",
            "sc->rxslot[slot].mode"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vc"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_WP_ST_CNT(vc)",
            "0"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_WP_ST_CNT",
          "args": [
            "vc"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_DST_RP(vc)",
            "0"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DST_RP",
          "args": [
            "vc"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "27"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_VC(vc)",
            "reg"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vc"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDV_SETMODE",
          "args": [
            "reg",
            "MIDV_TRASH"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_VC(vc)"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vc"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC void en_loadvc(sc, vc)\n\nstruct en_softc *sc;\nint vc;\n\n{\n  int slot;\n  u_int32_t reg = EN_READ(sc, MID_VC(vc));\n  \n  reg = MIDV_SETMODE(reg, MIDV_TRASH);\n  EN_WRITE(sc, MID_VC(vc), reg);\n  DELAY(27);\n\n  if ((slot = sc->rxvc2slot[vc]) == RX_NONE)\n    return;\n\n  /* no need to set CRC */\n  EN_WRITE(sc, MID_DST_RP(vc), 0);\t/* read pointer = 0, desc. start = 0 */\n  EN_WRITE(sc, MID_WP_ST_CNT(vc), 0);\t/* write pointer = 0 */\n  EN_WRITE(sc, MID_VC(vc), sc->rxslot[slot].mode);  /* set mode, size, loc */\n  sc->rxslot[slot].cur = sc->rxslot[slot].start;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: assigned to VCI %d\\n\", sc->sc_dev.dv_xname, slot, vc);\n#endif\n}"
  },
  {
    "function_name": "en_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1343-1434",
    "snippet": "STATIC void en_init(sc)\n\nstruct en_softc *sc;\n\n{\n  int vc, slot;\n  u_int32_t loc;\n\n  if ((sc->enif.if_flags & IFF_UP) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: going down\\n\", sc->sc_dev.dv_xname);\n#endif\n    en_reset(sc);\t\t\t/* to be safe */\n    sc->enif.if_flags &= ~IFF_RUNNING;\t/* disable */\n    return;\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: going up\\n\", sc->sc_dev.dv_xname);\n#endif\n  sc->enif.if_flags |= IFF_RUNNING;\t/* enable */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n\n  /*\n   * init obmem data structures: vc tab, dma q's, slist.\n   *\n   * note that we set drq_free/dtq_free to one less than the total number\n   * of DTQ/DRQs present.   we do this because the card uses the condition\n   * (drq_chip == drq_us) to mean \"list is empty\"... but if you allow the\n   * circular list to be completely full then (drq_chip == drq_us) [i.e.\n   * the drq_us pointer will wrap all the way around].   by restricting\n   * the number of active requests to (N - 1) we prevent the list from\n   * becoming completely full.    note that the card will sometimes give\n   * us an interrupt for a DTQ/DRQ we have already processes... this helps\n   * keep that interrupt from messing us up.\n   */\n\n  for (vc = 0 ; vc < MID_N_VC ; vc++) \n    en_loadvc(sc, vc);\n\n  bzero(&sc->drq, sizeof(sc->drq));\n  sc->drq_free = MID_DRQ_N - 1;\t\t/* N - 1 */\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->drq_us = sc->drq_chip;\n\n  bzero(&sc->dtq, sizeof(sc->dtq));\n  sc->dtq_free = MID_DTQ_N - 1;\t\t/* N - 1 */\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n  EN_WRITE(sc, MID_DMA_WRTX, MID_DRQ_A2REG(sc->dtq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->dtq_us = sc->dtq_chip;\n\n  sc->hwslistp = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n  sc->swsl_size = sc->swsl_head = sc->swsl_tail = 0;\n\n#ifdef EN_DEBUG\n  printf(\"%s: drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, hwslist: 0x%x\\n\", \n    sc->sc_dev.dv_xname, sc->drq_free, sc->drq_chip, \n    sc->dtq_free, sc->dtq_chip, sc->hwslistp);\n#endif\n\n  for (slot = 0 ; slot < EN_NTX ; slot++) {\n    sc->txslot[slot].bfree = EN_TXSZ * 1024;\n    EN_WRITE(sc, MIDX_READPTR(slot), 0);\n    EN_WRITE(sc, MIDX_DESCSTART(slot), 0);\n    loc = sc->txslot[slot].cur = sc->txslot[slot].start;\n    loc = loc - MID_RAMOFF;\n    loc = (loc & ~((EN_TXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    loc = loc >> MIDV_LOCTOPSHFT;\t/* top 11 bits */\n    EN_WRITE(sc, MIDX_PLACE(slot), MIDX_MKPLACE(en_k2sz(EN_TXSZ), loc));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: place 0x%x\\n\", sc->sc_dev.dv_xname,  slot,\n\tEN_READ(sc, MIDX_PLACE(slot)));\n#endif\n  }\n\n  /*\n   * enable!\n   */\n\n  EN_WRITE(sc, MID_INTENA, MID_INT_TX|MID_INT_DMA_OVR|MID_INT_IDENT|\n\tMID_INT_LERR|MID_INT_DMA_ERR|MID_INT_DMA_RX|MID_INT_DMA_TX|\n\tMID_INT_SERVICE| /* >>> MID_INT_SUNI| XXXCDC<<< */ MID_INT_STATS);\n  EN_WRITE(sc, MID_MAST_CSR, MID_SETIPL(sc->ipl)|MID_MCSR_ENDMA|\n\tMID_MCSR_ENTX|MID_MCSR_ENRX);\n\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC /* nothing */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_MAST_CSR",
            "MID_SETIPL(sc->ipl)|MID_MCSR_ENDMA|\n\tMID_MCSR_ENTX|MID_MCSR_ENRX"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_SETIPL",
          "args": [
            "sc->ipl"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_INTENA",
            "MID_INT_TX|MID_INT_DMA_OVR|MID_INT_IDENT|\n\tMID_INT_LERR|MID_INT_DMA_ERR|MID_INT_DMA_RX|MID_INT_DMA_TX|\n\tMID_INT_SERVICE| /* >>> MID_INT_SUNI| XXXCDC<<< */ MID_INT_STATS"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: tx%d: place 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "slot",
            "EN_READ(sc, MIDX_PLACE(slot))"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MIDX_PLACE(slot)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_PLACE",
          "args": [
            "slot"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MIDX_PLACE(slot)",
            "MIDX_MKPLACE(en_k2sz(EN_TXSZ), loc)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_MKPLACE",
          "args": [
            "en_k2sz(EN_TXSZ)",
            "loc"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_k2sz",
          "args": [
            "EN_TXSZ"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "en_k2sz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "464-481",
          "snippet": "int en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIDX_PLACE",
          "args": [
            "slot"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MIDX_DESCSTART(slot)",
            "0"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_DESCSTART",
          "args": [
            "slot"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MIDX_READPTR(slot)",
            "0"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_READPTR",
          "args": [
            "slot"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_SL_REG2A",
          "args": [
            "EN_READ(sc, MID_SERV_WRITE)"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_SERV_WRITE"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_DMA_WRTX",
            "MID_DRQ_A2REG(sc->dtq_chip)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_A2REG",
          "args": [
            "sc->dtq_chip"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_RDTX)"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDTX"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sc->dtq",
            "sizeof(sc->dtq)"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_DMA_WRRX",
            "MID_DRQ_A2REG(sc->drq_chip)"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_A2REG",
          "args": [
            "sc->drq_chip"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_RDRX)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDRX"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sc->drq",
            "sizeof(sc->drq)"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_loadvc",
          "args": [
            "sc",
            "vc"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "en_loadvc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1441-1466",
          "snippet": "STATIC void en_loadvc(sc, vc)\n\nstruct en_softc *sc;\nint vc;\n\n{\n  int slot;\n  u_int32_t reg = EN_READ(sc, MID_VC(vc));\n  \n  reg = MIDV_SETMODE(reg, MIDV_TRASH);\n  EN_WRITE(sc, MID_VC(vc), reg);\n  DELAY(27);\n\n  if ((slot = sc->rxvc2slot[vc]) == RX_NONE)\n    return;\n\n  /* no need to set CRC */\n  EN_WRITE(sc, MID_DST_RP(vc), 0);\t/* read pointer = 0, desc. start = 0 */\n  EN_WRITE(sc, MID_WP_ST_CNT(vc), 0);\t/* write pointer = 0 */\n  EN_WRITE(sc, MID_VC(vc), sc->rxslot[slot].mode);  /* set mode, size, loc */\n  sc->rxslot[slot].cur = sc->rxslot[slot].start;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: assigned to VCI %d\\n\", sc->sc_dev.dv_xname, slot, vc);\n#endif\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
            "#define STATIC static",
            "#define STATIC /* nothing */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC void en_loadvc(sc, vc)\n\nstruct en_softc *sc;\nint vc;\n\n{\n  int slot;\n  u_int32_t reg = EN_READ(sc, MID_VC(vc));\n  \n  reg = MIDV_SETMODE(reg, MIDV_TRASH);\n  EN_WRITE(sc, MID_VC(vc), reg);\n  DELAY(27);\n\n  if ((slot = sc->rxvc2slot[vc]) == RX_NONE)\n    return;\n\n  /* no need to set CRC */\n  EN_WRITE(sc, MID_DST_RP(vc), 0);\t/* read pointer = 0, desc. start = 0 */\n  EN_WRITE(sc, MID_WP_ST_CNT(vc), 0);\t/* write pointer = 0 */\n  EN_WRITE(sc, MID_VC(vc), sc->rxslot[slot].mode);  /* set mode, size, loc */\n  sc->rxslot[slot].cur = sc->rxslot[slot].start;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: assigned to VCI %d\\n\", sc->sc_dev.dv_xname, slot, vc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_RESID",
            "0x0"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->en_busreset",
          "args": [
            "sc"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_reset",
          "args": [
            "sc"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "en_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1268-1336",
          "snippet": "void en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
            "#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */",
            "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
            "#define RX_NONE\t\t0xffff\t/* recv VC not in use */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n\nvoid en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC void en_init(sc)\n\nstruct en_softc *sc;\n\n{\n  int vc, slot;\n  u_int32_t loc;\n\n  if ((sc->enif.if_flags & IFF_UP) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: going down\\n\", sc->sc_dev.dv_xname);\n#endif\n    en_reset(sc);\t\t\t/* to be safe */\n    sc->enif.if_flags &= ~IFF_RUNNING;\t/* disable */\n    return;\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: going up\\n\", sc->sc_dev.dv_xname);\n#endif\n  sc->enif.if_flags |= IFF_RUNNING;\t/* enable */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n\n  /*\n   * init obmem data structures: vc tab, dma q's, slist.\n   *\n   * note that we set drq_free/dtq_free to one less than the total number\n   * of DTQ/DRQs present.   we do this because the card uses the condition\n   * (drq_chip == drq_us) to mean \"list is empty\"... but if you allow the\n   * circular list to be completely full then (drq_chip == drq_us) [i.e.\n   * the drq_us pointer will wrap all the way around].   by restricting\n   * the number of active requests to (N - 1) we prevent the list from\n   * becoming completely full.    note that the card will sometimes give\n   * us an interrupt for a DTQ/DRQ we have already processes... this helps\n   * keep that interrupt from messing us up.\n   */\n\n  for (vc = 0 ; vc < MID_N_VC ; vc++) \n    en_loadvc(sc, vc);\n\n  bzero(&sc->drq, sizeof(sc->drq));\n  sc->drq_free = MID_DRQ_N - 1;\t\t/* N - 1 */\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->drq_us = sc->drq_chip;\n\n  bzero(&sc->dtq, sizeof(sc->dtq));\n  sc->dtq_free = MID_DTQ_N - 1;\t\t/* N - 1 */\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n  EN_WRITE(sc, MID_DMA_WRTX, MID_DRQ_A2REG(sc->dtq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->dtq_us = sc->dtq_chip;\n\n  sc->hwslistp = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n  sc->swsl_size = sc->swsl_head = sc->swsl_tail = 0;\n\n#ifdef EN_DEBUG\n  printf(\"%s: drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, hwslist: 0x%x\\n\", \n    sc->sc_dev.dv_xname, sc->drq_free, sc->drq_chip, \n    sc->dtq_free, sc->dtq_chip, sc->hwslistp);\n#endif\n\n  for (slot = 0 ; slot < EN_NTX ; slot++) {\n    sc->txslot[slot].bfree = EN_TXSZ * 1024;\n    EN_WRITE(sc, MIDX_READPTR(slot), 0);\n    EN_WRITE(sc, MIDX_DESCSTART(slot), 0);\n    loc = sc->txslot[slot].cur = sc->txslot[slot].start;\n    loc = loc - MID_RAMOFF;\n    loc = (loc & ~((EN_TXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    loc = loc >> MIDV_LOCTOPSHFT;\t/* top 11 bits */\n    EN_WRITE(sc, MIDX_PLACE(slot), MIDX_MKPLACE(en_k2sz(EN_TXSZ), loc));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: place 0x%x\\n\", sc->sc_dev.dv_xname,  slot,\n\tEN_READ(sc, MIDX_PLACE(slot)));\n#endif\n  }\n\n  /*\n   * enable!\n   */\n\n  EN_WRITE(sc, MID_INTENA, MID_INT_TX|MID_INT_DMA_OVR|MID_INT_IDENT|\n\tMID_INT_LERR|MID_INT_DMA_ERR|MID_INT_DMA_RX|MID_INT_DMA_TX|\n\tMID_INT_SERVICE| /* >>> MID_INT_SUNI| XXXCDC<<< */ MID_INT_STATS);\n  EN_WRITE(sc, MID_MAST_CSR, MID_SETIPL(sc->ipl)|MID_MCSR_ENDMA|\n\tMID_MCSR_ENTX|MID_MCSR_ENRX);\n\n}"
  },
  {
    "function_name": "en_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1268-1336",
    "snippet": "void en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
      "#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */",
      "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
      "#define RX_NONE\t\t0xffff\t/* recv VC not in use */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->txslot[lcv].q",
            "m"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->txslot[lcv].indma",
            "m"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx%d: VCI %d is now free\\n\"",
            "sc->sc_dev.dv_xname",
            "slot",
            "lcv"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->rxslot[slot].q",
            "m"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->rxslot[slot].indma",
            "m"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_RESID",
            "0x0"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->en_busreset",
          "args": [
            "sc"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n\nvoid en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}"
  },
  {
    "function_name": "en_rxctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1170-1259",
    "snippet": "STATIC int en_rxctl(sc, pi, on)\n\nstruct en_softc *sc;\nstruct atm_pseudoioctl *pi;\nint on;\n\n{\n  u_int s, vci, flags, slot;\n  u_int32_t oldmode, newmode;\n\n  vci = ATM_PH_VCI(&pi->aph);\n  flags = ATM_PH_FLAGS(&pi->aph);\n\n#ifdef EN_DEBUG\n  printf(\"%s: %s vpi=%d, vci=%d, flags=%d\\n\", sc->sc_dev.dv_xname,\n\t(on) ? \"enable\" : \"disable\", ATM_PH_VPI(&pi->aph), vci, flags);\n#endif\n\n  if (ATM_PH_VPI(&pi->aph) || vci >= MID_N_VC)\n    return(EINVAL);\n\n  /*\n   * turn on VCI!\n   */\n\n  if (on) {\n    if (sc->rxvc2slot[vci] != RX_NONE)\n      return(EINVAL);\n    for (slot = 0 ; slot < sc->en_nrx ; slot++)\n      if (sc->rxslot[slot].oth_flags & ENOTHER_FREE)\n\tbreak;\n    if (slot == sc->en_nrx)\n      return(ENOSPC);\n    sc->rxvc2slot[vci] = slot;\n    sc->rxslot[slot].rxhand = NULL;\n    oldmode = sc->rxslot[slot].mode;\n    newmode = (flags & ATM_PH_AAL5) ? MIDV_AAL5 : MIDV_NOAAL;\n    sc->rxslot[slot].mode = MIDV_SETMODE(oldmode, newmode);\n    sc->rxslot[slot].atm_vci = vci;\n    sc->rxslot[slot].atm_flags = flags;\n    sc->rxslot[slot].oth_flags = 0;\n    sc->rxslot[slot].rxhand = pi->rxhand;\n    if (sc->rxslot[slot].indma.ifq_head || sc->rxslot[slot].q.ifq_head)\n      panic(\"en_rxctl: left over mbufs on enable\");\n    sc->txspeed[vci] = 0;\t/* full speed to start */\n    sc->txvc2slot[vci] = 0;\t/* init value */\n    sc->txslot[0].nref++;\t/* bump reference count */\n    en_loadvc(sc, vci);\t\t/* does debug printf for us */\n    return(0);\n  }\n\n  /*\n   * turn off VCI\n   */\n\n  if (sc->rxvc2slot[vci] == RX_NONE)\n    return(EINVAL);\n  slot = sc->rxvc2slot[vci];\n  if ((sc->rxslot[slot].oth_flags & (ENOTHER_FREE|ENOTHER_DRAIN)) != 0)\n    return(EINVAL);\n  s = splimp();\t\t/* block out enintr() */\n  oldmode = EN_READ(sc, MID_VC(vci));\n  newmode = MIDV_SETMODE(oldmode, MIDV_TRASH) & ~MIDV_INSERVICE;\n  EN_WRITE(sc, MID_VC(vci), (newmode | (oldmode & MIDV_INSERVICE)));\n\t\t/* halt in tracks, be careful to preserve inserivce bit */\n  DELAY(27);\n  sc->rxslot[slot].rxhand = NULL;\n  sc->rxslot[slot].mode = newmode;\n\n  sc->txslot[sc->txvc2slot[vci]].nref--;\n  sc->txspeed[vci] = 0;\n  sc->txvc2slot[vci] = 0;\n\n  /* if stuff is still going on we are going to have to drain it out */\n  if (sc->rxslot[slot].indma.ifq_head || \n\t\tsc->rxslot[slot].q.ifq_head ||\n\t\t(sc->rxslot[slot].oth_flags & ENOTHER_SWSL) != 0) {\n    sc->rxslot[slot].oth_flags |= ENOTHER_DRAIN;\n  } else {\n    sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n    sc->rxslot[slot].atm_vci = RX_NONE;\n    sc->rxvc2slot[vci] = RX_NONE;\n  }\n  splx(s);\t\t/* enable enintr() */\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now %s\\n\", sc->sc_dev.dv_xname, slot, vci,\n\t(sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) ? \"draining\" : \"free\");\n#endif\n  return(0);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
      "#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */",
      "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
      "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
      "#define STATIC static",
      "#define STATIC /* nothing */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx%d: VCI %d is now %s\\n\"",
            "sc->sc_dev.dv_xname",
            "slot",
            "vci",
            "(sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) ? \"draining\" : \"free\""
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "27"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_VC(vci)",
            "(newmode | (oldmode & MIDV_INSERVICE))"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vci"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDV_SETMODE",
          "args": [
            "oldmode",
            "MIDV_TRASH"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_VC(vci)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "vci"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_loadvc",
          "args": [
            "sc",
            "vci"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "en_loadvc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1441-1466",
          "snippet": "STATIC void en_loadvc(sc, vc)\n\nstruct en_softc *sc;\nint vc;\n\n{\n  int slot;\n  u_int32_t reg = EN_READ(sc, MID_VC(vc));\n  \n  reg = MIDV_SETMODE(reg, MIDV_TRASH);\n  EN_WRITE(sc, MID_VC(vc), reg);\n  DELAY(27);\n\n  if ((slot = sc->rxvc2slot[vc]) == RX_NONE)\n    return;\n\n  /* no need to set CRC */\n  EN_WRITE(sc, MID_DST_RP(vc), 0);\t/* read pointer = 0, desc. start = 0 */\n  EN_WRITE(sc, MID_WP_ST_CNT(vc), 0);\t/* write pointer = 0 */\n  EN_WRITE(sc, MID_VC(vc), sc->rxslot[slot].mode);  /* set mode, size, loc */\n  sc->rxslot[slot].cur = sc->rxslot[slot].start;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: assigned to VCI %d\\n\", sc->sc_dev.dv_xname, slot, vc);\n#endif\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
            "#define STATIC static",
            "#define STATIC /* nothing */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC void en_loadvc(sc, vc)\n\nstruct en_softc *sc;\nint vc;\n\n{\n  int slot;\n  u_int32_t reg = EN_READ(sc, MID_VC(vc));\n  \n  reg = MIDV_SETMODE(reg, MIDV_TRASH);\n  EN_WRITE(sc, MID_VC(vc), reg);\n  DELAY(27);\n\n  if ((slot = sc->rxvc2slot[vc]) == RX_NONE)\n    return;\n\n  /* no need to set CRC */\n  EN_WRITE(sc, MID_DST_RP(vc), 0);\t/* read pointer = 0, desc. start = 0 */\n  EN_WRITE(sc, MID_WP_ST_CNT(vc), 0);\t/* write pointer = 0 */\n  EN_WRITE(sc, MID_VC(vc), sc->rxslot[slot].mode);  /* set mode, size, loc */\n  sc->rxslot[slot].cur = sc->rxslot[slot].start;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: assigned to VCI %d\\n\", sc->sc_dev.dv_xname, slot, vc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_rxctl: left over mbufs on enable\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDV_SETMODE",
          "args": [
            "oldmode",
            "newmode"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_VPI",
          "args": [
            "&pi->aph"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_VPI",
          "args": [
            "&pi->aph"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_FLAGS",
          "args": [
            "&pi->aph"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATM_PH_VCI",
          "args": [
            "&pi->aph"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC int en_rxctl(sc, pi, on)\n\nstruct en_softc *sc;\nstruct atm_pseudoioctl *pi;\nint on;\n\n{\n  u_int s, vci, flags, slot;\n  u_int32_t oldmode, newmode;\n\n  vci = ATM_PH_VCI(&pi->aph);\n  flags = ATM_PH_FLAGS(&pi->aph);\n\n#ifdef EN_DEBUG\n  printf(\"%s: %s vpi=%d, vci=%d, flags=%d\\n\", sc->sc_dev.dv_xname,\n\t(on) ? \"enable\" : \"disable\", ATM_PH_VPI(&pi->aph), vci, flags);\n#endif\n\n  if (ATM_PH_VPI(&pi->aph) || vci >= MID_N_VC)\n    return(EINVAL);\n\n  /*\n   * turn on VCI!\n   */\n\n  if (on) {\n    if (sc->rxvc2slot[vci] != RX_NONE)\n      return(EINVAL);\n    for (slot = 0 ; slot < sc->en_nrx ; slot++)\n      if (sc->rxslot[slot].oth_flags & ENOTHER_FREE)\n\tbreak;\n    if (slot == sc->en_nrx)\n      return(ENOSPC);\n    sc->rxvc2slot[vci] = slot;\n    sc->rxslot[slot].rxhand = NULL;\n    oldmode = sc->rxslot[slot].mode;\n    newmode = (flags & ATM_PH_AAL5) ? MIDV_AAL5 : MIDV_NOAAL;\n    sc->rxslot[slot].mode = MIDV_SETMODE(oldmode, newmode);\n    sc->rxslot[slot].atm_vci = vci;\n    sc->rxslot[slot].atm_flags = flags;\n    sc->rxslot[slot].oth_flags = 0;\n    sc->rxslot[slot].rxhand = pi->rxhand;\n    if (sc->rxslot[slot].indma.ifq_head || sc->rxslot[slot].q.ifq_head)\n      panic(\"en_rxctl: left over mbufs on enable\");\n    sc->txspeed[vci] = 0;\t/* full speed to start */\n    sc->txvc2slot[vci] = 0;\t/* init value */\n    sc->txslot[0].nref++;\t/* bump reference count */\n    en_loadvc(sc, vci);\t\t/* does debug printf for us */\n    return(0);\n  }\n\n  /*\n   * turn off VCI\n   */\n\n  if (sc->rxvc2slot[vci] == RX_NONE)\n    return(EINVAL);\n  slot = sc->rxvc2slot[vci];\n  if ((sc->rxslot[slot].oth_flags & (ENOTHER_FREE|ENOTHER_DRAIN)) != 0)\n    return(EINVAL);\n  s = splimp();\t\t/* block out enintr() */\n  oldmode = EN_READ(sc, MID_VC(vci));\n  newmode = MIDV_SETMODE(oldmode, MIDV_TRASH) & ~MIDV_INSERVICE;\n  EN_WRITE(sc, MID_VC(vci), (newmode | (oldmode & MIDV_INSERVICE)));\n\t\t/* halt in tracks, be careful to preserve inserivce bit */\n  DELAY(27);\n  sc->rxslot[slot].rxhand = NULL;\n  sc->rxslot[slot].mode = newmode;\n\n  sc->txslot[sc->txvc2slot[vci]].nref--;\n  sc->txspeed[vci] = 0;\n  sc->txvc2slot[vci] = 0;\n\n  /* if stuff is still going on we are going to have to drain it out */\n  if (sc->rxslot[slot].indma.ifq_head || \n\t\tsc->rxslot[slot].q.ifq_head ||\n\t\t(sc->rxslot[slot].oth_flags & ENOTHER_SWSL) != 0) {\n    sc->rxslot[slot].oth_flags |= ENOTHER_DRAIN;\n  } else {\n    sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n    sc->rxslot[slot].atm_vci = RX_NONE;\n    sc->rxvc2slot[vci] = RX_NONE;\n  }\n  splx(s);\t\t/* enable enintr() */\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now %s\\n\", sc->sc_dev.dv_xname, slot, vci,\n\t(sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) ? \"draining\" : \"free\");\n#endif\n  return(0);\n}"
  },
  {
    "function_name": "en_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "1064-1163",
    "snippet": "STATIC int en_ioctl(ifp, cmd, data)\n\nstruct ifnet *ifp;\nEN_IOCTL_CMDT cmd;\ncaddr_t data;\n\n{\n#ifdef MISSING_IF_SOFTC\n    struct en_softc *sc = (struct en_softc *) en_cd.cd_devs[ifp->if_unit];\n#else\n    struct en_softc *sc = (struct en_softc *) ifp->if_softc;\n#endif\n    struct ifaddr *ifa = (struct ifaddr *) data;\n    struct ifreq *ifr = (struct ifreq *) data;\n    struct atm_pseudoioctl *api = (struct atm_pseudoioctl *)data;\n#ifdef NATM\n    struct atm_rawioctl *ario = (struct atm_rawioctl *)data;\n    int slot;\n#endif\n    int s, error = 0;\n\n    s = splnet();\n\n    switch (cmd) {\n\tcase SIOCATMENA:\t\t/* enable circuit for recv */\n\t\terror = en_rxctl(sc, api, 1);\n\t\tbreak;\n\n\tcase SIOCATMDIS: \t\t/* disable circuit for recv */\n\t\terror = en_rxctl(sc, api, 0);\n\t\tbreak;\n\n#ifdef NATM\n\tcase SIOCXRAWATM:\n\t\tif ((slot = sc->rxvc2slot[ario->npcb->npcb_vci]) == RX_NONE) {\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ario->rawvalue > EN_RXSZ*1024)\n\t\t\tario->rawvalue = EN_RXSZ*1024;\n\t\tif (ario->rawvalue) {\n\t\t\tsc->rxslot[slot].oth_flags |= ENOTHER_RAW;\n\t\t\tsc->rxslot[slot].raw_threshold = ario->rawvalue;\n\t\t} else {\n\t\t\tsc->rxslot[slot].oth_flags &= (~ENOTHER_RAW);\n\t\t\tsc->rxslot[slot].raw_threshold = 0;\n\t\t}\n#ifdef EN_DEBUG\n\t\tprintf(\"%s: rxvci%d: turn %s raw (boodi) mode\\n\",\n\t\t\tsc->sc_dev.dv_xname, ario->npcb->npcb_vci,\n\t\t\t(ario->rawvalue) ? \"on\" : \"off\");\n#endif\n\t\tbreak;\n#endif\n\tcase SIOCSIFADDR: \n\t\tifp->if_flags |= IFF_UP;\n#ifdef INET\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\ten_reset(sc);\n\t\t\ten_init(sc);\n\t\t\tifa->ifa_rtrequest = atm_rtrequest; /* ??? */\n\t\t\tbreak;\n\t\t}\n#endif /* INET */\n\t\t/* what to do if not INET? */\n\t\ten_reset(sc);\n\t\ten_init(sc);\n\t\tbreak;\n\n\tcase SIOCGIFADDR: \n\t\terror = EINVAL;\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS: \n\t\terror = EINVAL;\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t    /*\n\t     * Set the interface MTU.\n\t     */\n#ifdef notsure\n\t    if (ifr->ifr_mtu > ATMMTU) {\n\t\terror = EINVAL;\n\t\tbreak;\n\t    }\n#endif\n\t    ifp->if_mtu = ifr->ifr_mtu;\n\t\t/* XXXCDC: do we really need to reset on MTU size change? */\n\t    en_reset(sc);\n\t    en_init(sc);\n\t    break;\n\n\tdefault: \n\t    error = EINVAL;\n\t    break;\n    }\n    splx(s);\n    return error;\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define ENOTHER_RAW\t0x04\t\t/* 'raw' access  (aka boodi mode) */",
      "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
      "#define MISSING_IF_SOFTC",
      "#define STATIC static",
      "#define STATIC /* nothing */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_init",
          "args": [
            "sc"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "en_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1343-1434",
          "snippet": "STATIC void en_init(sc)\n\nstruct en_softc *sc;\n\n{\n  int vc, slot;\n  u_int32_t loc;\n\n  if ((sc->enif.if_flags & IFF_UP) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: going down\\n\", sc->sc_dev.dv_xname);\n#endif\n    en_reset(sc);\t\t\t/* to be safe */\n    sc->enif.if_flags &= ~IFF_RUNNING;\t/* disable */\n    return;\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: going up\\n\", sc->sc_dev.dv_xname);\n#endif\n  sc->enif.if_flags |= IFF_RUNNING;\t/* enable */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n\n  /*\n   * init obmem data structures: vc tab, dma q's, slist.\n   *\n   * note that we set drq_free/dtq_free to one less than the total number\n   * of DTQ/DRQs present.   we do this because the card uses the condition\n   * (drq_chip == drq_us) to mean \"list is empty\"... but if you allow the\n   * circular list to be completely full then (drq_chip == drq_us) [i.e.\n   * the drq_us pointer will wrap all the way around].   by restricting\n   * the number of active requests to (N - 1) we prevent the list from\n   * becoming completely full.    note that the card will sometimes give\n   * us an interrupt for a DTQ/DRQ we have already processes... this helps\n   * keep that interrupt from messing us up.\n   */\n\n  for (vc = 0 ; vc < MID_N_VC ; vc++) \n    en_loadvc(sc, vc);\n\n  bzero(&sc->drq, sizeof(sc->drq));\n  sc->drq_free = MID_DRQ_N - 1;\t\t/* N - 1 */\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->drq_us = sc->drq_chip;\n\n  bzero(&sc->dtq, sizeof(sc->dtq));\n  sc->dtq_free = MID_DTQ_N - 1;\t\t/* N - 1 */\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n  EN_WRITE(sc, MID_DMA_WRTX, MID_DRQ_A2REG(sc->dtq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->dtq_us = sc->dtq_chip;\n\n  sc->hwslistp = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n  sc->swsl_size = sc->swsl_head = sc->swsl_tail = 0;\n\n#ifdef EN_DEBUG\n  printf(\"%s: drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, hwslist: 0x%x\\n\", \n    sc->sc_dev.dv_xname, sc->drq_free, sc->drq_chip, \n    sc->dtq_free, sc->dtq_chip, sc->hwslistp);\n#endif\n\n  for (slot = 0 ; slot < EN_NTX ; slot++) {\n    sc->txslot[slot].bfree = EN_TXSZ * 1024;\n    EN_WRITE(sc, MIDX_READPTR(slot), 0);\n    EN_WRITE(sc, MIDX_DESCSTART(slot), 0);\n    loc = sc->txslot[slot].cur = sc->txslot[slot].start;\n    loc = loc - MID_RAMOFF;\n    loc = (loc & ~((EN_TXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    loc = loc >> MIDV_LOCTOPSHFT;\t/* top 11 bits */\n    EN_WRITE(sc, MIDX_PLACE(slot), MIDX_MKPLACE(en_k2sz(EN_TXSZ), loc));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: place 0x%x\\n\", sc->sc_dev.dv_xname,  slot,\n\tEN_READ(sc, MIDX_PLACE(slot)));\n#endif\n  }\n\n  /*\n   * enable!\n   */\n\n  EN_WRITE(sc, MID_INTENA, MID_INT_TX|MID_INT_DMA_OVR|MID_INT_IDENT|\n\tMID_INT_LERR|MID_INT_DMA_ERR|MID_INT_DMA_RX|MID_INT_DMA_TX|\n\tMID_INT_SERVICE| /* >>> MID_INT_SUNI| XXXCDC<<< */ MID_INT_STATS);\n  EN_WRITE(sc, MID_MAST_CSR, MID_SETIPL(sc->ipl)|MID_MCSR_ENDMA|\n\tMID_MCSR_ENTX|MID_MCSR_ENRX);\n\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC /* nothing */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC void en_init(sc)\n\nstruct en_softc *sc;\n\n{\n  int vc, slot;\n  u_int32_t loc;\n\n  if ((sc->enif.if_flags & IFF_UP) == 0) {\n#ifdef EN_DEBUG\n    printf(\"%s: going down\\n\", sc->sc_dev.dv_xname);\n#endif\n    en_reset(sc);\t\t\t/* to be safe */\n    sc->enif.if_flags &= ~IFF_RUNNING;\t/* disable */\n    return;\n  }\n\n#ifdef EN_DEBUG\n  printf(\"%s: going up\\n\", sc->sc_dev.dv_xname);\n#endif\n  sc->enif.if_flags |= IFF_RUNNING;\t/* enable */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n\n  /*\n   * init obmem data structures: vc tab, dma q's, slist.\n   *\n   * note that we set drq_free/dtq_free to one less than the total number\n   * of DTQ/DRQs present.   we do this because the card uses the condition\n   * (drq_chip == drq_us) to mean \"list is empty\"... but if you allow the\n   * circular list to be completely full then (drq_chip == drq_us) [i.e.\n   * the drq_us pointer will wrap all the way around].   by restricting\n   * the number of active requests to (N - 1) we prevent the list from\n   * becoming completely full.    note that the card will sometimes give\n   * us an interrupt for a DTQ/DRQ we have already processes... this helps\n   * keep that interrupt from messing us up.\n   */\n\n  for (vc = 0 ; vc < MID_N_VC ; vc++) \n    en_loadvc(sc, vc);\n\n  bzero(&sc->drq, sizeof(sc->drq));\n  sc->drq_free = MID_DRQ_N - 1;\t\t/* N - 1 */\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->drq_us = sc->drq_chip;\n\n  bzero(&sc->dtq, sizeof(sc->dtq));\n  sc->dtq_free = MID_DTQ_N - 1;\t\t/* N - 1 */\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n  EN_WRITE(sc, MID_DMA_WRTX, MID_DRQ_A2REG(sc->dtq_chip)); \n\t\t\t\t\t\t/* ensure zero queue */\n  sc->dtq_us = sc->dtq_chip;\n\n  sc->hwslistp = MID_SL_REG2A(EN_READ(sc, MID_SERV_WRITE));\n  sc->swsl_size = sc->swsl_head = sc->swsl_tail = 0;\n\n#ifdef EN_DEBUG\n  printf(\"%s: drq free/chip: %d/0x%x, dtq free/chip: %d/0x%x, hwslist: 0x%x\\n\", \n    sc->sc_dev.dv_xname, sc->drq_free, sc->drq_chip, \n    sc->dtq_free, sc->dtq_chip, sc->hwslistp);\n#endif\n\n  for (slot = 0 ; slot < EN_NTX ; slot++) {\n    sc->txslot[slot].bfree = EN_TXSZ * 1024;\n    EN_WRITE(sc, MIDX_READPTR(slot), 0);\n    EN_WRITE(sc, MIDX_DESCSTART(slot), 0);\n    loc = sc->txslot[slot].cur = sc->txslot[slot].start;\n    loc = loc - MID_RAMOFF;\n    loc = (loc & ~((EN_TXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    loc = loc >> MIDV_LOCTOPSHFT;\t/* top 11 bits */\n    EN_WRITE(sc, MIDX_PLACE(slot), MIDX_MKPLACE(en_k2sz(EN_TXSZ), loc));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: place 0x%x\\n\", sc->sc_dev.dv_xname,  slot,\n\tEN_READ(sc, MIDX_PLACE(slot)));\n#endif\n  }\n\n  /*\n   * enable!\n   */\n\n  EN_WRITE(sc, MID_INTENA, MID_INT_TX|MID_INT_DMA_OVR|MID_INT_IDENT|\n\tMID_INT_LERR|MID_INT_DMA_ERR|MID_INT_DMA_RX|MID_INT_DMA_TX|\n\tMID_INT_SERVICE| /* >>> MID_INT_SUNI| XXXCDC<<< */ MID_INT_STATS);\n  EN_WRITE(sc, MID_MAST_CSR, MID_SETIPL(sc->ipl)|MID_MCSR_ENDMA|\n\tMID_MCSR_ENTX|MID_MCSR_ENRX);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "en_reset",
          "args": [
            "sc"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "en_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1268-1336",
          "snippet": "void en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
            "#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */",
            "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
            "#define RX_NONE\t\t0xffff\t/* recv VC not in use */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n\nvoid en_reset(sc)\n\nstruct en_softc *sc;\n\n{\n  struct mbuf *m;\n  int lcv, slot;\n\n#ifdef EN_DEBUG\n  printf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset hardware */\n\n  /*\n   * recv: dump any mbufs we are dma'ing into, if DRAINing, then a reset\n   * will free us!\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    if (sc->rxvc2slot[lcv] == RX_NONE)\n      continue;\n    slot = sc->rxvc2slot[lcv];\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->rxslot[slot].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->rxslot[slot].oth_flags &= ~ENOTHER_SWSL;\n    if (sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) {\n      sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n      sc->rxvc2slot[lcv] = RX_NONE;\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now free\\n\", sc->sc_dev.dv_xname, slot, lcv);\n#endif\n    }\n  }\n\n  /*\n   * xmit: dump everything\n   */\n\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].indma, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    while (1) {\n      IF_DEQUEUE(&sc->txslot[lcv].q, m);\n      if (m == NULL) \n\tbreak;\t\t/* >>> exit 'while(1)' here <<< */\n      m_freem(m);\n    }\n    sc->txslot[lcv].mbsize = 0;\n  }\n\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rxvci%d: turn %s raw (boodi) mode\\n\"",
            "sc->sc_dev.dv_xname",
            "ario->npcb->npcb_vci",
            "(ario->rawvalue) ? \"on\" : \"off\""
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "en_rxctl",
          "args": [
            "sc",
            "api",
            "0"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "en_rxctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "1170-1259",
          "snippet": "STATIC int en_rxctl(sc, pi, on)\n\nstruct en_softc *sc;\nstruct atm_pseudoioctl *pi;\nint on;\n\n{\n  u_int s, vci, flags, slot;\n  u_int32_t oldmode, newmode;\n\n  vci = ATM_PH_VCI(&pi->aph);\n  flags = ATM_PH_FLAGS(&pi->aph);\n\n#ifdef EN_DEBUG\n  printf(\"%s: %s vpi=%d, vci=%d, flags=%d\\n\", sc->sc_dev.dv_xname,\n\t(on) ? \"enable\" : \"disable\", ATM_PH_VPI(&pi->aph), vci, flags);\n#endif\n\n  if (ATM_PH_VPI(&pi->aph) || vci >= MID_N_VC)\n    return(EINVAL);\n\n  /*\n   * turn on VCI!\n   */\n\n  if (on) {\n    if (sc->rxvc2slot[vci] != RX_NONE)\n      return(EINVAL);\n    for (slot = 0 ; slot < sc->en_nrx ; slot++)\n      if (sc->rxslot[slot].oth_flags & ENOTHER_FREE)\n\tbreak;\n    if (slot == sc->en_nrx)\n      return(ENOSPC);\n    sc->rxvc2slot[vci] = slot;\n    sc->rxslot[slot].rxhand = NULL;\n    oldmode = sc->rxslot[slot].mode;\n    newmode = (flags & ATM_PH_AAL5) ? MIDV_AAL5 : MIDV_NOAAL;\n    sc->rxslot[slot].mode = MIDV_SETMODE(oldmode, newmode);\n    sc->rxslot[slot].atm_vci = vci;\n    sc->rxslot[slot].atm_flags = flags;\n    sc->rxslot[slot].oth_flags = 0;\n    sc->rxslot[slot].rxhand = pi->rxhand;\n    if (sc->rxslot[slot].indma.ifq_head || sc->rxslot[slot].q.ifq_head)\n      panic(\"en_rxctl: left over mbufs on enable\");\n    sc->txspeed[vci] = 0;\t/* full speed to start */\n    sc->txvc2slot[vci] = 0;\t/* init value */\n    sc->txslot[0].nref++;\t/* bump reference count */\n    en_loadvc(sc, vci);\t\t/* does debug printf for us */\n    return(0);\n  }\n\n  /*\n   * turn off VCI\n   */\n\n  if (sc->rxvc2slot[vci] == RX_NONE)\n    return(EINVAL);\n  slot = sc->rxvc2slot[vci];\n  if ((sc->rxslot[slot].oth_flags & (ENOTHER_FREE|ENOTHER_DRAIN)) != 0)\n    return(EINVAL);\n  s = splimp();\t\t/* block out enintr() */\n  oldmode = EN_READ(sc, MID_VC(vci));\n  newmode = MIDV_SETMODE(oldmode, MIDV_TRASH) & ~MIDV_INSERVICE;\n  EN_WRITE(sc, MID_VC(vci), (newmode | (oldmode & MIDV_INSERVICE)));\n\t\t/* halt in tracks, be careful to preserve inserivce bit */\n  DELAY(27);\n  sc->rxslot[slot].rxhand = NULL;\n  sc->rxslot[slot].mode = newmode;\n\n  sc->txslot[sc->txvc2slot[vci]].nref--;\n  sc->txspeed[vci] = 0;\n  sc->txvc2slot[vci] = 0;\n\n  /* if stuff is still going on we are going to have to drain it out */\n  if (sc->rxslot[slot].indma.ifq_head || \n\t\tsc->rxslot[slot].q.ifq_head ||\n\t\t(sc->rxslot[slot].oth_flags & ENOTHER_SWSL) != 0) {\n    sc->rxslot[slot].oth_flags |= ENOTHER_DRAIN;\n  } else {\n    sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n    sc->rxslot[slot].atm_vci = RX_NONE;\n    sc->rxvc2slot[vci] = RX_NONE;\n  }\n  splx(s);\t\t/* enable enintr() */\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now %s\\n\", sc->sc_dev.dv_xname, slot, vci,\n\t(sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) ? \"draining\" : \"free\");\n#endif\n  return(0);\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [
            "#define ENOTHER_SWSL\t0x08\t\t/* in software service list */",
            "#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */",
            "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
            "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
            "#define STATIC static",
            "#define STATIC /* nothing */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_SWSL\t0x08\t\t/* in software service list */\n#define ENOTHER_DRAIN\t0x02\t\t/* almost free (drain DRQ dma) */\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC int en_rxctl(sc, pi, on)\n\nstruct en_softc *sc;\nstruct atm_pseudoioctl *pi;\nint on;\n\n{\n  u_int s, vci, flags, slot;\n  u_int32_t oldmode, newmode;\n\n  vci = ATM_PH_VCI(&pi->aph);\n  flags = ATM_PH_FLAGS(&pi->aph);\n\n#ifdef EN_DEBUG\n  printf(\"%s: %s vpi=%d, vci=%d, flags=%d\\n\", sc->sc_dev.dv_xname,\n\t(on) ? \"enable\" : \"disable\", ATM_PH_VPI(&pi->aph), vci, flags);\n#endif\n\n  if (ATM_PH_VPI(&pi->aph) || vci >= MID_N_VC)\n    return(EINVAL);\n\n  /*\n   * turn on VCI!\n   */\n\n  if (on) {\n    if (sc->rxvc2slot[vci] != RX_NONE)\n      return(EINVAL);\n    for (slot = 0 ; slot < sc->en_nrx ; slot++)\n      if (sc->rxslot[slot].oth_flags & ENOTHER_FREE)\n\tbreak;\n    if (slot == sc->en_nrx)\n      return(ENOSPC);\n    sc->rxvc2slot[vci] = slot;\n    sc->rxslot[slot].rxhand = NULL;\n    oldmode = sc->rxslot[slot].mode;\n    newmode = (flags & ATM_PH_AAL5) ? MIDV_AAL5 : MIDV_NOAAL;\n    sc->rxslot[slot].mode = MIDV_SETMODE(oldmode, newmode);\n    sc->rxslot[slot].atm_vci = vci;\n    sc->rxslot[slot].atm_flags = flags;\n    sc->rxslot[slot].oth_flags = 0;\n    sc->rxslot[slot].rxhand = pi->rxhand;\n    if (sc->rxslot[slot].indma.ifq_head || sc->rxslot[slot].q.ifq_head)\n      panic(\"en_rxctl: left over mbufs on enable\");\n    sc->txspeed[vci] = 0;\t/* full speed to start */\n    sc->txvc2slot[vci] = 0;\t/* init value */\n    sc->txslot[0].nref++;\t/* bump reference count */\n    en_loadvc(sc, vci);\t\t/* does debug printf for us */\n    return(0);\n  }\n\n  /*\n   * turn off VCI\n   */\n\n  if (sc->rxvc2slot[vci] == RX_NONE)\n    return(EINVAL);\n  slot = sc->rxvc2slot[vci];\n  if ((sc->rxslot[slot].oth_flags & (ENOTHER_FREE|ENOTHER_DRAIN)) != 0)\n    return(EINVAL);\n  s = splimp();\t\t/* block out enintr() */\n  oldmode = EN_READ(sc, MID_VC(vci));\n  newmode = MIDV_SETMODE(oldmode, MIDV_TRASH) & ~MIDV_INSERVICE;\n  EN_WRITE(sc, MID_VC(vci), (newmode | (oldmode & MIDV_INSERVICE)));\n\t\t/* halt in tracks, be careful to preserve inserivce bit */\n  DELAY(27);\n  sc->rxslot[slot].rxhand = NULL;\n  sc->rxslot[slot].mode = newmode;\n\n  sc->txslot[sc->txvc2slot[vci]].nref--;\n  sc->txspeed[vci] = 0;\n  sc->txvc2slot[vci] = 0;\n\n  /* if stuff is still going on we are going to have to drain it out */\n  if (sc->rxslot[slot].indma.ifq_head || \n\t\tsc->rxslot[slot].q.ifq_head ||\n\t\t(sc->rxslot[slot].oth_flags & ENOTHER_SWSL) != 0) {\n    sc->rxslot[slot].oth_flags |= ENOTHER_DRAIN;\n  } else {\n    sc->rxslot[slot].oth_flags = ENOTHER_FREE;\n    sc->rxslot[slot].atm_vci = RX_NONE;\n    sc->rxvc2slot[vci] = RX_NONE;\n  }\n  splx(s);\t\t/* enable enintr() */\n#ifdef EN_DEBUG\n  printf(\"%s: rx%d: VCI %d is now %s\\n\", sc->sc_dev.dv_xname, slot, vci,\n\t(sc->rxslot[slot].oth_flags & ENOTHER_DRAIN) ? \"draining\" : \"free\");\n#endif\n  return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_RAW\t0x04\t\t/* 'raw' access  (aka boodi mode) */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define MISSING_IF_SOFTC\n#define STATIC static\n#define STATIC /* nothing */\n\nSTATIC int en_ioctl(ifp, cmd, data)\n\nstruct ifnet *ifp;\nEN_IOCTL_CMDT cmd;\ncaddr_t data;\n\n{\n#ifdef MISSING_IF_SOFTC\n    struct en_softc *sc = (struct en_softc *) en_cd.cd_devs[ifp->if_unit];\n#else\n    struct en_softc *sc = (struct en_softc *) ifp->if_softc;\n#endif\n    struct ifaddr *ifa = (struct ifaddr *) data;\n    struct ifreq *ifr = (struct ifreq *) data;\n    struct atm_pseudoioctl *api = (struct atm_pseudoioctl *)data;\n#ifdef NATM\n    struct atm_rawioctl *ario = (struct atm_rawioctl *)data;\n    int slot;\n#endif\n    int s, error = 0;\n\n    s = splnet();\n\n    switch (cmd) {\n\tcase SIOCATMENA:\t\t/* enable circuit for recv */\n\t\terror = en_rxctl(sc, api, 1);\n\t\tbreak;\n\n\tcase SIOCATMDIS: \t\t/* disable circuit for recv */\n\t\terror = en_rxctl(sc, api, 0);\n\t\tbreak;\n\n#ifdef NATM\n\tcase SIOCXRAWATM:\n\t\tif ((slot = sc->rxvc2slot[ario->npcb->npcb_vci]) == RX_NONE) {\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ario->rawvalue > EN_RXSZ*1024)\n\t\t\tario->rawvalue = EN_RXSZ*1024;\n\t\tif (ario->rawvalue) {\n\t\t\tsc->rxslot[slot].oth_flags |= ENOTHER_RAW;\n\t\t\tsc->rxslot[slot].raw_threshold = ario->rawvalue;\n\t\t} else {\n\t\t\tsc->rxslot[slot].oth_flags &= (~ENOTHER_RAW);\n\t\t\tsc->rxslot[slot].raw_threshold = 0;\n\t\t}\n#ifdef EN_DEBUG\n\t\tprintf(\"%s: rxvci%d: turn %s raw (boodi) mode\\n\",\n\t\t\tsc->sc_dev.dv_xname, ario->npcb->npcb_vci,\n\t\t\t(ario->rawvalue) ? \"on\" : \"off\");\n#endif\n\t\tbreak;\n#endif\n\tcase SIOCSIFADDR: \n\t\tifp->if_flags |= IFF_UP;\n#ifdef INET\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\ten_reset(sc);\n\t\t\ten_init(sc);\n\t\t\tifa->ifa_rtrequest = atm_rtrequest; /* ??? */\n\t\t\tbreak;\n\t\t}\n#endif /* INET */\n\t\t/* what to do if not INET? */\n\t\ten_reset(sc);\n\t\ten_init(sc);\n\t\tbreak;\n\n\tcase SIOCGIFADDR: \n\t\terror = EINVAL;\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS: \n\t\terror = EINVAL;\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t    /*\n\t     * Set the interface MTU.\n\t     */\n#ifdef notsure\n\t    if (ifr->ifr_mtu > ATMMTU) {\n\t\terror = EINVAL;\n\t\tbreak;\n\t    }\n#endif\n\t    ifp->if_mtu = ifr->ifr_mtu;\n\t\t/* XXXCDC: do we really need to reset on MTU size change? */\n\t    en_reset(sc);\n\t    en_init(sc);\n\t    break;\n\n\tdefault: \n\t    error = EINVAL;\n\t    break;\n    }\n    splx(s);\n    return error;\n}"
  },
  {
    "function_name": "en_dmaprobe_doit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "927-1050",
    "snippet": "int\nen_dmaprobe_doit(sc, sp, dp, wmtry)\n\nstruct en_softc *sc;\nu_int8_t *sp, *dp;\nint wmtry;\n\n{\n  int lcv, retval = 4, cnt, count;\n  u_int32_t reg, bcode, midvloc;\n\n  /*\n   * set up a 1k buffer at MID_BUFOFF\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n\n  midvloc = ((MID_BUFOFF - MID_RAMOFF) / sizeof(u_int32_t)) >> MIDV_LOCTOPSHFT;\n  EN_WRITE(sc, MIDX_PLACE(0), MIDX_MKPLACE(en_k2sz(1), midvloc));\n  EN_WRITE(sc, MID_VC(0), (midvloc << MIDV_LOCSHIFT) \n\t\t| (en_k2sz(1) << MIDV_SZSHIFT) | MIDV_TRASH);\n  EN_WRITE(sc, MID_DST_RP(0), 0);\n  EN_WRITE(sc, MID_WP_ST_CNT(0), 0);\n\n  for (lcv = 0 ; lcv < 68 ; lcv++) \t\t/* set up sample data */\n    sp[lcv] = lcv+1;\n  EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);\t/* enable DMA (only) */\n\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n\n  /*\n   * try it now . . .  DMA it out, then DMA it back in and compare\n   *\n   * note: in order to get the dma stuff to reverse directions it wants\n   * the \"end\" flag set!   since we are not dma'ing valid data we may\n   * get an ident mismatch interrupt (which we will ignore).\n   *\n   * note: we've got two different tests rolled up in the same loop\n   * if (wmtry) \n   *   then we are doing a wmaybe test and wmtry is a byte count\n   *   else we are doing a burst test\n   */\n\n  for (lcv = 8 ; lcv <= MIDDMA_MAXBURST ; lcv = lcv * 2) {\n\n    /* zero SRAM and dest buffer */\n    for (cnt = 0 ; cnt < 1024; cnt += 4) \n      EN_WRITE(sc, MID_BUFOFF+cnt, 0);\t/* zero memory */\n    for (cnt = 0 ; cnt < 68  ; cnt++) \n      dp[cnt] = 0;\n\n    if (wmtry) {\n      count = (sc->bestburstlen - sizeof(u_int32_t)) / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = wmtry >> en_dmaplan[count].divshift;\n    } else {\n      bcode = en_sz2b(lcv);\n      count = 1;\n    }\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->dtq_chip+4, vtophys(sp));\n    EN_WRITE(sc, MID_DMA_WRTX, MID_DTQ_A2REG(sc->dtq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDTX) == MID_DTQ_A2REG(sc->dtq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in tx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DTQOFF, MID_DTQEND, sc->dtq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_TX) != MID_INT_DMA_TX) {\n      printf(\"%s: unexpected status in tx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    /* \"return to sender...\"  address is known ... */\n\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->drq_chip+4, vtophys(dp));\n    EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDRX) == MID_DRQ_A2REG(sc->drq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in rx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DRQOFF, MID_DRQEND, sc->drq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_RX) != MID_INT_DMA_RX) {\n      printf(\"%s: unexpected status in rx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    if (wmtry) {\n      return(bcmp(sp, dp, wmtry));  /* wmtry always exits here, no looping */\n    }\n  \n    if (bcmp(sp, dp, lcv))\n      return(retval);\t\t/* failed, use last value */\n\n    retval = lcv;\n\n  }\n  return(retval);\t\t/* studly 64 byte DMA present!  oh baby!! */\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "sp",
            "dp",
            "lcv"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "sp",
            "dp",
            "wmtry"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_MAST_CSR",
            "MID_MCSR_ENDMA"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected status in rx DMA test: 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "reg"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_INTACK"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "MID_DRQOFF",
            "MID_DRQEND",
            "sc->drq_chip",
            "8"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_A2REG",
          "args": [
            "sc->drq_chip"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDRX"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_DMA_WRRX",
            "MID_DRQ_A2REG(sc->drq_chip+8)"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_A2REG",
          "args": [
            "sc->drq_chip+8"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "sc->drq_chip+4",
            "vtophys(dp)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "dp"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "sc->drq_chip",
            "MID_MK_RXQ_ENI(count, 0, MID_DMA_END, bcode)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_MK_RXQ_ENI",
          "args": [
            "count",
            "0",
            "MID_DMA_END",
            "bcode"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "sc->drq_chip",
            "MID_MK_RXQ_ADP(lcv, 0, MID_DMA_END, 0)"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_MK_RXQ_ADP",
          "args": [
            "lcv",
            "0",
            "MID_DMA_END",
            "0"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_MAST_CSR",
            "MID_MCSR_ENDMA"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_INTACK"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRAPADD",
          "args": [
            "MID_DTQOFF",
            "MID_DTQEND",
            "sc->dtq_chip",
            "8"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_A2REG",
          "args": [
            "sc->dtq_chip"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDTX"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_DMA_WRTX",
            "MID_DTQ_A2REG(sc->dtq_chip+8)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_A2REG",
          "args": [
            "sc->dtq_chip+8"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "sc->dtq_chip+4",
            "vtophys(sp)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sp"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "sc->dtq_chip",
            "MID_MK_TXQ_ENI(count, 0, MID_DMA_END, bcode)"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_MK_TXQ_ENI",
          "args": [
            "count",
            "0",
            "MID_DMA_END",
            "bcode"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "sc->dtq_chip",
            "MID_MK_TXQ_ADP(lcv, 0, MID_DMA_END, 0)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_MK_TXQ_ADP",
          "args": [
            "lcv",
            "0",
            "MID_DMA_END",
            "0"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_sz2b",
          "args": [
            "lcv"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "en_sz2b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "514-528",
          "snippet": "int en_sz2b(sz)\n\nint sz;\n\n{\n  switch (sz) {\n    case 1*4:  return(MIDDMA_WORD);\n    case 2*4:  return(MIDDMA_2WORD);\n    case 4*4:  return(MIDDMA_4WORD);\n    case 8*4:  return(MIDDMA_8WORD);\n    case 16*4: return(MIDDMA_16WORD);\n    default: panic(\"en_sz2b\");\n  }\n  return(0);\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_sz2b(sz)\n\nint sz;\n\n{\n  switch (sz) {\n    case 1*4:  return(MIDDMA_WORD);\n    case 2*4:  return(MIDDMA_2WORD);\n    case 4*4:  return(MIDDMA_4WORD);\n    case 8*4:  return(MIDDMA_8WORD);\n    case 16*4: return(MIDDMA_16WORD);\n    default: panic(\"en_sz2b\");\n  }\n  return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_BUFOFF+cnt",
            "0"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DTQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_RDTX)"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDTX"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DRQ_REG2A",
          "args": [
            "EN_READ(sc, MID_DMA_RDRX)"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_DMA_RDRX"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_MAST_CSR",
            "MID_MCSR_ENDMA"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_WP_ST_CNT(0)",
            "0"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_WP_ST_CNT",
          "args": [
            "0"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_DST_RP(0)",
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DST_RP",
          "args": [
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_VC(0)",
            "(midvloc << MIDV_LOCSHIFT) \n\t\t| (en_k2sz(1) << MIDV_SZSHIFT) | MIDV_TRASH"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_k2sz",
          "args": [
            "1"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "en_k2sz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "464-481",
          "snippet": "int en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MID_VC",
          "args": [
            "0"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MIDX_PLACE(0)",
            "MIDX_MKPLACE(en_k2sz(1), midvloc)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_MKPLACE",
          "args": [
            "en_k2sz(1)",
            "midvloc"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIDX_PLACE",
          "args": [
            "0"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_RESID",
            "0x0"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->en_busreset",
          "args": [
            "sc"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint\nen_dmaprobe_doit(sc, sp, dp, wmtry)\n\nstruct en_softc *sc;\nu_int8_t *sp, *dp;\nint wmtry;\n\n{\n  int lcv, retval = 4, cnt, count;\n  u_int32_t reg, bcode, midvloc;\n\n  /*\n   * set up a 1k buffer at MID_BUFOFF\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n\n  midvloc = ((MID_BUFOFF - MID_RAMOFF) / sizeof(u_int32_t)) >> MIDV_LOCTOPSHFT;\n  EN_WRITE(sc, MIDX_PLACE(0), MIDX_MKPLACE(en_k2sz(1), midvloc));\n  EN_WRITE(sc, MID_VC(0), (midvloc << MIDV_LOCSHIFT) \n\t\t| (en_k2sz(1) << MIDV_SZSHIFT) | MIDV_TRASH);\n  EN_WRITE(sc, MID_DST_RP(0), 0);\n  EN_WRITE(sc, MID_WP_ST_CNT(0), 0);\n\n  for (lcv = 0 ; lcv < 68 ; lcv++) \t\t/* set up sample data */\n    sp[lcv] = lcv+1;\n  EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);\t/* enable DMA (only) */\n\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n\n  /*\n   * try it now . . .  DMA it out, then DMA it back in and compare\n   *\n   * note: in order to get the dma stuff to reverse directions it wants\n   * the \"end\" flag set!   since we are not dma'ing valid data we may\n   * get an ident mismatch interrupt (which we will ignore).\n   *\n   * note: we've got two different tests rolled up in the same loop\n   * if (wmtry) \n   *   then we are doing a wmaybe test and wmtry is a byte count\n   *   else we are doing a burst test\n   */\n\n  for (lcv = 8 ; lcv <= MIDDMA_MAXBURST ; lcv = lcv * 2) {\n\n    /* zero SRAM and dest buffer */\n    for (cnt = 0 ; cnt < 1024; cnt += 4) \n      EN_WRITE(sc, MID_BUFOFF+cnt, 0);\t/* zero memory */\n    for (cnt = 0 ; cnt < 68  ; cnt++) \n      dp[cnt] = 0;\n\n    if (wmtry) {\n      count = (sc->bestburstlen - sizeof(u_int32_t)) / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = wmtry >> en_dmaplan[count].divshift;\n    } else {\n      bcode = en_sz2b(lcv);\n      count = 1;\n    }\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->dtq_chip+4, vtophys(sp));\n    EN_WRITE(sc, MID_DMA_WRTX, MID_DTQ_A2REG(sc->dtq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDTX) == MID_DTQ_A2REG(sc->dtq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in tx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DTQOFF, MID_DTQEND, sc->dtq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_TX) != MID_INT_DMA_TX) {\n      printf(\"%s: unexpected status in tx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    /* \"return to sender...\"  address is known ... */\n\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->drq_chip+4, vtophys(dp));\n    EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDRX) == MID_DRQ_A2REG(sc->drq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in rx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DRQOFF, MID_DRQEND, sc->drq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_RX) != MID_INT_DMA_RX) {\n      printf(\"%s: unexpected status in rx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    if (wmtry) {\n      return(bcmp(sp, dp, wmtry));  /* wmtry always exits here, no looping */\n    }\n  \n    if (bcmp(sp, dp, lcv))\n      return(retval);\t\t/* failed, use last value */\n\n    retval = lcv;\n\n  }\n  return(retval);\t\t/* studly 64 byte DMA present!  oh baby!! */\n}"
  },
  {
    "function_name": "en_dmaprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "853-920",
    "snippet": "STATIC void en_dmaprobe(sc)\n\nstruct en_softc *sc;\n\n{\n  u_int32_t srcbuf[64], dstbuf[64];\n  u_int8_t *sp, *dp;\n  int bestalgn, bestnotalgn, lcv, try, fail;\n\n  sc->alburst = 0;\n\n  sp = (u_int8_t *) srcbuf;\n  while ((((unsigned long) sp) % MIDDMA_MAXBURST) != 0)\n    sp += 4;\n  dp = (u_int8_t *) dstbuf;\n  while ((((unsigned long) dp) % MIDDMA_MAXBURST) != 0)\n    dp += 4;\n\n  bestalgn = bestnotalgn = en_dmaprobe_doit(sc, sp, dp, 0);\n\n  for (lcv = 4 ; lcv < MIDDMA_MAXBURST ; lcv += 4) {\n    try = en_dmaprobe_doit(sc, sp+lcv, dp+lcv, 0);\n    if (try < bestnotalgn)\n      bestnotalgn = try;\n  }\n\n  if (bestalgn != bestnotalgn) \t\t/* need bursts aligned */\n    sc->alburst = 1;\n\n  sc->bestburstlen = bestalgn;\n  sc->bestburstshift = en_log2(bestalgn);\n  sc->bestburstmask = sc->bestburstlen - 1; /* must be power of 2 */\n  sc->bestburstcode = en_sz2b(bestalgn);\n\n  if (sc->bestburstlen <= 2*sizeof(u_int32_t))\n    return;\t\t\t\t/* won't be using WMAYBE */\n\n  /*\n   * adaptec does not have (or need) wmaybe.   do not bother testing\n   * for it.\n   */\n  if (sc->is_adaptec) {\n    /* XXX, actually don't need a DMA plan: adaptec is smarter than that */\n    en_dmaplan = en_dma_planB; \n    return;\n  }\n\n  /*\n   * test that WMAYBE dma works like we think it should \n   * (i.e. no alignment restrictions on host address other than alburst)\n   */\n\n  try = sc->bestburstlen - 4;\n  fail = 0;\n  fail += en_dmaprobe_doit(sc, sp, dp, try);\n  for (lcv = 4 ; lcv < sc->bestburstlen ; lcv += 4) {\n    fail += en_dmaprobe_doit(sc, sp+lcv, dp+lcv, try);\n    if (sc->alburst)\n      try -= 4;\n  }\n  if (EN_NOWMAYBE || fail) {\n    if (fail)\n      printf(\"%s: WARNING: WMAYBE DMA test failed %d time(s)\\n\", \n\tsc->sc_dev.dv_xname, fail);\n    en_dmaplan = en_dma_planB;\t\t/* fall back to plan B */\n  }\n\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC /* nothing */",
      "#define EN_NOWMAYBE\t1\t/* hook to disable word maybe DMA */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: WARNING: WMAYBE DMA test failed %d time(s)\\n\"",
            "sc->sc_dev.dv_xname",
            "fail"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "en_dmaprobe_doit",
          "args": [
            "sc",
            "sp+lcv",
            "dp+lcv",
            "try"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "en_dmaprobe_doit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "927-1050",
          "snippet": "int\nen_dmaprobe_doit(sc, sp, dp, wmtry)\n\nstruct en_softc *sc;\nu_int8_t *sp, *dp;\nint wmtry;\n\n{\n  int lcv, retval = 4, cnt, count;\n  u_int32_t reg, bcode, midvloc;\n\n  /*\n   * set up a 1k buffer at MID_BUFOFF\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n\n  midvloc = ((MID_BUFOFF - MID_RAMOFF) / sizeof(u_int32_t)) >> MIDV_LOCTOPSHFT;\n  EN_WRITE(sc, MIDX_PLACE(0), MIDX_MKPLACE(en_k2sz(1), midvloc));\n  EN_WRITE(sc, MID_VC(0), (midvloc << MIDV_LOCSHIFT) \n\t\t| (en_k2sz(1) << MIDV_SZSHIFT) | MIDV_TRASH);\n  EN_WRITE(sc, MID_DST_RP(0), 0);\n  EN_WRITE(sc, MID_WP_ST_CNT(0), 0);\n\n  for (lcv = 0 ; lcv < 68 ; lcv++) \t\t/* set up sample data */\n    sp[lcv] = lcv+1;\n  EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);\t/* enable DMA (only) */\n\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n\n  /*\n   * try it now . . .  DMA it out, then DMA it back in and compare\n   *\n   * note: in order to get the dma stuff to reverse directions it wants\n   * the \"end\" flag set!   since we are not dma'ing valid data we may\n   * get an ident mismatch interrupt (which we will ignore).\n   *\n   * note: we've got two different tests rolled up in the same loop\n   * if (wmtry) \n   *   then we are doing a wmaybe test and wmtry is a byte count\n   *   else we are doing a burst test\n   */\n\n  for (lcv = 8 ; lcv <= MIDDMA_MAXBURST ; lcv = lcv * 2) {\n\n    /* zero SRAM and dest buffer */\n    for (cnt = 0 ; cnt < 1024; cnt += 4) \n      EN_WRITE(sc, MID_BUFOFF+cnt, 0);\t/* zero memory */\n    for (cnt = 0 ; cnt < 68  ; cnt++) \n      dp[cnt] = 0;\n\n    if (wmtry) {\n      count = (sc->bestburstlen - sizeof(u_int32_t)) / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = wmtry >> en_dmaplan[count].divshift;\n    } else {\n      bcode = en_sz2b(lcv);\n      count = 1;\n    }\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->dtq_chip+4, vtophys(sp));\n    EN_WRITE(sc, MID_DMA_WRTX, MID_DTQ_A2REG(sc->dtq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDTX) == MID_DTQ_A2REG(sc->dtq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in tx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DTQOFF, MID_DTQEND, sc->dtq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_TX) != MID_INT_DMA_TX) {\n      printf(\"%s: unexpected status in tx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    /* \"return to sender...\"  address is known ... */\n\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->drq_chip+4, vtophys(dp));\n    EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDRX) == MID_DRQ_A2REG(sc->drq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in rx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DRQOFF, MID_DRQEND, sc->drq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_RX) != MID_INT_DMA_RX) {\n      printf(\"%s: unexpected status in rx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    if (wmtry) {\n      return(bcmp(sp, dp, wmtry));  /* wmtry always exits here, no looping */\n    }\n  \n    if (bcmp(sp, dp, lcv))\n      return(retval);\t\t/* failed, use last value */\n\n    retval = lcv;\n\n  }\n  return(retval);\t\t/* studly 64 byte DMA present!  oh baby!! */\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint\nen_dmaprobe_doit(sc, sp, dp, wmtry)\n\nstruct en_softc *sc;\nu_int8_t *sp, *dp;\nint wmtry;\n\n{\n  int lcv, retval = 4, cnt, count;\n  u_int32_t reg, bcode, midvloc;\n\n  /*\n   * set up a 1k buffer at MID_BUFOFF\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n\n  midvloc = ((MID_BUFOFF - MID_RAMOFF) / sizeof(u_int32_t)) >> MIDV_LOCTOPSHFT;\n  EN_WRITE(sc, MIDX_PLACE(0), MIDX_MKPLACE(en_k2sz(1), midvloc));\n  EN_WRITE(sc, MID_VC(0), (midvloc << MIDV_LOCSHIFT) \n\t\t| (en_k2sz(1) << MIDV_SZSHIFT) | MIDV_TRASH);\n  EN_WRITE(sc, MID_DST_RP(0), 0);\n  EN_WRITE(sc, MID_WP_ST_CNT(0), 0);\n\n  for (lcv = 0 ; lcv < 68 ; lcv++) \t\t/* set up sample data */\n    sp[lcv] = lcv+1;\n  EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);\t/* enable DMA (only) */\n\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n\n  /*\n   * try it now . . .  DMA it out, then DMA it back in and compare\n   *\n   * note: in order to get the dma stuff to reverse directions it wants\n   * the \"end\" flag set!   since we are not dma'ing valid data we may\n   * get an ident mismatch interrupt (which we will ignore).\n   *\n   * note: we've got two different tests rolled up in the same loop\n   * if (wmtry) \n   *   then we are doing a wmaybe test and wmtry is a byte count\n   *   else we are doing a burst test\n   */\n\n  for (lcv = 8 ; lcv <= MIDDMA_MAXBURST ; lcv = lcv * 2) {\n\n    /* zero SRAM and dest buffer */\n    for (cnt = 0 ; cnt < 1024; cnt += 4) \n      EN_WRITE(sc, MID_BUFOFF+cnt, 0);\t/* zero memory */\n    for (cnt = 0 ; cnt < 68  ; cnt++) \n      dp[cnt] = 0;\n\n    if (wmtry) {\n      count = (sc->bestburstlen - sizeof(u_int32_t)) / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = wmtry >> en_dmaplan[count].divshift;\n    } else {\n      bcode = en_sz2b(lcv);\n      count = 1;\n    }\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->dtq_chip+4, vtophys(sp));\n    EN_WRITE(sc, MID_DMA_WRTX, MID_DTQ_A2REG(sc->dtq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDTX) == MID_DTQ_A2REG(sc->dtq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in tx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DTQOFF, MID_DTQEND, sc->dtq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_TX) != MID_INT_DMA_TX) {\n      printf(\"%s: unexpected status in tx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    /* \"return to sender...\"  address is known ... */\n\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->drq_chip+4, vtophys(dp));\n    EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDRX) == MID_DRQ_A2REG(sc->drq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in rx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DRQOFF, MID_DRQEND, sc->drq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_RX) != MID_INT_DMA_RX) {\n      printf(\"%s: unexpected status in rx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    if (wmtry) {\n      return(bcmp(sp, dp, wmtry));  /* wmtry always exits here, no looping */\n    }\n  \n    if (bcmp(sp, dp, lcv))\n      return(retval);\t\t/* failed, use last value */\n\n    retval = lcv;\n\n  }\n  return(retval);\t\t/* studly 64 byte DMA present!  oh baby!! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "en_sz2b",
          "args": [
            "bestalgn"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "en_sz2b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "514-528",
          "snippet": "int en_sz2b(sz)\n\nint sz;\n\n{\n  switch (sz) {\n    case 1*4:  return(MIDDMA_WORD);\n    case 2*4:  return(MIDDMA_2WORD);\n    case 4*4:  return(MIDDMA_4WORD);\n    case 8*4:  return(MIDDMA_8WORD);\n    case 16*4: return(MIDDMA_16WORD);\n    default: panic(\"en_sz2b\");\n  }\n  return(0);\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_sz2b(sz)\n\nint sz;\n\n{\n  switch (sz) {\n    case 1*4:  return(MIDDMA_WORD);\n    case 2*4:  return(MIDDMA_2WORD);\n    case 4*4:  return(MIDDMA_4WORD);\n    case 8*4:  return(MIDDMA_8WORD);\n    case 16*4: return(MIDDMA_16WORD);\n    default: panic(\"en_sz2b\");\n  }\n  return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "en_log2",
          "args": [
            "bestalgn"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define STATIC static\n#define STATIC /* nothing */\n#define EN_NOWMAYBE\t1\t/* hook to disable word maybe DMA */\n\nSTATIC void en_dmaprobe(sc)\n\nstruct en_softc *sc;\n\n{\n  u_int32_t srcbuf[64], dstbuf[64];\n  u_int8_t *sp, *dp;\n  int bestalgn, bestnotalgn, lcv, try, fail;\n\n  sc->alburst = 0;\n\n  sp = (u_int8_t *) srcbuf;\n  while ((((unsigned long) sp) % MIDDMA_MAXBURST) != 0)\n    sp += 4;\n  dp = (u_int8_t *) dstbuf;\n  while ((((unsigned long) dp) % MIDDMA_MAXBURST) != 0)\n    dp += 4;\n\n  bestalgn = bestnotalgn = en_dmaprobe_doit(sc, sp, dp, 0);\n\n  for (lcv = 4 ; lcv < MIDDMA_MAXBURST ; lcv += 4) {\n    try = en_dmaprobe_doit(sc, sp+lcv, dp+lcv, 0);\n    if (try < bestnotalgn)\n      bestnotalgn = try;\n  }\n\n  if (bestalgn != bestnotalgn) \t\t/* need bursts aligned */\n    sc->alburst = 1;\n\n  sc->bestburstlen = bestalgn;\n  sc->bestburstshift = en_log2(bestalgn);\n  sc->bestburstmask = sc->bestburstlen - 1; /* must be power of 2 */\n  sc->bestburstcode = en_sz2b(bestalgn);\n\n  if (sc->bestburstlen <= 2*sizeof(u_int32_t))\n    return;\t\t\t\t/* won't be using WMAYBE */\n\n  /*\n   * adaptec does not have (or need) wmaybe.   do not bother testing\n   * for it.\n   */\n  if (sc->is_adaptec) {\n    /* XXX, actually don't need a DMA plan: adaptec is smarter than that */\n    en_dmaplan = en_dma_planB; \n    return;\n  }\n\n  /*\n   * test that WMAYBE dma works like we think it should \n   * (i.e. no alignment restrictions on host address other than alburst)\n   */\n\n  try = sc->bestburstlen - 4;\n  fail = 0;\n  fail += en_dmaprobe_doit(sc, sp, dp, try);\n  for (lcv = 4 ; lcv < sc->bestburstlen ; lcv += 4) {\n    fail += en_dmaprobe_doit(sc, sp+lcv, dp+lcv, try);\n    if (sc->alburst)\n      try -= 4;\n  }\n  if (EN_NOWMAYBE || fail) {\n    if (fail)\n      printf(\"%s: WARNING: WMAYBE DMA test failed %d time(s)\\n\", \n\tsc->sc_dev.dv_xname, fail);\n    en_dmaplan = en_dma_planB;\t\t/* fall back to plan B */\n  }\n\n}"
  },
  {
    "function_name": "en_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "656-836",
    "snippet": "void en_attach(sc)\n\nstruct en_softc *sc;\n\n{\n  struct ifnet *ifp = &sc->enif;\n  int sz;\n  u_int32_t reg, lcv, check, ptr, sav, midvloc;\n\n  /*\n   * probe card to determine memory size.   the stupid ENI card always\n   * reports to PCI that it needs 4MB of space (2MB regs and 2MB RAM).\n   * if it has less than 2MB RAM the addresses wrap in the RAM address space.\n   * (i.e. on a 512KB card addresses 0x3ffffc, 0x37fffc, and 0x2ffffc\n   * are aliases for 0x27fffc  [note that RAM starts at offset 0x200000]).\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n  for (lcv = MID_PROBEOFF; lcv <= MID_MAXOFF ; lcv += MID_PROBSIZE) {\n    EN_WRITE(sc, lcv, lcv);\t/* data[address] = address */\n    for (check = MID_PROBEOFF ; check < lcv ; check += MID_PROBSIZE) {\n      reg = EN_READ(sc, check);\n      if (reg != check) {\t\t/* found an alias! */\n\tgoto done_probe;\t\t/* and quit */\n      }\n    }\n  }\ndone_probe:\n  lcv -= MID_PROBSIZE;\t\t\t/* take one step back */\n  sc->en_obmemsz = (lcv + 4) - MID_RAMOFF;\n\n  /*\n   * determine the largest DMA burst supported\n   */\n\n  en_dmaprobe(sc);\n\n  /*\n   * \"hello world\"\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n  for (lcv = MID_RAMOFF ; lcv < MID_RAMOFF + sc->en_obmemsz ; lcv += 4)\n    EN_WRITE(sc, lcv, 0);\t/* zero memory */\n\n  reg = EN_READ(sc, MID_RESID);\n\n  printf(\"%s: ATM midway v%d, board IDs %d.%d, %s%s%s, %ldKB on-board RAM\\n\",\n\tsc->sc_dev.dv_xname, MID_VER(reg), MID_MID(reg), MID_DID(reg), \n\t(MID_IS_SABRE(reg)) ? \"sabre controller, \" : \"\",\n\t(MID_IS_SUNI(reg)) ? \"SUNI\" : \"Utopia\",\n\t(!MID_IS_SUNI(reg) && MID_IS_UPIPE(reg)) ? \" (pipelined)\" : \"\",\n\tsc->en_obmemsz / 1024);\n\n  if (sc->is_adaptec) {\n    if (sc->bestburstlen == 64 && sc->alburst == 0)\n      printf(\"%s: passed 64 byte DMA test\\n\", sc->sc_dev.dv_xname);\n    else\n      printf(\"%s: FAILED DMA TEST: burst=%d, alburst=%d\\n\", \n\t    sc->sc_dev.dv_xname, sc->bestburstlen, sc->alburst);\n  } else {\n    printf(\"%s: maximum DMA burst length = %d bytes%s\\n\", sc->sc_dev.dv_xname,\n\t  sc->bestburstlen, (sc->alburst) ? \" (must align)\" : \"\");\n  }\n\n#if 0\t\t/* WMAYBE doesn't work, don't complain about it */\n  /* check if en_dmaprobe disabled wmaybe */\n  if (en_dmaplan == en_dma_planB)\n    printf(\"%s: note: WMAYBE DMA has been disabled\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  /*\n   * link into network subsystem and prepare card\n   */\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n  bcopy(sc->sc_dev.dv_xname, sc->enif.if_xname, IFNAMSIZ);\n#endif\n#if !defined(MISSING_IF_SOFTC)\n  sc->enif.if_softc = sc;\n#endif\n  ifp->if_flags = IFF_SIMPLEX|IFF_NOTRAILERS;\n  ifp->if_ioctl = en_ioctl;\n  ifp->if_output = atm_output;\n  ifp->if_start = en_start;\n\n  /*\n   * init softc\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    sc->rxvc2slot[lcv] = RX_NONE;\n    sc->txspeed[lcv] = 0;\t/* full */\n    sc->txvc2slot[lcv] = 0;\t/* full speed == slot 0 */\n  }\n\n  sz = sc->en_obmemsz - (MID_BUFOFF - MID_RAMOFF);\n  ptr = sav = MID_BUFOFF;\n  ptr = roundup(ptr, EN_TXSZ * 1024);\t/* align */\n  sz = sz - (ptr - sav);\n  if (EN_TXSZ*1024 * EN_NTX > sz) {\n    printf(\"%s: EN_NTX/EN_TXSZ too big\\n\", sc->sc_dev.dv_xname);\n    return;\n  }\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    sc->txslot[lcv].mbsize = 0;\n    sc->txslot[lcv].start = ptr;\n    ptr += (EN_TXSZ * 1024);\n    sz -= (EN_TXSZ * 1024);\n    sc->txslot[lcv].stop = ptr;\n    sc->txslot[lcv].nref = 0;\n    bzero(&sc->txslot[lcv].indma, sizeof(sc->txslot[lcv].indma));\n    bzero(&sc->txslot[lcv].q, sizeof(sc->txslot[lcv].q));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: start 0x%x, stop 0x%x\\n\", sc->sc_dev.dv_xname, lcv,\n\t\tsc->txslot[lcv].start, sc->txslot[lcv].stop);\n#endif\n  }\n\n  sav = ptr;\n  ptr = roundup(ptr, EN_RXSZ * 1024);\t/* align */\n  sz = sz - (ptr - sav);\n  sc->en_nrx = sz / (EN_RXSZ * 1024);\n  if (sc->en_nrx <= 0) {\n    printf(\"%s: EN_NTX/EN_TXSZ/EN_RXSZ too big\\n\", sc->sc_dev.dv_xname);\n    return;\n  }\n\n  /* \n   * ensure that there is always one VC slot on the service list free\n   * so that we can tell the difference between a full and empty list.\n   */\n  if (sc->en_nrx >= MID_N_VC)\n    sc->en_nrx = MID_N_VC - 1;\n\n  for (lcv = 0 ; lcv < sc->en_nrx ; lcv++) {\n    sc->rxslot[lcv].rxhand = NULL;\n    sc->rxslot[lcv].oth_flags = ENOTHER_FREE;\n    bzero(&sc->rxslot[lcv].indma, sizeof(sc->rxslot[lcv].indma));\n    bzero(&sc->rxslot[lcv].q, sizeof(sc->rxslot[lcv].q));\n    midvloc = sc->rxslot[lcv].start = ptr;\n    ptr += (EN_RXSZ * 1024);\n    sz -= (EN_RXSZ * 1024);\n    sc->rxslot[lcv].stop = ptr;\n    midvloc = midvloc - MID_RAMOFF;\n    midvloc = (midvloc & ~((EN_RXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    midvloc = midvloc >> MIDV_LOCTOPSHFT;  /* we only want the top 11 bits */\n    midvloc = (midvloc & MIDV_LOCMASK) << MIDV_LOCSHIFT;\n    sc->rxslot[lcv].mode = midvloc | \n\t(en_k2sz(EN_RXSZ) << MIDV_SZSHIFT) | MIDV_TRASH;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: start 0x%x, stop 0x%x, mode 0x%x\\n\", sc->sc_dev.dv_xname,\n\tlcv, sc->rxslot[lcv].start, sc->rxslot[lcv].stop, sc->rxslot[lcv].mode);\n#endif\n  }\n\n#ifdef EN_STAT\n  sc->vtrash = sc->otrash = sc->mfix = sc->txmbovr = sc->dmaovr = 0;\n  sc->txoutspace = sc->txdtqout = sc->launch = sc->lheader = sc->ltail = 0;\n  sc->hwpull = sc->swadd = sc->rxqnotus = sc->rxqus = sc->rxoutboth = 0;\n  sc->rxdrqout = sc->ttrash = sc->rxmbufout = sc->mfixfail = 0;\n  sc->headbyte = sc->tailbyte = sc->tailflush = 0;\n#endif\n  sc->need_drqs = sc->need_dtqs = 0;\n\n  printf(\"%s: %d %dKB receive buffers, %d %dKB transmit buffers allocated\\n\",\n\tsc->sc_dev.dv_xname, sc->en_nrx, EN_RXSZ, EN_NTX, EN_TXSZ);\n\n  /*\n   * final commit\n   */\n\n  if_attach(ifp);\n  atm_ifattach(ifp); \n\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define ENOTHER_FREE\t0x01\t\t/* free rxslot */",
      "#define RX_NONE\t\t0xffff\t/* recv VC not in use */",
      "#define IFF_NOTRAILERS 0",
      "#define MISSING_IF_SOFTC",
      "#define\tEN_STAT"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atm_ifattach",
          "args": [
            "ifp"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d %dKB receive buffers, %d %dKB transmit buffers allocated\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->en_nrx",
            "EN_RXSZ",
            "EN_NTX",
            "EN_TXSZ"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "en_k2sz",
          "args": [
            "EN_RXSZ"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "en_k2sz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "464-481",
          "snippet": "int en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sc->rxslot[lcv].q",
            "sizeof(sc->rxslot[lcv].q)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sc->rxslot[lcv].indma",
            "sizeof(sc->rxslot[lcv].indma)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "ptr",
            "EN_RXSZ * 1024"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sc->txslot[lcv].q",
            "sizeof(sc->txslot[lcv].q)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sc->txslot[lcv].indma",
            "sizeof(sc->txslot[lcv].indma)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "ptr",
            "EN_TXSZ * 1024"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "sc->enif.if_xname",
            "IFNAMSIZ"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MID_IS_UPIPE",
          "args": [
            "reg"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_IS_SUNI",
          "args": [
            "reg"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_IS_SUNI",
          "args": [
            "reg"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_IS_SABRE",
          "args": [
            "reg"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_DID",
          "args": [
            "reg"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_MID",
          "args": [
            "reg"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MID_VER",
          "args": [
            "reg"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "MID_RESID"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "lcv",
            "0"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_RESID",
            "0x0"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->en_busreset",
          "args": [
            "sc"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_dmaprobe",
          "args": [
            "sc"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "en_dmaprobe_doit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
          "lines": "927-1050",
          "snippet": "int\nen_dmaprobe_doit(sc, sp, dp, wmtry)\n\nstruct en_softc *sc;\nu_int8_t *sp, *dp;\nint wmtry;\n\n{\n  int lcv, retval = 4, cnt, count;\n  u_int32_t reg, bcode, midvloc;\n\n  /*\n   * set up a 1k buffer at MID_BUFOFF\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n\n  midvloc = ((MID_BUFOFF - MID_RAMOFF) / sizeof(u_int32_t)) >> MIDV_LOCTOPSHFT;\n  EN_WRITE(sc, MIDX_PLACE(0), MIDX_MKPLACE(en_k2sz(1), midvloc));\n  EN_WRITE(sc, MID_VC(0), (midvloc << MIDV_LOCSHIFT) \n\t\t| (en_k2sz(1) << MIDV_SZSHIFT) | MIDV_TRASH);\n  EN_WRITE(sc, MID_DST_RP(0), 0);\n  EN_WRITE(sc, MID_WP_ST_CNT(0), 0);\n\n  for (lcv = 0 ; lcv < 68 ; lcv++) \t\t/* set up sample data */\n    sp[lcv] = lcv+1;\n  EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);\t/* enable DMA (only) */\n\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n\n  /*\n   * try it now . . .  DMA it out, then DMA it back in and compare\n   *\n   * note: in order to get the dma stuff to reverse directions it wants\n   * the \"end\" flag set!   since we are not dma'ing valid data we may\n   * get an ident mismatch interrupt (which we will ignore).\n   *\n   * note: we've got two different tests rolled up in the same loop\n   * if (wmtry) \n   *   then we are doing a wmaybe test and wmtry is a byte count\n   *   else we are doing a burst test\n   */\n\n  for (lcv = 8 ; lcv <= MIDDMA_MAXBURST ; lcv = lcv * 2) {\n\n    /* zero SRAM and dest buffer */\n    for (cnt = 0 ; cnt < 1024; cnt += 4) \n      EN_WRITE(sc, MID_BUFOFF+cnt, 0);\t/* zero memory */\n    for (cnt = 0 ; cnt < 68  ; cnt++) \n      dp[cnt] = 0;\n\n    if (wmtry) {\n      count = (sc->bestburstlen - sizeof(u_int32_t)) / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = wmtry >> en_dmaplan[count].divshift;\n    } else {\n      bcode = en_sz2b(lcv);\n      count = 1;\n    }\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->dtq_chip+4, vtophys(sp));\n    EN_WRITE(sc, MID_DMA_WRTX, MID_DTQ_A2REG(sc->dtq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDTX) == MID_DTQ_A2REG(sc->dtq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in tx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DTQOFF, MID_DTQEND, sc->dtq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_TX) != MID_INT_DMA_TX) {\n      printf(\"%s: unexpected status in tx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    /* \"return to sender...\"  address is known ... */\n\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->drq_chip+4, vtophys(dp));\n    EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDRX) == MID_DRQ_A2REG(sc->drq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in rx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DRQOFF, MID_DRQEND, sc->drq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_RX) != MID_INT_DMA_RX) {\n      printf(\"%s: unexpected status in rx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    if (wmtry) {\n      return(bcmp(sp, dp, wmtry));  /* wmtry always exits here, no looping */\n    }\n  \n    if (bcmp(sp, dp, lcv))\n      return(retval);\t\t/* failed, use last value */\n\n    retval = lcv;\n\n  }\n  return(retval);\t\t/* studly 64 byte DMA present!  oh baby!! */\n}",
          "includes": [
            "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
            "#include <dev/en/midwayvar.h>",
            "#include <dev/en/midwayreg.h>",
            "#include <machine/clock.h>              /* for DELAY */",
            "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
            "#include <dev/ic/midwayvar.h>",
            "#include <dev/ic/midwayreg.h>",
            "#include <machine/bus.h>",
            "#include <netnatm/natm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_atm.h>",
            "#include <vm/vm.h>",
            "#include <net/if_atm.h>",
            "#include <net/if.h>",
            "#include <sys/socketvar.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"en.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint\nen_dmaprobe_doit(sc, sp, dp, wmtry)\n\nstruct en_softc *sc;\nu_int8_t *sp, *dp;\nint wmtry;\n\n{\n  int lcv, retval = 4, cnt, count;\n  u_int32_t reg, bcode, midvloc;\n\n  /*\n   * set up a 1k buffer at MID_BUFOFF\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n\n  midvloc = ((MID_BUFOFF - MID_RAMOFF) / sizeof(u_int32_t)) >> MIDV_LOCTOPSHFT;\n  EN_WRITE(sc, MIDX_PLACE(0), MIDX_MKPLACE(en_k2sz(1), midvloc));\n  EN_WRITE(sc, MID_VC(0), (midvloc << MIDV_LOCSHIFT) \n\t\t| (en_k2sz(1) << MIDV_SZSHIFT) | MIDV_TRASH);\n  EN_WRITE(sc, MID_DST_RP(0), 0);\n  EN_WRITE(sc, MID_WP_ST_CNT(0), 0);\n\n  for (lcv = 0 ; lcv < 68 ; lcv++) \t\t/* set up sample data */\n    sp[lcv] = lcv+1;\n  EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);\t/* enable DMA (only) */\n\n  sc->drq_chip = MID_DRQ_REG2A(EN_READ(sc, MID_DMA_RDRX));\n  sc->dtq_chip = MID_DTQ_REG2A(EN_READ(sc, MID_DMA_RDTX));\n\n  /*\n   * try it now . . .  DMA it out, then DMA it back in and compare\n   *\n   * note: in order to get the dma stuff to reverse directions it wants\n   * the \"end\" flag set!   since we are not dma'ing valid data we may\n   * get an ident mismatch interrupt (which we will ignore).\n   *\n   * note: we've got two different tests rolled up in the same loop\n   * if (wmtry) \n   *   then we are doing a wmaybe test and wmtry is a byte count\n   *   else we are doing a burst test\n   */\n\n  for (lcv = 8 ; lcv <= MIDDMA_MAXBURST ; lcv = lcv * 2) {\n\n    /* zero SRAM and dest buffer */\n    for (cnt = 0 ; cnt < 1024; cnt += 4) \n      EN_WRITE(sc, MID_BUFOFF+cnt, 0);\t/* zero memory */\n    for (cnt = 0 ; cnt < 68  ; cnt++) \n      dp[cnt] = 0;\n\n    if (wmtry) {\n      count = (sc->bestburstlen - sizeof(u_int32_t)) / sizeof(u_int32_t);\n      bcode = en_dmaplan[count].bcode;\n      count = wmtry >> en_dmaplan[count].divshift;\n    } else {\n      bcode = en_sz2b(lcv);\n      count = 1;\n    }\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->dtq_chip, MID_MK_TXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->dtq_chip+4, vtophys(sp));\n    EN_WRITE(sc, MID_DMA_WRTX, MID_DTQ_A2REG(sc->dtq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDTX) == MID_DTQ_A2REG(sc->dtq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in tx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DTQOFF, MID_DTQEND, sc->dtq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_TX) != MID_INT_DMA_TX) {\n      printf(\"%s: unexpected status in tx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    /* \"return to sender...\"  address is known ... */\n\n    if (sc->is_adaptec)\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ADP(lcv, 0, MID_DMA_END, 0));\n    else\n      EN_WRITE(sc, sc->drq_chip, MID_MK_RXQ_ENI(count, 0, MID_DMA_END, bcode));\n    EN_WRITE(sc, sc->drq_chip+4, vtophys(dp));\n    EN_WRITE(sc, MID_DMA_WRRX, MID_DRQ_A2REG(sc->drq_chip+8));\n    cnt = 1000;\n    while (EN_READ(sc, MID_DMA_RDRX) == MID_DRQ_A2REG(sc->drq_chip)) {\n      DELAY(1);\n      cnt--;\n      if (cnt == 0) {\n\tprintf(\"%s: unexpected timeout in rx DMA test\\n\", sc->sc_dev.dv_xname);\n\treturn(retval);\t\t/* timeout, give up */\n      }\n    }\n    EN_WRAPADD(MID_DRQOFF, MID_DRQEND, sc->drq_chip, 8);\n    reg = EN_READ(sc, MID_INTACK); \n    if ((reg & MID_INT_DMA_RX) != MID_INT_DMA_RX) {\n      printf(\"%s: unexpected status in rx DMA test: 0x%x\\n\", \n\t\tsc->sc_dev.dv_xname, reg);\n      return(retval);\n    }\n    EN_WRITE(sc, MID_MAST_CSR, MID_MCSR_ENDMA);   /* re-enable DMA (only) */\n\n    if (wmtry) {\n      return(bcmp(sp, dp, wmtry));  /* wmtry always exits here, no looping */\n    }\n  \n    if (bcmp(sp, dp, lcv))\n      return(retval);\t\t/* failed, use last value */\n\n    retval = lcv;\n\n  }\n  return(retval);\t\t/* studly 64 byte DMA present!  oh baby!! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EN_READ",
          "args": [
            "sc",
            "check"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "lcv",
            "lcv"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EN_WRITE",
          "args": [
            "sc",
            "MID_RESID",
            "0x0"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->en_busreset",
          "args": [
            "sc"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define ENOTHER_FREE\t0x01\t\t/* free rxslot */\n#define RX_NONE\t\t0xffff\t/* recv VC not in use */\n#define IFF_NOTRAILERS 0\n#define MISSING_IF_SOFTC\n#define\tEN_STAT\n\nvoid en_attach(sc)\n\nstruct en_softc *sc;\n\n{\n  struct ifnet *ifp = &sc->enif;\n  int sz;\n  u_int32_t reg, lcv, check, ptr, sav, midvloc;\n\n  /*\n   * probe card to determine memory size.   the stupid ENI card always\n   * reports to PCI that it needs 4MB of space (2MB regs and 2MB RAM).\n   * if it has less than 2MB RAM the addresses wrap in the RAM address space.\n   * (i.e. on a 512KB card addresses 0x3ffffc, 0x37fffc, and 0x2ffffc\n   * are aliases for 0x27fffc  [note that RAM starts at offset 0x200000]).\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t/* reset card before touching RAM */\n  for (lcv = MID_PROBEOFF; lcv <= MID_MAXOFF ; lcv += MID_PROBSIZE) {\n    EN_WRITE(sc, lcv, lcv);\t/* data[address] = address */\n    for (check = MID_PROBEOFF ; check < lcv ; check += MID_PROBSIZE) {\n      reg = EN_READ(sc, check);\n      if (reg != check) {\t\t/* found an alias! */\n\tgoto done_probe;\t\t/* and quit */\n      }\n    }\n  }\ndone_probe:\n  lcv -= MID_PROBSIZE;\t\t\t/* take one step back */\n  sc->en_obmemsz = (lcv + 4) - MID_RAMOFF;\n\n  /*\n   * determine the largest DMA burst supported\n   */\n\n  en_dmaprobe(sc);\n\n  /*\n   * \"hello world\"\n   */\n\n  if (sc->en_busreset)\n    sc->en_busreset(sc);\n  EN_WRITE(sc, MID_RESID, 0x0);\t\t/* reset */\n  for (lcv = MID_RAMOFF ; lcv < MID_RAMOFF + sc->en_obmemsz ; lcv += 4)\n    EN_WRITE(sc, lcv, 0);\t/* zero memory */\n\n  reg = EN_READ(sc, MID_RESID);\n\n  printf(\"%s: ATM midway v%d, board IDs %d.%d, %s%s%s, %ldKB on-board RAM\\n\",\n\tsc->sc_dev.dv_xname, MID_VER(reg), MID_MID(reg), MID_DID(reg), \n\t(MID_IS_SABRE(reg)) ? \"sabre controller, \" : \"\",\n\t(MID_IS_SUNI(reg)) ? \"SUNI\" : \"Utopia\",\n\t(!MID_IS_SUNI(reg) && MID_IS_UPIPE(reg)) ? \" (pipelined)\" : \"\",\n\tsc->en_obmemsz / 1024);\n\n  if (sc->is_adaptec) {\n    if (sc->bestburstlen == 64 && sc->alburst == 0)\n      printf(\"%s: passed 64 byte DMA test\\n\", sc->sc_dev.dv_xname);\n    else\n      printf(\"%s: FAILED DMA TEST: burst=%d, alburst=%d\\n\", \n\t    sc->sc_dev.dv_xname, sc->bestburstlen, sc->alburst);\n  } else {\n    printf(\"%s: maximum DMA burst length = %d bytes%s\\n\", sc->sc_dev.dv_xname,\n\t  sc->bestburstlen, (sc->alburst) ? \" (must align)\" : \"\");\n  }\n\n#if 0\t\t/* WMAYBE doesn't work, don't complain about it */\n  /* check if en_dmaprobe disabled wmaybe */\n  if (en_dmaplan == en_dma_planB)\n    printf(\"%s: note: WMAYBE DMA has been disabled\\n\", sc->sc_dev.dv_xname);\n#endif\n\n  /*\n   * link into network subsystem and prepare card\n   */\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n  bcopy(sc->sc_dev.dv_xname, sc->enif.if_xname, IFNAMSIZ);\n#endif\n#if !defined(MISSING_IF_SOFTC)\n  sc->enif.if_softc = sc;\n#endif\n  ifp->if_flags = IFF_SIMPLEX|IFF_NOTRAILERS;\n  ifp->if_ioctl = en_ioctl;\n  ifp->if_output = atm_output;\n  ifp->if_start = en_start;\n\n  /*\n   * init softc\n   */\n\n  for (lcv = 0 ; lcv < MID_N_VC ; lcv++) {\n    sc->rxvc2slot[lcv] = RX_NONE;\n    sc->txspeed[lcv] = 0;\t/* full */\n    sc->txvc2slot[lcv] = 0;\t/* full speed == slot 0 */\n  }\n\n  sz = sc->en_obmemsz - (MID_BUFOFF - MID_RAMOFF);\n  ptr = sav = MID_BUFOFF;\n  ptr = roundup(ptr, EN_TXSZ * 1024);\t/* align */\n  sz = sz - (ptr - sav);\n  if (EN_TXSZ*1024 * EN_NTX > sz) {\n    printf(\"%s: EN_NTX/EN_TXSZ too big\\n\", sc->sc_dev.dv_xname);\n    return;\n  }\n  for (lcv = 0 ; lcv < EN_NTX ; lcv++) {\n    sc->txslot[lcv].mbsize = 0;\n    sc->txslot[lcv].start = ptr;\n    ptr += (EN_TXSZ * 1024);\n    sz -= (EN_TXSZ * 1024);\n    sc->txslot[lcv].stop = ptr;\n    sc->txslot[lcv].nref = 0;\n    bzero(&sc->txslot[lcv].indma, sizeof(sc->txslot[lcv].indma));\n    bzero(&sc->txslot[lcv].q, sizeof(sc->txslot[lcv].q));\n#ifdef EN_DEBUG\n    printf(\"%s: tx%d: start 0x%x, stop 0x%x\\n\", sc->sc_dev.dv_xname, lcv,\n\t\tsc->txslot[lcv].start, sc->txslot[lcv].stop);\n#endif\n  }\n\n  sav = ptr;\n  ptr = roundup(ptr, EN_RXSZ * 1024);\t/* align */\n  sz = sz - (ptr - sav);\n  sc->en_nrx = sz / (EN_RXSZ * 1024);\n  if (sc->en_nrx <= 0) {\n    printf(\"%s: EN_NTX/EN_TXSZ/EN_RXSZ too big\\n\", sc->sc_dev.dv_xname);\n    return;\n  }\n\n  /* \n   * ensure that there is always one VC slot on the service list free\n   * so that we can tell the difference between a full and empty list.\n   */\n  if (sc->en_nrx >= MID_N_VC)\n    sc->en_nrx = MID_N_VC - 1;\n\n  for (lcv = 0 ; lcv < sc->en_nrx ; lcv++) {\n    sc->rxslot[lcv].rxhand = NULL;\n    sc->rxslot[lcv].oth_flags = ENOTHER_FREE;\n    bzero(&sc->rxslot[lcv].indma, sizeof(sc->rxslot[lcv].indma));\n    bzero(&sc->rxslot[lcv].q, sizeof(sc->rxslot[lcv].q));\n    midvloc = sc->rxslot[lcv].start = ptr;\n    ptr += (EN_RXSZ * 1024);\n    sz -= (EN_RXSZ * 1024);\n    sc->rxslot[lcv].stop = ptr;\n    midvloc = midvloc - MID_RAMOFF;\n    midvloc = (midvloc & ~((EN_RXSZ*1024) - 1)) >> 2; /* mask, cvt to words */\n    midvloc = midvloc >> MIDV_LOCTOPSHFT;  /* we only want the top 11 bits */\n    midvloc = (midvloc & MIDV_LOCMASK) << MIDV_LOCSHIFT;\n    sc->rxslot[lcv].mode = midvloc | \n\t(en_k2sz(EN_RXSZ) << MIDV_SZSHIFT) | MIDV_TRASH;\n\n#ifdef EN_DEBUG\n    printf(\"%s: rx%d: start 0x%x, stop 0x%x, mode 0x%x\\n\", sc->sc_dev.dv_xname,\n\tlcv, sc->rxslot[lcv].start, sc->rxslot[lcv].stop, sc->rxslot[lcv].mode);\n#endif\n  }\n\n#ifdef EN_STAT\n  sc->vtrash = sc->otrash = sc->mfix = sc->txmbovr = sc->dmaovr = 0;\n  sc->txoutspace = sc->txdtqout = sc->launch = sc->lheader = sc->ltail = 0;\n  sc->hwpull = sc->swadd = sc->rxqnotus = sc->rxqus = sc->rxoutboth = 0;\n  sc->rxdrqout = sc->ttrash = sc->rxmbufout = sc->mfixfail = 0;\n  sc->headbyte = sc->tailbyte = sc->tailflush = 0;\n#endif\n  sc->need_drqs = sc->need_dtqs = 0;\n\n  printf(\"%s: %d %dKB receive buffers, %d %dKB transmit buffers allocated\\n\",\n\tsc->sc_dev.dv_xname, sc->en_nrx, EN_RXSZ, EN_NTX, EN_TXSZ);\n\n  /*\n   * final commit\n   */\n\n  if_attach(ifp);\n  atm_ifattach(ifp); \n\n}"
  },
  {
    "function_name": "en_dqneed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "535-592",
    "snippet": "int en_dqneed(sc, data, len, tx)\n\nstruct en_softc *sc;\ncaddr_t data;\nu_int len, tx;\n\n{\n  int result, needalign, sz;\n\n#if !defined(MIDWAY_ENIONLY)\n#if !defined(MIDWAY_ADPONLY)\n    if (sc->is_adaptec)\n#endif /* !MIDWAY_ADPONLY */\n      return(1);\t/* adaptec can DMA anything in one go */\n#endif\n    \n#if !defined(MIDWAY_ADPONLY)\n    result = 0;\n    if (len < EN_MINDMA) {\n      if (!tx)\t\t\t/* XXX: conservative */\n        return(1);\t\t/* will copy/DMA_JK */\n    }\n\n    if (tx) {\t\t\t/* byte burst? */\n      needalign = (((unsigned long) data) % sizeof(u_int32_t));\n      if (needalign) {\n        result++;\n        sz = min(len, sizeof(u_int32_t) - needalign);\n        len -= sz;\n        data += sz;\n      }\n    }\n\n    if (sc->alburst && len) {\n      needalign = (((unsigned long) data) & sc->bestburstmask);\n      if (needalign) {\n\tresult++;\t\t/* alburst */\n        sz = min(len, sc->bestburstlen - needalign);\n        len -= sz;\n      }\n    }\n\n    if (len >= sc->bestburstlen) {\n      sz = len / sc->bestburstlen;\n      sz = sz * sc->bestburstlen;\n      len -= sz;\n      result++;\t\t\t/* best shot */\n    }\n    \n    if (len) {\n      result++;\t\t\t/* clean up */\n      if (tx && (len % sizeof(u_int32_t)) != 0)\n        result++;\t\t/* byte cleanup */\n    }\n\n    return(result);\n#endif\t/* !MIDWAY_ADPONLY */\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [
      "#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "sc->bestburstlen - needalign"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\n#define EN_MINDMA\t32\t/* don't DMA anything less than this (bytes) */\n\nint en_dqneed(sc, data, len, tx)\n\nstruct en_softc *sc;\ncaddr_t data;\nu_int len, tx;\n\n{\n  int result, needalign, sz;\n\n#if !defined(MIDWAY_ENIONLY)\n#if !defined(MIDWAY_ADPONLY)\n    if (sc->is_adaptec)\n#endif /* !MIDWAY_ADPONLY */\n      return(1);\t/* adaptec can DMA anything in one go */\n#endif\n    \n#if !defined(MIDWAY_ADPONLY)\n    result = 0;\n    if (len < EN_MINDMA) {\n      if (!tx)\t\t\t/* XXX: conservative */\n        return(1);\t\t/* will copy/DMA_JK */\n    }\n\n    if (tx) {\t\t\t/* byte burst? */\n      needalign = (((unsigned long) data) % sizeof(u_int32_t));\n      if (needalign) {\n        result++;\n        sz = min(len, sizeof(u_int32_t) - needalign);\n        len -= sz;\n        data += sz;\n      }\n    }\n\n    if (sc->alburst && len) {\n      needalign = (((unsigned long) data) & sc->bestburstmask);\n      if (needalign) {\n\tresult++;\t\t/* alburst */\n        sz = min(len, sc->bestburstlen - needalign);\n        len -= sz;\n      }\n    }\n\n    if (len >= sc->bestburstlen) {\n      sz = len / sc->bestburstlen;\n      sz = sz * sc->bestburstlen;\n      len -= sz;\n      result++;\t\t\t/* best shot */\n    }\n    \n    if (len) {\n      result++;\t\t\t/* clean up */\n      if (tx && (len % sizeof(u_int32_t)) != 0)\n        result++;\t\t/* byte cleanup */\n    }\n\n    return(result);\n#endif\t/* !MIDWAY_ADPONLY */\n}"
  },
  {
    "function_name": "en_sz2b",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "514-528",
    "snippet": "int en_sz2b(sz)\n\nint sz;\n\n{\n  switch (sz) {\n    case 1*4:  return(MIDDMA_WORD);\n    case 2*4:  return(MIDDMA_2WORD);\n    case 4*4:  return(MIDDMA_4WORD);\n    case 8*4:  return(MIDDMA_8WORD);\n    case 16*4: return(MIDDMA_16WORD);\n    default: panic(\"en_sz2b\");\n  }\n  return(0);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_sz2b\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_sz2b(sz)\n\nint sz;\n\n{\n  switch (sz) {\n    case 1*4:  return(MIDDMA_WORD);\n    case 2*4:  return(MIDDMA_2WORD);\n    case 4*4:  return(MIDDMA_4WORD);\n    case 8*4:  return(MIDDMA_8WORD);\n    case 16*4: return(MIDDMA_16WORD);\n    default: panic(\"en_sz2b\");\n  }\n  return(0);\n}"
  },
  {
    "function_name": "en_b2sz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "489-507",
    "snippet": "int en_b2sz(b)\n\nint b;\n\n{\n  switch (b) {\n    case MIDDMA_WORD:   return(1*4);\n    case MIDDMA_2WMAYBE:\n    case MIDDMA_2WORD:  return(2*4);\n    case MIDDMA_4WMAYBE:\n    case MIDDMA_4WORD:  return(4*4);\n    case MIDDMA_8WMAYBE:\n    case MIDDMA_8WORD:  return(8*4);\n    case MIDDMA_16WMAYBE:\n    case MIDDMA_16WORD: return(16*4);\n    default: panic(\"en_b2sz\");\n  }\n  return(0);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_b2sz\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_b2sz(b)\n\nint b;\n\n{\n  switch (b) {\n    case MIDDMA_WORD:   return(1*4);\n    case MIDDMA_2WMAYBE:\n    case MIDDMA_2WORD:  return(2*4);\n    case MIDDMA_4WMAYBE:\n    case MIDDMA_4WORD:  return(4*4);\n    case MIDDMA_8WMAYBE:\n    case MIDDMA_8WORD:  return(8*4);\n    case MIDDMA_16WMAYBE:\n    case MIDDMA_16WORD: return(16*4);\n    default: panic(\"en_b2sz\");\n  }\n  return(0);\n}"
  },
  {
    "function_name": "en_k2sz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "464-481",
    "snippet": "int en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_k2sz\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nint en_k2sz(k)\n\nint k;\n\n{\n  switch(k) {\n    case 1:   return(0);\n    case 2:   return(1);\n    case 4:   return(2);\n    case 8:   return(3);\n    case 16:  return(4);\n    case 32:  return(5);\n    case 64:  return(6);\n    case 128: return(7);\n    default: panic(\"en_k2sz\");\n  }\n  return(0);\n}"
  },
  {
    "function_name": "en_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "445-458",
    "snippet": "void en_write(sc, r, v)\n\nstruct en_softc *sc;\nu_int32_t r, v;\n\n{\n#ifdef EN_DEBUG_RANGE\n  if (r > MID_MAXOFF || (r % 4)) {\n    panic(\"en_write: out of range, r=0x%x\", r);\n  }\n#endif\n\n  bus_space_write_4(sc->en_memt, sc->en_base, r, v);\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->en_memt",
            "sc->en_base",
            "r",
            "v"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_write: out of range, r=0x%x\"",
            "r"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nvoid en_write(sc, r, v)\n\nstruct en_softc *sc;\nu_int32_t r, v;\n\n{\n#ifdef EN_DEBUG_RANGE\n  if (r > MID_MAXOFF || (r % 4)) {\n    panic(\"en_write: out of range, r=0x%x\", r);\n  }\n#endif\n\n  bus_space_write_4(sc->en_memt, sc->en_base, r, v);\n}"
  },
  {
    "function_name": "en_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/midway.c",
    "lines": "424-438",
    "snippet": "u_int32_t en_read(sc, r)\n\nstruct en_softc *sc;\nu_int32_t r;\n\n{\n\n#ifdef EN_DEBUG_RANGE\n  if (r > MID_MAXOFF || (r % 4)) {\n    panic(\"en_read: out of range, r=0x%x\", r);\n  }\n#endif\n\n  return(bus_space_read_4(sc->en_memt, sc->en_base, r));\n}",
    "includes": [
      "#include <vm/pmap.h>\t\t\t/* for vtophys proto */",
      "#include <dev/en/midwayvar.h>",
      "#include <dev/en/midwayreg.h>",
      "#include <machine/clock.h>              /* for DELAY */",
      "#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */",
      "#include <dev/ic/midwayvar.h>",
      "#include <dev/ic/midwayreg.h>",
      "#include <machine/bus.h>",
      "#include <netnatm/natm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_atm.h>",
      "#include <vm/vm.h>",
      "#include <net/if_atm.h>",
      "#include <net/if.h>",
      "#include <sys/socketvar.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"en.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "sc->en_memt",
            "sc->en_base",
            "r"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"en_read: out of range, r=0x%x\"",
            "r"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vm/pmap.h>\t\t\t/* for vtophys proto */\n#include <dev/en/midwayvar.h>\n#include <dev/en/midwayreg.h>\n#include <machine/clock.h>              /* for DELAY */\n#include <machine/cpufunc.h>            /* for rdtsc proto for clock.h below */\n#include <dev/ic/midwayvar.h>\n#include <dev/ic/midwayreg.h>\n#include <machine/bus.h>\n#include <netnatm/natm.h>\n#include <netinet/in.h>\n#include <netinet/if_atm.h>\n#include <vm/vm.h>\n#include <net/if_atm.h>\n#include <net/if.h>\n#include <sys/socketvar.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"en.h\"\n\nu_int32_t en_read(sc, r)\n\nstruct en_softc *sc;\nu_int32_t r;\n\n{\n\n#ifdef EN_DEBUG_RANGE\n  if (r > MID_MAXOFF || (r % 4)) {\n    panic(\"en_read: out of range, r=0x%x\", r);\n  }\n#endif\n\n  return(bus_space_read_4(sc->en_memt, sc->en_base, r));\n}"
  }
]