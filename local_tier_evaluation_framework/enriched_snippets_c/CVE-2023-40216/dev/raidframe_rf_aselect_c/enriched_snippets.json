[
  {
    "function_name": "rf_SelectAlgorithm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_aselect.c",
    "lines": "205-495",
    "snippet": "int \nrf_SelectAlgorithm(desc, flags)\n\tRF_RaidAccessDesc_t *desc;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_AccessStripeMapHeader_t *asm_h = desc->asmap;\n\tRF_IoType_t type = desc->type;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tvoid   *bp = desc->bp;\n\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_AccessStripeMap_t *asm_p;\n\tRF_DagHeader_t *dag_h = NULL, *tempdag_h, *lastdag_h;\n\tint     i, j, k;\n\tRF_VoidFuncPtr *stripeFuncs, normalStripeFuncs[MAXNSTRIPES];\n\tRF_AccessStripeMap_t *asm_up, *asm_bp;\n\tRF_AccessStripeMapHeader_t ***asmh_u, *endASMList;\n\tRF_AccessStripeMapHeader_t ***asmh_b;\n\tRF_VoidFuncPtr **stripeUnitFuncs, uFunc;\n\tRF_VoidFuncPtr **blockFuncs, bFunc;\n\tint     numStripesBailed = 0, cantCreateDAGs = RF_FALSE;\n\tint     numStripeUnitsBailed = 0;\n\tint     stripeNum, numUnitDags = 0, stripeUnitNum, numBlockDags = 0;\n\tRF_StripeNum_t numStripeUnits;\n\tRF_SectorNum_t numBlocks;\n\tRF_RaidAddr_t address;\n\tint     length;\n\tRF_PhysDiskAddr_t *physPtr;\n\tcaddr_t buffer;\n\n\tlastdag_h = NULL;\n\tasmh_u = asmh_b = NULL;\n\tstripeUnitFuncs = NULL;\n\tblockFuncs = NULL;\n\n\t/* get an array of dag-function creation pointers, try to avoid\n\t * calling malloc */\n\tif (asm_h->numStripes <= MAXNSTRIPES)\n\t\tstripeFuncs = normalStripeFuncs;\n\telse\n\t\tRF_Calloc(stripeFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));\n\n\t/* walk through the asm list once collecting information */\n\t/* attempt to find a single creation function for each stripe */\n\tdesc->numStripes = 0;\n\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++) {\n\t\tdesc->numStripes++;\n\t\t(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_p, &stripeFuncs[i]);\n\t\t/* check to see if we found a creation func for this stripe */\n\t\tif (stripeFuncs[i] == (RF_VoidFuncPtr) NULL) {\n\t\t\t/* could not find creation function for entire stripe\n\t\t\t * so, let's see if we can find one for each stripe\n\t\t\t * unit in the stripe */\n\n\t\t\tif (numStripesBailed == 0) {\n\t\t\t\t/* one stripe map header for each stripe we\n\t\t\t\t * bail on */\n\t\t\t\tRF_Malloc(asmh_u, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes, (RF_AccessStripeMapHeader_t ***));\n\t\t\t\t/* create an array of ptrs to arrays of\n\t\t\t\t * stripeFuncs */\n\t\t\t\tRF_Calloc(stripeUnitFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));\n\t\t\t}\n\t\t\t/* create an array of creation funcs (called\n\t\t\t * stripeFuncs) for this stripe */\n\t\t\tnumStripeUnits = asm_p->numStripeUnitsAccessed;\n\t\t\tRF_Calloc(stripeUnitFuncs[numStripesBailed], numStripeUnits, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));\n\t\t\tRF_Malloc(asmh_u[numStripesBailed], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));\n\n\t\t\t/* lookup array of stripeUnitFuncs for this stripe */\n\t\t\tfor (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {\n\t\t\t\t/* remap for series of single stripe-unit\n\t\t\t\t * accesses */\n\t\t\t\taddress = physPtr->raidAddress;\n\t\t\t\tlength = physPtr->numSector;\n\t\t\t\tbuffer = physPtr->bufPtr;\n\n\t\t\t\tasmh_u[numStripesBailed][j] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);\n\t\t\t\tasm_up = asmh_u[numStripesBailed][j]->stripeMap;\n\n\t\t\t\t/* get the creation func for this stripe unit */\n\t\t\t\t(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_up, &(stripeUnitFuncs[numStripesBailed][j]));\n\n\t\t\t\t/* check to see if we found a creation func\n\t\t\t\t * for this stripe unit */\n\t\t\t\tif (stripeUnitFuncs[numStripesBailed][j] == (RF_VoidFuncPtr) NULL) {\n\t\t\t\t\t/* could not find creation function\n\t\t\t\t\t * for stripe unit so, let's see if we\n\t\t\t\t\t * can find one for each block in the\n\t\t\t\t\t * stripe unit */\n\t\t\t\t\tif (numStripeUnitsBailed == 0) {\n\t\t\t\t\t\t/* one stripe map header for\n\t\t\t\t\t\t * each stripe unit we bail on */\n\t\t\t\t\t\tRF_Malloc(asmh_b, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes * raidPtr->Layout.numDataCol, (RF_AccessStripeMapHeader_t ***));\n\t\t\t\t\t\t/* create an array of ptrs to\n\t\t\t\t\t\t * arrays of blockFuncs */\n\t\t\t\t\t\tRF_Calloc(blockFuncs, asm_h->numStripes * raidPtr->Layout.numDataCol, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));\n\t\t\t\t\t}\n\t\t\t\t\t/* create an array of creation funcs\n\t\t\t\t\t * (called blockFuncs) for this stripe\n\t\t\t\t\t * unit */\n\t\t\t\t\tnumBlocks = physPtr->numSector;\n\t\t\t\t\tnumBlockDags += numBlocks;\n\t\t\t\t\tRF_Calloc(blockFuncs[numStripeUnitsBailed], numBlocks, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));\n\t\t\t\t\tRF_Malloc(asmh_b[numStripeUnitsBailed], numBlocks * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));\n\n\t\t\t\t\t/* lookup array of blockFuncs for this\n\t\t\t\t\t * stripe unit */\n\t\t\t\t\tfor (k = 0; k < numBlocks; k++) {\n\t\t\t\t\t\t/* remap for series of single\n\t\t\t\t\t\t * stripe-unit accesses */\n\t\t\t\t\t\taddress = physPtr->raidAddress + k;\n\t\t\t\t\t\tlength = 1;\n\t\t\t\t\t\tbuffer = physPtr->bufPtr + (k * (1 << raidPtr->logBytesPerSector));\n\n\t\t\t\t\t\tasmh_b[numStripeUnitsBailed][k] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);\n\t\t\t\t\t\tasm_bp = asmh_b[numStripeUnitsBailed][k]->stripeMap;\n\n\t\t\t\t\t\t/* get the creation func for\n\t\t\t\t\t\t * this stripe unit */\n\t\t\t\t\t\t(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_bp, &(blockFuncs[numStripeUnitsBailed][k]));\n\n\t\t\t\t\t\t/* check to see if we found a\n\t\t\t\t\t\t * creation func for this\n\t\t\t\t\t\t * stripe unit */\n\t\t\t\t\t\tif (blockFuncs[numStripeUnitsBailed][k] == NULL)\n\t\t\t\t\t\t\tcantCreateDAGs = RF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tnumStripeUnitsBailed++;\n\t\t\t\t} else {\n\t\t\t\t\tnumUnitDags++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRF_ASSERT(j == numStripeUnits);\n\t\t\tnumStripesBailed++;\n\t\t}\n\t}\n\n\tif (cantCreateDAGs) {\n\t\t/* free memory and punt */\n\t\tif (asm_h->numStripes > MAXNSTRIPES)\n\t\t\tRF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\tif (numStripesBailed > 0) {\n\t\t\tstripeNum = 0;\n\t\t\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)\n\t\t\t\tif (stripeFuncs[i] == NULL) {\n\t\t\t\t\tnumStripeUnits = asm_p->numStripeUnitsAccessed;\n\t\t\t\t\tfor (j = 0; j < numStripeUnits; j++)\n\t\t\t\t\t\trf_FreeAccessStripeMap(asmh_u[stripeNum][j]);\n\t\t\t\t\tRF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));\n\t\t\t\t\tRF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));\n\t\t\t\t\tstripeNum++;\n\t\t\t\t}\n\t\t\tRF_ASSERT(stripeNum == numStripesBailed);\n\t\t\tRF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\t\tRF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));\n\t\t}\n\t\treturn (1);\n\t} else {\n\t\t/* begin dag creation */\n\t\tstripeNum = 0;\n\t\tstripeUnitNum = 0;\n\n\t\t/* create an array of dagLists and fill them in */\n\t\tRF_CallocAndAdd(desc->dagArray, desc->numStripes, sizeof(RF_DagList_t), (RF_DagList_t *), desc->cleanupList);\n\n\t\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++) {\n\t\t\t/* grab dag header for this stripe */\n\t\t\tdag_h = NULL;\n\t\t\tdesc->dagArray[i].desc = desc;\n\n\t\t\tif (stripeFuncs[i] == (RF_VoidFuncPtr) NULL) {\n\t\t\t\t/* use bailout functions for this stripe */\n\t\t\t\tfor (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {\n\t\t\t\t\tuFunc = stripeUnitFuncs[stripeNum][j];\n\t\t\t\t\tif (uFunc == (RF_VoidFuncPtr) NULL) {\n\t\t\t\t\t\t/* use bailout functions for\n\t\t\t\t\t\t * this stripe unit */\n\t\t\t\t\t\tfor (k = 0; k < physPtr->numSector; k++) {\n\t\t\t\t\t\t\t/* create a dag for\n\t\t\t\t\t\t\t * this block */\n\t\t\t\t\t\t\tInitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);\n\t\t\t\t\t\t\tdesc->dagArray[i].numDags++;\n\t\t\t\t\t\t\tif (dag_h == NULL) {\n\t\t\t\t\t\t\t\tdag_h = tempdag_h;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlastdag_h->next = tempdag_h;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastdag_h = tempdag_h;\n\n\t\t\t\t\t\t\tbFunc = blockFuncs[stripeUnitNum][k];\n\t\t\t\t\t\t\tRF_ASSERT(bFunc);\n\t\t\t\t\t\t\tasm_bp = asmh_b[stripeUnitNum][k]->stripeMap;\n\t\t\t\t\t\t\t(*bFunc) (raidPtr, asm_bp, tempdag_h, bp, flags, tempdag_h->allocList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstripeUnitNum++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* create a dag for this unit */\n\t\t\t\t\t\tInitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);\n\t\t\t\t\t\tdesc->dagArray[i].numDags++;\n\t\t\t\t\t\tif (dag_h == NULL) {\n\t\t\t\t\t\t\tdag_h = tempdag_h;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlastdag_h->next = tempdag_h;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastdag_h = tempdag_h;\n\n\t\t\t\t\t\tasm_up = asmh_u[stripeNum][j]->stripeMap;\n\t\t\t\t\t\t(*uFunc) (raidPtr, asm_up, tempdag_h, bp, flags, tempdag_h->allocList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRF_ASSERT(j == asm_p->numStripeUnitsAccessed);\n\t\t\t\t/* merge linked bailout dag to existing dag\n\t\t\t\t * collection */\n\t\t\t\tstripeNum++;\n\t\t\t} else {\n\t\t\t\t/* Create a dag for this parity stripe */\n\t\t\t\tInitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);\n\t\t\t\tdesc->dagArray[i].numDags++;\n\t\t\t\tif (dag_h == NULL) {\n\t\t\t\t\tdag_h = tempdag_h;\n\t\t\t\t} else {\n\t\t\t\t\tlastdag_h->next = tempdag_h;\n\t\t\t\t}\n\t\t\t\tlastdag_h = tempdag_h;\n\n\t\t\t\t(stripeFuncs[i]) (raidPtr, asm_p, tempdag_h, bp, flags, tempdag_h->allocList);\n\t\t\t}\n\t\t\tdesc->dagArray[i].dags = dag_h;\n\t\t}\n\t\tRF_ASSERT(i == desc->numStripes);\n\n\t\t/* free memory */\n\t\tif (asm_h->numStripes > MAXNSTRIPES)\n\t\t\tRF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\tif ((numStripesBailed > 0) || (numStripeUnitsBailed > 0)) {\n\t\t\tstripeNum = 0;\n\t\t\tstripeUnitNum = 0;\n\t\t\tif (dag_h->asmList) {\n\t\t\t\tendASMList = dag_h->asmList;\n\t\t\t\twhile (endASMList->next)\n\t\t\t\t\tendASMList = endASMList->next;\n\t\t\t} else\n\t\t\t\tendASMList = NULL;\n\t\t\t/* walk through io, stripe by stripe */\n\t\t\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)\n\t\t\t\tif (stripeFuncs[i] == NULL) {\n\t\t\t\t\tnumStripeUnits = asm_p->numStripeUnitsAccessed;\n\t\t\t\t\t/* walk through stripe, stripe unit by\n\t\t\t\t\t * stripe unit */\n\t\t\t\t\tfor (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {\n\t\t\t\t\t\tif (stripeUnitFuncs[stripeNum][j] == NULL) {\n\t\t\t\t\t\t\tnumBlocks = physPtr->numSector;\n\t\t\t\t\t\t\t/* walk through stripe\n\t\t\t\t\t\t\t * unit, block by\n\t\t\t\t\t\t\t * block */\n\t\t\t\t\t\t\tfor (k = 0; k < numBlocks; k++)\n\t\t\t\t\t\t\t\tif (dag_h->asmList == NULL) {\n\t\t\t\t\t\t\t\t\tdag_h->asmList = asmh_b[stripeUnitNum][k];\n\t\t\t\t\t\t\t\t\tendASMList = dag_h->asmList;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tendASMList->next = asmh_b[stripeUnitNum][k];\n\t\t\t\t\t\t\t\t\tendASMList = endASMList->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRF_Free(asmh_b[stripeUnitNum], numBlocks * sizeof(RF_AccessStripeMapHeader_t *));\n\t\t\t\t\t\t\tRF_Free(blockFuncs[stripeUnitNum], numBlocks * sizeof(RF_VoidFuncPtr));\n\t\t\t\t\t\t\tstripeUnitNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dag_h->asmList == NULL) {\n\t\t\t\t\t\t\tdag_h->asmList = asmh_u[stripeNum][j];\n\t\t\t\t\t\t\tendASMList = dag_h->asmList;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tendASMList->next = asmh_u[stripeNum][j];\n\t\t\t\t\t\t\tendASMList = endASMList->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tRF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));\n\t\t\t\t\tRF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));\n\t\t\t\t\tstripeNum++;\n\t\t\t\t}\n\t\t\tRF_ASSERT(stripeNum == numStripesBailed);\n\t\t\tRF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\t\tRF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));\n\t\t\tif (numStripeUnitsBailed > 0) {\n\t\t\t\tRF_ASSERT(stripeUnitNum == numStripeUnitsBailed);\n\t\t\t\tRF_Free(blockFuncs, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\t\t\tRF_Free(asmh_b, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));\n\t\t\t}\n\t\t}\n\t\treturn (0);\n\t}\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [
      "#define MAXNSTRIPES 50"
    ],
    "globals_used": [
      "static int InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);",
      "int     rf_SelectAlgorithm(RF_RaidAccessDesc_t *, RF_RaidAccessFlags_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "asmh_b",
            "raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "blockFuncs",
            "raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "stripeUnitNum == numStripeUnitsBailed"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "asmh_u",
            "asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "stripeUnitFuncs",
            "asm_h->numStripes * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "stripeNum == numStripesBailed"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "stripeUnitFuncs[stripeNum]",
            "numStripeUnits * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "asmh_u[stripeNum]",
            "numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "blockFuncs[stripeUnitNum]",
            "numBlocks * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "asmh_b[stripeUnitNum]",
            "numBlocks * sizeof(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "stripeFuncs",
            "asm_h->numStripes * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == desc->numStripes"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "asm_p",
            "tempdag_h",
            "bp",
            "flags",
            "tempdag_h->allocList"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitHdrNode",
          "args": [
            "&tempdag_h",
            "raidPtr",
            "rf_useMemChunks"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "InitHdrNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_aselect.c",
          "lines": "63-81",
          "snippet": "static int \nInitHdrNode(hdr, raidPtr, memChunkEnable)\n\tRF_DagHeader_t **hdr;\n\tRF_Raid_t *raidPtr;\n\tint     memChunkEnable;\n{\n\t/* create and initialize dag hdr */\n\t*hdr = rf_AllocDAGHeader();\n\trf_MakeAllocList((*hdr)->allocList);\n\tif ((*hdr)->allocList == NULL) {\n\t\trf_FreeDAGHeader(*hdr);\n\t\treturn (ENOMEM);\n\t}\n\t(*hdr)->status = rf_enable;\n\t(*hdr)->numSuccedents = 0;\n\t(*hdr)->raidPtr = raidPtr;\n\t(*hdr)->next = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_map.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic int InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);\n\nstatic int \nInitHdrNode(hdr, raidPtr, memChunkEnable)\n\tRF_DagHeader_t **hdr;\n\tRF_Raid_t *raidPtr;\n\tint     memChunkEnable;\n{\n\t/* create and initialize dag hdr */\n\t*hdr = rf_AllocDAGHeader();\n\trf_MakeAllocList((*hdr)->allocList);\n\tif ((*hdr)->allocList == NULL) {\n\t\trf_FreeDAGHeader(*hdr);\n\t\treturn (ENOMEM);\n\t}\n\t(*hdr)->status = rf_enable;\n\t(*hdr)->numSuccedents = 0;\n\t(*hdr)->raidPtr = raidPtr;\n\t(*hdr)->next = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "j == asm_p->numStripeUnitsAccessed"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "asm_up",
            "tempdag_h",
            "bp",
            "flags",
            "tempdag_h->allocList"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "asm_bp",
            "tempdag_h",
            "bp",
            "flags",
            "tempdag_h->allocList"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "bFunc"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "desc->dagArray",
            "desc->numStripes",
            "sizeof(RF_DagList_t)",
            "(RF_DagList_t *), desc->cleanupList"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "asmh_u",
            "asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "stripeUnitFuncs",
            "asm_h->numStripes * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "stripeNum == numStripesBailed"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "stripeUnitFuncs[stripeNum]",
            "numStripeUnits * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "asmh_u[stripeNum]",
            "numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeAccessStripeMap",
          "args": [
            "asmh_u[stripeNum][j]"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAccessStripeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "537-598",
          "snippet": "void \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
            "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
            "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;",
            "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
            "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nvoid \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "stripeFuncs",
            "asm_h->numStripes * sizeof(RF_VoidFuncPtr)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "j == numStripeUnits"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "type",
            "asm_bp",
            "&(blockFuncs[numStripeUnitsBailed][k])"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "address",
            "length",
            "buffer",
            "RF_DONT_REMAP"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "asmh_b[numStripeUnitsBailed]",
            "numBlocks * sizeof(RF_AccessStripeMapHeader_t *)",
            "(RF_AccessStripeMapHeader_t **)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "blockFuncs[numStripeUnitsBailed]",
            "numBlocks",
            "sizeof(RF_VoidFuncPtr)",
            "(RF_VoidFuncPtr *)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "blockFuncs",
            "asm_h->numStripes * raidPtr->Layout.numDataCol",
            "sizeof(RF_VoidFuncPtr)",
            "(RF_VoidFuncPtr **)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "asmh_b",
            "sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes * raidPtr->Layout.numDataCol",
            "(RF_AccessStripeMapHeader_t ***)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "type",
            "asm_up",
            "&(stripeUnitFuncs[numStripesBailed][j])"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "address",
            "length",
            "buffer",
            "RF_DONT_REMAP"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "asmh_u[numStripesBailed]",
            "numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *)",
            "(RF_AccessStripeMapHeader_t **)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "stripeUnitFuncs[numStripesBailed]",
            "numStripeUnits",
            "sizeof(RF_VoidFuncPtr)",
            "(RF_VoidFuncPtr *)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "stripeUnitFuncs",
            "asm_h->numStripes",
            "sizeof(RF_VoidFuncPtr)",
            "(RF_VoidFuncPtr **)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "asmh_u",
            "sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes",
            "(RF_AccessStripeMapHeader_t ***)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "type",
            "asm_p",
            "&stripeFuncs[i]"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "stripeFuncs",
            "asm_h->numStripes",
            "sizeof(RF_VoidFuncPtr)",
            "(RF_VoidFuncPtr *)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\n#define MAXNSTRIPES 50\n\nstatic int InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);\nint     rf_SelectAlgorithm(RF_RaidAccessDesc_t *, RF_RaidAccessFlags_t);\n\nint \nrf_SelectAlgorithm(desc, flags)\n\tRF_RaidAccessDesc_t *desc;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_AccessStripeMapHeader_t *asm_h = desc->asmap;\n\tRF_IoType_t type = desc->type;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tvoid   *bp = desc->bp;\n\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_AccessStripeMap_t *asm_p;\n\tRF_DagHeader_t *dag_h = NULL, *tempdag_h, *lastdag_h;\n\tint     i, j, k;\n\tRF_VoidFuncPtr *stripeFuncs, normalStripeFuncs[MAXNSTRIPES];\n\tRF_AccessStripeMap_t *asm_up, *asm_bp;\n\tRF_AccessStripeMapHeader_t ***asmh_u, *endASMList;\n\tRF_AccessStripeMapHeader_t ***asmh_b;\n\tRF_VoidFuncPtr **stripeUnitFuncs, uFunc;\n\tRF_VoidFuncPtr **blockFuncs, bFunc;\n\tint     numStripesBailed = 0, cantCreateDAGs = RF_FALSE;\n\tint     numStripeUnitsBailed = 0;\n\tint     stripeNum, numUnitDags = 0, stripeUnitNum, numBlockDags = 0;\n\tRF_StripeNum_t numStripeUnits;\n\tRF_SectorNum_t numBlocks;\n\tRF_RaidAddr_t address;\n\tint     length;\n\tRF_PhysDiskAddr_t *physPtr;\n\tcaddr_t buffer;\n\n\tlastdag_h = NULL;\n\tasmh_u = asmh_b = NULL;\n\tstripeUnitFuncs = NULL;\n\tblockFuncs = NULL;\n\n\t/* get an array of dag-function creation pointers, try to avoid\n\t * calling malloc */\n\tif (asm_h->numStripes <= MAXNSTRIPES)\n\t\tstripeFuncs = normalStripeFuncs;\n\telse\n\t\tRF_Calloc(stripeFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));\n\n\t/* walk through the asm list once collecting information */\n\t/* attempt to find a single creation function for each stripe */\n\tdesc->numStripes = 0;\n\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++) {\n\t\tdesc->numStripes++;\n\t\t(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_p, &stripeFuncs[i]);\n\t\t/* check to see if we found a creation func for this stripe */\n\t\tif (stripeFuncs[i] == (RF_VoidFuncPtr) NULL) {\n\t\t\t/* could not find creation function for entire stripe\n\t\t\t * so, let's see if we can find one for each stripe\n\t\t\t * unit in the stripe */\n\n\t\t\tif (numStripesBailed == 0) {\n\t\t\t\t/* one stripe map header for each stripe we\n\t\t\t\t * bail on */\n\t\t\t\tRF_Malloc(asmh_u, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes, (RF_AccessStripeMapHeader_t ***));\n\t\t\t\t/* create an array of ptrs to arrays of\n\t\t\t\t * stripeFuncs */\n\t\t\t\tRF_Calloc(stripeUnitFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));\n\t\t\t}\n\t\t\t/* create an array of creation funcs (called\n\t\t\t * stripeFuncs) for this stripe */\n\t\t\tnumStripeUnits = asm_p->numStripeUnitsAccessed;\n\t\t\tRF_Calloc(stripeUnitFuncs[numStripesBailed], numStripeUnits, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));\n\t\t\tRF_Malloc(asmh_u[numStripesBailed], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));\n\n\t\t\t/* lookup array of stripeUnitFuncs for this stripe */\n\t\t\tfor (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {\n\t\t\t\t/* remap for series of single stripe-unit\n\t\t\t\t * accesses */\n\t\t\t\taddress = physPtr->raidAddress;\n\t\t\t\tlength = physPtr->numSector;\n\t\t\t\tbuffer = physPtr->bufPtr;\n\n\t\t\t\tasmh_u[numStripesBailed][j] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);\n\t\t\t\tasm_up = asmh_u[numStripesBailed][j]->stripeMap;\n\n\t\t\t\t/* get the creation func for this stripe unit */\n\t\t\t\t(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_up, &(stripeUnitFuncs[numStripesBailed][j]));\n\n\t\t\t\t/* check to see if we found a creation func\n\t\t\t\t * for this stripe unit */\n\t\t\t\tif (stripeUnitFuncs[numStripesBailed][j] == (RF_VoidFuncPtr) NULL) {\n\t\t\t\t\t/* could not find creation function\n\t\t\t\t\t * for stripe unit so, let's see if we\n\t\t\t\t\t * can find one for each block in the\n\t\t\t\t\t * stripe unit */\n\t\t\t\t\tif (numStripeUnitsBailed == 0) {\n\t\t\t\t\t\t/* one stripe map header for\n\t\t\t\t\t\t * each stripe unit we bail on */\n\t\t\t\t\t\tRF_Malloc(asmh_b, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes * raidPtr->Layout.numDataCol, (RF_AccessStripeMapHeader_t ***));\n\t\t\t\t\t\t/* create an array of ptrs to\n\t\t\t\t\t\t * arrays of blockFuncs */\n\t\t\t\t\t\tRF_Calloc(blockFuncs, asm_h->numStripes * raidPtr->Layout.numDataCol, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));\n\t\t\t\t\t}\n\t\t\t\t\t/* create an array of creation funcs\n\t\t\t\t\t * (called blockFuncs) for this stripe\n\t\t\t\t\t * unit */\n\t\t\t\t\tnumBlocks = physPtr->numSector;\n\t\t\t\t\tnumBlockDags += numBlocks;\n\t\t\t\t\tRF_Calloc(blockFuncs[numStripeUnitsBailed], numBlocks, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));\n\t\t\t\t\tRF_Malloc(asmh_b[numStripeUnitsBailed], numBlocks * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));\n\n\t\t\t\t\t/* lookup array of blockFuncs for this\n\t\t\t\t\t * stripe unit */\n\t\t\t\t\tfor (k = 0; k < numBlocks; k++) {\n\t\t\t\t\t\t/* remap for series of single\n\t\t\t\t\t\t * stripe-unit accesses */\n\t\t\t\t\t\taddress = physPtr->raidAddress + k;\n\t\t\t\t\t\tlength = 1;\n\t\t\t\t\t\tbuffer = physPtr->bufPtr + (k * (1 << raidPtr->logBytesPerSector));\n\n\t\t\t\t\t\tasmh_b[numStripeUnitsBailed][k] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);\n\t\t\t\t\t\tasm_bp = asmh_b[numStripeUnitsBailed][k]->stripeMap;\n\n\t\t\t\t\t\t/* get the creation func for\n\t\t\t\t\t\t * this stripe unit */\n\t\t\t\t\t\t(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_bp, &(blockFuncs[numStripeUnitsBailed][k]));\n\n\t\t\t\t\t\t/* check to see if we found a\n\t\t\t\t\t\t * creation func for this\n\t\t\t\t\t\t * stripe unit */\n\t\t\t\t\t\tif (blockFuncs[numStripeUnitsBailed][k] == NULL)\n\t\t\t\t\t\t\tcantCreateDAGs = RF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tnumStripeUnitsBailed++;\n\t\t\t\t} else {\n\t\t\t\t\tnumUnitDags++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRF_ASSERT(j == numStripeUnits);\n\t\t\tnumStripesBailed++;\n\t\t}\n\t}\n\n\tif (cantCreateDAGs) {\n\t\t/* free memory and punt */\n\t\tif (asm_h->numStripes > MAXNSTRIPES)\n\t\t\tRF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\tif (numStripesBailed > 0) {\n\t\t\tstripeNum = 0;\n\t\t\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)\n\t\t\t\tif (stripeFuncs[i] == NULL) {\n\t\t\t\t\tnumStripeUnits = asm_p->numStripeUnitsAccessed;\n\t\t\t\t\tfor (j = 0; j < numStripeUnits; j++)\n\t\t\t\t\t\trf_FreeAccessStripeMap(asmh_u[stripeNum][j]);\n\t\t\t\t\tRF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));\n\t\t\t\t\tRF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));\n\t\t\t\t\tstripeNum++;\n\t\t\t\t}\n\t\t\tRF_ASSERT(stripeNum == numStripesBailed);\n\t\t\tRF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\t\tRF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));\n\t\t}\n\t\treturn (1);\n\t} else {\n\t\t/* begin dag creation */\n\t\tstripeNum = 0;\n\t\tstripeUnitNum = 0;\n\n\t\t/* create an array of dagLists and fill them in */\n\t\tRF_CallocAndAdd(desc->dagArray, desc->numStripes, sizeof(RF_DagList_t), (RF_DagList_t *), desc->cleanupList);\n\n\t\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++) {\n\t\t\t/* grab dag header for this stripe */\n\t\t\tdag_h = NULL;\n\t\t\tdesc->dagArray[i].desc = desc;\n\n\t\t\tif (stripeFuncs[i] == (RF_VoidFuncPtr) NULL) {\n\t\t\t\t/* use bailout functions for this stripe */\n\t\t\t\tfor (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {\n\t\t\t\t\tuFunc = stripeUnitFuncs[stripeNum][j];\n\t\t\t\t\tif (uFunc == (RF_VoidFuncPtr) NULL) {\n\t\t\t\t\t\t/* use bailout functions for\n\t\t\t\t\t\t * this stripe unit */\n\t\t\t\t\t\tfor (k = 0; k < physPtr->numSector; k++) {\n\t\t\t\t\t\t\t/* create a dag for\n\t\t\t\t\t\t\t * this block */\n\t\t\t\t\t\t\tInitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);\n\t\t\t\t\t\t\tdesc->dagArray[i].numDags++;\n\t\t\t\t\t\t\tif (dag_h == NULL) {\n\t\t\t\t\t\t\t\tdag_h = tempdag_h;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlastdag_h->next = tempdag_h;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastdag_h = tempdag_h;\n\n\t\t\t\t\t\t\tbFunc = blockFuncs[stripeUnitNum][k];\n\t\t\t\t\t\t\tRF_ASSERT(bFunc);\n\t\t\t\t\t\t\tasm_bp = asmh_b[stripeUnitNum][k]->stripeMap;\n\t\t\t\t\t\t\t(*bFunc) (raidPtr, asm_bp, tempdag_h, bp, flags, tempdag_h->allocList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstripeUnitNum++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* create a dag for this unit */\n\t\t\t\t\t\tInitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);\n\t\t\t\t\t\tdesc->dagArray[i].numDags++;\n\t\t\t\t\t\tif (dag_h == NULL) {\n\t\t\t\t\t\t\tdag_h = tempdag_h;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlastdag_h->next = tempdag_h;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastdag_h = tempdag_h;\n\n\t\t\t\t\t\tasm_up = asmh_u[stripeNum][j]->stripeMap;\n\t\t\t\t\t\t(*uFunc) (raidPtr, asm_up, tempdag_h, bp, flags, tempdag_h->allocList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRF_ASSERT(j == asm_p->numStripeUnitsAccessed);\n\t\t\t\t/* merge linked bailout dag to existing dag\n\t\t\t\t * collection */\n\t\t\t\tstripeNum++;\n\t\t\t} else {\n\t\t\t\t/* Create a dag for this parity stripe */\n\t\t\t\tInitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);\n\t\t\t\tdesc->dagArray[i].numDags++;\n\t\t\t\tif (dag_h == NULL) {\n\t\t\t\t\tdag_h = tempdag_h;\n\t\t\t\t} else {\n\t\t\t\t\tlastdag_h->next = tempdag_h;\n\t\t\t\t}\n\t\t\t\tlastdag_h = tempdag_h;\n\n\t\t\t\t(stripeFuncs[i]) (raidPtr, asm_p, tempdag_h, bp, flags, tempdag_h->allocList);\n\t\t\t}\n\t\t\tdesc->dagArray[i].dags = dag_h;\n\t\t}\n\t\tRF_ASSERT(i == desc->numStripes);\n\n\t\t/* free memory */\n\t\tif (asm_h->numStripes > MAXNSTRIPES)\n\t\t\tRF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\tif ((numStripesBailed > 0) || (numStripeUnitsBailed > 0)) {\n\t\t\tstripeNum = 0;\n\t\t\tstripeUnitNum = 0;\n\t\t\tif (dag_h->asmList) {\n\t\t\t\tendASMList = dag_h->asmList;\n\t\t\t\twhile (endASMList->next)\n\t\t\t\t\tendASMList = endASMList->next;\n\t\t\t} else\n\t\t\t\tendASMList = NULL;\n\t\t\t/* walk through io, stripe by stripe */\n\t\t\tfor (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)\n\t\t\t\tif (stripeFuncs[i] == NULL) {\n\t\t\t\t\tnumStripeUnits = asm_p->numStripeUnitsAccessed;\n\t\t\t\t\t/* walk through stripe, stripe unit by\n\t\t\t\t\t * stripe unit */\n\t\t\t\t\tfor (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {\n\t\t\t\t\t\tif (stripeUnitFuncs[stripeNum][j] == NULL) {\n\t\t\t\t\t\t\tnumBlocks = physPtr->numSector;\n\t\t\t\t\t\t\t/* walk through stripe\n\t\t\t\t\t\t\t * unit, block by\n\t\t\t\t\t\t\t * block */\n\t\t\t\t\t\t\tfor (k = 0; k < numBlocks; k++)\n\t\t\t\t\t\t\t\tif (dag_h->asmList == NULL) {\n\t\t\t\t\t\t\t\t\tdag_h->asmList = asmh_b[stripeUnitNum][k];\n\t\t\t\t\t\t\t\t\tendASMList = dag_h->asmList;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tendASMList->next = asmh_b[stripeUnitNum][k];\n\t\t\t\t\t\t\t\t\tendASMList = endASMList->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRF_Free(asmh_b[stripeUnitNum], numBlocks * sizeof(RF_AccessStripeMapHeader_t *));\n\t\t\t\t\t\t\tRF_Free(blockFuncs[stripeUnitNum], numBlocks * sizeof(RF_VoidFuncPtr));\n\t\t\t\t\t\t\tstripeUnitNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dag_h->asmList == NULL) {\n\t\t\t\t\t\t\tdag_h->asmList = asmh_u[stripeNum][j];\n\t\t\t\t\t\t\tendASMList = dag_h->asmList;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tendASMList->next = asmh_u[stripeNum][j];\n\t\t\t\t\t\t\tendASMList = endASMList->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tRF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));\n\t\t\t\t\tRF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));\n\t\t\t\t\tstripeNum++;\n\t\t\t\t}\n\t\t\tRF_ASSERT(stripeNum == numStripesBailed);\n\t\t\tRF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\t\tRF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));\n\t\t\tif (numStripeUnitsBailed > 0) {\n\t\t\t\tRF_ASSERT(stripeUnitNum == numStripeUnitsBailed);\n\t\t\t\tRF_Free(blockFuncs, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_VoidFuncPtr));\n\t\t\t\tRF_Free(asmh_b, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));\n\t\t\t}\n\t\t}\n\t\treturn (0);\n\t}\n}"
  },
  {
    "function_name": "UpdateNodeHdrPtr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_aselect.c",
    "lines": "159-170",
    "snippet": "static void \nUpdateNodeHdrPtr(hdr, node)\n\tRF_DagHeader_t *hdr;\n\tRF_DagNode_t *node;\n{\n\tint     i;\n\tRF_ASSERT(hdr != NULL && node != NULL);\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != hdr)\n\t\t\tUpdateNodeHdrPtr(hdr, node->succedents[i]);\n\tnode->dagHdr = hdr;\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void UpdateNodeHdrPtr(RF_DagHeader_t *, RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpdateNodeHdrPtr",
          "args": [
            "hdr",
            "node->succedents[i]"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateNodeHdrPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_aselect.c",
          "lines": "159-170",
          "snippet": "static void \nUpdateNodeHdrPtr(hdr, node)\n\tRF_DagHeader_t *hdr;\n\tRF_DagNode_t *node;\n{\n\tint     i;\n\tRF_ASSERT(hdr != NULL && node != NULL);\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != hdr)\n\t\t\tUpdateNodeHdrPtr(hdr, node->succedents[i]);\n\tnode->dagHdr = hdr;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "hdr != NULL && node != NULL"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void UpdateNodeHdrPtr(RF_DagHeader_t *, RF_DagNode_t *);\n\nstatic void \nUpdateNodeHdrPtr(hdr, node)\n\tRF_DagHeader_t *hdr;\n\tRF_DagNode_t *node;\n{\n\tint     i;\n\tRF_ASSERT(hdr != NULL && node != NULL);\n\tfor (i = 0; i < node->numSuccedents; i++)\n\t\tif (node->succedents[i]->dagHdr != hdr)\n\t\t\tUpdateNodeHdrPtr(hdr, node->succedents[i]);\n\tnode->dagHdr = hdr;\n}"
  },
  {
    "function_name": "TransferDagMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_aselect.c",
    "lines": "90-147",
    "snippet": "static void \nTransferDagMemory(daga, dagb)\n\tRF_DagHeader_t *daga;\n\tRF_DagHeader_t *dagb;\n{\n\tRF_AccessStripeMapHeader_t *end;\n\tRF_AllocListElem_t *p;\n\tint     i, memChunksXfrd = 0, xtraChunksXfrd = 0;\n\n\t/* transfer allocList from dagb to daga */\n\tfor (p = dagb->allocList; p; p = p->next) {\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\trf_AddToAllocList(daga->allocList, p->pointers[i], p->sizes[i]);\n\t\t\tp->pointers[i] = NULL;\n\t\t\tp->sizes[i] = 0;\n\t\t}\n\t\tp->numPointers = 0;\n\t}\n\n\t/* transfer chunks from dagb to daga */\n\twhile ((memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) && (daga->chunkIndex < RF_MAXCHUNKS)) {\n\t\t/* stuff chunks into daga's memChunk array */\n\t\tif (memChunksXfrd < dagb->chunkIndex) {\n\t\t\tdaga->memChunk[daga->chunkIndex++] = dagb->memChunk[memChunksXfrd];\n\t\t\tdagb->memChunk[memChunksXfrd++] = NULL;\n\t\t} else {\n\t\t\tdaga->memChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];\n\t\t\tdagb->xtraMemChunk[xtraChunksXfrd++] = NULL;\n\t\t}\n\t}\n\t/* use escape hatch to hold excess chunks */\n\twhile (memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) {\n\t\tif (memChunksXfrd < dagb->chunkIndex) {\n\t\t\tdaga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->memChunk[memChunksXfrd];\n\t\t\tdagb->memChunk[memChunksXfrd++] = NULL;\n\t\t} else {\n\t\t\tdaga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];\n\t\t\tdagb->xtraMemChunk[xtraChunksXfrd++] = NULL;\n\t\t}\n\t}\n\tRF_ASSERT((memChunksXfrd == dagb->chunkIndex) && (xtraChunksXfrd == dagb->xtraChunkIndex));\n\tRF_ASSERT(daga->chunkIndex <= RF_MAXCHUNKS);\n\tRF_ASSERT(daga->xtraChunkIndex <= daga->xtraChunkCnt);\n\tdagb->chunkIndex = 0;\n\tdagb->xtraChunkIndex = 0;\n\n\t/* transfer asmList from dagb to daga */\n\tif (dagb->asmList) {\n\t\tif (daga->asmList) {\n\t\t\tend = daga->asmList;\n\t\t\twhile (end->next)\n\t\t\t\tend = end->next;\n\t\t\tend->next = dagb->asmList;\n\t\t} else\n\t\t\tdaga->asmList = dagb->asmList;\n\t\tdagb->asmList = NULL;\n\t}\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "daga->xtraChunkIndex <= daga->xtraChunkCnt"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "daga->chunkIndex <= RF_MAXCHUNKS"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(memChunksXfrd == dagb->chunkIndex) && (xtraChunksXfrd == dagb->xtraChunkIndex)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AddToAllocList",
          "args": [
            "daga->allocList",
            "p->pointers[i]",
            "p->sizes[i]"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nTransferDagMemory(daga, dagb)\n\tRF_DagHeader_t *daga;\n\tRF_DagHeader_t *dagb;\n{\n\tRF_AccessStripeMapHeader_t *end;\n\tRF_AllocListElem_t *p;\n\tint     i, memChunksXfrd = 0, xtraChunksXfrd = 0;\n\n\t/* transfer allocList from dagb to daga */\n\tfor (p = dagb->allocList; p; p = p->next) {\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\trf_AddToAllocList(daga->allocList, p->pointers[i], p->sizes[i]);\n\t\t\tp->pointers[i] = NULL;\n\t\t\tp->sizes[i] = 0;\n\t\t}\n\t\tp->numPointers = 0;\n\t}\n\n\t/* transfer chunks from dagb to daga */\n\twhile ((memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) && (daga->chunkIndex < RF_MAXCHUNKS)) {\n\t\t/* stuff chunks into daga's memChunk array */\n\t\tif (memChunksXfrd < dagb->chunkIndex) {\n\t\t\tdaga->memChunk[daga->chunkIndex++] = dagb->memChunk[memChunksXfrd];\n\t\t\tdagb->memChunk[memChunksXfrd++] = NULL;\n\t\t} else {\n\t\t\tdaga->memChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];\n\t\t\tdagb->xtraMemChunk[xtraChunksXfrd++] = NULL;\n\t\t}\n\t}\n\t/* use escape hatch to hold excess chunks */\n\twhile (memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) {\n\t\tif (memChunksXfrd < dagb->chunkIndex) {\n\t\t\tdaga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->memChunk[memChunksXfrd];\n\t\t\tdagb->memChunk[memChunksXfrd++] = NULL;\n\t\t} else {\n\t\t\tdaga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];\n\t\t\tdagb->xtraMemChunk[xtraChunksXfrd++] = NULL;\n\t\t}\n\t}\n\tRF_ASSERT((memChunksXfrd == dagb->chunkIndex) && (xtraChunksXfrd == dagb->xtraChunkIndex));\n\tRF_ASSERT(daga->chunkIndex <= RF_MAXCHUNKS);\n\tRF_ASSERT(daga->xtraChunkIndex <= daga->xtraChunkCnt);\n\tdagb->chunkIndex = 0;\n\tdagb->xtraChunkIndex = 0;\n\n\t/* transfer asmList from dagb to daga */\n\tif (dagb->asmList) {\n\t\tif (daga->asmList) {\n\t\t\tend = daga->asmList;\n\t\t\twhile (end->next)\n\t\t\t\tend = end->next;\n\t\t\tend->next = dagb->asmList;\n\t\t} else\n\t\t\tdaga->asmList = dagb->asmList;\n\t\tdagb->asmList = NULL;\n\t}\n}"
  },
  {
    "function_name": "InitHdrNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_aselect.c",
    "lines": "63-81",
    "snippet": "static int \nInitHdrNode(hdr, raidPtr, memChunkEnable)\n\tRF_DagHeader_t **hdr;\n\tRF_Raid_t *raidPtr;\n\tint     memChunkEnable;\n{\n\t/* create and initialize dag hdr */\n\t*hdr = rf_AllocDAGHeader();\n\trf_MakeAllocList((*hdr)->allocList);\n\tif ((*hdr)->allocList == NULL) {\n\t\trf_FreeDAGHeader(*hdr);\n\t\treturn (ENOMEM);\n\t}\n\t(*hdr)->status = rf_enable;\n\t(*hdr)->numSuccedents = 0;\n\t(*hdr)->raidPtr = raidPtr;\n\t(*hdr)->next = NULL;\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeDAGHeader",
          "args": [
            "*hdr"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeDAGHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "257-261",
          "snippet": "void \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
            "static RF_FreeList_t *rf_dagh_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\n\nvoid \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_MakeAllocList",
          "args": [
            "(*hdr)->allocList"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocDAGHeader",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocDAGHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "245-255",
          "snippet": "RF_DagHeader_t *\nrf_AllocDAGHeader()\n{\n\tRF_DagHeader_t *dh;\n\n\tRF_FREELIST_GET(rf_dagh_freelist, dh, next, (RF_DagHeader_t *));\n\tif (dh) {\n\t\tbzero((char *) dh, sizeof(RF_DagHeader_t));\n\t}\n\treturn (dh);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
            "static RF_FreeList_t *rf_dagh_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\n\nRF_DagHeader_t *\nrf_AllocDAGHeader()\n{\n\tRF_DagHeader_t *dh;\n\n\tRF_FREELIST_GET(rf_dagh_freelist, dh, next, (RF_DagHeader_t *));\n\tif (dh) {\n\t\tbzero((char *) dh, sizeof(RF_DagHeader_t));\n\t}\n\treturn (dh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic int InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);\n\nstatic int \nInitHdrNode(hdr, raidPtr, memChunkEnable)\n\tRF_DagHeader_t **hdr;\n\tRF_Raid_t *raidPtr;\n\tint     memChunkEnable;\n{\n\t/* create and initialize dag hdr */\n\t*hdr = rf_AllocDAGHeader();\n\trf_MakeAllocList((*hdr)->allocList);\n\tif ((*hdr)->allocList == NULL) {\n\t\trf_FreeDAGHeader(*hdr);\n\t\treturn (ENOMEM);\n\t}\n\t(*hdr)->status = rf_enable;\n\t(*hdr)->numSuccedents = 0;\n\t(*hdr)->raidPtr = raidPtr;\n\t(*hdr)->next = NULL;\n\treturn (0);\n}"
  }
]