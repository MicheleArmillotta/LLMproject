[
  {
    "function_name": "pcmcia_parse_cis_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
    "lines": "600-1257",
    "snippet": "int\npcmcia_parse_cis_tuple(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\t/* most of these are educated guesses */\n\tstatic struct pcmcia_config_entry init_cfe = {\n\t\t-1, PCMCIA_CFE_RDYBSY_ACTIVE | PCMCIA_CFE_WP_ACTIVE |\n\t\tPCMCIA_CFE_BVD_ACTIVE, PCMCIA_IFTYPE_MEMORY,\n\t};\n\n\tstruct cis_state *state = arg;\n\n\tswitch (tuple->code) {\n\tcase PCMCIA_CISTPL_END:\n\t\t/*\n\t\t * If we've seen a LONGLINK_MFC, and this is the first\n\t\t * END after it, reset the function list.  \n\t\t *\n\t\t * XXX This might also be the right place to start a\n\t\t * new function, but that assumes that a function\n\t\t * definition never crosses any longlink, and I'm not\n\t\t * sure about that.  This is probably safe for MFC\n\t\t * cards, but what we have now isn't broken, so I'd\n\t\t * rather not change it.\n\t\t */\n\t\tif (state->gotmfc == 1) {\n\t\t\tstruct pcmcia_function *pf, *pfnext;\n\n\t\t\tfor (pf = state->card->pf_head.sqh_first; pf != NULL;\n\t\t\t    pf = pfnext) {\n\t\t\t\tpfnext = pf->pf_list.sqe_next;\n\t\t\t\tfree(pf, M_DEVBUF);\n\t\t\t}\n\n\t\t\tSIMPLEQ_INIT(&state->card->pf_head);\n\n\t\t\tstate->count = 0;\n\t\t\tstate->gotmfc = 2;\n\t\t\tstate->pf = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t/*\n\t\t * This tuple's structure was dealt with in scan_cis.  here,\n\t\t * record the fact that the MFC tuple was seen, so that\n\t\t * functions declared before the MFC link can be cleaned\n\t\t * up.\n\t\t */\n\t\tstate->gotmfc = 1;\n\t\tbreak;\n\n#ifdef PCMCIACISDEBUG\n\tcase PCMCIA_CISTPL_DEVICE:\n\tcase PCMCIA_CISTPL_DEVICE_A:\n\t\t{\n\t\t\tu_int reg, dtype, dspeed;\n\n\t\t\treg = pcmcia_tuple_read_1(tuple, 0);\n\t\t\tdtype = reg & PCMCIA_DTYPE_MASK;\n\t\t\tdspeed = reg & PCMCIA_DSPEED_MASK;\n\n\t\t\tDPRINTF((\"CISTPL_DEVICE%s type=\",\n\t\t\t(tuple->code == PCMCIA_CISTPL_DEVICE) ? \"\" : \"_A\"));\n\t\t\tswitch (dtype) {\n\t\t\tcase PCMCIA_DTYPE_NULL:\n\t\t\t\tDPRINTF((\"null\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_ROM:\n\t\t\t\tDPRINTF((\"rom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_OTPROM:\n\t\t\t\tDPRINTF((\"otprom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_EPROM:\n\t\t\t\tDPRINTF((\"eprom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_EEPROM:\n\t\t\t\tDPRINTF((\"eeprom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_FLASH:\n\t\t\t\tDPRINTF((\"flash\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_SRAM:\n\t\t\t\tDPRINTF((\"sram\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_DRAM:\n\t\t\t\tDPRINTF((\"dram\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_FUNCSPEC:\n\t\t\t\tDPRINTF((\"funcspec\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_EXTEND:\n\t\t\t\tDPRINTF((\"extend\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDPRINTF((\"reserved\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTF((\" speed=\"));\n\t\t\tswitch (dspeed) {\n\t\t\tcase PCMCIA_DSPEED_NULL:\n\t\t\t\tDPRINTF((\"null\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_250NS:\n\t\t\t\tDPRINTF((\"250ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_200NS:\n\t\t\t\tDPRINTF((\"200ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_150NS:\n\t\t\t\tDPRINTF((\"150ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_100NS:\n\t\t\t\tDPRINTF((\"100ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_EXT:\n\t\t\t\tDPRINTF((\"ext\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDPRINTF((\"reserved\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t\tbreak;\n#endif\n\n\tcase PCMCIA_CISTPL_VERS_1:\n\t\tif (tuple->length < 6) {\n\t\t\tDPRINTF((\"CISTPL_VERS_1 too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t} {\n\t\t\tint start, i, ch, count;\n\n\t\t\tstate->card->cis1_major = pcmcia_tuple_read_1(tuple, 0);\n\t\t\tstate->card->cis1_minor = pcmcia_tuple_read_1(tuple, 1);\n\n\t\t\tfor (count = 0, start = 0, i = 0;\n\t\t\t    (count < 4) && ((i + 4) < 256); i++) {\n\t\t\t\tch = pcmcia_tuple_read_1(tuple, 2 + i);\n\t\t\t\tif (ch == 0xff)\n\t\t\t\t\tbreak;\n\t\t\t\tstate->card->cis1_info_buf[i] = ch;\n\t\t\t\tif (ch == 0) {\n\t\t\t\t\tstate->card->cis1_info[count] =\n\t\t\t\t\t    state->card->cis1_info_buf + start;\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDPRINTF((\"CISTPL_VERS_1\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_MANFID:\n\t\tif (tuple->length < 4) {\n\t\t\tDPRINTF((\"CISTPL_MANFID too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t}\n\t\tstate->card->manufacturer = pcmcia_tuple_read_2(tuple, 0);\n\t\tstate->card->product = pcmcia_tuple_read_2(tuple, 2);\n\t\tDPRINTF((\"CISTPL_MANFID\\n\"));\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_FUNCID:\n\t\tif (tuple->length < 1) {\n\t\t\tDPRINTF((\"CISTPL_FUNCID too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * As far as I understand this, manufacturers do multifunction\n\t\t * cards in various ways.  Sadly enough I do not have the\n\t\t * PC-Card standard (donate!) so I can only guess what can\n\t\t * be done.\n\t\t * The original code implies FUNCID nodes are above CONFIG\n\t\t * nodes in the CIS tree, however Xircom does it the other\n\t\t * way round, which of course makes things a bit hard.\n\t\t * --niklas@openbsd.org\n\t\t */\n\t\tif (state->pf) {\n\t\t\tif (state->pf->function == PCMCIA_FUNCTION_UNSPEC) {\n\t\t\t\t/*\n\t\t\t\t * This looks like a opportunistic function\n\t\t\t\t * created by a CONFIG tuple.  Just keep it.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * A function is being defined, end it.\n\t\t\t\t */\n\t\t\t\tstate->pf = NULL;\n\t\t\t}\n\t\t}\n\t\tif (state->pf == NULL) {\n\t\t\tstate->pf = malloc(sizeof(*state->pf), M_DEVBUF,\n\t\t\t    M_NOWAIT);\n\t\t\tbzero(state->pf, sizeof(*state->pf));\n\t\t\tstate->pf->number = state->count++;\n\t\t\tstate->pf->last_config_index = -1;\n\t\t\tSIMPLEQ_INIT(&state->pf->cfe_head);\n\n\t\t\tSIMPLEQ_INSERT_TAIL(&state->card->pf_head, state->pf,\n\t\t\t    pf_list);\n\t\t}\n\t\tstate->pf->function = pcmcia_tuple_read_1(tuple, 0);\n\n\t\tDPRINTF((\"CISTPL_FUNCID\\n\"));\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_CONFIG:\n\t\tif (tuple->length < 3) {\n\t\t\tDPRINTF((\"CISTPL_CONFIG too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t} {\n\t\t\tu_int reg, rasz, rmsz, rfsz;\n\t\t\tint i;\n\n\t\t\treg = pcmcia_tuple_read_1(tuple, 0);\n\t\t\trasz = 1 + ((reg & PCMCIA_TPCC_RASZ_MASK) >>\n\t\t\t    PCMCIA_TPCC_RASZ_SHIFT);\n\t\t\trmsz = 1 + ((reg & PCMCIA_TPCC_RMSZ_MASK) >>\n\t\t\t    PCMCIA_TPCC_RMSZ_SHIFT);\n\t\t\trfsz = ((reg & PCMCIA_TPCC_RFSZ_MASK) >>\n\t\t\t    PCMCIA_TPCC_RFSZ_SHIFT);\n\n\t\t\tif (tuple->length < (rasz + rmsz + rfsz)) {\n\t\t\t\tDPRINTF((\"CISTPL_CONFIG (%d,%d,%d) too \"\n\t\t\t\t    \"short %d\\n\", rasz, rmsz, rfsz,\n\t\t\t\t    tuple->length));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (state->pf == NULL) {\n\t\t\t\tstate->pf = malloc(sizeof(*state->pf),\n\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\t\t\tbzero(state->pf, sizeof(*state->pf));\n\t\t\t\tstate->pf->number = state->count++;\n\t\t\t\tstate->pf->last_config_index = -1;\n\t\t\t\tSIMPLEQ_INIT(&state->pf->cfe_head);\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&state->card->pf_head,\n\t\t\t\t    state->pf, pf_list);\n\n\t\t\t\tstate->pf->function = PCMCIA_FUNCTION_UNSPEC;\n\t\t\t}\n\t\t\tstate->pf->last_config_index =\n\t\t\t    pcmcia_tuple_read_1(tuple, 1);\n\n\t\t\tstate->pf->ccr_base = 0;\n\t\t\tfor (i = 0; i < rasz; i++)\n\t\t\t\tstate->pf->ccr_base |=\n\t\t\t\t    ((pcmcia_tuple_read_1(tuple, 2 + i)) <<\n\t\t\t\t    (i * 8));\n\n\t\t\tstate->pf->ccr_mask = 0;\n\t\t\tfor (i = 0; i < rmsz; i++)\n\t\t\t\tstate->pf->ccr_mask |=\n\t\t\t\t    ((pcmcia_tuple_read_1(tuple,\n\t\t\t\t    2 + rasz + i)) << (i * 8));\n\n\t\t\t/* skip the reserved area and subtuples */\n\n\t\t\t/* reset the default cfe for each cfe list */\n\t\t\tstate->temp_cfe = init_cfe;\n\t\t\tstate->default_cfe = &state->temp_cfe;\n\t\t}\n\t\tDPRINTF((\"CISTPL_CONFIG\\n\"));\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_CFTABLE_ENTRY:\n\t\t{\n\t\t\tint idx, i, j;\n\t\t\tu_int reg, reg2;\n\t\t\tu_int intface, def, num;\n\t\t\tu_int power, timing, iospace, irq, memspace, misc;\n\t\t\tstruct pcmcia_config_entry *cfe;\n\n\t\t\tidx = 0;\n\n\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\tidx++;\n\t\t\tintface = reg & PCMCIA_TPCE_INDX_INTFACE;\n\t\t\tdef = reg & PCMCIA_TPCE_INDX_DEFAULT;\n\t\t\tnum = reg & PCMCIA_TPCE_INDX_NUM_MASK;\n\n\t\t\t/*\n\t\t\t * this is a little messy.  Some cards have only a\n\t\t\t * cfentry with the default bit set.  So, as we go\n\t\t\t * through the list, we add new indexes to the queue,\n\t\t\t * and keep a pointer to the last one with the\n\t\t\t * default bit set.  if we see a record with the same\n\t\t\t * index, as the default, we stash the default and\n\t\t\t * replace the queue entry. otherwise, we just add\n\t\t\t * new entries to the queue, pointing the default ptr\n\t\t\t * at them if the default bit is set.  if we get to\n\t\t\t * the end with the default pointer pointing at a\n\t\t\t * record which hasn't had a matching index, that's\n\t\t\t * ok; it just becomes a cfentry like any other.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * if the index in the cis differs from the default\n\t\t\t * cis, create new entry in the queue and start it\n\t\t\t * with the current default\n\t\t\t */\n\t\t\tif (num != state->default_cfe->number) {\n\t\t\t\tcfe = (struct pcmcia_config_entry *)\n\t\t\t\t    malloc(sizeof(*cfe), M_DEVBUF, M_NOWAIT);\n\n\t\t\t\t*cfe = *state->default_cfe;\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&state->pf->cfe_head,\n\t\t\t\t    cfe, cfe_list);\n\n\t\t\t\tcfe->number = num;\n\n\t\t\t\t/*\n\t\t\t\t * if the default bit is set in the cis, then\n\t\t\t\t * point the new default at whatever is being\n\t\t\t\t * filled in\n\t\t\t\t */\n\t\t\t\tif (def)\n\t\t\t\t\tstate->default_cfe = cfe;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * the cis index matches the default index,\n\t\t\t\t * fill in the default cfentry.  It is\n\t\t\t\t * assumed that the cfdefault index is in the\n\t\t\t\t * queue.  For it to be otherwise, the cis\n\t\t\t\t * index would have to be -1 (initial\n\t\t\t\t * condition) which is not possible, or there\n\t\t\t\t * would have to be a preceding cis entry\n\t\t\t\t * which had the same cis index and had the\n\t\t\t\t * default bit unset. Neither condition\n\t\t\t\t * should happen.  If it does, this cfentry\n\t\t\t\t * is lost (written into temp space), which\n\t\t\t\t * is an acceptable failure mode.\n\t\t\t\t */\n\n\t\t\t\tcfe = state->default_cfe;\n\n\t\t\t\t/*\n\t\t\t\t * if the cis entry does not have the default\n\t\t\t\t * bit set, copy the default out of the way\n\t\t\t\t * first.\n\t\t\t\t */\n\t\t\t\tif (!def) {\n\t\t\t\t\tstate->temp_cfe = *state->default_cfe;\n\t\t\t\t\tstate->default_cfe = &state->temp_cfe;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (intface) {\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_MWAIT)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_MWAIT_REQUIRED;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_RDYBSY)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_RDYBSY_ACTIVE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_WP)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_WP_ACTIVE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_BVD)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_BVD_ACTIVE;\n\t\t\t\tcfe->iftype = reg & PCMCIA_TPCE_IF_IFTYPE;\n\t\t\t}\n\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\tidx++;\n\n\t\t\tpower = reg & PCMCIA_TPCE_FS_POWER_MASK;\n\t\t\ttiming = reg & PCMCIA_TPCE_FS_TIMING;\n\t\t\tiospace = reg & PCMCIA_TPCE_FS_IOSPACE;\n\t\t\tirq = reg & PCMCIA_TPCE_FS_IRQ;\n\t\t\tmemspace = reg & PCMCIA_TPCE_FS_MEMSPACE_MASK;\n\t\t\tmisc = reg & PCMCIA_TPCE_FS_MISC;\n\n\t\t\tif (power) {\n\t\t\t\t/* skip over power, don't save */\n\t\t\t\t/* for each parameter selection byte */\n\t\t\t\tfor (i = 0; i < power; i++) {\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\t\t\t\t\t/* for each bit */\n\t\t\t\t\tfor (j = 0; j < 7; j++) {\n\t\t\t\t\t\t/* if the bit is set */\n\t\t\t\t\t\tif ((reg >> j) & 0x01) {\n\t\t\t\t\t\t\t/* skip over bytes */\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\treg2 = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * until\n\t\t\t\t\t\t\t\t * non-extensi\n\t\t\t\t\t\t\t\t * on byte\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t} while (reg2 & 0x80);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (timing) {\n\t\t\t\t/* skip over timing, don't save */\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif ((reg & PCMCIA_TPCE_TD_RESERVED_MASK) !=\n\t\t\t\t    PCMCIA_TPCE_TD_RESERVED_MASK)\n\t\t\t\t\tidx++;\n\t\t\t\tif ((reg & PCMCIA_TPCE_TD_RDYBSY_MASK) !=\n\t\t\t\t    PCMCIA_TPCE_TD_RDYBSY_MASK)\n\t\t\t\t\tidx++;\n\t\t\t\tif ((reg & PCMCIA_TPCE_TD_WAIT_MASK) !=\n\t\t\t\t    PCMCIA_TPCE_TD_WAIT_MASK)\n\t\t\t\t\tidx++;\n\t\t\t}\n\t\t\tif (iospace) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_IO\\n\"));\n\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IO_BUSWIDTH_8BIT)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IO8;\n\t\t\t\tif (reg & PCMCIA_TPCE_IO_BUSWIDTH_16BIT)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IO16;\n\t\t\t\tcfe->iomask =\n\t\t\t\t    reg & PCMCIA_TPCE_IO_IOADDRLINES_MASK;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IO_HASRANGE) {\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\n\t\t\t\t\tcfe->num_iospace = 1 + (reg &\n\t\t\t\t\t    PCMCIA_TPCE_IO_RANGE_COUNT);\n\n\t\t\t\t\tif (cfe->num_iospace >\n\t\t\t\t\t    (sizeof(cfe->iospace) /\n\t\t\t\t\t     sizeof(cfe->iospace[0]))) {\n\t\t\t\t\t\tDPRINTF((\"too many io \"\n\t\t\t\t\t\t    \"spaces %d\",\n\t\t\t\t\t\t    cfe->num_iospace));\n\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < cfe->num_iospace; i++) {\n\t\t\t\t\t\tswitch (reg & PCMCIA_TPCE_IO_RANGE_ADDRSIZE_MASK) {\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_ADDRSIZE_ONE:\n\t\t\t\t\t\t\tcfe->iospace[i].start =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_ADDRSIZE_TWO:\n\t\t\t\t\t\t\tcfe->iospace[i].start =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_ADDRSIZE_FOUR:\n\t\t\t\t\t\t\tcfe->iospace[i].start =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_4(tuple, idx);\n\t\t\t\t\t\t\tidx += 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (reg &\n\t\t\t\t\t\t\tPCMCIA_TPCE_IO_RANGE_LENGTHSIZE_MASK) {\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_ONE:\n\t\t\t\t\t\t\tcfe->iospace[i].length =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_TWO:\n\t\t\t\t\t\t\tcfe->iospace[i].length =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_FOUR:\n\t\t\t\t\t\t\tcfe->iospace[i].length =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_4(tuple, idx);\n\t\t\t\t\t\t\tidx += 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfe->iospace[i].length++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcfe->num_iospace = 1;\n\t\t\t\t\tcfe->iospace[0].start = 0;\n\t\t\t\t\tcfe->iospace[0].length =\n\t\t\t\t\t    (1 << cfe->iomask);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (irq) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_IR\\n\"));\n\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_SHARE)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IRQSHARE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_PULSE)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IRQPULSE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_LEVEL)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IRQLEVEL;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_HASMASK) {\n\t\t\t\t\t/*\n\t\t\t\t\t * it's legal to ignore the\n\t\t\t\t\t * special-interrupt bits, so I will\n\t\t\t\t\t */\n\n\t\t\t\t\tcfe->irqmask =\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t} else {\n\t\t\t\t\tcfe->irqmask =\n\t\t\t\t\t    (1 << (reg & PCMCIA_TPCE_IR_IRQ));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (memspace) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_MS\\n\"));\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\tif (memspace == PCMCIA_TPCE_FS_MEMSPACE_NONE) {\n\t\t\t\t\tcfe->num_memspace = 0;\n\t\t\t\t} else if (memspace == PCMCIA_TPCE_FS_MEMSPACE_LENGTH) {\n\t\t\t\t\tcfe->num_memspace = 1;\n\t\t\t\t\tcfe->memspace[0].length = 256 *\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tcfe->memspace[0].cardaddr = 0;\n\t\t\t\t\tcfe->memspace[0].hostaddr = 0;\n\t\t\t\t} else if (memspace ==\n\t\t\t\t    PCMCIA_TPCE_FS_MEMSPACE_LENGTHADDR) {\n\t\t\t\t\tcfe->num_memspace = 1;\n\t\t\t\t\tcfe->memspace[0].length = 256 *\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tcfe->memspace[0].cardaddr = 256 *\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tcfe->memspace[0].hostaddr = cfe->memspace[0].cardaddr;\n\t\t\t\t} else {\n\t\t\t\t\tint lengthsize;\n\t\t\t\t\tint cardaddrsize;\n\t\t\t\t\tint hostaddrsize;\n\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\n\t\t\t\t\tcfe->num_memspace = reg &\n\t\t\t\t\t    PCMCIA_TPCE_MS_COUNT;\n\n\t\t\t\t\tif (cfe->num_memspace >\n\t\t\t\t\t    (sizeof(cfe->memspace) /\n\t\t\t\t\t     sizeof(cfe->memspace[0]))) {\n\t\t\t\t\t\tDPRINTF((\"too many mem \"\n\t\t\t\t\t\t    \"spaces %d\",\n\t\t\t\t\t\t    cfe->num_memspace));\n\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlengthsize =\n\t\t\t\t\t\t((reg & PCMCIA_TPCE_MS_LENGTH_SIZE_MASK) >>\n\t\t\t\t\t\t PCMCIA_TPCE_MS_LENGTH_SIZE_SHIFT);\n\t\t\t\t\tcardaddrsize =\n\t\t\t\t\t\t((reg & PCMCIA_TPCE_MS_CARDADDR_SIZE_MASK) >>\n\t\t\t\t\t\t PCMCIA_TPCE_MS_CARDADDR_SIZE_SHIFT);\n\t\t\t\t\thostaddrsize =\n\t\t\t\t\t\t(reg & PCMCIA_TPCE_MS_HOSTADDR) ? cardaddrsize : 0;\n\n\t\t\t\t\tif (lengthsize == 0) {\n\t\t\t\t\t\tDPRINTF((\"cfe memspace \"\n\t\t\t\t\t\t    \"lengthsize == 0\"));\n\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < cfe->num_memspace; i++) {\n\t\t\t\t\t\tif (lengthsize) {\n\t\t\t\t\t\t\tcfe->memspace[i].length =\n\t\t\t\t\t\t\t\t256 * pcmcia_tuple_read_n(tuple, lengthsize,\n\t\t\t\t\t\t\t\t       idx);\n\t\t\t\t\t\t\tidx += lengthsize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfe->memspace[i].length = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cfe->memspace[i].length == 0) {\n\t\t\t\t\t\t\tDPRINTF((\"cfe->memspace[%d].length == 0\",\n\t\t\t\t\t\t\t\t i));\n\t\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cardaddrsize) {\n\t\t\t\t\t\t\tcfe->memspace[i].cardaddr =\n\t\t\t\t\t\t\t\t256 * pcmcia_tuple_read_n(tuple, cardaddrsize,\n\t\t\t\t\t\t\t\t       idx);\n\t\t\t\t\t\t\tidx += cardaddrsize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfe->memspace[i].cardaddr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hostaddrsize) {\n\t\t\t\t\t\t\tcfe->memspace[i].hostaddr =\n\t\t\t\t\t\t\t\t256 * pcmcia_tuple_read_n(tuple, hostaddrsize,\n\t\t\t\t\t\t\t\t       idx);\n\t\t\t\t\t\t\tidx += hostaddrsize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfe->memspace[i].hostaddr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (misc) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_MI\\n\"));\n\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_MI_PWRDOWN)\n\t\t\t\t\tcfe->flags = PCMCIA_CFE_POWERDOWN;\n\t\t\t\tif (reg & PCMCIA_TPCE_MI_READONLY)\n\t\t\t\t\tcfe->flags = PCMCIA_CFE_READONLY;\n\t\t\t\tif (reg & PCMCIA_TPCE_MI_AUDIO)\n\t\t\t\t\tcfe->flags = PCMCIA_CFE_AUDIO;\n\t\t\t\tcfe->maxtwins = reg & PCMCIA_TPCE_MI_MAXTWINS;\n\n\t\t\t\twhile (reg & PCMCIA_TPCE_MI_EXT) {\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* skip all the subtuples */\n\t\t}\n\n\tabort_cfe:\n\t\tDPRINTF((\"CISTPL_CFTABLE_ENTRY\\n\"));\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF((\"unhandled CISTPL %x\\n\", tuple->code));\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcmcia_parse_cis_tuple"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"unhandled CISTPL %x\\n\", tuple->code)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_CFTABLE_ENTRY\\n\")"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ran out of space before TPCE_MI\\n\")"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_n",
          "args": [
            "tuple",
            "hostaddrsize",
            "idx"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_n",
          "args": [
            "tuple",
            "cardaddrsize",
            "idx"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cfe->memspace[%d].length == 0\",\n\t\t\t\t\t\t\t\t i)"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_n",
          "args": [
            "tuple",
            "lengthsize",
            "idx"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cfe memspace \"\n\t\t\t\t\t\t    \"lengthsize == 0\")"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"too many mem \"\n\t\t\t\t\t\t    \"spaces %d\",\n\t\t\t\t\t\t    cfe->num_memspace)"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ran out of space before TPCE_MS\\n\")"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ran out of space before TPCE_IR\\n\")"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_4",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_4",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"too many io \"\n\t\t\t\t\t\t    \"spaces %d\",\n\t\t\t\t\t\t    cfe->num_iospace)"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ran out of space before TPCE_IO\\n\")"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&state->pf->cfe_head",
            "cfe",
            "cfe_list"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*cfe)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "idx"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_CONFIG\\n\")"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "2 + rasz + i"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "2 + i"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "1"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&state->card->pf_head",
            "state->pf",
            "pf_list"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&state->pf->cfe_head"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "state->pf",
            "sizeof(*state->pf)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_CONFIG (%d,%d,%d) too \"\n\t\t\t\t    \"short %d\\n\", rasz, rmsz, rfsz,\n\t\t\t\t    tuple->length)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "0"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_CONFIG too short %d\\n\",\n\t\t\t    tuple->length)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_FUNCID\\n\")"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "0"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&state->card->pf_head",
            "state->pf",
            "pf_list"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&state->pf->cfe_head"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "state->pf",
            "sizeof(*state->pf)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_FUNCID too short %d\\n\",\n\t\t\t    tuple->length)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_MANFID\\n\")"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "2"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "tuple",
            "0"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_MANFID too short %d\\n\",\n\t\t\t    tuple->length)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_VERS_1\\n\")"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "2 + i"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "1"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "0"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_VERS_1 too short %d\\n\",\n\t\t\t    tuple->length)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"reserved\")"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ext\")"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"100ns\")"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"150ns\")"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"200ns\")"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"250ns\")"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"null\")"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" speed=\")"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"reserved\")"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"extend\")"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"funcspec\")"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"dram\")"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sram\")"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"flash\")"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eeprom\")"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eprom\")"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"otprom\")"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"rom\")"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"null\")"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_DEVICE%s type=\",\n\t\t\t(tuple->code == PCMCIA_CISTPL_DEVICE) ? \"\" : \"_A\")"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "0"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&state->card->pf_head"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pf",
            "M_DEVBUF"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ray_free_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2156-2172",
          "snippet": "u_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "u_int8_t ray_free_ccs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nu_int8_t ray_free_ccs;\n\nu_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_parse_cis_tuple;\n\nint\npcmcia_parse_cis_tuple(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\t/* most of these are educated guesses */\n\tstatic struct pcmcia_config_entry init_cfe = {\n\t\t-1, PCMCIA_CFE_RDYBSY_ACTIVE | PCMCIA_CFE_WP_ACTIVE |\n\t\tPCMCIA_CFE_BVD_ACTIVE, PCMCIA_IFTYPE_MEMORY,\n\t};\n\n\tstruct cis_state *state = arg;\n\n\tswitch (tuple->code) {\n\tcase PCMCIA_CISTPL_END:\n\t\t/*\n\t\t * If we've seen a LONGLINK_MFC, and this is the first\n\t\t * END after it, reset the function list.  \n\t\t *\n\t\t * XXX This might also be the right place to start a\n\t\t * new function, but that assumes that a function\n\t\t * definition never crosses any longlink, and I'm not\n\t\t * sure about that.  This is probably safe for MFC\n\t\t * cards, but what we have now isn't broken, so I'd\n\t\t * rather not change it.\n\t\t */\n\t\tif (state->gotmfc == 1) {\n\t\t\tstruct pcmcia_function *pf, *pfnext;\n\n\t\t\tfor (pf = state->card->pf_head.sqh_first; pf != NULL;\n\t\t\t    pf = pfnext) {\n\t\t\t\tpfnext = pf->pf_list.sqe_next;\n\t\t\t\tfree(pf, M_DEVBUF);\n\t\t\t}\n\n\t\t\tSIMPLEQ_INIT(&state->card->pf_head);\n\n\t\t\tstate->count = 0;\n\t\t\tstate->gotmfc = 2;\n\t\t\tstate->pf = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t/*\n\t\t * This tuple's structure was dealt with in scan_cis.  here,\n\t\t * record the fact that the MFC tuple was seen, so that\n\t\t * functions declared before the MFC link can be cleaned\n\t\t * up.\n\t\t */\n\t\tstate->gotmfc = 1;\n\t\tbreak;\n\n#ifdef PCMCIACISDEBUG\n\tcase PCMCIA_CISTPL_DEVICE:\n\tcase PCMCIA_CISTPL_DEVICE_A:\n\t\t{\n\t\t\tu_int reg, dtype, dspeed;\n\n\t\t\treg = pcmcia_tuple_read_1(tuple, 0);\n\t\t\tdtype = reg & PCMCIA_DTYPE_MASK;\n\t\t\tdspeed = reg & PCMCIA_DSPEED_MASK;\n\n\t\t\tDPRINTF((\"CISTPL_DEVICE%s type=\",\n\t\t\t(tuple->code == PCMCIA_CISTPL_DEVICE) ? \"\" : \"_A\"));\n\t\t\tswitch (dtype) {\n\t\t\tcase PCMCIA_DTYPE_NULL:\n\t\t\t\tDPRINTF((\"null\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_ROM:\n\t\t\t\tDPRINTF((\"rom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_OTPROM:\n\t\t\t\tDPRINTF((\"otprom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_EPROM:\n\t\t\t\tDPRINTF((\"eprom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_EEPROM:\n\t\t\t\tDPRINTF((\"eeprom\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_FLASH:\n\t\t\t\tDPRINTF((\"flash\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_SRAM:\n\t\t\t\tDPRINTF((\"sram\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_DRAM:\n\t\t\t\tDPRINTF((\"dram\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_FUNCSPEC:\n\t\t\t\tDPRINTF((\"funcspec\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DTYPE_EXTEND:\n\t\t\t\tDPRINTF((\"extend\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDPRINTF((\"reserved\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTF((\" speed=\"));\n\t\t\tswitch (dspeed) {\n\t\t\tcase PCMCIA_DSPEED_NULL:\n\t\t\t\tDPRINTF((\"null\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_250NS:\n\t\t\t\tDPRINTF((\"250ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_200NS:\n\t\t\t\tDPRINTF((\"200ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_150NS:\n\t\t\t\tDPRINTF((\"150ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_100NS:\n\t\t\t\tDPRINTF((\"100ns\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_DSPEED_EXT:\n\t\t\t\tDPRINTF((\"ext\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDPRINTF((\"reserved\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t\tbreak;\n#endif\n\n\tcase PCMCIA_CISTPL_VERS_1:\n\t\tif (tuple->length < 6) {\n\t\t\tDPRINTF((\"CISTPL_VERS_1 too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t} {\n\t\t\tint start, i, ch, count;\n\n\t\t\tstate->card->cis1_major = pcmcia_tuple_read_1(tuple, 0);\n\t\t\tstate->card->cis1_minor = pcmcia_tuple_read_1(tuple, 1);\n\n\t\t\tfor (count = 0, start = 0, i = 0;\n\t\t\t    (count < 4) && ((i + 4) < 256); i++) {\n\t\t\t\tch = pcmcia_tuple_read_1(tuple, 2 + i);\n\t\t\t\tif (ch == 0xff)\n\t\t\t\t\tbreak;\n\t\t\t\tstate->card->cis1_info_buf[i] = ch;\n\t\t\t\tif (ch == 0) {\n\t\t\t\t\tstate->card->cis1_info[count] =\n\t\t\t\t\t    state->card->cis1_info_buf + start;\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDPRINTF((\"CISTPL_VERS_1\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_MANFID:\n\t\tif (tuple->length < 4) {\n\t\t\tDPRINTF((\"CISTPL_MANFID too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t}\n\t\tstate->card->manufacturer = pcmcia_tuple_read_2(tuple, 0);\n\t\tstate->card->product = pcmcia_tuple_read_2(tuple, 2);\n\t\tDPRINTF((\"CISTPL_MANFID\\n\"));\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_FUNCID:\n\t\tif (tuple->length < 1) {\n\t\t\tDPRINTF((\"CISTPL_FUNCID too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * As far as I understand this, manufacturers do multifunction\n\t\t * cards in various ways.  Sadly enough I do not have the\n\t\t * PC-Card standard (donate!) so I can only guess what can\n\t\t * be done.\n\t\t * The original code implies FUNCID nodes are above CONFIG\n\t\t * nodes in the CIS tree, however Xircom does it the other\n\t\t * way round, which of course makes things a bit hard.\n\t\t * --niklas@openbsd.org\n\t\t */\n\t\tif (state->pf) {\n\t\t\tif (state->pf->function == PCMCIA_FUNCTION_UNSPEC) {\n\t\t\t\t/*\n\t\t\t\t * This looks like a opportunistic function\n\t\t\t\t * created by a CONFIG tuple.  Just keep it.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * A function is being defined, end it.\n\t\t\t\t */\n\t\t\t\tstate->pf = NULL;\n\t\t\t}\n\t\t}\n\t\tif (state->pf == NULL) {\n\t\t\tstate->pf = malloc(sizeof(*state->pf), M_DEVBUF,\n\t\t\t    M_NOWAIT);\n\t\t\tbzero(state->pf, sizeof(*state->pf));\n\t\t\tstate->pf->number = state->count++;\n\t\t\tstate->pf->last_config_index = -1;\n\t\t\tSIMPLEQ_INIT(&state->pf->cfe_head);\n\n\t\t\tSIMPLEQ_INSERT_TAIL(&state->card->pf_head, state->pf,\n\t\t\t    pf_list);\n\t\t}\n\t\tstate->pf->function = pcmcia_tuple_read_1(tuple, 0);\n\n\t\tDPRINTF((\"CISTPL_FUNCID\\n\"));\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_CONFIG:\n\t\tif (tuple->length < 3) {\n\t\t\tDPRINTF((\"CISTPL_CONFIG too short %d\\n\",\n\t\t\t    tuple->length));\n\t\t\tbreak;\n\t\t} {\n\t\t\tu_int reg, rasz, rmsz, rfsz;\n\t\t\tint i;\n\n\t\t\treg = pcmcia_tuple_read_1(tuple, 0);\n\t\t\trasz = 1 + ((reg & PCMCIA_TPCC_RASZ_MASK) >>\n\t\t\t    PCMCIA_TPCC_RASZ_SHIFT);\n\t\t\trmsz = 1 + ((reg & PCMCIA_TPCC_RMSZ_MASK) >>\n\t\t\t    PCMCIA_TPCC_RMSZ_SHIFT);\n\t\t\trfsz = ((reg & PCMCIA_TPCC_RFSZ_MASK) >>\n\t\t\t    PCMCIA_TPCC_RFSZ_SHIFT);\n\n\t\t\tif (tuple->length < (rasz + rmsz + rfsz)) {\n\t\t\t\tDPRINTF((\"CISTPL_CONFIG (%d,%d,%d) too \"\n\t\t\t\t    \"short %d\\n\", rasz, rmsz, rfsz,\n\t\t\t\t    tuple->length));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (state->pf == NULL) {\n\t\t\t\tstate->pf = malloc(sizeof(*state->pf),\n\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\t\t\tbzero(state->pf, sizeof(*state->pf));\n\t\t\t\tstate->pf->number = state->count++;\n\t\t\t\tstate->pf->last_config_index = -1;\n\t\t\t\tSIMPLEQ_INIT(&state->pf->cfe_head);\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&state->card->pf_head,\n\t\t\t\t    state->pf, pf_list);\n\n\t\t\t\tstate->pf->function = PCMCIA_FUNCTION_UNSPEC;\n\t\t\t}\n\t\t\tstate->pf->last_config_index =\n\t\t\t    pcmcia_tuple_read_1(tuple, 1);\n\n\t\t\tstate->pf->ccr_base = 0;\n\t\t\tfor (i = 0; i < rasz; i++)\n\t\t\t\tstate->pf->ccr_base |=\n\t\t\t\t    ((pcmcia_tuple_read_1(tuple, 2 + i)) <<\n\t\t\t\t    (i * 8));\n\n\t\t\tstate->pf->ccr_mask = 0;\n\t\t\tfor (i = 0; i < rmsz; i++)\n\t\t\t\tstate->pf->ccr_mask |=\n\t\t\t\t    ((pcmcia_tuple_read_1(tuple,\n\t\t\t\t    2 + rasz + i)) << (i * 8));\n\n\t\t\t/* skip the reserved area and subtuples */\n\n\t\t\t/* reset the default cfe for each cfe list */\n\t\t\tstate->temp_cfe = init_cfe;\n\t\t\tstate->default_cfe = &state->temp_cfe;\n\t\t}\n\t\tDPRINTF((\"CISTPL_CONFIG\\n\"));\n\t\tbreak;\n\n\tcase PCMCIA_CISTPL_CFTABLE_ENTRY:\n\t\t{\n\t\t\tint idx, i, j;\n\t\t\tu_int reg, reg2;\n\t\t\tu_int intface, def, num;\n\t\t\tu_int power, timing, iospace, irq, memspace, misc;\n\t\t\tstruct pcmcia_config_entry *cfe;\n\n\t\t\tidx = 0;\n\n\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\tidx++;\n\t\t\tintface = reg & PCMCIA_TPCE_INDX_INTFACE;\n\t\t\tdef = reg & PCMCIA_TPCE_INDX_DEFAULT;\n\t\t\tnum = reg & PCMCIA_TPCE_INDX_NUM_MASK;\n\n\t\t\t/*\n\t\t\t * this is a little messy.  Some cards have only a\n\t\t\t * cfentry with the default bit set.  So, as we go\n\t\t\t * through the list, we add new indexes to the queue,\n\t\t\t * and keep a pointer to the last one with the\n\t\t\t * default bit set.  if we see a record with the same\n\t\t\t * index, as the default, we stash the default and\n\t\t\t * replace the queue entry. otherwise, we just add\n\t\t\t * new entries to the queue, pointing the default ptr\n\t\t\t * at them if the default bit is set.  if we get to\n\t\t\t * the end with the default pointer pointing at a\n\t\t\t * record which hasn't had a matching index, that's\n\t\t\t * ok; it just becomes a cfentry like any other.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * if the index in the cis differs from the default\n\t\t\t * cis, create new entry in the queue and start it\n\t\t\t * with the current default\n\t\t\t */\n\t\t\tif (num != state->default_cfe->number) {\n\t\t\t\tcfe = (struct pcmcia_config_entry *)\n\t\t\t\t    malloc(sizeof(*cfe), M_DEVBUF, M_NOWAIT);\n\n\t\t\t\t*cfe = *state->default_cfe;\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&state->pf->cfe_head,\n\t\t\t\t    cfe, cfe_list);\n\n\t\t\t\tcfe->number = num;\n\n\t\t\t\t/*\n\t\t\t\t * if the default bit is set in the cis, then\n\t\t\t\t * point the new default at whatever is being\n\t\t\t\t * filled in\n\t\t\t\t */\n\t\t\t\tif (def)\n\t\t\t\t\tstate->default_cfe = cfe;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * the cis index matches the default index,\n\t\t\t\t * fill in the default cfentry.  It is\n\t\t\t\t * assumed that the cfdefault index is in the\n\t\t\t\t * queue.  For it to be otherwise, the cis\n\t\t\t\t * index would have to be -1 (initial\n\t\t\t\t * condition) which is not possible, or there\n\t\t\t\t * would have to be a preceding cis entry\n\t\t\t\t * which had the same cis index and had the\n\t\t\t\t * default bit unset. Neither condition\n\t\t\t\t * should happen.  If it does, this cfentry\n\t\t\t\t * is lost (written into temp space), which\n\t\t\t\t * is an acceptable failure mode.\n\t\t\t\t */\n\n\t\t\t\tcfe = state->default_cfe;\n\n\t\t\t\t/*\n\t\t\t\t * if the cis entry does not have the default\n\t\t\t\t * bit set, copy the default out of the way\n\t\t\t\t * first.\n\t\t\t\t */\n\t\t\t\tif (!def) {\n\t\t\t\t\tstate->temp_cfe = *state->default_cfe;\n\t\t\t\t\tstate->default_cfe = &state->temp_cfe;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (intface) {\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_MWAIT)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_MWAIT_REQUIRED;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_RDYBSY)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_RDYBSY_ACTIVE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_WP)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_WP_ACTIVE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IF_BVD)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_BVD_ACTIVE;\n\t\t\t\tcfe->iftype = reg & PCMCIA_TPCE_IF_IFTYPE;\n\t\t\t}\n\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\tidx++;\n\n\t\t\tpower = reg & PCMCIA_TPCE_FS_POWER_MASK;\n\t\t\ttiming = reg & PCMCIA_TPCE_FS_TIMING;\n\t\t\tiospace = reg & PCMCIA_TPCE_FS_IOSPACE;\n\t\t\tirq = reg & PCMCIA_TPCE_FS_IRQ;\n\t\t\tmemspace = reg & PCMCIA_TPCE_FS_MEMSPACE_MASK;\n\t\t\tmisc = reg & PCMCIA_TPCE_FS_MISC;\n\n\t\t\tif (power) {\n\t\t\t\t/* skip over power, don't save */\n\t\t\t\t/* for each parameter selection byte */\n\t\t\t\tfor (i = 0; i < power; i++) {\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\t\t\t\t\t/* for each bit */\n\t\t\t\t\tfor (j = 0; j < 7; j++) {\n\t\t\t\t\t\t/* if the bit is set */\n\t\t\t\t\t\tif ((reg >> j) & 0x01) {\n\t\t\t\t\t\t\t/* skip over bytes */\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\treg2 = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * until\n\t\t\t\t\t\t\t\t * non-extensi\n\t\t\t\t\t\t\t\t * on byte\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t} while (reg2 & 0x80);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (timing) {\n\t\t\t\t/* skip over timing, don't save */\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif ((reg & PCMCIA_TPCE_TD_RESERVED_MASK) !=\n\t\t\t\t    PCMCIA_TPCE_TD_RESERVED_MASK)\n\t\t\t\t\tidx++;\n\t\t\t\tif ((reg & PCMCIA_TPCE_TD_RDYBSY_MASK) !=\n\t\t\t\t    PCMCIA_TPCE_TD_RDYBSY_MASK)\n\t\t\t\t\tidx++;\n\t\t\t\tif ((reg & PCMCIA_TPCE_TD_WAIT_MASK) !=\n\t\t\t\t    PCMCIA_TPCE_TD_WAIT_MASK)\n\t\t\t\t\tidx++;\n\t\t\t}\n\t\t\tif (iospace) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_IO\\n\"));\n\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IO_BUSWIDTH_8BIT)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IO8;\n\t\t\t\tif (reg & PCMCIA_TPCE_IO_BUSWIDTH_16BIT)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IO16;\n\t\t\t\tcfe->iomask =\n\t\t\t\t    reg & PCMCIA_TPCE_IO_IOADDRLINES_MASK;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IO_HASRANGE) {\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\n\t\t\t\t\tcfe->num_iospace = 1 + (reg &\n\t\t\t\t\t    PCMCIA_TPCE_IO_RANGE_COUNT);\n\n\t\t\t\t\tif (cfe->num_iospace >\n\t\t\t\t\t    (sizeof(cfe->iospace) /\n\t\t\t\t\t     sizeof(cfe->iospace[0]))) {\n\t\t\t\t\t\tDPRINTF((\"too many io \"\n\t\t\t\t\t\t    \"spaces %d\",\n\t\t\t\t\t\t    cfe->num_iospace));\n\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < cfe->num_iospace; i++) {\n\t\t\t\t\t\tswitch (reg & PCMCIA_TPCE_IO_RANGE_ADDRSIZE_MASK) {\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_ADDRSIZE_ONE:\n\t\t\t\t\t\t\tcfe->iospace[i].start =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_ADDRSIZE_TWO:\n\t\t\t\t\t\t\tcfe->iospace[i].start =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_ADDRSIZE_FOUR:\n\t\t\t\t\t\t\tcfe->iospace[i].start =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_4(tuple, idx);\n\t\t\t\t\t\t\tidx += 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (reg &\n\t\t\t\t\t\t\tPCMCIA_TPCE_IO_RANGE_LENGTHSIZE_MASK) {\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_ONE:\n\t\t\t\t\t\t\tcfe->iospace[i].length =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_TWO:\n\t\t\t\t\t\t\tcfe->iospace[i].length =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_FOUR:\n\t\t\t\t\t\t\tcfe->iospace[i].length =\n\t\t\t\t\t\t\t\tpcmcia_tuple_read_4(tuple, idx);\n\t\t\t\t\t\t\tidx += 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfe->iospace[i].length++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcfe->num_iospace = 1;\n\t\t\t\t\tcfe->iospace[0].start = 0;\n\t\t\t\t\tcfe->iospace[0].length =\n\t\t\t\t\t    (1 << cfe->iomask);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (irq) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_IR\\n\"));\n\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_SHARE)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IRQSHARE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_PULSE)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IRQPULSE;\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_LEVEL)\n\t\t\t\t\tcfe->flags |= PCMCIA_CFE_IRQLEVEL;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_IR_HASMASK) {\n\t\t\t\t\t/*\n\t\t\t\t\t * it's legal to ignore the\n\t\t\t\t\t * special-interrupt bits, so I will\n\t\t\t\t\t */\n\n\t\t\t\t\tcfe->irqmask =\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t} else {\n\t\t\t\t\tcfe->irqmask =\n\t\t\t\t\t    (1 << (reg & PCMCIA_TPCE_IR_IRQ));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (memspace) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_MS\\n\"));\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\tif (memspace == PCMCIA_TPCE_FS_MEMSPACE_NONE) {\n\t\t\t\t\tcfe->num_memspace = 0;\n\t\t\t\t} else if (memspace == PCMCIA_TPCE_FS_MEMSPACE_LENGTH) {\n\t\t\t\t\tcfe->num_memspace = 1;\n\t\t\t\t\tcfe->memspace[0].length = 256 *\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tcfe->memspace[0].cardaddr = 0;\n\t\t\t\t\tcfe->memspace[0].hostaddr = 0;\n\t\t\t\t} else if (memspace ==\n\t\t\t\t    PCMCIA_TPCE_FS_MEMSPACE_LENGTHADDR) {\n\t\t\t\t\tcfe->num_memspace = 1;\n\t\t\t\t\tcfe->memspace[0].length = 256 *\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tcfe->memspace[0].cardaddr = 256 *\n\t\t\t\t\t    pcmcia_tuple_read_2(tuple, idx);\n\t\t\t\t\tidx += 2;\n\t\t\t\t\tcfe->memspace[0].hostaddr = cfe->memspace[0].cardaddr;\n\t\t\t\t} else {\n\t\t\t\t\tint lengthsize;\n\t\t\t\t\tint cardaddrsize;\n\t\t\t\t\tint hostaddrsize;\n\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\n\t\t\t\t\tcfe->num_memspace = reg &\n\t\t\t\t\t    PCMCIA_TPCE_MS_COUNT;\n\n\t\t\t\t\tif (cfe->num_memspace >\n\t\t\t\t\t    (sizeof(cfe->memspace) /\n\t\t\t\t\t     sizeof(cfe->memspace[0]))) {\n\t\t\t\t\t\tDPRINTF((\"too many mem \"\n\t\t\t\t\t\t    \"spaces %d\",\n\t\t\t\t\t\t    cfe->num_memspace));\n\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlengthsize =\n\t\t\t\t\t\t((reg & PCMCIA_TPCE_MS_LENGTH_SIZE_MASK) >>\n\t\t\t\t\t\t PCMCIA_TPCE_MS_LENGTH_SIZE_SHIFT);\n\t\t\t\t\tcardaddrsize =\n\t\t\t\t\t\t((reg & PCMCIA_TPCE_MS_CARDADDR_SIZE_MASK) >>\n\t\t\t\t\t\t PCMCIA_TPCE_MS_CARDADDR_SIZE_SHIFT);\n\t\t\t\t\thostaddrsize =\n\t\t\t\t\t\t(reg & PCMCIA_TPCE_MS_HOSTADDR) ? cardaddrsize : 0;\n\n\t\t\t\t\tif (lengthsize == 0) {\n\t\t\t\t\t\tDPRINTF((\"cfe memspace \"\n\t\t\t\t\t\t    \"lengthsize == 0\"));\n\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < cfe->num_memspace; i++) {\n\t\t\t\t\t\tif (lengthsize) {\n\t\t\t\t\t\t\tcfe->memspace[i].length =\n\t\t\t\t\t\t\t\t256 * pcmcia_tuple_read_n(tuple, lengthsize,\n\t\t\t\t\t\t\t\t       idx);\n\t\t\t\t\t\t\tidx += lengthsize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfe->memspace[i].length = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cfe->memspace[i].length == 0) {\n\t\t\t\t\t\t\tDPRINTF((\"cfe->memspace[%d].length == 0\",\n\t\t\t\t\t\t\t\t i));\n\t\t\t\t\t\t\tstate->card->error++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cardaddrsize) {\n\t\t\t\t\t\t\tcfe->memspace[i].cardaddr =\n\t\t\t\t\t\t\t\t256 * pcmcia_tuple_read_n(tuple, cardaddrsize,\n\t\t\t\t\t\t\t\t       idx);\n\t\t\t\t\t\t\tidx += cardaddrsize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfe->memspace[i].cardaddr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hostaddrsize) {\n\t\t\t\t\t\t\tcfe->memspace[i].hostaddr =\n\t\t\t\t\t\t\t\t256 * pcmcia_tuple_read_n(tuple, hostaddrsize,\n\t\t\t\t\t\t\t\t       idx);\n\t\t\t\t\t\t\tidx += hostaddrsize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcfe->memspace[i].hostaddr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (misc) {\n\t\t\t\tif (tuple->length <= idx) {\n\t\t\t\t\tDPRINTF((\"ran out of space before TPCE_MI\\n\"));\n\n\t\t\t\t\tgoto abort_cfe;\n\t\t\t\t}\n\n\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\tidx++;\n\n\t\t\t\tif (reg & PCMCIA_TPCE_MI_PWRDOWN)\n\t\t\t\t\tcfe->flags = PCMCIA_CFE_POWERDOWN;\n\t\t\t\tif (reg & PCMCIA_TPCE_MI_READONLY)\n\t\t\t\t\tcfe->flags = PCMCIA_CFE_READONLY;\n\t\t\t\tif (reg & PCMCIA_TPCE_MI_AUDIO)\n\t\t\t\t\tcfe->flags = PCMCIA_CFE_AUDIO;\n\t\t\t\tcfe->maxtwins = reg & PCMCIA_TPCE_MI_MAXTWINS;\n\n\t\t\t\twhile (reg & PCMCIA_TPCE_MI_EXT) {\n\t\t\t\t\treg = pcmcia_tuple_read_1(tuple, idx);\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* skip all the subtuples */\n\t\t}\n\n\tabort_cfe:\n\t\tDPRINTF((\"CISTPL_CFTABLE_ENTRY\\n\"));\n\t\tbreak;\n\n\tdefault:\n\t\tDPRINTF((\"unhandled CISTPL %x\\n\", tuple->code));\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "pcmcia_print_cis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
    "lines": "437-598",
    "snippet": "void\npcmcia_print_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct pcmcia_card *card = &sc->card;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n\tint i;\n\n\tprintf(\"%s: CIS version \", sc->dev.dv_xname);\n\tif (card->cis1_major == 4) {\n\t\tif (card->cis1_minor == 0)\n\t\t\tprintf(\"PCMCIA 1.0\\n\");\n\t\telse if (card->cis1_minor == 1)\n\t\t\tprintf(\"PCMCIA 2.0 or 2.1\\n\");\n\t} else if (card->cis1_major >= 5)\n\t\tprintf(\"PC Card Standard %d.%d\\n\", card->cis1_major, card->cis1_minor);\n\telse\n\t\tprintf(\"unknown (major=%d, minor=%d)\\n\",\n\t\t    card->cis1_major, card->cis1_minor);\n\n\tprintf(\"%s: CIS info: \", sc->dev.dv_xname);\n\tfor (i = 0; i < 4; i++) {\n\t\tif (card->cis1_info[i] == NULL)\n\t\t\tbreak;\n\t\tif (i)\n\t\t\tprintf(\", \");\n\t\tprintf(\"%s\", card->cis1_info[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tprintf(\"%s: Manufacturer code 0x%x, product 0x%x\\n\",\n\t       sc->dev.dv_xname, card->manufacturer, card->product);\n\n\tfor (pf = card->pf_head.sqh_first; pf != NULL;\n\t    pf = pf->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d: \", sc->dev.dv_xname, pf->number);\n\n\t\tswitch (pf->function) {\n\t\tcase PCMCIA_FUNCTION_UNSPEC:\n\t\t\tprintf(\"unspecified\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MULTIFUNCTION:\n\t\t\tprintf(\"multi-function\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MEMORY:\n\t\t\tprintf(\"memory\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SERIAL:\n\t\t\tprintf(\"serial port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_PARALLEL:\n\t\t\tprintf(\"parallel port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_DISK:\n\t\t\tprintf(\"fixed disk\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_VIDEO:\n\t\t\tprintf(\"video adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_NETWORK:\n\t\t\tprintf(\"network adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_AIMS:\n\t\t\tprintf(\"auto incrementing mass storage\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SCSI:\n\t\t\tprintf(\"SCSI bridge\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SECURITY:\n\t\t\tprintf(\"Security services\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_INSTRUMENT:\n\t\t\tprintf(\"Instrument\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"unknown (%d)\", pf->function);\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\", ccr addr %lx mask %lx\\n\", pf->ccr_base, pf->ccr_mask);\n\n\t\tfor (cfe = pf->cfe_head.sqh_first; cfe != NULL;\n\t\t    cfe = cfe->cfe_list.sqe_next) {\n\t\t\tprintf(\"%s: function %d, config table entry %d: \",\n\t\t\t    sc->dev.dv_xname, pf->number, cfe->number);\n\n\t\t\tswitch (cfe->iftype) {\n\t\t\tcase PCMCIA_IFTYPE_MEMORY:\n\t\t\t\tprintf(\"memory card\");\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_IFTYPE_IO:\n\t\t\t\tprintf(\"I/O card\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"card type unknown\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"; irq mask %x\", cfe->irqmask);\n\n\t\t\tif (cfe->num_iospace) {\n\t\t\t\tprintf(\"; iomask %lx, iospace\", cfe->iomask);\n\n\t\t\t\tfor (i = 0; i < cfe->num_iospace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx\",\n\t\t\t\t\t    cfe->iospace[i].start,\n\t\t\t\t\t    cfe->iospace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->iospace[i].start +\n\t\t\t\t\t      cfe->iospace[i].length - 1);\n\t\t\t}\n\t\t\tif (cfe->num_memspace) {\n\t\t\t\tprintf(\"; memspace\");\n\n\t\t\t\tfor (i = 0; i < cfe->num_memspace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx%s%lx\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr,\n\t\t\t\t\t    cfe->memspace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr +\n\t\t\t\t\t      cfe->memspace[i].length - 1,\n\t\t\t\t\t    cfe->memspace[i].hostaddr ?\n\t\t\t\t\t      \"@\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].hostaddr);\n\t\t\t}\n\t\t\tif (cfe->maxtwins)\n\t\t\t\tprintf(\"; maxtwins %d\", cfe->maxtwins);\n\n\t\t\tprintf(\";\");\n\n\t\t\tif (cfe->flags & PCMCIA_CFE_MWAIT_REQUIRED)\n\t\t\t\tprintf(\" mwait_required\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_RDYBSY_ACTIVE)\n\t\t\t\tprintf(\" rdybsy_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_WP_ACTIVE)\n\t\t\t\tprintf(\" wp_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_BVD_ACTIVE)\n\t\t\t\tprintf(\" bvd_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO8)\n\t\t\t\tprintf(\" io8\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO16)\n\t\t\t\tprintf(\" io16\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQSHARE)\n\t\t\t\tprintf(\" irqshare\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQPULSE)\n\t\t\t\tprintf(\" irqpulse\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQLEVEL)\n\t\t\t\tprintf(\" irqlevel\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_POWERDOWN)\n\t\t\t\tprintf(\" powerdown\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_READONLY)\n\t\t\t\tprintf(\" readonly\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_AUDIO)\n\t\t\t\tprintf(\" audio\");\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\tif (card->error)\n\t\tprintf(\"%s: %d errors found while parsing CIS\\n\",\n\t\t    sc->dev.dv_xname, card->error);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d errors found while parsing CIS\\n\"",
            "sc->dev.dv_xname",
            "card->error"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\npcmcia_print_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct pcmcia_card *card = &sc->card;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n\tint i;\n\n\tprintf(\"%s: CIS version \", sc->dev.dv_xname);\n\tif (card->cis1_major == 4) {\n\t\tif (card->cis1_minor == 0)\n\t\t\tprintf(\"PCMCIA 1.0\\n\");\n\t\telse if (card->cis1_minor == 1)\n\t\t\tprintf(\"PCMCIA 2.0 or 2.1\\n\");\n\t} else if (card->cis1_major >= 5)\n\t\tprintf(\"PC Card Standard %d.%d\\n\", card->cis1_major, card->cis1_minor);\n\telse\n\t\tprintf(\"unknown (major=%d, minor=%d)\\n\",\n\t\t    card->cis1_major, card->cis1_minor);\n\n\tprintf(\"%s: CIS info: \", sc->dev.dv_xname);\n\tfor (i = 0; i < 4; i++) {\n\t\tif (card->cis1_info[i] == NULL)\n\t\t\tbreak;\n\t\tif (i)\n\t\t\tprintf(\", \");\n\t\tprintf(\"%s\", card->cis1_info[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tprintf(\"%s: Manufacturer code 0x%x, product 0x%x\\n\",\n\t       sc->dev.dv_xname, card->manufacturer, card->product);\n\n\tfor (pf = card->pf_head.sqh_first; pf != NULL;\n\t    pf = pf->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d: \", sc->dev.dv_xname, pf->number);\n\n\t\tswitch (pf->function) {\n\t\tcase PCMCIA_FUNCTION_UNSPEC:\n\t\t\tprintf(\"unspecified\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MULTIFUNCTION:\n\t\t\tprintf(\"multi-function\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MEMORY:\n\t\t\tprintf(\"memory\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SERIAL:\n\t\t\tprintf(\"serial port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_PARALLEL:\n\t\t\tprintf(\"parallel port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_DISK:\n\t\t\tprintf(\"fixed disk\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_VIDEO:\n\t\t\tprintf(\"video adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_NETWORK:\n\t\t\tprintf(\"network adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_AIMS:\n\t\t\tprintf(\"auto incrementing mass storage\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SCSI:\n\t\t\tprintf(\"SCSI bridge\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SECURITY:\n\t\t\tprintf(\"Security services\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_INSTRUMENT:\n\t\t\tprintf(\"Instrument\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"unknown (%d)\", pf->function);\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\", ccr addr %lx mask %lx\\n\", pf->ccr_base, pf->ccr_mask);\n\n\t\tfor (cfe = pf->cfe_head.sqh_first; cfe != NULL;\n\t\t    cfe = cfe->cfe_list.sqe_next) {\n\t\t\tprintf(\"%s: function %d, config table entry %d: \",\n\t\t\t    sc->dev.dv_xname, pf->number, cfe->number);\n\n\t\t\tswitch (cfe->iftype) {\n\t\t\tcase PCMCIA_IFTYPE_MEMORY:\n\t\t\t\tprintf(\"memory card\");\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_IFTYPE_IO:\n\t\t\t\tprintf(\"I/O card\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"card type unknown\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"; irq mask %x\", cfe->irqmask);\n\n\t\t\tif (cfe->num_iospace) {\n\t\t\t\tprintf(\"; iomask %lx, iospace\", cfe->iomask);\n\n\t\t\t\tfor (i = 0; i < cfe->num_iospace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx\",\n\t\t\t\t\t    cfe->iospace[i].start,\n\t\t\t\t\t    cfe->iospace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->iospace[i].start +\n\t\t\t\t\t      cfe->iospace[i].length - 1);\n\t\t\t}\n\t\t\tif (cfe->num_memspace) {\n\t\t\t\tprintf(\"; memspace\");\n\n\t\t\t\tfor (i = 0; i < cfe->num_memspace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx%s%lx\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr,\n\t\t\t\t\t    cfe->memspace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr +\n\t\t\t\t\t      cfe->memspace[i].length - 1,\n\t\t\t\t\t    cfe->memspace[i].hostaddr ?\n\t\t\t\t\t      \"@\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].hostaddr);\n\t\t\t}\n\t\t\tif (cfe->maxtwins)\n\t\t\t\tprintf(\"; maxtwins %d\", cfe->maxtwins);\n\n\t\t\tprintf(\";\");\n\n\t\t\tif (cfe->flags & PCMCIA_CFE_MWAIT_REQUIRED)\n\t\t\t\tprintf(\" mwait_required\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_RDYBSY_ACTIVE)\n\t\t\t\tprintf(\" rdybsy_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_WP_ACTIVE)\n\t\t\t\tprintf(\" wp_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_BVD_ACTIVE)\n\t\t\t\tprintf(\" bvd_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO8)\n\t\t\t\tprintf(\" io8\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO16)\n\t\t\t\tprintf(\" io16\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQSHARE)\n\t\t\t\tprintf(\" irqshare\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQPULSE)\n\t\t\t\tprintf(\" irqpulse\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQLEVEL)\n\t\t\t\tprintf(\" irqlevel\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_POWERDOWN)\n\t\t\t\tprintf(\" powerdown\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_READONLY)\n\t\t\t\tprintf(\" readonly\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_AUDIO)\n\t\t\t\tprintf(\" audio\");\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\tif (card->error)\n\t\tprintf(\"%s: %d errors found while parsing CIS\\n\",\n\t\t    sc->dev.dv_xname, card->error);\n}"
  },
  {
    "function_name": "pcmcia_scan_cis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
    "lines": "91-433",
    "snippet": "int\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tPCMCIA_CIS_SIZE\t\t1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_free",
          "args": [
            "pct",
            "pch",
            "&pcmh"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_unmap",
          "args": [
            "pct",
            "pch",
            "window"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2))"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "2"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "1"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "0"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "2"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "1"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "0"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_cis_read_1",
          "args": [
            "&tuple",
            "tuple.ptr + 1"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_cis_read_1",
          "args": [
            "&tuple",
            "tuple.ptr"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_map",
          "args": [
            "pct",
            "pch",
            "mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR",
            "mfc[mfc_index].addr",
            "PCMCIA_CIS_SIZE",
            "&pcmh",
            "&tuple.ptr",
            "&window"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_map",
          "args": [
            "pct",
            "pch",
            "longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR",
            "longlink_addr",
            "PCMCIA_CIS_SIZE",
            "&pcmh",
            "&tuple.ptr",
            "&window"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_unmap",
          "args": [
            "pct",
            "pch",
            "window"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i))"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "i"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_unmap",
          "args": [
            "pct",
            "pch",
            "window"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&tuple",
            "arg"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_4",
          "args": [
            "&tuple",
            "1 + 5 * i + 1"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "1 + 5 * i"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "0"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" ok\\n\")"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\"",
            "sc->dev.dv_xname"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "tuple.memt",
            "tuple.memh",
            "addr + tuple.mult * i"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\")"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "&tuple",
            "4"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "&tuple",
            "2"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_2",
          "args": [
            "&tuple",
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_NO_LINK\\n\")"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_4",
          "args": [
            "&tuple",
            "0"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_cis_read_1",
          "args": [
            "&tuple",
            "tuple.ptr + 1"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_unmap",
          "args": [
            "pct",
            "pch",
            "window"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&tuple",
            "arg"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_END\\n ff\\n\")"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CISTPL_NONE\\n 00\\n\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_cis_read_1",
          "args": [
            "&tuple",
            "tuple.ptr"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cis mem map %x\\n\", (unsigned int) tuple.memh)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_free",
          "args": [
            "pct",
            "pch",
            "&pcmh"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_map",
          "args": [
            "pct",
            "pch",
            "PCMCIA_MEM_ATTR",
            "0",
            "PCMCIA_CIS_SIZE",
            "&pcmh",
            "&tuple.ptr",
            "&window"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_mem_alloc",
          "args": [
            "pct",
            "pch",
            "PCMCIA_CIS_SIZE",
            "&pcmh"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCMCIA_CIS_SIZE\t\t1024\n\nint\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "pcmcia_read_cis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
    "lines": "62-89",
    "snippet": "void\npcmcia_read_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct cis_state state;\n\n\tstate.count = 0;\n\tstate.gotmfc = 0;\n\n\tstate.card = &sc->card;\n\n\tstate.card->error = 0;\n\tstate.card->cis1_major = -1;\n\tstate.card->cis1_minor = -1;\n\tstate.card->cis1_info[0] = NULL;\n\tstate.card->cis1_info[1] = NULL;\n\tstate.card->cis1_info[2] = NULL;\n\tstate.card->cis1_info[3] = NULL;\n\tstate.card->manufacturer = PCMCIA_VENDOR_INVALID;\n\tstate.card->product = PCMCIA_PRODUCT_INVALID;\n\tSIMPLEQ_INIT(&state.card->pf_head);\n\n\tstate.pf = NULL;\n\n\tif (pcmcia_scan_cis((struct device *)sc, pcmcia_parse_cis_tuple,\n\t    &state) == -1)\n\t\tstate.card->error++;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcmcia_parse_cis_tuple"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_scan_cis",
          "args": [
            "(struct device *)sc",
            "pcmcia_parse_cis_tuple",
            "&state"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_scan_cis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
          "lines": "91-433",
          "snippet": "int\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tPCMCIA_CIS_SIZE\t\t1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCMCIA_CIS_SIZE\t\t1024\n\nint\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&state.card->pf_head"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_parse_cis_tuple;\n\nvoid\npcmcia_read_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct cis_state state;\n\n\tstate.count = 0;\n\tstate.gotmfc = 0;\n\n\tstate.card = &sc->card;\n\n\tstate.card->error = 0;\n\tstate.card->cis1_major = -1;\n\tstate.card->cis1_minor = -1;\n\tstate.card->cis1_info[0] = NULL;\n\tstate.card->cis1_info[1] = NULL;\n\tstate.card->cis1_info[2] = NULL;\n\tstate.card->cis1_info[3] = NULL;\n\tstate.card->manufacturer = PCMCIA_VENDOR_INVALID;\n\tstate.card->product = PCMCIA_PRODUCT_INVALID;\n\tSIMPLEQ_INIT(&state.card->pf_head);\n\n\tstate.pf = NULL;\n\n\tif (pcmcia_scan_cis((struct device *)sc, pcmcia_parse_cis_tuple,\n\t    &state) == -1)\n\t\tstate.card->error++;\n}"
  }
]