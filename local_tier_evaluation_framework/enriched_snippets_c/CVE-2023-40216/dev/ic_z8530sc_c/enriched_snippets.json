[
  {
    "function_name": "zsnull_softint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "313-317",
    "snippet": "static void\nzsnull_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void zsnull_softint"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void zsnull_softint;\n\nstatic void\nzsnull_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n}"
  },
  {
    "function_name": "zsnull_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "305-311",
    "snippet": "static void\nzsnull_intr(cs)\n\tstruct zs_chanstate *cs;\n{\n\tzs_write_reg(cs,  1, 0);\n\tzs_write_reg(cs, 15, 0);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void zsnull_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "15",
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "1",
            "0"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void zsnull_intr;\n\nstatic void\nzsnull_intr(cs)\n\tstruct zs_chanstate *cs;\n{\n\tzs_write_reg(cs,  1, 0);\n\tzs_write_reg(cs, 15, 0);\n}"
  },
  {
    "function_name": "zsc_intr_soft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "278-302",
    "snippet": "int\nzsc_intr_soft(arg)\n\tvoid *arg;\n{\n\tregister struct zsc_softc *zsc = arg;\n\tregister struct zs_chanstate *cs;\n\tregister int rval, unit;\n\n\trval = 0;\n\tfor (unit = 0; unit < 2; unit++) {\n\t\tcs = &zsc->zsc_cs[unit];\n\n\t\t/*\n\t\t * The softint flag can be safely cleared once\n\t\t * we have decided to call the softint routine.\n\t\t * (No need to do splzs() first.)\n\t\t */\n\t\tif (cs->cs_softreq) {\n\t\t\tcs->cs_softreq = 0;\n\t\t\t(*cs->cs_ops->zsop_softint)(cs);\n\t\t\trval = 1;\n\t\t}\n\t}\n\treturn (rval);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cs"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nzsc_intr_soft(arg)\n\tvoid *arg;\n{\n\tregister struct zsc_softc *zsc = arg;\n\tregister struct zs_chanstate *cs;\n\tregister int rval, unit;\n\n\trval = 0;\n\tfor (unit = 0; unit < 2; unit++) {\n\t\tcs = &zsc->zsc_cs[unit];\n\n\t\t/*\n\t\t * The softint flag can be safely cleared once\n\t\t * we have decided to call the softint routine.\n\t\t * (No need to do splzs() first.)\n\t\t */\n\t\tif (cs->cs_softreq) {\n\t\t\tcs->cs_softreq = 0;\n\t\t\t(*cs->cs_ops->zsop_softint)(cs);\n\t\t\trval = 1;\n\t\t}\n\t}\n\treturn (rval);\n}"
  },
  {
    "function_name": "zsc_intr_hard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "221-272",
    "snippet": "int\nzsc_intr_hard(arg)\n\tvoid *arg;\n{\n\tregister struct zsc_softc *zsc = arg;\n\tregister struct zs_chanstate *cs_a;\n\tregister struct zs_chanstate *cs_b;\n\tregister int rval;\n\tregister u_char rr3;\n\n\tcs_a = &zsc->zsc_cs[0];\n\tcs_b = &zsc->zsc_cs[1];\n\trval = 0;\n\n\t/* Note: only channel A has an RR3 */\n\trr3 = zs_read_reg(cs_a, 3);\n\n\t/* Handle receive interrupts first. */\n\tif (rr3 & ZSRR3_IP_A_RX)\n\t\t(*cs_a->cs_ops->zsop_rxint)(cs_a);\n\tif (rr3 & ZSRR3_IP_B_RX)\n\t\t(*cs_b->cs_ops->zsop_rxint)(cs_b);\n\n\t/* Handle status interrupts (i.e. flow control). */\n\tif (rr3 & ZSRR3_IP_A_STAT)\n\t\t(*cs_a->cs_ops->zsop_stint)(cs_a);\n\tif (rr3 & ZSRR3_IP_B_STAT)\n\t\t(*cs_b->cs_ops->zsop_stint)(cs_b);\n\n\t/* Handle transmit done interrupts. */\n\tif (rr3 & ZSRR3_IP_A_TX)\n\t\t(*cs_a->cs_ops->zsop_txint)(cs_a);\n\tif (rr3 & ZSRR3_IP_B_TX)\n\t\t(*cs_b->cs_ops->zsop_txint)(cs_b);\n\n\t/* Clear interrupt. */\n\tif (rr3 & (ZSRR3_IP_A_RX | ZSRR3_IP_A_TX | ZSRR3_IP_A_STAT)) {\n\t\tzs_write_csr(cs_a, ZSWR0_CLR_INTR);\n\t\trval |= 1;\n\t}\n\tif (rr3 & (ZSRR3_IP_B_RX | ZSRR3_IP_B_TX | ZSRR3_IP_B_STAT)) {\n\t\tzs_write_csr(cs_b, ZSWR0_CLR_INTR);\n\t\trval |= 2;\n\t}\n\n\tif ((cs_a->cs_softreq) || (cs_b->cs_softreq)) {\n\t\t/* This is a machine-dependent function (or macro). */\n\t\tzsc_req_softint(zsc);\n\t}\n\n\treturn (rval);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zsc_req_softint",
          "args": [
            "zsc"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs_b",
            "ZSWR0_CLR_INTR"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs_a",
            "ZSWR0_CLR_INTR"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cs_b"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cs_a"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cs_b"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cs_a"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cs_b"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cs_a"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_reg",
          "args": [
            "cs_a",
            "3"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nzsc_intr_hard(arg)\n\tvoid *arg;\n{\n\tregister struct zsc_softc *zsc = arg;\n\tregister struct zs_chanstate *cs_a;\n\tregister struct zs_chanstate *cs_b;\n\tregister int rval;\n\tregister u_char rr3;\n\n\tcs_a = &zsc->zsc_cs[0];\n\tcs_b = &zsc->zsc_cs[1];\n\trval = 0;\n\n\t/* Note: only channel A has an RR3 */\n\trr3 = zs_read_reg(cs_a, 3);\n\n\t/* Handle receive interrupts first. */\n\tif (rr3 & ZSRR3_IP_A_RX)\n\t\t(*cs_a->cs_ops->zsop_rxint)(cs_a);\n\tif (rr3 & ZSRR3_IP_B_RX)\n\t\t(*cs_b->cs_ops->zsop_rxint)(cs_b);\n\n\t/* Handle status interrupts (i.e. flow control). */\n\tif (rr3 & ZSRR3_IP_A_STAT)\n\t\t(*cs_a->cs_ops->zsop_stint)(cs_a);\n\tif (rr3 & ZSRR3_IP_B_STAT)\n\t\t(*cs_b->cs_ops->zsop_stint)(cs_b);\n\n\t/* Handle transmit done interrupts. */\n\tif (rr3 & ZSRR3_IP_A_TX)\n\t\t(*cs_a->cs_ops->zsop_txint)(cs_a);\n\tif (rr3 & ZSRR3_IP_B_TX)\n\t\t(*cs_b->cs_ops->zsop_txint)(cs_b);\n\n\t/* Clear interrupt. */\n\tif (rr3 & (ZSRR3_IP_A_RX | ZSRR3_IP_A_TX | ZSRR3_IP_A_STAT)) {\n\t\tzs_write_csr(cs_a, ZSWR0_CLR_INTR);\n\t\trval |= 1;\n\t}\n\tif (rr3 & (ZSRR3_IP_B_RX | ZSRR3_IP_B_TX | ZSRR3_IP_B_STAT)) {\n\t\tzs_write_csr(cs_b, ZSWR0_CLR_INTR);\n\t\trval |= 2;\n\t}\n\n\tif ((cs_a->cs_softreq) || (cs_b->cs_softreq)) {\n\t\t/* This is a machine-dependent function (or macro). */\n\t\tzsc_req_softint(zsc);\n\t}\n\n\treturn (rval);\n}"
  },
  {
    "function_name": "zs_loadchannelregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "144-207",
    "snippet": "void\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "5",
            "reg[5]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "3",
            "reg[3]"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "15",
            "reg[15]"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "14",
            "reg[14]"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "13",
            "reg[13]"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "12",
            "reg[12]"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "11",
            "reg[11]"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "9",
            "reg[9]"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "2",
            "reg[2]"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "1",
            "reg[1]"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "5",
            "reg[5] & ~ZSWR5_TX_ENABLE"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "3",
            "reg[3] & ~ZSWR3_RX_ENABLE"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "10",
            "reg[10]"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "4",
            "reg[4]"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_iflush",
          "args": [
            "cs"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "zs_iflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "111-135",
          "snippet": "void\nzs_iflush(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char c, rr0, rr1;\n\n\tfor (;;) {\n\t\t/* Is there input available? */\n\t\trr0 = zs_read_csr(cs);\n\t\tif ((rr0 & ZSRR0_RX_READY) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * First read the status, because reading the data\n\t\t * destroys the status of this char.\n\t\t */\n\t\trr1 = zs_read_reg(cs, 1);\n\t\tc = zs_read_data(cs);\n\n\t\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t\t/* Clear the receive error. */\n\t\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_iflush(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char c, rr0, rr1;\n\n\tfor (;;) {\n\t\t/* Is there input available? */\n\t\trr0 = zs_read_csr(cs);\n\t\tif ((rr0 & ZSRR0_RX_READY) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * First read the status, because reading the data\n\t\t * destroys the status of this char.\n\t\t */\n\t\trr1 = zs_read_reg(cs, 1);\n\t\tc = zs_read_data(cs);\n\n\t\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t\t/* Clear the receive error. */\n\t\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSM_RESET_ERR"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t)cs->cs_preg",
            "(caddr_t)cs->cs_creg",
            "16"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}"
  },
  {
    "function_name": "zs_iflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "111-135",
    "snippet": "void\nzs_iflush(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char c, rr0, rr1;\n\n\tfor (;;) {\n\t\t/* Is there input available? */\n\t\trr0 = zs_read_csr(cs);\n\t\tif ((rr0 & ZSRR0_RX_READY) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * First read the status, because reading the data\n\t\t * destroys the status of this char.\n\t\t */\n\t\trr1 = zs_read_reg(cs, 1);\n\t\tc = zs_read_data(cs);\n\n\t\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t\t/* Clear the receive error. */\n\t\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_ERRORS"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_data",
          "args": [
            "cs"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_reg",
          "args": [
            "cs",
            "1"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_csr",
          "args": [
            "cs"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_iflush(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char c, rr0, rr1;\n\n\tfor (;;) {\n\t\t/* Is there input available? */\n\t\trr0 = zs_read_csr(cs);\n\t\tif ((rr0 & ZSRR0_RX_READY) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * First read the status, because reading the data\n\t\t * destroys the status of this char.\n\t\t */\n\t\trr1 = zs_read_reg(cs, 1);\n\t\tc = zs_read_data(cs);\n\n\t\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t\t/* Clear the receive error. */\n\t\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "zs_getspeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "97-106",
    "snippet": "int\nzs_getspeed(cs)\n\tstruct zs_chanstate *cs;\n{\n\tint tconst;\n\n\ttconst = zs_read_reg(cs, 12);\n\ttconst |= zs_read_reg(cs, 13) << 8;\n\treturn (TCONST_TO_BPS(cs->cs_brg_clk, tconst));\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TCONST_TO_BPS",
          "args": [
            "cs->cs_brg_clk",
            "tconst"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_reg",
          "args": [
            "cs",
            "13"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_reg",
          "args": [
            "cs",
            "12"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nzs_getspeed(cs)\n\tstruct zs_chanstate *cs;\n{\n\tint tconst;\n\n\ttconst = zs_read_reg(cs, 12);\n\ttconst |= zs_read_reg(cs, 13) << 8;\n\treturn (TCONST_TO_BPS(cs->cs_brg_clk, tconst));\n}"
  },
  {
    "function_name": "zs_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
    "lines": "74-91",
    "snippet": "void\nzs_break(cs, set)\n\tstruct zs_chanstate *cs;\n\tint set;\n{\n\tint s;\n\n\ts = splzs();\n\tif (set) {\n\t\tcs->cs_preg[5] |= ZSWR5_BREAK;\n\t\tcs->cs_creg[5] |= ZSWR5_BREAK;\n\t} else {\n\t\tcs->cs_preg[5] &= ~ZSWR5_BREAK;\n\t\tcs->cs_creg[5] &= ~ZSWR5_BREAK;\n\t}\n\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/time.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "5",
            "cs->cs_creg[5]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_break(cs, set)\n\tstruct zs_chanstate *cs;\n\tint set;\n{\n\tint s;\n\n\ts = splzs();\n\tif (set) {\n\t\tcs->cs_preg[5] |= ZSWR5_BREAK;\n\t\tcs->cs_creg[5] |= ZSWR5_BREAK;\n\t} else {\n\t\tcs->cs_preg[5] &= ~ZSWR5_BREAK;\n\t\tcs->cs_creg[5] &= ~ZSWR5_BREAK;\n\t}\n\tzs_write_reg(cs, 5, cs->cs_creg[5]);\n\tsplx(s);\n}"
  }
]