[
  {
    "function_name": "rf_PrintPSStatusTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "369-376",
    "snippet": "void \nrf_PrintPSStatusTable(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;\n\tRealPrintPSStatusTable(raidPtr, pssTable);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RealPrintPSStatusTable",
          "args": [
            "raidPtr",
            "pssTable"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "RealPrintPSStatusTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "327-367",
          "snippet": "static void \nRealPrintPSStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i, j, procsWaiting, blocksWaiting, bufsWaiting;\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_CallbackDesc_t *cb;\n\n\tprintf(\"\\nParity Stripe Status Table\\n\");\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\tprocsWaiting = blocksWaiting = bufsWaiting = 0;\n\t\t\tfor (cb = p->procWaitList; cb; cb = cb->next)\n\t\t\t\tprocsWaiting++;\n\t\t\tfor (cb = p->blockWaitList; cb; cb = cb->next)\n\t\t\t\tblocksWaiting++;\n\t\t\tfor (cb = p->bufWaitList; cb; cb = cb->next)\n\t\t\t\tbufsWaiting++;\n\t\t\tprintf(\"PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued \",\n\t\t\t    (long) p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);\n\t\t\tfor (j = 0; j < raidPtr->numCol; j++)\n\t\t\t\tprintf(\"%c\", (p->issued[j]) ? '1' : '0');\n\t\t\tif (!p->flags)\n\t\t\t\tprintf(\" flags: (none)\");\n\t\t\telse {\n\t\t\t\tif (p->flags & RF_PSS_UNDER_RECON)\n\t\t\t\t\tprintf(\" under-recon\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_WRITE)\n\t\t\t\t\tprintf(\" forced-w\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_READ)\n\t\t\t\t\tprintf(\" forced-r\");\n\t\t\t\tif (p->flags & RF_PSS_RECON_BLOCKED)\n\t\t\t\t\tprintf(\" blocked\");\n\t\t\t\tif (p->flags & RF_PSS_BUFFERWAIT)\n\t\t\t\t\tprintf(\" bufwait\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nstatic void \nRealPrintPSStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i, j, procsWaiting, blocksWaiting, bufsWaiting;\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_CallbackDesc_t *cb;\n\n\tprintf(\"\\nParity Stripe Status Table\\n\");\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\tprocsWaiting = blocksWaiting = bufsWaiting = 0;\n\t\t\tfor (cb = p->procWaitList; cb; cb = cb->next)\n\t\t\t\tprocsWaiting++;\n\t\t\tfor (cb = p->blockWaitList; cb; cb = cb->next)\n\t\t\t\tblocksWaiting++;\n\t\t\tfor (cb = p->bufWaitList; cb; cb = cb->next)\n\t\t\t\tbufsWaiting++;\n\t\t\tprintf(\"PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued \",\n\t\t\t    (long) p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);\n\t\t\tfor (j = 0; j < raidPtr->numCol; j++)\n\t\t\t\tprintf(\"%c\", (p->issued[j]) ? '1' : '0');\n\t\t\tif (!p->flags)\n\t\t\t\tprintf(\" flags: (none)\");\n\t\t\telse {\n\t\t\t\tif (p->flags & RF_PSS_UNDER_RECON)\n\t\t\t\t\tprintf(\" under-recon\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_WRITE)\n\t\t\t\t\tprintf(\" forced-w\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_READ)\n\t\t\t\t\tprintf(\" forced-r\");\n\t\t\t\tif (p->flags & RF_PSS_RECON_BLOCKED)\n\t\t\t\t\tprintf(\" blocked\");\n\t\t\t\tif (p->flags & RF_PSS_BUFFERWAIT)\n\t\t\t\t\tprintf(\" bufwait\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_PrintPSStatusTable(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;\n\tRealPrintPSStatusTable(raidPtr, pssTable);\n}"
  },
  {
    "function_name": "RealPrintPSStatusTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "327-367",
    "snippet": "static void \nRealPrintPSStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i, j, procsWaiting, blocksWaiting, bufsWaiting;\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_CallbackDesc_t *cb;\n\n\tprintf(\"\\nParity Stripe Status Table\\n\");\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\tprocsWaiting = blocksWaiting = bufsWaiting = 0;\n\t\t\tfor (cb = p->procWaitList; cb; cb = cb->next)\n\t\t\t\tprocsWaiting++;\n\t\t\tfor (cb = p->blockWaitList; cb; cb = cb->next)\n\t\t\t\tblocksWaiting++;\n\t\t\tfor (cb = p->bufWaitList; cb; cb = cb->next)\n\t\t\t\tbufsWaiting++;\n\t\t\tprintf(\"PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued \",\n\t\t\t    (long) p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);\n\t\t\tfor (j = 0; j < raidPtr->numCol; j++)\n\t\t\t\tprintf(\"%c\", (p->issued[j]) ? '1' : '0');\n\t\t\tif (!p->flags)\n\t\t\t\tprintf(\" flags: (none)\");\n\t\t\telse {\n\t\t\t\tif (p->flags & RF_PSS_UNDER_RECON)\n\t\t\t\t\tprintf(\" under-recon\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_WRITE)\n\t\t\t\t\tprintf(\" forced-w\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_READ)\n\t\t\t\t\tprintf(\" forced-r\");\n\t\t\t\tif (p->flags & RF_PSS_RECON_BLOCKED)\n\t\t\t\t\tprintf(\" blocked\");\n\t\t\t\tif (p->flags & RF_PSS_BUFFERWAIT)\n\t\t\t\t\tprintf(\" bufwait\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nstatic void \nRealPrintPSStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i, j, procsWaiting, blocksWaiting, bufsWaiting;\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_CallbackDesc_t *cb;\n\n\tprintf(\"\\nParity Stripe Status Table\\n\");\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\tprocsWaiting = blocksWaiting = bufsWaiting = 0;\n\t\t\tfor (cb = p->procWaitList; cb; cb = cb->next)\n\t\t\t\tprocsWaiting++;\n\t\t\tfor (cb = p->blockWaitList; cb; cb = cb->next)\n\t\t\t\tblocksWaiting++;\n\t\t\tfor (cb = p->bufWaitList; cb; cb = cb->next)\n\t\t\t\tbufsWaiting++;\n\t\t\tprintf(\"PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued \",\n\t\t\t    (long) p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);\n\t\t\tfor (j = 0; j < raidPtr->numCol; j++)\n\t\t\t\tprintf(\"%c\", (p->issued[j]) ? '1' : '0');\n\t\t\tif (!p->flags)\n\t\t\t\tprintf(\" flags: (none)\");\n\t\t\telse {\n\t\t\t\tif (p->flags & RF_PSS_UNDER_RECON)\n\t\t\t\t\tprintf(\" under-recon\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_WRITE)\n\t\t\t\t\tprintf(\" forced-w\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_READ)\n\t\t\t\t\tprintf(\" forced-r\");\n\t\t\t\tif (p->flags & RF_PSS_RECON_BLOCKED)\n\t\t\t\t\tprintf(\" blocked\");\n\t\t\t\tif (p->flags & RF_PSS_BUFFERWAIT)\n\t\t\t\t\tprintf(\" bufwait\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rf_FreePSStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "315-325",
    "snippet": "void \nrf_FreePSStatus(raidPtr, p)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *p;\n{\n\tRF_ASSERT(p->procWaitList == NULL);\n\tRF_ASSERT(p->blockWaitList == NULL);\n\tRF_ASSERT(p->bufWaitList == NULL);\n\n\tRF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next, clean_pss, raidPtr);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE_CLEAN_ARG",
          "args": [
            "raidPtr->pss_freelist",
            "p",
            "next",
            "clean_pss",
            "raidPtr"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "p->bufWaitList == NULL"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "p->blockWaitList == NULL"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "p->procWaitList == NULL"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_FreePSStatus(raidPtr, p)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *p;\n{\n\tRF_ASSERT(p->procWaitList == NULL);\n\tRF_ASSERT(p->blockWaitList == NULL);\n\tRF_ASSERT(p->bufWaitList == NULL);\n\n\tRF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next, clean_pss, raidPtr);\n}"
  },
  {
    "function_name": "rf_RemoveFromActiveReconTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "249-297",
    "snippet": "void \nrf_RemoveFromActiveReconTable(raidPtr, row, psid, which_ru)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psid;\n{\n\tRF_PSStatusHeader_t *hdr = &(raidPtr->reconControl[row]->pssTable[RF_HASH_PSID(raidPtr, psid)]);\n\tRF_ReconParityStripeStatus_t *p, *pt;\n\tRF_CallbackDesc_t *cb, *cb1;\n\n\tRF_LOCK_MUTEX(hdr->mutex);\n\tfor (pt = NULL, p = hdr->chain; p; pt = p, p = p->next) {\n\t\tif ((p->parityStripeID == psid) && (p->which_ru == which_ru))\n\t\t\tbreak;\n\t}\n\tif (p == NULL) {\n\t\trf_PrintPSStatusTable(raidPtr, row);\n\t}\n\tRF_ASSERT(p);\t\t/* it must be there */\n\n\tDprintf2(\"PSS: deleting pss for psid %ld ru %d\\n\", psid, which_ru);\n\n\t/* delete this entry from the hash chain */\n\tif (pt)\n\t\tpt->next = p->next;\n\telse\n\t\thdr->chain = p->next;\n\tp->next = NULL;\n\n\tRF_UNLOCK_MUTEX(hdr->mutex);\n\n\t/* wakup anyone waiting on the parity stripe ID */\n\tcb = p->procWaitList;\n\tp->procWaitList = NULL;\n\twhile (cb) {\n\t\tDprintf1(\"Waking up access waiting on parity stripe ID %ld\\n\", p->parityStripeID);\n\t\tcb1 = cb->next;\n\t\t(cb->callbackFunc) (cb->callbackArg);\n\n\t\t/* THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,\n\t\t * IMHO */\n\t\t/* (cb->callbackFunc)(cb->callbackArg, 0); */\n\t\trf_FreeCallbackDesc(cb);\n\t\tcb = cb1;\n\t}\n\n\trf_FreePSStatus(raidPtr, p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreePSStatus",
          "args": [
            "raidPtr",
            "p"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreePSStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "315-325",
          "snippet": "void \nrf_FreePSStatus(raidPtr, p)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *p;\n{\n\tRF_ASSERT(p->procWaitList == NULL);\n\tRF_ASSERT(p->blockWaitList == NULL);\n\tRF_ASSERT(p->bufWaitList == NULL);\n\n\tRF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next, clean_pss, raidPtr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_FreePSStatus(raidPtr, p)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *p;\n{\n\tRF_ASSERT(p->procWaitList == NULL);\n\tRF_ASSERT(p->blockWaitList == NULL);\n\tRF_ASSERT(p->bufWaitList == NULL);\n\n\tRF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next, clean_pss, raidPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeCallbackDesc",
          "args": [
            "cb"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "89-94",
          "snippet": "void \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nvoid \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cb->callbackArg"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf1",
          "args": [
            "\"Waking up access waiting on parity stripe ID %ld\\n\"",
            "p->parityStripeID"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "hdr->mutex"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"PSS: deleting pss for psid %ld ru %d\\n\"",
            "psid",
            "which_ru"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "p"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PrintPSStatusTable",
          "args": [
            "raidPtr",
            "row"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintPSStatusTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "369-376",
          "snippet": "void \nrf_PrintPSStatusTable(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;\n\tRealPrintPSStatusTable(raidPtr, pssTable);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_PrintPSStatusTable(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;\n\tRealPrintPSStatusTable(raidPtr, pssTable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "hdr->mutex"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_HASH_PSID",
          "args": [
            "raidPtr",
            "psid"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_RemoveFromActiveReconTable(raidPtr, row, psid, which_ru)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psid;\n{\n\tRF_PSStatusHeader_t *hdr = &(raidPtr->reconControl[row]->pssTable[RF_HASH_PSID(raidPtr, psid)]);\n\tRF_ReconParityStripeStatus_t *p, *pt;\n\tRF_CallbackDesc_t *cb, *cb1;\n\n\tRF_LOCK_MUTEX(hdr->mutex);\n\tfor (pt = NULL, p = hdr->chain; p; pt = p, p = p->next) {\n\t\tif ((p->parityStripeID == psid) && (p->which_ru == which_ru))\n\t\t\tbreak;\n\t}\n\tif (p == NULL) {\n\t\trf_PrintPSStatusTable(raidPtr, row);\n\t}\n\tRF_ASSERT(p);\t\t/* it must be there */\n\n\tDprintf2(\"PSS: deleting pss for psid %ld ru %d\\n\", psid, which_ru);\n\n\t/* delete this entry from the hash chain */\n\tif (pt)\n\t\tpt->next = p->next;\n\telse\n\t\thdr->chain = p->next;\n\tp->next = NULL;\n\n\tRF_UNLOCK_MUTEX(hdr->mutex);\n\n\t/* wakup anyone waiting on the parity stripe ID */\n\tcb = p->procWaitList;\n\tp->procWaitList = NULL;\n\twhile (cb) {\n\t\tDprintf1(\"Waking up access waiting on parity stripe ID %ld\\n\", p->parityStripeID);\n\t\tcb1 = cb->next;\n\t\t(cb->callbackFunc) (cb->callbackArg);\n\n\t\t/* THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,\n\t\t * IMHO */\n\t\t/* (cb->callbackFunc)(cb->callbackArg, 0); */\n\t\trf_FreeCallbackDesc(cb);\n\t\tcb = cb1;\n\t}\n\n\trf_FreePSStatus(raidPtr, p);\n}"
  },
  {
    "function_name": "rf_PSStatusDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "224-247",
    "snippet": "void \nrf_PSStatusDelete(raidPtr, pssTable, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_PSStatusHeader_t *hdr = &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);\n\tRF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;\n\n\twhile (p) {\n\t\tif (p == pssPtr) {\n\t\t\tif (pt)\n\t\t\t\tpt->next = p->next;\n\t\t\telse\n\t\t\t\thdr->chain = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_FreePSStatus(raidPtr, p);\n\t\t\treturn;\n\t\t}\n\t\tpt = p;\n\t\tp = p->next;\n\t}\n\tRF_ASSERT(0);\t\t/* we must find it here */\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreePSStatus",
          "args": [
            "raidPtr",
            "p"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreePSStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "315-325",
          "snippet": "void \nrf_FreePSStatus(raidPtr, p)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *p;\n{\n\tRF_ASSERT(p->procWaitList == NULL);\n\tRF_ASSERT(p->blockWaitList == NULL);\n\tRF_ASSERT(p->bufWaitList == NULL);\n\n\tRF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next, clean_pss, raidPtr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_FreePSStatus(raidPtr, p)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconParityStripeStatus_t *p;\n{\n\tRF_ASSERT(p->procWaitList == NULL);\n\tRF_ASSERT(p->blockWaitList == NULL);\n\tRF_ASSERT(p->bufWaitList == NULL);\n\n\tRF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next, clean_pss, raidPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_HASH_PSID",
          "args": [
            "raidPtr",
            "pssPtr->parityStripeID"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_PSStatusDelete(raidPtr, pssTable, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_PSStatusHeader_t *hdr = &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);\n\tRF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;\n\n\twhile (p) {\n\t\tif (p == pssPtr) {\n\t\t\tif (pt)\n\t\t\t\tpt->next = p->next;\n\t\t\telse\n\t\t\t\thdr->chain = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_FreePSStatus(raidPtr, p);\n\t\t\treturn;\n\t\t}\n\t\tpt = p;\n\t\tp = p->next;\n\t}\n\tRF_ASSERT(0);\t\t/* we must find it here */\n}"
  },
  {
    "function_name": "rf_LookupRUStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "170-218",
    "snippet": "RF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"raid%d: Blocked recon on psid %ld.  count now %d\\n\"",
            "raidPtr->raidid",
            "psID",
            "p->blockCount"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocPSStatus",
          "args": [
            "raidPtr"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"PSS: creating pss for psid %ld ru %d\\n\"",
            "psID",
            "which_ru"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_HASH_PSID",
          "args": [
            "raidPtr",
            "psID"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nRF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}"
  },
  {
    "function_name": "rf_FreeParityStripeStatusTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "145-161",
    "snippet": "void \nrf_FreeParityStripeStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i;\n\n\tif (rf_pssDebug)\n\t\tRealPrintPSStatusTable(raidPtr, pssTable);\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tif (pssTable[i].chain) {\n\t\t\tprintf(\"ERROR: pss hash chain not null at recon shutdown\\n\");\n\t\t}\n\t\trf_mutex_destroy(&pssTable[i].mutex);\n\t}\n\tRF_Free(pssTable, raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t));\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "pssTable",
            "raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&pssTable[i].mutex"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: pss hash chain not null at recon shutdown\\n\""
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RealPrintPSStatusTable",
          "args": [
            "raidPtr",
            "pssTable"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "RealPrintPSStatusTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "327-367",
          "snippet": "static void \nRealPrintPSStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i, j, procsWaiting, blocksWaiting, bufsWaiting;\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_CallbackDesc_t *cb;\n\n\tprintf(\"\\nParity Stripe Status Table\\n\");\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\tprocsWaiting = blocksWaiting = bufsWaiting = 0;\n\t\t\tfor (cb = p->procWaitList; cb; cb = cb->next)\n\t\t\t\tprocsWaiting++;\n\t\t\tfor (cb = p->blockWaitList; cb; cb = cb->next)\n\t\t\t\tblocksWaiting++;\n\t\t\tfor (cb = p->bufWaitList; cb; cb = cb->next)\n\t\t\t\tbufsWaiting++;\n\t\t\tprintf(\"PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued \",\n\t\t\t    (long) p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);\n\t\t\tfor (j = 0; j < raidPtr->numCol; j++)\n\t\t\t\tprintf(\"%c\", (p->issued[j]) ? '1' : '0');\n\t\t\tif (!p->flags)\n\t\t\t\tprintf(\" flags: (none)\");\n\t\t\telse {\n\t\t\t\tif (p->flags & RF_PSS_UNDER_RECON)\n\t\t\t\t\tprintf(\" under-recon\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_WRITE)\n\t\t\t\t\tprintf(\" forced-w\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_READ)\n\t\t\t\t\tprintf(\" forced-r\");\n\t\t\t\tif (p->flags & RF_PSS_RECON_BLOCKED)\n\t\t\t\t\tprintf(\" blocked\");\n\t\t\t\tif (p->flags & RF_PSS_BUFFERWAIT)\n\t\t\t\t\tprintf(\" bufwait\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nstatic void \nRealPrintPSStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i, j, procsWaiting, blocksWaiting, bufsWaiting;\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_CallbackDesc_t *cb;\n\n\tprintf(\"\\nParity Stripe Status Table\\n\");\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\tprocsWaiting = blocksWaiting = bufsWaiting = 0;\n\t\t\tfor (cb = p->procWaitList; cb; cb = cb->next)\n\t\t\t\tprocsWaiting++;\n\t\t\tfor (cb = p->blockWaitList; cb; cb = cb->next)\n\t\t\t\tblocksWaiting++;\n\t\t\tfor (cb = p->bufWaitList; cb; cb = cb->next)\n\t\t\t\tbufsWaiting++;\n\t\t\tprintf(\"PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued \",\n\t\t\t    (long) p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);\n\t\t\tfor (j = 0; j < raidPtr->numCol; j++)\n\t\t\t\tprintf(\"%c\", (p->issued[j]) ? '1' : '0');\n\t\t\tif (!p->flags)\n\t\t\t\tprintf(\" flags: (none)\");\n\t\t\telse {\n\t\t\t\tif (p->flags & RF_PSS_UNDER_RECON)\n\t\t\t\t\tprintf(\" under-recon\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_WRITE)\n\t\t\t\t\tprintf(\" forced-w\");\n\t\t\t\tif (p->flags & RF_PSS_FORCED_ON_READ)\n\t\t\t\t\tprintf(\" forced-r\");\n\t\t\t\tif (p->flags & RF_PSS_RECON_BLOCKED)\n\t\t\t\t\tprintf(\" blocked\");\n\t\t\t\tif (p->flags & RF_PSS_BUFFERWAIT)\n\t\t\t\t\tprintf(\" bufwait\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_FreeParityStripeStatusTable(raidPtr, pssTable)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n{\n\tint     i;\n\n\tif (rf_pssDebug)\n\t\tRealPrintPSStatusTable(raidPtr, pssTable);\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tif (pssTable[i].chain) {\n\t\t\tprintf(\"ERROR: pss hash chain not null at recon shutdown\\n\");\n\t\t}\n\t\trf_mutex_destroy(&pssTable[i].mutex);\n\t}\n\tRF_Free(pssTable, raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t));\n}"
  },
  {
    "function_name": "rf_ConfigurePSStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "92-115",
    "snippet": "int \nrf_ConfigurePSStatus(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\traidPtr->pssTableSize = RF_PSS_DEFAULT_TABLESIZE;\n\tRF_FREELIST_CREATE(raidPtr->pss_freelist, RF_MAX_FREE_PSS,\n\t    RF_PSS_INC, sizeof(RF_ReconParityStripeStatus_t));\n\tif (raidPtr->pss_freelist == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownPSStatus, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownPSStatus(raidPtr);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME_INIT_ARG(raidPtr->pss_freelist, RF_PSS_INITIAL, next,\n\t    (RF_ReconParityStripeStatus_t *), init_pss, raidPtr);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define RF_PSS_INITIAL    4",
      "#define RF_PSS_INC        8",
      "#define RF_MAX_FREE_PSS  32"
    ],
    "globals_used": [
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void rf_ShutdownPSStatus(void *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME_INIT_ARG",
          "args": [
            "raidPtr->pss_freelist",
            "RF_PSS_INITIAL",
            "next",
            "(RF_ReconParityStripeStatus_t *), init_pss",
            "raidPtr"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownPSStatus",
          "args": [
            "raidPtr"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownPSStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "83-90",
          "snippet": "static void \nrf_ShutdownPSStatus(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) arg;\n\n\tRF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next, (RF_ReconParityStripeStatus_t *), clean_pss, raidPtr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void rf_ShutdownPSStatus(void *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void rf_ShutdownPSStatus(void *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nstatic void \nrf_ShutdownPSStatus(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) arg;\n\n\tRF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next, (RF_ReconParityStripeStatus_t *), clean_pss, raidPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownPSStatus",
            "raidPtr"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "raidPtr->pss_freelist",
            "RF_MAX_FREE_PSS",
            "RF_PSS_INC",
            "sizeof(RF_ReconParityStripeStatus_t)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\n#define RF_PSS_INITIAL    4\n#define RF_PSS_INC        8\n#define RF_MAX_FREE_PSS  32\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void rf_ShutdownPSStatus(void *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nint \nrf_ConfigurePSStatus(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\traidPtr->pssTableSize = RF_PSS_DEFAULT_TABLESIZE;\n\tRF_FREELIST_CREATE(raidPtr->pss_freelist, RF_MAX_FREE_PSS,\n\t    RF_PSS_INC, sizeof(RF_ReconParityStripeStatus_t));\n\tif (raidPtr->pss_freelist == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_ShutdownPSStatus, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownPSStatus(raidPtr);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME_INIT_ARG(raidPtr->pss_freelist, RF_PSS_INITIAL, next,\n\t    (RF_ReconParityStripeStatus_t *), init_pss, raidPtr);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownPSStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "83-90",
    "snippet": "static void \nrf_ShutdownPSStatus(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) arg;\n\n\tRF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next, (RF_ReconParityStripeStatus_t *), clean_pss, raidPtr);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void rf_ShutdownPSStatus(void *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY_CLEAN_ARG",
          "args": [
            "raidPtr->pss_freelist",
            "next",
            "(RF_ReconParityStripeStatus_t *), clean_pss",
            "raidPtr"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void rf_ShutdownPSStatus(void *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nstatic void \nrf_ShutdownPSStatus(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) arg;\n\n\tRF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next, (RF_ReconParityStripeStatus_t *), clean_pss, raidPtr);\n}"
  },
  {
    "function_name": "clean_pss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "75-81",
    "snippet": "static void \nclean_pss(p, raidPtr)\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_Raid_t *raidPtr;\n{\n\tRF_Free(p->issued, raidPtr->numCol * sizeof(char));\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "p->issued",
            "raidPtr->numCol * sizeof(char)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nstatic void \nclean_pss(p, raidPtr)\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_Raid_t *raidPtr;\n{\n\tRF_Free(p->issued, raidPtr->numCol * sizeof(char));\n}"
  },
  {
    "function_name": "init_pss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
    "lines": "64-73",
    "snippet": "static int \ninit_pss(p, raidPtr)\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_Raid_t *raidPtr;\n{\n\tRF_Calloc(p->issued, raidPtr->numCol, sizeof(char), (char *));\n\tif (p->issued == NULL)\n\t\treturn (ENOMEM);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_psstatus.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
      "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
      "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "p->issued",
            "raidPtr->numCol",
            "sizeof(char)",
            "(char *)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nstatic int \ninit_pss(p, raidPtr)\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_Raid_t *raidPtr;\n{\n\tRF_Calloc(p->issued, raidPtr->numCol, sizeof(char), (char *));\n\tif (p->issued == NULL)\n\t\treturn (ENOMEM);\n\treturn (0);\n}"
  }
]