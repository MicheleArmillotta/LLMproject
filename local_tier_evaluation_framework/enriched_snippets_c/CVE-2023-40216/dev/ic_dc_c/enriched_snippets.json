[
  {
    "function_name": "dc_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2450-2456",
    "snippet": "void dc_shutdown(v)\n\tvoid\t\t\t*v;\n{\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)v;\n\n\tdc_stop(sc);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_shutdown",
      "void dc_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_stop",
          "args": [
            "sc"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "dc_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2394-2444",
          "snippet": "void dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_stop;\n\nvoid dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_shutdown;\nvoid dc_stop;\n\nvoid dc_shutdown(v)\n\tvoid\t\t\t*v;\n{\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)v;\n\n\tdc_stop(sc);\n}"
  },
  {
    "function_name": "dc_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2394-2444",
    "snippet": "void dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_tick",
      "void dc_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->dc_ldata->dc_tx_list",
            "sizeof(sc->dc_ldata->dc_tx_list)"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->dc_cdata.dc_tx_chain[i]"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->dc_ldata->dc_rx_list",
            "sizeof(sc->dc_ldata->dc_rx_list)"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->dc_cdata.dc_rx_chain[i]"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_RXADDR",
            "0x00000000"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_TXADDR",
            "0x00000000"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_IMR",
            "0x00000000"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "(DC_NETCFG_RX_ON|DC_NETCFG_TX_ON)"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "dc_tick",
            "sc"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_stop;\n\nvoid dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2370-2388",
    "snippet": "void dc_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifp->if_oerrors++;\n\tprintf(\"dc%d: watchdog timeout\\n\", sc->dc_unit);\n\n\tdc_stop(sc);\n\tdc_reset(sc);\n\tdc_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tdc_start(ifp);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_start",
      "void dc_init",
      "void dc_stop",
      "void dc_watchdog",
      "void dc_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_start",
          "args": [
            "ifp"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "dc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2041-2098",
          "snippet": "void dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_encap",
            "int dc_coal",
            "void dc_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_encap;\nint dc_coal;\nvoid dc_start;\n\nvoid dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_init",
          "args": [
            "sc"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "dc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2100-2233",
          "snippet": "void dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_init",
            "void dc_stop",
            "void dc_setcfg",
            "void dc_setfilt",
            "void dc_reset",
            "int dc_list_rx_init",
            "int dc_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_setcfg;\nvoid dc_setfilt;\nvoid dc_reset;\nint dc_list_rx_init;\nint dc_list_tx_init;\n\nvoid dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_reset",
          "args": [
            "sc"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "dc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1167-1206",
          "snippet": "void dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_reset;\n\nvoid dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_stop",
          "args": [
            "sc"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "dc_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2394-2444",
          "snippet": "void dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_stop;\n\nvoid dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: watchdog timeout\\n\"",
            "sc->dc_unit"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_start;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_watchdog;\nvoid dc_reset;\n\nvoid dc_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tifp->if_oerrors++;\n\tprintf(\"dc%d: watchdog timeout\\n\", sc->dc_unit);\n\n\tdc_stop(sc);\n\tdc_reset(sc);\n\tdc_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tdc_start(ifp);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2288-2368",
    "snippet": "int dc_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct dc_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tdc_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdc_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->dc_if_flags & IFF_PROMISC)) {\n\t\t\t\tdc_setfilt(sc);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->dc_if_flags & IFF_PROMISC) {\n\t\t\t\tdc_setfilt(sc);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING)) {\n\t\t\t\tsc->dc_txthresh = 0;\n\t\t\t\tdc_init(sc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tdc_stop(sc);\n\t\t}\n\t\tsc->dc_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tdc_setfilt(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tmii = &sc->sc_mii;\n\t\terror = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_ioctl",
      "void dc_init",
      "void dc_stop",
      "void dc_setfilt"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&mii->mii_media",
            "command"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_setfilt",
          "args": [
            "sc"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setfilt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1040-1054",
          "snippet": "void dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_setfilt_21143",
            "void dc_setfilt_asix",
            "void dc_setfilt_admtek",
            "void dc_setfilt"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setfilt_21143;\nvoid dc_setfilt_asix;\nvoid dc_setfilt_admtek;\nvoid dc_setfilt;\n\nvoid dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_stop",
          "args": [
            "sc"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "dc_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2394-2444",
          "snippet": "void dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_stop;\n\nvoid dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_init",
          "args": [
            "sc"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "dc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2100-2233",
          "snippet": "void dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_init",
            "void dc_stop",
            "void dc_setcfg",
            "void dc_setfilt",
            "void dc_reset",
            "int dc_list_rx_init",
            "int dc_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_setcfg;\nvoid dc_setfilt;\nvoid dc_reset;\nint dc_list_rx_init;\nint dc_list_tx_init;\n\nvoid dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_ioctl;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_setfilt;\n\nint dc_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct dc_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tdc_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdc_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->dc_if_flags & IFF_PROMISC)) {\n\t\t\t\tdc_setfilt(sc);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->dc_if_flags & IFF_PROMISC) {\n\t\t\t\tdc_setfilt(sc);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING)) {\n\t\t\t\tsc->dc_txthresh = 0;\n\t\t\t\tdc_init(sc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tdc_stop(sc);\n\t\t}\n\t\tsc->dc_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tdc_setfilt(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tmii = &sc->sc_mii;\n\t\terror = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "dc_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2263-2286",
    "snippet": "void dc_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tmii_pollstat(mii);\n\tifm = &mii->mii_media;\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1) {\n\t\t\tifmr->ifm_active = ifm->ifm_media;\n\t\t\tifmr->ifm_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_ifmedia_sts"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "mii"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_ifmedia_sts;\n\nvoid dc_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tmii_pollstat(mii);\n\tifm = &mii->mii_media;\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1) {\n\t\t\tifmr->ifm_active = ifm->ifm_media;\n\t\t\tifmr->ifm_status = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2238-2258",
    "snippet": "int dc_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\tstruct ifmedia *ifm;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tmii_mediachg(mii);\n\n\tifm = &mii->mii_media;\n\n\tif (DC_IS_DAVICOM(sc) &&\n\t    IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1)\n\t\tdc_setcfg(sc, ifm->ifm_media);\n\telse\n\t\tsc->dc_link = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_ifmedia_upd",
      "void dc_setcfg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_setcfg",
          "args": [
            "sc",
            "ifm->ifm_media"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1061-1165",
          "snippet": "void dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setcfg;\n\nvoid dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "mii"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_ifmedia_upd;\nvoid dc_setcfg;\n\nint dc_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mii_data\t\t*mii;\n\tstruct ifmedia *ifm;\n\n\tsc = ifp->if_softc;\n\tmii = &sc->sc_mii;\n\tmii_mediachg(mii);\n\n\tifm = &mii->mii_media;\n\n\tif (DC_IS_DAVICOM(sc) &&\n\t    IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1)\n\t\tdc_setcfg(sc, ifm->ifm_media);\n\telse\n\t\tsc->dc_link = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2100-2233",
    "snippet": "void dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_tick",
      "void dc_init",
      "void dc_stop",
      "void dc_setcfg",
      "void dc_setfilt",
      "void dc_reset",
      "int dc_list_rx_init",
      "int dc_list_tx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "dc_tick",
            "sc",
            "hz"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_setcfg",
          "args": [
            "sc",
            "sc->dc_if_media"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1061-1165",
          "snippet": "void dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setcfg;\n\nvoid dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "mii"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_RXSTART",
            "0xFFFFFFFF"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_ON"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_setfilt",
          "args": [
            "sc"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setfilt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1040-1054",
          "snippet": "void dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_setfilt_21143",
            "void dc_setfilt_asix",
            "void dc_setfilt_admtek",
            "void dc_setfilt"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setfilt_21143;\nvoid dc_setfilt_asix;\nvoid dc_setfilt_admtek;\nvoid dc_setfilt;\n\nvoid dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_TX_ON"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_ISR",
            "0xFFFFFFFF"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_IMR",
            "DC_INTRS"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_TXADDR",
            "vtophys(&sc->dc_ldata->dc_tx_list[0])"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->dc_ldata->dc_tx_list[0]"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_RXADDR",
            "vtophys(&sc->dc_ldata->dc_rx_list[0])"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->dc_ldata->dc_rx_list[0]"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_list_tx_init",
          "args": [
            "sc"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "dc_list_tx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1328-1353",
          "snippet": "int dc_list_tx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (i == (DC_TX_LIST_CNT - 1)) {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[0]);\n\t\t} else {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[i + 1]);\n\t\t}\n\t\tcd->dc_tx_chain[i] = NULL;\n\t\tld->dc_tx_list[i].dc_data = 0;\n\t\tld->dc_tx_list[i].dc_ctl = 0;\n\t}\n\n\tcd->dc_tx_prod = cd->dc_tx_cons = cd->dc_tx_cnt = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_list_tx_init;\n\nint dc_list_tx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (i == (DC_TX_LIST_CNT - 1)) {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[0]);\n\t\t} else {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[i + 1]);\n\t\t}\n\t\tcd->dc_tx_chain[i] = NULL;\n\t\tld->dc_tx_list[i].dc_data = 0;\n\t\tld->dc_tx_list[i].dc_ctl = 0;\n\t}\n\n\tcd->dc_tx_prod = cd->dc_tx_cons = cd->dc_tx_cnt = 0;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_stop",
          "args": [
            "sc"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "dc_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2394-2444",
          "snippet": "void dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_stop;\n\nvoid dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\"",
            "sc->dc_unit"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_list_rx_init",
          "args": [
            "sc"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "dc_list_rx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1361-1386",
          "snippet": "int dc_list_rx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (dc_newbuf(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (DC_RX_LIST_CNT - 1)) {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[0]);\n\t\t} else {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->dc_rx_prod = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_newbuf",
            "int dc_list_rx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\nint dc_list_rx_init;\n\nint dc_list_rx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (dc_newbuf(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (DC_RX_LIST_CNT - 1)) {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[0]);\n\t\t} else {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->dc_rx_prod = 0;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_TXTHRESH_72BYTES"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_TX_THRESH"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_MX_MAGICPACKET",
            "DC_MX_MAGIC_98715"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_MX_MAGICPACKET",
            "DC_MX_MAGIC_98713"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_MX_MAGICPACKET",
            "0xFFFF0000"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNICII",
          "args": [
            "sc"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_MACRONIX",
          "args": [
            "sc"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_TX_BACKOFF"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_NO_RXCRC"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "sc->dc_txthresh"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_STORENFWD"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_STORENFWD"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_STORENFWD"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_CACHEALIGN_NONE"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_CACHEALIGN_8LONG"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_CACHEALIGN_16LONG"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_CACHEALIGN_32LONG"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_TXPOLL_1"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_BURSTLEN_16LONG"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_BURSTLEN_USECA"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_INTEL",
          "args": [
            "sc"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_BUSCTL_MRME|DC_BUSCTL_MRLE"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_BUSCTL",
            "0"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_ASIX",
          "args": [
            "sc"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_reset",
          "args": [
            "sc"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "dc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1167-1206",
          "snippet": "void dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_reset;\n\nvoid dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_setcfg;\nvoid dc_setfilt;\nvoid dc_reset;\nint dc_list_rx_init;\nint dc_list_tx_init;\n\nvoid dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2041-2098",
    "snippet": "void dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_encap",
      "int dc_coal",
      "void dc_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_TXSTART",
            "0xFFFFFFFF"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m_head"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_encap",
          "args": [
            "sc",
            "m_head",
            "&idx"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "dc_encap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1941-1999",
          "snippet": "int dc_encap(sc, m_head, txidx)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct dc_desc\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tfrag, cur, cnt = 0;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->dc_flags & DC_TX_ADMTEK_WAR) {\n\t\t\t\tif (*txidx != sc->dc_cdata.dc_tx_prod &&\n\t\t\t\t    frag == (DC_TX_LIST_CNT - 1))\n\t\t\t\t\treturn(ENOBUFS);\n\t\t\t}\n\t\t\tif ((DC_TX_LIST_CNT -\n\t\t\t    (sc->dc_cdata.dc_tx_cnt + cnt)) < 5)\n\t\t\t\treturn(ENOBUFS);\n\n\t\t\tf = &sc->dc_ldata->dc_tx_list[frag];\n\t\t\tf->dc_ctl = DC_TXCTL_TLINK | m->m_len;\n\t\t\tif (cnt == 0) {\n\t\t\t\tf->dc_status = 0;\n\t\t\t\tf->dc_ctl |= DC_TXCTL_FIRSTFRAG;\n\t\t\t} else\n\t\t\t\tf->dc_status = DC_TXSTAT_OWN;\n\t\t\tf->dc_data = vtophys(mtod(m, vm_offset_t));\n\t\t\tcur = frag;\n\t\t\tDC_INC(frag, DC_TX_LIST_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc->dc_cdata.dc_tx_cnt += cnt;\n\tsc->dc_cdata.dc_tx_chain[cur] = m_head;\n\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_LASTFRAG;\n\tif (sc->dc_flags & DC_TX_INTR_FIRSTFRAG)\n\t\tsc->dc_ldata->dc_tx_list[*txidx].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_INTR_ALWAYS)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_USE_TX_INTR && sc->dc_cdata.dc_tx_cnt > 64)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tsc->dc_ldata->dc_tx_list[*txidx].dc_status = DC_TXSTAT_OWN;\n\t*txidx = frag;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_encap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_encap;\n\nint dc_encap(sc, m_head, txidx)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct dc_desc\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tfrag, cur, cnt = 0;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->dc_flags & DC_TX_ADMTEK_WAR) {\n\t\t\t\tif (*txidx != sc->dc_cdata.dc_tx_prod &&\n\t\t\t\t    frag == (DC_TX_LIST_CNT - 1))\n\t\t\t\t\treturn(ENOBUFS);\n\t\t\t}\n\t\t\tif ((DC_TX_LIST_CNT -\n\t\t\t    (sc->dc_cdata.dc_tx_cnt + cnt)) < 5)\n\t\t\t\treturn(ENOBUFS);\n\n\t\t\tf = &sc->dc_ldata->dc_tx_list[frag];\n\t\t\tf->dc_ctl = DC_TXCTL_TLINK | m->m_len;\n\t\t\tif (cnt == 0) {\n\t\t\t\tf->dc_status = 0;\n\t\t\t\tf->dc_ctl |= DC_TXCTL_FIRSTFRAG;\n\t\t\t} else\n\t\t\t\tf->dc_status = DC_TXSTAT_OWN;\n\t\t\tf->dc_data = vtophys(mtod(m, vm_offset_t));\n\t\t\tcur = frag;\n\t\t\tDC_INC(frag, DC_TX_LIST_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc->dc_cdata.dc_tx_cnt += cnt;\n\tsc->dc_cdata.dc_tx_chain[cur] = m_head;\n\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_LASTFRAG;\n\tif (sc->dc_flags & DC_TX_INTR_FIRSTFRAG)\n\t\tsc->dc_ldata->dc_tx_list[*txidx].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_INTR_ALWAYS)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_USE_TX_INTR && sc->dc_cdata.dc_tx_cnt > 64)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tsc->dc_ldata->dc_tx_list[*txidx].dc_status = DC_TXSTAT_OWN;\n\t*txidx = frag;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_coal",
          "args": [
            "sc",
            "&m_head"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "dc_coal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2006-2032",
          "snippet": "int dc_coal(sc, m_head)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t**m_head;\n{\n        struct mbuf\t\t*m_new, *m;\n\n\tm = *m_head;\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\treturn(ENOBUFS);\n\t}\n\tif (m->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m->m_pkthdr.len;\n\tm_freem(m);\n\t*m_head = m_new;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_coal"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_coal;\n\nint dc_coal(sc, m_head)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t**m_head;\n{\n        struct mbuf\t\t*m_new, *m;\n\n\tm = *m_head;\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\treturn(ENOBUFS);\n\t}\n\tif (m->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m->m_pkthdr.len;\n\tm_freem(m);\n\t*m_head = m_new;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_encap;\nint dc_coal;\nvoid dc_start;\n\nvoid dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_coal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "2006-2032",
    "snippet": "int dc_coal(sc, m_head)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t**m_head;\n{\n        struct mbuf\t\t*m_new, *m;\n\n\tm = *m_head;\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\treturn(ENOBUFS);\n\t}\n\tif (m->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m->m_pkthdr.len;\n\tm_freem(m);\n\t*m_head = m_new;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_coal"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "0",
            "m->m_pkthdr.len",
            "mtod(m_new, caddr_t)"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: no memory for tx list\"",
            "sc->dc_unit"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_coal;\n\nint dc_coal(sc, m_head)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t**m_head;\n{\n        struct mbuf\t\t*m_new, *m;\n\n\tm = *m_head;\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL) {\n\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\treturn(ENOBUFS);\n\t}\n\tif (m->m_pkthdr.len > MHLEN) {\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\tprintf(\"dc%d: no memory for tx list\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m_new, caddr_t));\n\tm_new->m_pkthdr.len = m_new->m_len = m->m_pkthdr.len;\n\tm_freem(m);\n\t*m_head = m_new;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1941-1999",
    "snippet": "int dc_encap(sc, m_head, txidx)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct dc_desc\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tfrag, cur, cnt = 0;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->dc_flags & DC_TX_ADMTEK_WAR) {\n\t\t\t\tif (*txidx != sc->dc_cdata.dc_tx_prod &&\n\t\t\t\t    frag == (DC_TX_LIST_CNT - 1))\n\t\t\t\t\treturn(ENOBUFS);\n\t\t\t}\n\t\t\tif ((DC_TX_LIST_CNT -\n\t\t\t    (sc->dc_cdata.dc_tx_cnt + cnt)) < 5)\n\t\t\t\treturn(ENOBUFS);\n\n\t\t\tf = &sc->dc_ldata->dc_tx_list[frag];\n\t\t\tf->dc_ctl = DC_TXCTL_TLINK | m->m_len;\n\t\t\tif (cnt == 0) {\n\t\t\t\tf->dc_status = 0;\n\t\t\t\tf->dc_ctl |= DC_TXCTL_FIRSTFRAG;\n\t\t\t} else\n\t\t\t\tf->dc_status = DC_TXSTAT_OWN;\n\t\t\tf->dc_data = vtophys(mtod(m, vm_offset_t));\n\t\t\tcur = frag;\n\t\t\tDC_INC(frag, DC_TX_LIST_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc->dc_cdata.dc_tx_cnt += cnt;\n\tsc->dc_cdata.dc_tx_chain[cur] = m_head;\n\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_LASTFRAG;\n\tif (sc->dc_flags & DC_TX_INTR_FIRSTFRAG)\n\t\tsc->dc_ldata->dc_tx_list[*txidx].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_INTR_ALWAYS)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_USE_TX_INTR && sc->dc_cdata.dc_tx_cnt > 64)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tsc->dc_ldata->dc_tx_list[*txidx].dc_status = DC_TXSTAT_OWN;\n\t*txidx = frag;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_encap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "frag",
            "DC_TX_LIST_CNT"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_encap;\n\nint dc_encap(sc, m_head, txidx)\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head;\n\tu_int32_t\t\t*txidx;\n{\n\tstruct dc_desc\t\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tfrag, cur, cnt = 0;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (sc->dc_flags & DC_TX_ADMTEK_WAR) {\n\t\t\t\tif (*txidx != sc->dc_cdata.dc_tx_prod &&\n\t\t\t\t    frag == (DC_TX_LIST_CNT - 1))\n\t\t\t\t\treturn(ENOBUFS);\n\t\t\t}\n\t\t\tif ((DC_TX_LIST_CNT -\n\t\t\t    (sc->dc_cdata.dc_tx_cnt + cnt)) < 5)\n\t\t\t\treturn(ENOBUFS);\n\n\t\t\tf = &sc->dc_ldata->dc_tx_list[frag];\n\t\t\tf->dc_ctl = DC_TXCTL_TLINK | m->m_len;\n\t\t\tif (cnt == 0) {\n\t\t\t\tf->dc_status = 0;\n\t\t\t\tf->dc_ctl |= DC_TXCTL_FIRSTFRAG;\n\t\t\t} else\n\t\t\t\tf->dc_status = DC_TXSTAT_OWN;\n\t\t\tf->dc_data = vtophys(mtod(m, vm_offset_t));\n\t\t\tcur = frag;\n\t\t\tDC_INC(frag, DC_TX_LIST_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc->dc_cdata.dc_tx_cnt += cnt;\n\tsc->dc_cdata.dc_tx_chain[cur] = m_head;\n\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_LASTFRAG;\n\tif (sc->dc_flags & DC_TX_INTR_FIRSTFRAG)\n\t\tsc->dc_ldata->dc_tx_list[*txidx].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_INTR_ALWAYS)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tif (sc->dc_flags & DC_TX_USE_TX_INTR && sc->dc_cdata.dc_tx_cnt > 64)\n\t\tsc->dc_ldata->dc_tx_list[cur].dc_ctl |= DC_TXCTL_FINT;\n\tsc->dc_ldata->dc_tx_list[*txidx].dc_status = DC_TXSTAT_OWN;\n\t*txidx = frag;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1837-1935",
    "snippet": "int dc_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tstatus;\n\tint\t\t\tclaimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Supress unwanted interrupts */\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tif (CSR_READ_4(sc, DC_ISR) & DC_INTRS)\n\t\t\tdc_stop(sc);\n\t\treturn claimed;\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\n\twhile((status = CSR_READ_4(sc, DC_ISR)) & DC_INTRS) {\n\n\t\tclaimed = 1;\n\n\t\tCSR_WRITE_4(sc, DC_ISR, status);\n\t\tif ((status & DC_INTRS) == 0) {\n\t\t\tclaimed = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status & DC_ISR_RX_OK) {\n\t\t\tint\t\tcurpkts;\n\t\t\tcurpkts = ifp->if_ipackets;\n\t\t\tdc_rxeof(sc);\n\t\t\tif (curpkts == ifp->if_ipackets) {\n\t\t\t\twhile(dc_rx_resync(sc))\n\t\t\t\t\tdc_rxeof(sc);\n\t\t\t}\n\t\t}\n\n\t\tif (status & (DC_ISR_TX_OK|DC_ISR_TX_NOBUF))\n\t\t\tdc_txeof(sc);\n\n\t\tif (status & DC_ISR_TX_IDLE) {\n\t\t\tdc_txeof(sc);\n\t\t\tif (sc->dc_cdata.dc_tx_cnt) {\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\t\t\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\t\t\t}\n\t\t}\n\n\t\tif (status & DC_ISR_TX_UNDERRUN) {\n\t\t\tu_int32_t\t\tcfg;\n\n\t\t\tprintf(\"dc%d: TX underrun -- \", sc->dc_unit);\n\t\t\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc))\n\t\t\t\tdc_init(sc);\n\t\t\tcfg = CSR_READ_4(sc, DC_NETCFG);\n\t\t\tcfg &= ~DC_NETCFG_TX_THRESH;\n\t\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\t\tprintf(\"using store and forward mode\\n\");\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\t} else if (sc->dc_flags & DC_TX_STORENFWD) {\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t} else {\n\t\t\t\tsc->dc_txthresh += 0x4000;\n\t\t\t\tprintf(\"increasing TX threshold\\n\");\n\t\t\t\tCSR_WRITE_4(sc, DC_NETCFG, cfg);\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\t}\n\t\t}\n\n\t\tif ((status & DC_ISR_RX_WATDOGTIMEO)\n\t\t    || (status & DC_ISR_RX_NOBUF)) {\n\t\t\tint\t\tcurpkts;\n\t\t\tcurpkts = ifp->if_ipackets;\n\t\t\tdc_rxeof(sc);\n\t\t\tif (curpkts == ifp->if_ipackets) {\n\t\t\t\twhile(dc_rx_resync(sc))\n\t\t\t\t\tdc_rxeof(sc);\n\t\t\t}\n\t\t}\n\n\t\tif (status & DC_ISR_BUS_ERR) {\n\t\t\tdc_reset(sc);\n\t\t\tdc_init(sc);\n\t\t}\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tdc_start(ifp);\n\n\treturn (claimed);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_intr",
      "int dc_rx_resync",
      "void dc_rxeof",
      "void dc_txeof",
      "void dc_start",
      "void dc_init",
      "void dc_stop",
      "void dc_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_start",
          "args": [
            "ifp"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "dc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2041-2098",
          "snippet": "void dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_encap",
            "int dc_coal",
            "void dc_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_encap;\nint dc_coal;\nvoid dc_start;\n\nvoid dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_IMR",
            "DC_INTRS"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_init",
          "args": [
            "sc"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "dc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2100-2233",
          "snippet": "void dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_init",
            "void dc_stop",
            "void dc_setcfg",
            "void dc_setfilt",
            "void dc_reset",
            "int dc_list_rx_init",
            "int dc_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_setcfg;\nvoid dc_setfilt;\nvoid dc_reset;\nint dc_list_rx_init;\nint dc_list_tx_init;\n\nvoid dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_reset",
          "args": [
            "sc"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "dc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1167-1206",
          "snippet": "void dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_reset;\n\nvoid dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_rxeof",
          "args": [
            "sc"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "dc_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1592-1679",
          "snippet": "void dc_rxeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct dc_desc\t\t*cur_rx;\n\tint\t\t\ti, total_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\ti = sc->dc_cdata.dc_rx_prod;\n\n\twhile(!(sc->dc_ldata->dc_rx_list[i].dc_status & DC_RXSTAT_OWN)) {\n\t\tstruct mbuf\t\t*m0 = NULL;\n\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = cur_rx->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\ttotal_len = DC_RXBYTES(rxstat);\n\n\t\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR) {\n\t\t\tif ((rxstat & DC_WHOLEFRAME) != DC_WHOLEFRAME) {\n\t\t\t\tif (rxstat & DC_RXSTAT_FIRSTFRAG)\n\t\t\t\t\tsc->dc_pnic_rx_bug_save = i;\n\t\t\t\tif ((rxstat & DC_RXSTAT_LASTFRAG) == 0) {\n\t\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdc_pnic_rx_bug_war(sc, i);\n\t\t\t\trxstat = cur_rx->dc_status;\n\t\t\t\ttotal_len = DC_RXBYTES(rxstat);\n\t\t\t}\n\t\t}\n\n\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & DC_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (rxstat & DC_RXSTAT_COLLSEEN)\n\t\t\t\tifp->if_collisions++;\n\t\t\tdc_newbuf(sc, i, m);\n\t\t\tif (rxstat & DC_RXSTAT_CRCERR) {\n\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc->dc_cdata.dc_rx_prod = i;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define DC_WHOLEFRAME\t(DC_RXSTAT_FIRSTFRAG|DC_RXSTAT_LASTFRAG)"
          ],
          "globals_used": [
            "int dc_newbuf",
            "void dc_pnic_rx_bug_war",
            "void dc_rxeof",
            "void dc_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define DC_WHOLEFRAME\t(DC_RXSTAT_FIRSTFRAG|DC_RXSTAT_LASTFRAG)\n\nint dc_newbuf;\nvoid dc_pnic_rx_bug_war;\nvoid dc_rxeof;\nvoid dc_init;\n\nvoid dc_rxeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct dc_desc\t\t*cur_rx;\n\tint\t\t\ti, total_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\ti = sc->dc_cdata.dc_rx_prod;\n\n\twhile(!(sc->dc_ldata->dc_rx_list[i].dc_status & DC_RXSTAT_OWN)) {\n\t\tstruct mbuf\t\t*m0 = NULL;\n\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = cur_rx->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\ttotal_len = DC_RXBYTES(rxstat);\n\n\t\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR) {\n\t\t\tif ((rxstat & DC_WHOLEFRAME) != DC_WHOLEFRAME) {\n\t\t\t\tif (rxstat & DC_RXSTAT_FIRSTFRAG)\n\t\t\t\t\tsc->dc_pnic_rx_bug_save = i;\n\t\t\t\tif ((rxstat & DC_RXSTAT_LASTFRAG) == 0) {\n\t\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdc_pnic_rx_bug_war(sc, i);\n\t\t\t\trxstat = cur_rx->dc_status;\n\t\t\t\ttotal_len = DC_RXBYTES(rxstat);\n\t\t\t}\n\t\t}\n\n\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & DC_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (rxstat & DC_RXSTAT_COLLSEEN)\n\t\t\t\tifp->if_collisions++;\n\t\t\tdc_newbuf(sc, i, m);\n\t\t\tif (rxstat & DC_RXSTAT_CRCERR) {\n\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc->dc_cdata.dc_rx_prod = i;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_rx_resync",
          "args": [
            "sc"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "dc_rx_resync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1563-1586",
          "snippet": "int dc_rx_resync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\ti, pos;\n\tstruct dc_desc\t\t*cur_rx;\n\n\tpos = sc->dc_cdata.dc_rx_prod;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[pos];\n\t\tif (!(cur_rx->dc_status & DC_RXSTAT_OWN))\n\t\t\tbreak;\n\t\tDC_INC(pos, DC_RX_LIST_CNT);\n\t}\n\n\t/* If the ring really is empty, then just return. */\n\tif (i == DC_RX_LIST_CNT)\n\t\treturn(0);\n\n\t/* We've fallen behing the chip: catch it. */\n\tsc->dc_cdata.dc_rx_prod = pos;\n\n\treturn(EAGAIN);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_rx_resync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_rx_resync;\n\nint dc_rx_resync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\ti, pos;\n\tstruct dc_desc\t\t*cur_rx;\n\n\tpos = sc->dc_cdata.dc_rx_prod;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[pos];\n\t\tif (!(cur_rx->dc_status & DC_RXSTAT_OWN))\n\t\t\tbreak;\n\t\tDC_INC(pos, DC_RX_LIST_CNT);\n\t}\n\n\t/* If the ring really is empty, then just return. */\n\tif (i == DC_RX_LIST_CNT)\n\t\treturn(0);\n\n\t/* We've fallen behing the chip: catch it. */\n\tsc->dc_cdata.dc_rx_prod = pos;\n\n\treturn(EAGAIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_STORENFWD"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "sc->dc_txthresh"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_NETCFG",
            "cfg"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"increasing TX threshold\\n\""
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_STORENFWD"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_NETCFG"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_INTEL",
          "args": [
            "sc"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_TXSTART",
            "0xFFFFFFFF"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_TX_ON"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_txeof",
          "args": [
            "sc"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "dc_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1686-1770",
          "snippet": "void dc_txeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\tidx = sc->dc_cdata.dc_tx_cons;\n\twhile(idx != sc->dc_cdata.dc_tx_prod) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = &sc->dc_ldata->dc_tx_list[idx];\n\t\ttxstat = cur_tx->dc_status;\n\n\t\tif (txstat & DC_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (!(cur_tx->dc_ctl & DC_TXCTL_LASTFRAG) ||\n\t\t    cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\t\tif (cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\t\t/*\n\t\t\t\t * Yes, the PNIC is so brain damaged\n\t\t\t\t * that it will sometimes generate a TX\n\t\t\t\t * underrun error while DMAing the RX\n\t\t\t\t * filter setup frame. If we detect this,\n\t\t\t\t * we have to send the setup frame again,\n\t\t\t\t * or else the filter won't be programmed\n\t\t\t\t * correctly.\n\t\t\t\t */\n\t\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\t\tif (txstat & DC_TXSTAT_ERRSUM)\n\t\t\t\t\t\tdc_setfilt(sc);\n\t\t\t\t}\n\t\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t\t}\n\t\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (/*sc->dc_type == DC_TYPE_21143 &&*/\n\t\t    sc->dc_pmode == DC_PMODE_MII &&\n\t\t    ((txstat & 0xFFFF) & ~(DC_TXSTAT_ERRSUM|\n\t\t    DC_TXSTAT_NOCARRIER|DC_TXSTAT_CARRLOST)))\n\t\t\ttxstat &= ~DC_TXSTAT_ERRSUM;\n\n\t\tif (txstat & DC_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & DC_TXSTAT_EXCESSCOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & DC_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (!(txstat & DC_TXSTAT_UNDERRUN)) {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_collisions += (txstat & DC_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n\t\tif (sc->dc_cdata.dc_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[idx]);\n\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t}\n\n\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t}\n\n\tsc->dc_cdata.dc_tx_cons = idx;\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_txeof",
            "void dc_init",
            "void dc_setfilt"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_txeof;\nvoid dc_init;\nvoid dc_setfilt;\n\nvoid dc_txeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\tidx = sc->dc_cdata.dc_tx_cons;\n\twhile(idx != sc->dc_cdata.dc_tx_prod) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = &sc->dc_ldata->dc_tx_list[idx];\n\t\ttxstat = cur_tx->dc_status;\n\n\t\tif (txstat & DC_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (!(cur_tx->dc_ctl & DC_TXCTL_LASTFRAG) ||\n\t\t    cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\t\tif (cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\t\t/*\n\t\t\t\t * Yes, the PNIC is so brain damaged\n\t\t\t\t * that it will sometimes generate a TX\n\t\t\t\t * underrun error while DMAing the RX\n\t\t\t\t * filter setup frame. If we detect this,\n\t\t\t\t * we have to send the setup frame again,\n\t\t\t\t * or else the filter won't be programmed\n\t\t\t\t * correctly.\n\t\t\t\t */\n\t\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\t\tif (txstat & DC_TXSTAT_ERRSUM)\n\t\t\t\t\t\tdc_setfilt(sc);\n\t\t\t\t}\n\t\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t\t}\n\t\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (/*sc->dc_type == DC_TYPE_21143 &&*/\n\t\t    sc->dc_pmode == DC_PMODE_MII &&\n\t\t    ((txstat & 0xFFFF) & ~(DC_TXSTAT_ERRSUM|\n\t\t    DC_TXSTAT_NOCARRIER|DC_TXSTAT_CARRLOST)))\n\t\t\ttxstat &= ~DC_TXSTAT_ERRSUM;\n\n\t\tif (txstat & DC_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & DC_TXSTAT_EXCESSCOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & DC_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (!(txstat & DC_TXSTAT_UNDERRUN)) {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_collisions += (txstat & DC_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n\t\tif (sc->dc_cdata.dc_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[idx]);\n\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t}\n\n\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t}\n\n\tsc->dc_cdata.dc_tx_cons = idx;\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_ISR",
            "status"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_ISR"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_IMR",
            "0x00000000"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_stop",
          "args": [
            "sc"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "dc_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2394-2444",
          "snippet": "void dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_stop;\n\nvoid dc_stop(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tuntimeout(dc_tick, sc);\n\n\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_RX_ON|DC_NETCFG_TX_ON));\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_RXADDR, 0x00000000);\n\tsc->dc_link = 0;\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_rx_chain[i] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_rx_chain[i]);\n\t\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->dc_ldata->dc_rx_list,\n\t\tsizeof(sc->dc_ldata->dc_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (sc->dc_cdata.dc_tx_chain[i] != NULL) {\n\t\t\tif (sc->dc_ldata->dc_tx_list[i].dc_ctl &\n\t\t\t    DC_TXCTL_SETUP) {\n\t\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[i]);\n\t\t\tsc->dc_cdata.dc_tx_chain[i] = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->dc_ldata->dc_tx_list,\n\t\tsizeof(sc->dc_ldata->dc_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_ISR"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_intr;\nint dc_rx_resync;\nvoid dc_rxeof;\nvoid dc_txeof;\nvoid dc_start;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_reset;\n\nint dc_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tstatus;\n\tint\t\t\tclaimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Supress unwanted interrupts */\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tif (CSR_READ_4(sc, DC_ISR) & DC_INTRS)\n\t\t\tdc_stop(sc);\n\t\treturn claimed;\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\n\twhile((status = CSR_READ_4(sc, DC_ISR)) & DC_INTRS) {\n\n\t\tclaimed = 1;\n\n\t\tCSR_WRITE_4(sc, DC_ISR, status);\n\t\tif ((status & DC_INTRS) == 0) {\n\t\t\tclaimed = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status & DC_ISR_RX_OK) {\n\t\t\tint\t\tcurpkts;\n\t\t\tcurpkts = ifp->if_ipackets;\n\t\t\tdc_rxeof(sc);\n\t\t\tif (curpkts == ifp->if_ipackets) {\n\t\t\t\twhile(dc_rx_resync(sc))\n\t\t\t\t\tdc_rxeof(sc);\n\t\t\t}\n\t\t}\n\n\t\tif (status & (DC_ISR_TX_OK|DC_ISR_TX_NOBUF))\n\t\t\tdc_txeof(sc);\n\n\t\tif (status & DC_ISR_TX_IDLE) {\n\t\t\tdc_txeof(sc);\n\t\t\tif (sc->dc_cdata.dc_tx_cnt) {\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\t\t\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\t\t\t}\n\t\t}\n\n\t\tif (status & DC_ISR_TX_UNDERRUN) {\n\t\t\tu_int32_t\t\tcfg;\n\n\t\t\tprintf(\"dc%d: TX underrun -- \", sc->dc_unit);\n\t\t\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc))\n\t\t\t\tdc_init(sc);\n\t\t\tcfg = CSR_READ_4(sc, DC_NETCFG);\n\t\t\tcfg &= ~DC_NETCFG_TX_THRESH;\n\t\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\t\tprintf(\"using store and forward mode\\n\");\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\t} else if (sc->dc_flags & DC_TX_STORENFWD) {\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t} else {\n\t\t\t\tsc->dc_txthresh += 0x4000;\n\t\t\t\tprintf(\"increasing TX threshold\\n\");\n\t\t\t\tCSR_WRITE_4(sc, DC_NETCFG, cfg);\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\t}\n\t\t}\n\n\t\tif ((status & DC_ISR_RX_WATDOGTIMEO)\n\t\t    || (status & DC_ISR_RX_NOBUF)) {\n\t\t\tint\t\tcurpkts;\n\t\t\tcurpkts = ifp->if_ipackets;\n\t\t\tdc_rxeof(sc);\n\t\t\tif (curpkts == ifp->if_ipackets) {\n\t\t\t\twhile(dc_rx_resync(sc))\n\t\t\t\t\tdc_rxeof(sc);\n\t\t\t}\n\t\t}\n\n\t\tif (status & DC_ISR_BUS_ERR) {\n\t\t\tdc_reset(sc);\n\t\t\tdc_init(sc);\n\t\t}\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tdc_start(ifp);\n\n\treturn (claimed);\n}"
  },
  {
    "function_name": "dc_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1772-1835",
    "snippet": "void dc_tick(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)xsc;\n\tstruct mii_data\t\t*mii;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\tu_int32_t\t\tr;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\tmii = &sc->sc_mii;\n\n\tif (sc->dc_flags & DC_REDUCED_MII_POLL) {\n\t\tr = CSR_READ_4(sc, DC_ISR);\n\t\tif (DC_IS_INTEL(sc)) {\n\t\t\tif (r & DC_ISR_LINKFAIL) \n\t\t\t\tsc->dc_link = 0;\n\t\t\tif (sc->dc_link == 0)\n\t\t\t\tmii_tick(mii);\n\t\t} else {\n\t\t\tif ((r & DC_ISR_RX_STATE) == DC_RXSTATE_WAIT &&\n\t\t\t    sc->dc_cdata.dc_tx_prod == 0)\n\t\t\t\tmii_tick(mii);\n\t\t}\n\t} else\n\t\tmii_tick(mii);\n\n\t/*\n\t * When the init routine completes, we expect to be able to send\n\t * packets right away, and in fact the network code will send a\n\t * gratuitous ARP the moment the init routine marks the interface\n\t * as running. However, even though the MAC may have been initialized,\n\t * there may be a delay of a few seconds before the PHY completes\n\t * autonegotiation and the link is brought up. Any transmissions\n\t * made during that delay will be lost. Dealing with this is tricky:\n\t * we can't just pause in the init routine while waiting for the\n\t * PHY to come ready since that would bring the whole system to\n\t * a screeching halt for several seconds.\n\t *\n\t * What we do here is prevent the TX start routine from sending\n\t * any packets until a link has been established. After the\n\t * interface has been initialized, the tick routine will poll\n\t * the state of the PHY until the IFM_ACTIVE flag is set. Until\n\t * that time, packets will stay in the send queue, and once the\n\t * link comes up, they will be flushed out to the wire.\n\t */\n\tif (!sc->dc_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {\n\t\t\tsc->dc_link++;\n\t\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\t\tdc_start(ifp);\n\t\t}\n\t}\n\n\ttimeout(dc_tick, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_tick",
      "void dc_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "dc_tick",
            "sc",
            "hz"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_start",
          "args": [
            "ifp"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "dc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2041-2098",
          "snippet": "void dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_encap",
            "int dc_coal",
            "void dc_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_encap;\nint dc_coal;\nvoid dc_start;\n\nvoid dc_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct dc_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tint\t\t\tidx;\n\n\tsc = ifp->if_softc;\n\n\tif (!sc->dc_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->dc_cdata.dc_tx_prod;\n\n\twhile(sc->dc_cdata.dc_tx_chain[idx] == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tif (sc->dc_flags & DC_TX_COALESCE) {\n\t\t\tif (dc_coal(sc, &m_head)) {\n\t\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_encap(sc, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc->dc_cdata.dc_tx_prod = idx;\n\tif (!(sc->dc_flags & DC_TX_POLL))\n\t\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "mii->mii_media_active"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "mii"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_tick",
          "args": [
            "mii"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "mii_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "192-201",
          "snippet": "void\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_INTEL",
          "args": [
            "sc"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_ISR"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_start;\n\nvoid dc_tick(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)xsc;\n\tstruct mii_data\t\t*mii;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\tu_int32_t\t\tr;\n\n\ts = splimp();\n\n\tifp = &sc->arpcom.ac_if;\n\tmii = &sc->sc_mii;\n\n\tif (sc->dc_flags & DC_REDUCED_MII_POLL) {\n\t\tr = CSR_READ_4(sc, DC_ISR);\n\t\tif (DC_IS_INTEL(sc)) {\n\t\t\tif (r & DC_ISR_LINKFAIL) \n\t\t\t\tsc->dc_link = 0;\n\t\t\tif (sc->dc_link == 0)\n\t\t\t\tmii_tick(mii);\n\t\t} else {\n\t\t\tif ((r & DC_ISR_RX_STATE) == DC_RXSTATE_WAIT &&\n\t\t\t    sc->dc_cdata.dc_tx_prod == 0)\n\t\t\t\tmii_tick(mii);\n\t\t}\n\t} else\n\t\tmii_tick(mii);\n\n\t/*\n\t * When the init routine completes, we expect to be able to send\n\t * packets right away, and in fact the network code will send a\n\t * gratuitous ARP the moment the init routine marks the interface\n\t * as running. However, even though the MAC may have been initialized,\n\t * there may be a delay of a few seconds before the PHY completes\n\t * autonegotiation and the link is brought up. Any transmissions\n\t * made during that delay will be lost. Dealing with this is tricky:\n\t * we can't just pause in the init routine while waiting for the\n\t * PHY to come ready since that would bring the whole system to\n\t * a screeching halt for several seconds.\n\t *\n\t * What we do here is prevent the TX start routine from sending\n\t * any packets until a link has been established. After the\n\t * interface has been initialized, the tick routine will poll\n\t * the state of the PHY until the IFM_ACTIVE flag is set. Until\n\t * that time, packets will stay in the send queue, and once the\n\t * link comes up, they will be flushed out to the wire.\n\t */\n\tif (!sc->dc_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {\n\t\t\tsc->dc_link++;\n\t\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\t\tdc_start(ifp);\n\t\t}\n\t}\n\n\ttimeout(dc_tick, sc, hz);\n\n\tsplx(s);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1686-1770",
    "snippet": "void dc_txeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\tidx = sc->dc_cdata.dc_tx_cons;\n\twhile(idx != sc->dc_cdata.dc_tx_prod) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = &sc->dc_ldata->dc_tx_list[idx];\n\t\ttxstat = cur_tx->dc_status;\n\n\t\tif (txstat & DC_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (!(cur_tx->dc_ctl & DC_TXCTL_LASTFRAG) ||\n\t\t    cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\t\tif (cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\t\t/*\n\t\t\t\t * Yes, the PNIC is so brain damaged\n\t\t\t\t * that it will sometimes generate a TX\n\t\t\t\t * underrun error while DMAing the RX\n\t\t\t\t * filter setup frame. If we detect this,\n\t\t\t\t * we have to send the setup frame again,\n\t\t\t\t * or else the filter won't be programmed\n\t\t\t\t * correctly.\n\t\t\t\t */\n\t\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\t\tif (txstat & DC_TXSTAT_ERRSUM)\n\t\t\t\t\t\tdc_setfilt(sc);\n\t\t\t\t}\n\t\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t\t}\n\t\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (/*sc->dc_type == DC_TYPE_21143 &&*/\n\t\t    sc->dc_pmode == DC_PMODE_MII &&\n\t\t    ((txstat & 0xFFFF) & ~(DC_TXSTAT_ERRSUM|\n\t\t    DC_TXSTAT_NOCARRIER|DC_TXSTAT_CARRLOST)))\n\t\t\ttxstat &= ~DC_TXSTAT_ERRSUM;\n\n\t\tif (txstat & DC_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & DC_TXSTAT_EXCESSCOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & DC_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (!(txstat & DC_TXSTAT_UNDERRUN)) {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_collisions += (txstat & DC_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n\t\tif (sc->dc_cdata.dc_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[idx]);\n\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t}\n\n\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t}\n\n\tsc->dc_cdata.dc_tx_cons = idx;\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_txeof",
      "void dc_init",
      "void dc_setfilt"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "idx",
            "DC_TX_LIST_CNT"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->dc_cdata.dc_tx_chain[idx]"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_init",
          "args": [
            "sc"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "dc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2100-2233",
          "snippet": "void dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_init",
            "void dc_stop",
            "void dc_setcfg",
            "void dc_setfilt",
            "void dc_reset",
            "int dc_list_rx_init",
            "int dc_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_setcfg;\nvoid dc_setfilt;\nvoid dc_reset;\nint dc_list_rx_init;\nint dc_list_tx_init;\n\nvoid dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "idx",
            "DC_TX_LIST_CNT"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_setfilt",
          "args": [
            "sc"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setfilt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1040-1054",
          "snippet": "void dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_setfilt_21143",
            "void dc_setfilt_asix",
            "void dc_setfilt_admtek",
            "void dc_setfilt"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setfilt_21143;\nvoid dc_setfilt_asix;\nvoid dc_setfilt_admtek;\nvoid dc_setfilt;\n\nvoid dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_txeof;\nvoid dc_init;\nvoid dc_setfilt;\n\nvoid dc_txeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tidx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\tidx = sc->dc_cdata.dc_tx_cons;\n\twhile(idx != sc->dc_cdata.dc_tx_prod) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = &sc->dc_ldata->dc_tx_list[idx];\n\t\ttxstat = cur_tx->dc_status;\n\n\t\tif (txstat & DC_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (!(cur_tx->dc_ctl & DC_TXCTL_LASTFRAG) ||\n\t\t    cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\t\tif (cur_tx->dc_ctl & DC_TXCTL_SETUP) {\n\t\t\t\t/*\n\t\t\t\t * Yes, the PNIC is so brain damaged\n\t\t\t\t * that it will sometimes generate a TX\n\t\t\t\t * underrun error while DMAing the RX\n\t\t\t\t * filter setup frame. If we detect this,\n\t\t\t\t * we have to send the setup frame again,\n\t\t\t\t * or else the filter won't be programmed\n\t\t\t\t * correctly.\n\t\t\t\t */\n\t\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\t\tif (txstat & DC_TXSTAT_ERRSUM)\n\t\t\t\t\t\tdc_setfilt(sc);\n\t\t\t\t}\n\t\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t\t}\n\t\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (/*sc->dc_type == DC_TYPE_21143 &&*/\n\t\t    sc->dc_pmode == DC_PMODE_MII &&\n\t\t    ((txstat & 0xFFFF) & ~(DC_TXSTAT_ERRSUM|\n\t\t    DC_TXSTAT_NOCARRIER|DC_TXSTAT_CARRLOST)))\n\t\t\ttxstat &= ~DC_TXSTAT_ERRSUM;\n\n\t\tif (txstat & DC_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & DC_TXSTAT_EXCESSCOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & DC_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (!(txstat & DC_TXSTAT_UNDERRUN)) {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tifp->if_collisions += (txstat & DC_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n\t\tif (sc->dc_cdata.dc_tx_chain[idx] != NULL) {\n\t\t\tm_freem(sc->dc_cdata.dc_tx_chain[idx]);\n\t\t\tsc->dc_cdata.dc_tx_chain[idx] = NULL;\n\t\t}\n\n\t\tsc->dc_cdata.dc_tx_cnt--;\n\t\tDC_INC(idx, DC_TX_LIST_CNT);\n\t}\n\n\tsc->dc_cdata.dc_tx_cons = idx;\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1592-1679",
    "snippet": "void dc_rxeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct dc_desc\t\t*cur_rx;\n\tint\t\t\ti, total_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\ti = sc->dc_cdata.dc_rx_prod;\n\n\twhile(!(sc->dc_ldata->dc_rx_list[i].dc_status & DC_RXSTAT_OWN)) {\n\t\tstruct mbuf\t\t*m0 = NULL;\n\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = cur_rx->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\ttotal_len = DC_RXBYTES(rxstat);\n\n\t\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR) {\n\t\t\tif ((rxstat & DC_WHOLEFRAME) != DC_WHOLEFRAME) {\n\t\t\t\tif (rxstat & DC_RXSTAT_FIRSTFRAG)\n\t\t\t\t\tsc->dc_pnic_rx_bug_save = i;\n\t\t\t\tif ((rxstat & DC_RXSTAT_LASTFRAG) == 0) {\n\t\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdc_pnic_rx_bug_war(sc, i);\n\t\t\t\trxstat = cur_rx->dc_status;\n\t\t\t\ttotal_len = DC_RXBYTES(rxstat);\n\t\t\t}\n\t\t}\n\n\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & DC_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (rxstat & DC_RXSTAT_COLLSEEN)\n\t\t\t\tifp->if_collisions++;\n\t\t\tdc_newbuf(sc, i, m);\n\t\t\tif (rxstat & DC_RXSTAT_CRCERR) {\n\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc->dc_cdata.dc_rx_prod = i;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define DC_WHOLEFRAME\t(DC_RXSTAT_FIRSTFRAG|DC_RXSTAT_LASTFRAG)"
    ],
    "globals_used": [
      "int dc_newbuf",
      "void dc_pnic_rx_bug_war",
      "void dc_rxeof",
      "void dc_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m0",
            "ETHER_ALIGN"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "i",
            "DC_RX_LIST_CNT"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_newbuf",
          "args": [
            "sc",
            "i",
            "m"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "dc_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1391-1439",
          "snippet": "int dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\n\nint dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_devget",
          "args": [
            "mtod(m, char *) - ETHER_ALIGN",
            "total_len + ETHER_ALIGN",
            "0",
            "ifp",
            "NULL"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "char*"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_init",
          "args": [
            "sc"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "dc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "2100-2233",
          "snippet": "void dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_tick",
            "void dc_init",
            "void dc_stop",
            "void dc_setcfg",
            "void dc_setfilt",
            "void dc_reset",
            "int dc_list_rx_init",
            "int dc_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_tick;\nvoid dc_init;\nvoid dc_stop;\nvoid dc_setcfg;\nvoid dc_setfilt;\nvoid dc_reset;\nint dc_list_rx_init;\nint dc_list_tx_init;\n\nvoid dc_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct dc_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tmii = &sc->sc_mii;\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tdc_stop(sc);\n\tdc_reset(sc);\n\n\t/*\n\t * Set cache alignment and burst length.\n\t */\n\tif (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc))\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, 0);\n\telse\n\t\tCSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME|DC_BUSCTL_MRLE);\n\tif (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);\n\t} else {\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);\n\t}\n\tif (sc->dc_flags & DC_TX_POLL)\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);\n\tswitch(sc->dc_cachesize) {\n\tcase 32:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);\n\t\tbreak;\n\tcase 16:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);\n\t\tbreak; \n\tcase 8:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);\n\t\tbreak;  \n\tcase 0:\n\tdefault:\n\t\tDC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);\n\t\tbreak;\n\t}\n\n\tif (sc->dc_flags & DC_TX_STORENFWD)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\telse {\n\t\tif (sc->dc_txthresh == DC_TXTHRESH_160BYTES) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, sc->dc_txthresh);\n\t\t}\n\t}\n\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);\n\n\tif (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {\n\t\t/*\n\t\t * The app notes for the 98713 and 98715A say that\n\t\t * in order to have the chips operate properly, a magic\n\t\t * number must be written to CSR16. Macronix does not\n\t\t * document the meaning of these bits so there's no way\n\t\t * to know exactly what they do. The 98713 has a magic\n\t\t * number all its own; the rest all use a different one.\n\t\t */\n\t\tDC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);\n\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);\n\t\telse\n\t\t\tDC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);\n\t}\n\n\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);\n\tDC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_72BYTES);\n\n\t/* Init circular RX list. */\n\tif (dc_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"dc%d: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc->dc_unit);\n\t\tdc_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tdc_list_tx_init(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, DC_RXADDR, vtophys(&sc->dc_ldata->dc_rx_list[0]));\n\tCSR_WRITE_4(sc, DC_TXADDR, vtophys(&sc->dc_ldata->dc_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_4(sc, DC_IMR, DC_INTRS);\n\tCSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);\n\n\t/* Enable transmitter. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);\n\n\t/*\n\t * Load the RX/multicast filter. We do this sort of late\n\t * because the filter programming scheme on the 21143 and\n\t * some clones requires DMAing a setup frame via the TX\n\t * engine, and we need the transmitter enabled for that.\n\t */\n\tdc_setfilt(sc);\n\n\t/* Enable receiver. */\n\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);\n\tCSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);\n\n\tmii_mediachg(mii);\n\tdc_setcfg(sc, sc->dc_if_media);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(dc_tick, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "i",
            "DC_RX_LIST_CNT"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_RXBYTES",
          "args": [
            "rxstat"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_pnic_rx_bug_war",
          "args": [
            "sc",
            "i"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "dc_pnic_rx_bug_war",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1494-1550",
          "snippet": "void dc_pnic_rx_bug_war(sc, idx)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tidx;\n{\n\tstruct dc_desc\t\t*cur_rx;\n\tstruct dc_desc\t\t*c = NULL;\n\tstruct mbuf\t\t*m = NULL;\n\tunsigned char\t\t*ptr;\n\tint\t\t\ti, total_len;\n\tu_int32_t\t\trxstat = 0;\n\n\ti = sc->dc_pnic_rx_bug_save;\n\tcur_rx = &sc->dc_ldata->dc_rx_list[idx];\n\tptr = sc->dc_pnic_rx_buf;\n\tbzero(ptr, sizeof(DC_RXLEN * 5));\n\n\t/* Copy all the bytes from the bogus buffers. */\n\twhile (1) {\n\t\tc = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = c->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\tbcopy(mtod(m, char *), ptr, DC_RXLEN);\n\t\tptr += DC_RXLEN;\n\t\t/* If this is the last buffer, break out. */\n\t\tif (i == idx || rxstat & DC_RXSTAT_LASTFRAG)\n\t\t\tbreak;\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t}\n\n\t/* Find the length of the actual receive frame. */\n\ttotal_len = DC_RXBYTES(rxstat);\n\n\t/* Scan backwards until we hit a non-zero byte. */\n\twhile(*ptr == 0x00)\n\t\tptr--;\n\n\t/* Round off. */\n\tif ((unsigned long)(ptr) & 0x3)\n\t\tptr -= 1;\n\n\t/* Now find the start of the frame. */\n\tptr -= total_len;\n\tif (ptr < sc->dc_pnic_rx_buf)\n\t\tptr = sc->dc_pnic_rx_buf;\n\n\t/*\n\t * Now copy the salvaged frame to the last mbuf and fake up\n\t * the status word to make it look like a successful\n \t * frame reception.\n\t */\n\tdc_newbuf(sc, i, m);\n\tbcopy(ptr, mtod(m, char *), total_len);\t\n\tcur_rx->dc_status = rxstat | DC_RXSTAT_FIRSTFRAG;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_newbuf",
            "void dc_pnic_rx_bug_war"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\nvoid dc_pnic_rx_bug_war;\n\nvoid dc_pnic_rx_bug_war(sc, idx)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tidx;\n{\n\tstruct dc_desc\t\t*cur_rx;\n\tstruct dc_desc\t\t*c = NULL;\n\tstruct mbuf\t\t*m = NULL;\n\tunsigned char\t\t*ptr;\n\tint\t\t\ti, total_len;\n\tu_int32_t\t\trxstat = 0;\n\n\ti = sc->dc_pnic_rx_bug_save;\n\tcur_rx = &sc->dc_ldata->dc_rx_list[idx];\n\tptr = sc->dc_pnic_rx_buf;\n\tbzero(ptr, sizeof(DC_RXLEN * 5));\n\n\t/* Copy all the bytes from the bogus buffers. */\n\twhile (1) {\n\t\tc = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = c->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\tbcopy(mtod(m, char *), ptr, DC_RXLEN);\n\t\tptr += DC_RXLEN;\n\t\t/* If this is the last buffer, break out. */\n\t\tif (i == idx || rxstat & DC_RXSTAT_LASTFRAG)\n\t\t\tbreak;\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t}\n\n\t/* Find the length of the actual receive frame. */\n\ttotal_len = DC_RXBYTES(rxstat);\n\n\t/* Scan backwards until we hit a non-zero byte. */\n\twhile(*ptr == 0x00)\n\t\tptr--;\n\n\t/* Round off. */\n\tif ((unsigned long)(ptr) & 0x3)\n\t\tptr -= 1;\n\n\t/* Now find the start of the frame. */\n\tptr -= total_len;\n\tif (ptr < sc->dc_pnic_rx_buf)\n\t\tptr = sc->dc_pnic_rx_buf;\n\n\t/*\n\t * Now copy the salvaged frame to the last mbuf and fake up\n\t * the status word to make it look like a successful\n \t * frame reception.\n\t */\n\tdc_newbuf(sc, i, m);\n\tbcopy(ptr, mtod(m, char *), total_len);\t\n\tcur_rx->dc_status = rxstat | DC_RXSTAT_FIRSTFRAG;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "i",
            "DC_RX_LIST_CNT"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_RXBYTES",
          "args": [
            "rxstat"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define DC_WHOLEFRAME\t(DC_RXSTAT_FIRSTFRAG|DC_RXSTAT_LASTFRAG)\n\nint dc_newbuf;\nvoid dc_pnic_rx_bug_war;\nvoid dc_rxeof;\nvoid dc_init;\n\nvoid dc_rxeof(sc)\n\tstruct dc_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct dc_desc\t\t*cur_rx;\n\tint\t\t\ti, total_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\ti = sc->dc_cdata.dc_rx_prod;\n\n\twhile(!(sc->dc_ldata->dc_rx_list[i].dc_status & DC_RXSTAT_OWN)) {\n\t\tstruct mbuf\t\t*m0 = NULL;\n\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = cur_rx->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\ttotal_len = DC_RXBYTES(rxstat);\n\n\t\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR) {\n\t\t\tif ((rxstat & DC_WHOLEFRAME) != DC_WHOLEFRAME) {\n\t\t\t\tif (rxstat & DC_RXSTAT_FIRSTFRAG)\n\t\t\t\t\tsc->dc_pnic_rx_bug_save = i;\n\t\t\t\tif ((rxstat & DC_RXSTAT_LASTFRAG) == 0) {\n\t\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdc_pnic_rx_bug_war(sc, i);\n\t\t\t\trxstat = cur_rx->dc_status;\n\t\t\t\ttotal_len = DC_RXBYTES(rxstat);\n\t\t\t}\n\t\t}\n\n\t\tsc->dc_cdata.dc_rx_chain[i] = NULL;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & DC_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tif (rxstat & DC_RXSTAT_COLLSEEN)\n\t\t\t\tifp->if_collisions++;\n\t\t\tdc_newbuf(sc, i, m);\n\t\t\tif (rxstat & DC_RXSTAT_CRCERR) {\n\t\t\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tdc_init(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t\tif (m0 == NULL) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcontinue;\n\t\t}\n\t\tm_adj(m0, ETHER_ALIGN);\n\t\tm = m0;\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc->dc_cdata.dc_rx_prod = i;\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_rx_resync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1563-1586",
    "snippet": "int dc_rx_resync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\ti, pos;\n\tstruct dc_desc\t\t*cur_rx;\n\n\tpos = sc->dc_cdata.dc_rx_prod;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[pos];\n\t\tif (!(cur_rx->dc_status & DC_RXSTAT_OWN))\n\t\t\tbreak;\n\t\tDC_INC(pos, DC_RX_LIST_CNT);\n\t}\n\n\t/* If the ring really is empty, then just return. */\n\tif (i == DC_RX_LIST_CNT)\n\t\treturn(0);\n\n\t/* We've fallen behing the chip: catch it. */\n\tsc->dc_cdata.dc_rx_prod = pos;\n\n\treturn(EAGAIN);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_rx_resync"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "pos",
            "DC_RX_LIST_CNT"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_rx_resync;\n\nint dc_rx_resync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\ti, pos;\n\tstruct dc_desc\t\t*cur_rx;\n\n\tpos = sc->dc_cdata.dc_rx_prod;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tcur_rx = &sc->dc_ldata->dc_rx_list[pos];\n\t\tif (!(cur_rx->dc_status & DC_RXSTAT_OWN))\n\t\t\tbreak;\n\t\tDC_INC(pos, DC_RX_LIST_CNT);\n\t}\n\n\t/* If the ring really is empty, then just return. */\n\tif (i == DC_RX_LIST_CNT)\n\t\treturn(0);\n\n\t/* We've fallen behing the chip: catch it. */\n\tsc->dc_cdata.dc_rx_prod = pos;\n\n\treturn(EAGAIN);\n}"
  },
  {
    "function_name": "dc_pnic_rx_bug_war",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1494-1550",
    "snippet": "void dc_pnic_rx_bug_war(sc, idx)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tidx;\n{\n\tstruct dc_desc\t\t*cur_rx;\n\tstruct dc_desc\t\t*c = NULL;\n\tstruct mbuf\t\t*m = NULL;\n\tunsigned char\t\t*ptr;\n\tint\t\t\ti, total_len;\n\tu_int32_t\t\trxstat = 0;\n\n\ti = sc->dc_pnic_rx_bug_save;\n\tcur_rx = &sc->dc_ldata->dc_rx_list[idx];\n\tptr = sc->dc_pnic_rx_buf;\n\tbzero(ptr, sizeof(DC_RXLEN * 5));\n\n\t/* Copy all the bytes from the bogus buffers. */\n\twhile (1) {\n\t\tc = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = c->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\tbcopy(mtod(m, char *), ptr, DC_RXLEN);\n\t\tptr += DC_RXLEN;\n\t\t/* If this is the last buffer, break out. */\n\t\tif (i == idx || rxstat & DC_RXSTAT_LASTFRAG)\n\t\t\tbreak;\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t}\n\n\t/* Find the length of the actual receive frame. */\n\ttotal_len = DC_RXBYTES(rxstat);\n\n\t/* Scan backwards until we hit a non-zero byte. */\n\twhile(*ptr == 0x00)\n\t\tptr--;\n\n\t/* Round off. */\n\tif ((unsigned long)(ptr) & 0x3)\n\t\tptr -= 1;\n\n\t/* Now find the start of the frame. */\n\tptr -= total_len;\n\tif (ptr < sc->dc_pnic_rx_buf)\n\t\tptr = sc->dc_pnic_rx_buf;\n\n\t/*\n\t * Now copy the salvaged frame to the last mbuf and fake up\n\t * the status word to make it look like a successful\n \t * frame reception.\n\t */\n\tdc_newbuf(sc, i, m);\n\tbcopy(ptr, mtod(m, char *), total_len);\t\n\tcur_rx->dc_status = rxstat | DC_RXSTAT_FIRSTFRAG;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_newbuf",
      "void dc_pnic_rx_bug_war"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "ptr",
            "mtod(m, char *)",
            "total_len"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "char*"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_newbuf",
          "args": [
            "sc",
            "i",
            "m"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "dc_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1391-1439",
          "snippet": "int dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\n\nint dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_RXBYTES",
          "args": [
            "rxstat"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "i",
            "DC_RX_LIST_CNT"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ptr",
            "sizeof(DC_RXLEN * 5)"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\nvoid dc_pnic_rx_bug_war;\n\nvoid dc_pnic_rx_bug_war(sc, idx)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tidx;\n{\n\tstruct dc_desc\t\t*cur_rx;\n\tstruct dc_desc\t\t*c = NULL;\n\tstruct mbuf\t\t*m = NULL;\n\tunsigned char\t\t*ptr;\n\tint\t\t\ti, total_len;\n\tu_int32_t\t\trxstat = 0;\n\n\ti = sc->dc_pnic_rx_bug_save;\n\tcur_rx = &sc->dc_ldata->dc_rx_list[idx];\n\tptr = sc->dc_pnic_rx_buf;\n\tbzero(ptr, sizeof(DC_RXLEN * 5));\n\n\t/* Copy all the bytes from the bogus buffers. */\n\twhile (1) {\n\t\tc = &sc->dc_ldata->dc_rx_list[i];\n\t\trxstat = c->dc_status;\n\t\tm = sc->dc_cdata.dc_rx_chain[i];\n\t\tbcopy(mtod(m, char *), ptr, DC_RXLEN);\n\t\tptr += DC_RXLEN;\n\t\t/* If this is the last buffer, break out. */\n\t\tif (i == idx || rxstat & DC_RXSTAT_LASTFRAG)\n\t\t\tbreak;\n\t\tdc_newbuf(sc, i, m);\n\t\tDC_INC(i, DC_RX_LIST_CNT);\n\t}\n\n\t/* Find the length of the actual receive frame. */\n\ttotal_len = DC_RXBYTES(rxstat);\n\n\t/* Scan backwards until we hit a non-zero byte. */\n\twhile(*ptr == 0x00)\n\t\tptr--;\n\n\t/* Round off. */\n\tif ((unsigned long)(ptr) & 0x3)\n\t\tptr -= 1;\n\n\t/* Now find the start of the frame. */\n\tptr -= total_len;\n\tif (ptr < sc->dc_pnic_rx_buf)\n\t\tptr = sc->dc_pnic_rx_buf;\n\n\t/*\n\t * Now copy the salvaged frame to the last mbuf and fake up\n\t * the status word to make it look like a successful\n \t * frame reception.\n\t */\n\tdc_newbuf(sc, i, m);\n\tbcopy(ptr, mtod(m, char *), total_len);\t\n\tcur_rx->dc_status = rxstat | DC_RXSTAT_FIRSTFRAG;\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1391-1439",
    "snippet": "int dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)mtod(m_new, char *)",
            "m_new->m_len"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "char*"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "sizeof(u_int64_t)"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\"",
            "sc->dc_unit"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\n\nint dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_list_rx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1361-1386",
    "snippet": "int dc_list_rx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (dc_newbuf(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (DC_RX_LIST_CNT - 1)) {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[0]);\n\t\t} else {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->dc_rx_prod = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_newbuf",
      "int dc_list_rx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->dc_rx_list[i + 1]"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->dc_rx_list[0]"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_newbuf",
          "args": [
            "sc",
            "i",
            "NULL"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "dc_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1391-1439",
          "snippet": "int dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\n\nint dc_newbuf(sc, i, m)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\ti;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct dc_desc\t\t*c;\n\n\tc = &sc->dc_ldata->dc_rx_list[i];\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"dc%d: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", sc->dc_unit);\n\t\t\tm_freem(m_new);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, sizeof(u_int64_t));\n\n\t/*\n\t * If this is a PNIC chip, zero the buffer. This is part\n\t * of the workaround for the receive bug in the 82c168 and\n\t * 82c169 chips.\n\t */\n\tif (sc->dc_flags & DC_PNIC_RX_BUG_WAR)\n\t\tbzero((char *)mtod(m_new, char *), m_new->m_len);\n\n\tsc->dc_cdata.dc_rx_chain[i] = m_new;\n\tc->dc_data = vtophys(mtod(m_new, caddr_t));\n\tc->dc_ctl = DC_RXCTL_RLINK | DC_RXLEN;\n\tc->dc_status = DC_RXSTAT_OWN;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_newbuf;\nint dc_list_rx_init;\n\nint dc_list_rx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\n\tfor (i = 0; i < DC_RX_LIST_CNT; i++) {\n\t\tif (dc_newbuf(sc, i, NULL) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (DC_RX_LIST_CNT - 1)) {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[0]);\n\t\t} else {\n\t\t\tld->dc_rx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->dc_rx_prod = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_list_tx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1328-1353",
    "snippet": "int dc_list_tx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (i == (DC_TX_LIST_CNT - 1)) {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[0]);\n\t\t} else {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[i + 1]);\n\t\t}\n\t\tcd->dc_tx_chain[i] = NULL;\n\t\tld->dc_tx_list[i].dc_data = 0;\n\t\tld->dc_tx_list[i].dc_ctl = 0;\n\t}\n\n\tcd->dc_tx_prod = cd->dc_tx_cons = cd->dc_tx_cnt = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_list_tx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->dc_tx_list[i + 1]"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->dc_tx_list[0]"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_list_tx_init;\n\nint dc_list_tx_init(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_chain_data\t*cd;\n\tstruct dc_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->dc_cdata;\n\tld = sc->dc_ldata;\n\tfor (i = 0; i < DC_TX_LIST_CNT; i++) {\n\t\tif (i == (DC_TX_LIST_CNT - 1)) {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[0]);\n\t\t} else {\n\t\t\tld->dc_tx_list[i].dc_next =\n\t\t\t    vtophys(&ld->dc_tx_list[i + 1]);\n\t\t}\n\t\tcd->dc_tx_chain[i] = NULL;\n\t\tld->dc_tx_list[i].dc_data = 0;\n\t\tld->dc_tx_list[i].dc_ctl = 0;\n\t}\n\n\tcd->dc_tx_prod = cd->dc_tx_cons = cd->dc_tx_cnt = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_attach_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1212-1323",
    "snippet": "void dc_attach_common(sc)\n\tstruct dc_softc *sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tmac_offset;\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tswitch(sc->dc_type) {\n\tcase DC_TYPE_98713:\n\tcase DC_TYPE_98713A:\n\tcase DC_TYPE_987x5:\n\tcase DC_TYPE_PNICII:\n\t\tdc_read_eeprom(sc, (caddr_t)&mac_offset,\n\t\t    (DC_EE_NODEADDR_OFFSET / 2), 1, 0);\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t    (mac_offset / 2), 3, 0);\n\t\tbreak;\n\tcase DC_TYPE_PNIC:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0, 3, 1);\n\t\tbreak;\n\tcase DC_TYPE_DM9102:\n\tcase DC_TYPE_21143:\n\tcase DC_TYPE_ASIX:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\t\n\t\t    DC_EE_NODEADDR, 3, 0);\n\t\tbreak;\n\tcase DC_TYPE_AL981:\n\tcase DC_TYPE_AN985:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t    DC_AL_EE_NODEADDR, 3, 0);\n\t\tbreak;\n\tdefault:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t    DC_EE_NODEADDR, 3, 0);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A 21143 or clone chip was detected. Inform the world.\n\t */\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tsc->dc_ldata_ptr = malloc(sizeof(struct dc_list_data), M_DEVBUF,\n\t\t\t\tM_NOWAIT);\n\tif (sc->dc_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers!\\n\", sc->dc_unit);\n\t\tgoto fail;\n\t}\n\n\tsc->dc_ldata = (struct dc_list_data *)sc->dc_ldata_ptr;\n\tbzero(sc->dc_ldata, sizeof(struct dc_list_data));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = dc_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = dc_start;\n\tifp->if_watchdog = dc_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = DC_TX_LIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = dc_miibus_readreg;\n\tsc->sc_mii.mii_writereg = dc_miibus_writereg;\n\tsc->sc_mii.mii_statchg = dc_miibus_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, dc_ifmedia_upd, dc_ifmedia_sts);\n\tmii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t} else\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\n\tif (DC_IS_DAVICOM(sc) && sc->dc_revision >= DC_REVISION_DM9102A)\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_HPNA_1,0,NULL);\n\n\t/* if (error && DC_IS_INTEL(sc)) {\n\t\tsc->dc_pmode = DC_PMODE_SYM;\n\t\tmii_phy_probe(dev, &sc->dc_miibus,\n\t\t    dc_ifmedia_upd, dc_ifmedia_sts);\n\t\terror = 0;\n\t}\n\n\tif (error) {\n\t\tprintf(\"dc%d: MII without any PHY!\\n\", sc->dc_unit);\n\t\tbus_teardown_intr(dev, sc->dc_irq, sc->dc_intrhand);\n\t\tbus_release_resource(dev, SYS_RES_IRQ, 0, sc->dc_irq);\n\t\tbus_release_resource(dev, DC_RES, DC_RID, sc->dc_res);\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t} */\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(dc_shutdown, sc);\n\nfail:\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_shutdown",
      "void dc_start",
      "int dc_ioctl",
      "void dc_watchdog",
      "int dc_ifmedia_upd",
      "void dc_ifmedia_sts",
      "void dc_read_eeprom",
      "int dc_miibus_readreg",
      "void dc_miibus_writereg",
      "void dc_miibus_statchg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "dc_shutdown",
            "sc"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_HPNA_1",
            "0",
            "NULL"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_AUTO"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE",
            "0",
            "NULL"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_probe",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_mii",
            "0xffffffff"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "68-122",
          "snippet": "void\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmii_print",
            "int\tmii_submatch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tmii_print;\nint\tmii_submatch;\n\nvoid\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_mii.mii_media",
            "0",
            "dc_ifmedia_upd",
            "dc_ifmedia_sts"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->dc_ldata",
            "sizeof(struct dc_list_data)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no memory for list buffers!\\n\"",
            "sc->dc_unit"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct dc_list_data)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_read_eeprom",
          "args": [
            "sc",
            "(caddr_t)&sc->arpcom.ac_enaddr",
            "DC_EE_NODEADDR",
            "3",
            "0"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "dc_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "372-395",
          "snippet": "void dc_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (DC_IS_PNIC(sc))\n\t\t\tdc_eeprom_getword_pnic(sc, off + i, &word);\n\t\telse\n\t\t\tdc_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_eeprom_getword",
            "void dc_eeprom_getword_pnic",
            "void dc_read_eeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_eeprom_getword;\nvoid dc_eeprom_getword_pnic;\nvoid dc_read_eeprom;\n\nvoid dc_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (DC_IS_PNIC(sc))\n\t\t\tdc_eeprom_getword_pnic(sc, off + i, &word);\n\t\telse\n\t\t\tdc_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_shutdown;\nvoid dc_start;\nint dc_ioctl;\nvoid dc_watchdog;\nint dc_ifmedia_upd;\nvoid dc_ifmedia_sts;\nvoid dc_read_eeprom;\nint dc_miibus_readreg;\nvoid dc_miibus_writereg;\nvoid dc_miibus_statchg;\n\nvoid dc_attach_common(sc)\n\tstruct dc_softc *sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tmac_offset;\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tswitch(sc->dc_type) {\n\tcase DC_TYPE_98713:\n\tcase DC_TYPE_98713A:\n\tcase DC_TYPE_987x5:\n\tcase DC_TYPE_PNICII:\n\t\tdc_read_eeprom(sc, (caddr_t)&mac_offset,\n\t\t    (DC_EE_NODEADDR_OFFSET / 2), 1, 0);\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t    (mac_offset / 2), 3, 0);\n\t\tbreak;\n\tcase DC_TYPE_PNIC:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0, 3, 1);\n\t\tbreak;\n\tcase DC_TYPE_DM9102:\n\tcase DC_TYPE_21143:\n\tcase DC_TYPE_ASIX:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\t\n\t\t    DC_EE_NODEADDR, 3, 0);\n\t\tbreak;\n\tcase DC_TYPE_AL981:\n\tcase DC_TYPE_AN985:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t    DC_AL_EE_NODEADDR, 3, 0);\n\t\tbreak;\n\tdefault:\n\t\tdc_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,\n\t\t    DC_EE_NODEADDR, 3, 0);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A 21143 or clone chip was detected. Inform the world.\n\t */\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tsc->dc_ldata_ptr = malloc(sizeof(struct dc_list_data), M_DEVBUF,\n\t\t\t\tM_NOWAIT);\n\tif (sc->dc_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers!\\n\", sc->dc_unit);\n\t\tgoto fail;\n\t}\n\n\tsc->dc_ldata = (struct dc_list_data *)sc->dc_ldata_ptr;\n\tbzero(sc->dc_ldata, sizeof(struct dc_list_data));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = dc_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = dc_start;\n\tifp->if_watchdog = dc_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = DC_TX_LIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = dc_miibus_readreg;\n\tsc->sc_mii.mii_writereg = dc_miibus_writereg;\n\tsc->sc_mii.mii_statchg = dc_miibus_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, dc_ifmedia_upd, dc_ifmedia_sts);\n\tmii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t} else\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\n\tif (DC_IS_DAVICOM(sc) && sc->dc_revision >= DC_REVISION_DM9102A)\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_HPNA_1,0,NULL);\n\n\t/* if (error && DC_IS_INTEL(sc)) {\n\t\tsc->dc_pmode = DC_PMODE_SYM;\n\t\tmii_phy_probe(dev, &sc->dc_miibus,\n\t\t    dc_ifmedia_upd, dc_ifmedia_sts);\n\t\terror = 0;\n\t}\n\n\tif (error) {\n\t\tprintf(\"dc%d: MII without any PHY!\\n\", sc->dc_unit);\n\t\tbus_teardown_intr(dev, sc->dc_irq, sc->dc_intrhand);\n\t\tbus_release_resource(dev, SYS_RES_IRQ, 0, sc->dc_irq);\n\t\tbus_release_resource(dev, DC_RES, DC_RID, sc->dc_res);\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t} */\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(dc_shutdown, sc);\n\nfail:\n\treturn;\n}"
  },
  {
    "function_name": "dc_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1167-1206",
    "snippet": "void dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIARESET",
            "DC_SIA_RESET"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_INTEL",
          "args": [
            "sc"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_NETCFG",
            "0x00000000"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_BUSCTL",
            "0x00000000"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_IMR",
            "0x00000000"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: reset never completed!\\n\"",
            "sc->dc_unit"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_BUSCTL_RESET"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10000"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_ADMTEK",
          "args": [
            "sc"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_ASIX",
          "args": [
            "sc"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_BUSCTL"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_BUSCTL",
            "DC_BUSCTL_RESET"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_reset;\n\nvoid dc_reset(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tDC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_4(sc, DC_BUSCTL) & DC_BUSCTL_RESET))\n\t\t\tbreak;\n\t}\n\n\tif (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc)) {\n\t\tDELAY(10000);\n\t\tDC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);\n\t\ti = 0;\n\t}\n\n\tif (i == DC_TIMEOUT)\n\t\tprintf(\"dc%d: reset never completed!\\n\", sc->dc_unit);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n\tCSR_WRITE_4(sc, DC_IMR, 0x00000000);\n\tCSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);\n\tCSR_WRITE_4(sc, DC_NETCFG, 0x00000000);\n\n\t/*\n\t * Bring the SIA out of reset. In some cases, it looks\n\t * like failing to unreset the SIA soon enough gets it\n\t * into a state where it will never come out of reset\n\t * until we reset the whole chip again.\n\t */\n\t if (DC_IS_INTEL(sc))\n\t\tDC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);\n\n        return;\n}"
  },
  {
    "function_name": "dc_setcfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1061-1165",
    "snippet": "void dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_setcfg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_TX_ON|DC_NETCFG_RX_ON"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_PN_NWAY",
            "DC_PN_NWAY_DUPLEX"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_FULLDUPLEX"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_PN_NWAY",
            "DC_PN_NWAY_DUPLEX"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_FULLDUPLEX"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PORTSEL"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PORTSEL"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PCS"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_SCRAMBLER"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PORTSEL"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_PN_NWAY",
            "DC_PN_NWAY_SPEEDSEL"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_PN_GPIO_SETBIT",
          "args": [
            "sc",
            "DC_PN_GPIO_100TX_LOOP"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_PN_GPIO_CLRBIT",
          "args": [
            "sc",
            "DC_PN_GPIO_SPEEDSEL"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_10BTCTRL",
            "0xFFFF"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PORTSEL"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PCS"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "(DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_WATCHDOG",
            "DC_WDOG_JABBERDIS"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_HEARTBEAT"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_SPEEDSEL"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_PN_NWAY",
            "DC_PN_NWAY_SPEEDSEL"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_PN_GPIO_SETBIT",
          "args": [
            "sc",
            "DC_PN_GPIO_100TX_LOOP"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_PN_GPIO_SETBIT",
          "args": [
            "sc",
            "DC_PN_GPIO_SPEEDSEL"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_10BTCTRL",
            "0xFFFF"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_PORTSEL"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "(DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "(DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_WATCHDOG",
            "DC_WDOG_JABBERDIS"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_HEARTBEAT"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_SPEEDSEL"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\"",
            "sc->dc_unit"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_ISR"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "(DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_NETCFG"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setcfg;\n\nvoid dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_setfilt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "1040-1054",
    "snippet": "void dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_setfilt_21143",
      "void dc_setfilt_asix",
      "void dc_setfilt_admtek",
      "void dc_setfilt"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_setfilt_admtek",
          "args": [
            "sc"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setfilt_admtek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "913-966",
          "snippet": "void dc_setfilt_admtek(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Init our MAC address */\n\tCSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tCSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AL_MAR0, 0);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t dc_crc_be",
            "void dc_setfilt_admtek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_be;\nvoid dc_setfilt_admtek;\n\nvoid dc_setfilt_admtek(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Init our MAC address */\n\tCSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tCSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AL_MAR0, 0);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_ADMTEK",
          "args": [
            "sc"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_setfilt_asix",
          "args": [
            "sc"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setfilt_asix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "968-1038",
          "snippet": "void dc_setfilt_asix(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n        /* Init our MAC address */\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR0);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR1);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/*\n\t * The ASIX chip has a special bit to enable reception\n\t * of broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t dc_crc_be",
            "void dc_setfilt_asix"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_be;\nvoid dc_setfilt_asix;\n\nvoid dc_setfilt_asix(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n        /* Init our MAC address */\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR0);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR1);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/*\n\t * The ASIX chip has a special bit to enable reception\n\t * of broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_ASIX",
          "args": [
            "sc"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_setfilt_21143",
          "args": [
            "sc"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setfilt_21143",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "843-911",
          "snippet": "void dc_setfilt_21143(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*sframe;\n\tu_int32_t\t\th, *sp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ti = sc->dc_cdata.dc_tx_prod;\n\tDC_INC(sc->dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);\n\tsc->dc_cdata.dc_tx_cnt++;\n\tsframe = &sc->dc_ldata->dc_tx_list[i];\n\tsp = (u_int32_t *)&sc->dc_cdata.dc_sbuf;\n\tbzero((char *)sp, DC_SFRAME_LEN);\n\n\tsframe->dc_data = vtophys(&sc->dc_cdata.dc_sbuf);\n\tsframe->dc_ctl = DC_SFRAME_LEN | DC_TXCTL_SETUP | DC_TXCTL_TLINK |\n\t    DC_FILTER_HASHPERF | DC_TXCTL_FINT;\n\n\tsc->dc_cdata.dc_tx_chain[i] = (struct mbuf *)&sc->dc_cdata.dc_sbuf;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_le(sc, enm->enm_addrlo);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t}\n\n\t/* Set our MAC address */\n\tsp[39] = ((u_int16_t *)sc->arpcom.ac_enaddr)[0];\n\tsp[40] = ((u_int16_t *)sc->arpcom.ac_enaddr)[1];\n\tsp[41] = ((u_int16_t *)sc->arpcom.ac_enaddr)[2];\n\n\tsframe->dc_status = DC_TXSTAT_OWN;\n\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * The PNIC takes an exceedingly long time to process its\n\t * setup frame; wait 10ms after posting the setup frame\n\t * before proceeding, just so it has time to swallow its\n\t * medicine.\n\t */\n\tDELAY(10000);\n\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t dc_crc_le",
            "void dc_setfilt_21143"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_le;\nvoid dc_setfilt_21143;\n\nvoid dc_setfilt_21143(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*sframe;\n\tu_int32_t\t\th, *sp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ti = sc->dc_cdata.dc_tx_prod;\n\tDC_INC(sc->dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);\n\tsc->dc_cdata.dc_tx_cnt++;\n\tsframe = &sc->dc_ldata->dc_tx_list[i];\n\tsp = (u_int32_t *)&sc->dc_cdata.dc_sbuf;\n\tbzero((char *)sp, DC_SFRAME_LEN);\n\n\tsframe->dc_data = vtophys(&sc->dc_cdata.dc_sbuf);\n\tsframe->dc_ctl = DC_SFRAME_LEN | DC_TXCTL_SETUP | DC_TXCTL_TLINK |\n\t    DC_FILTER_HASHPERF | DC_TXCTL_FINT;\n\n\tsc->dc_cdata.dc_tx_chain[i] = (struct mbuf *)&sc->dc_cdata.dc_sbuf;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_le(sc, enm->enm_addrlo);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t}\n\n\t/* Set our MAC address */\n\tsp[39] = ((u_int16_t *)sc->arpcom.ac_enaddr)[0];\n\tsp[40] = ((u_int16_t *)sc->arpcom.ac_enaddr)[1];\n\tsp[41] = ((u_int16_t *)sc->arpcom.ac_enaddr)[2];\n\n\tsframe->dc_status = DC_TXSTAT_OWN;\n\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * The PNIC takes an exceedingly long time to process its\n\t * setup frame; wait 10ms after posting the setup frame\n\t * before proceeding, just so it has time to swallow its\n\t * medicine.\n\t */\n\tDELAY(10000);\n\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNICII",
          "args": [
            "sc"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_MACRONIX",
          "args": [
            "sc"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_INTEL",
          "args": [
            "sc"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setfilt_21143;\nvoid dc_setfilt_asix;\nvoid dc_setfilt_admtek;\nvoid dc_setfilt;\n\nvoid dc_setfilt(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tif (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||\n\t    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc))\n\t\tdc_setfilt_21143(sc);\n\n\tif (DC_IS_ASIX(sc))\n\t\tdc_setfilt_asix(sc);\n\n\tif (DC_IS_ADMTEK(sc))\n\t\tdc_setfilt_admtek(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_setfilt_asix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "968-1038",
    "snippet": "void dc_setfilt_asix(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n        /* Init our MAC address */\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR0);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR1);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/*\n\t * The ASIX chip has a special bit to enable reception\n\t * of broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[1]);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t dc_crc_be",
      "void dc_setfilt_asix"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTDATA",
            "hashes[1]"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTIDX",
            "DC_AX_FILTIDX_MAR1"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTDATA",
            "hashes[0]"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTIDX",
            "DC_AX_FILTIDX_MAR0"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_crc_be",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "dc_crc_be",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "808-831",
          "snippet": "u_int32_t dc_crc_be(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t dc_crc_be"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_be;\n\nu_int32_t dc_crc_be(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTDATA",
            "0"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTIDX",
            "DC_AX_FILTIDX_MAR1"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTDATA",
            "0"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTIDX",
            "DC_AX_FILTIDX_MAR0"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_AX_NETCFG_RX_BROAD"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_AX_NETCFG_RX_BROAD"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_ALLMULTI"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_ALLMULTI"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_PROMISC"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_PROMISC"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTDATA",
            "*(u_int32_t *)(&sc->arpcom.ac_enaddr[4])"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTIDX",
            "DC_AX_FILTIDX_PAR1"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTDATA",
            "*(u_int32_t *)(&sc->arpcom.ac_enaddr[0])"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AX_FILTIDX",
            "DC_AX_FILTIDX_PAR0"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_be;\nvoid dc_setfilt_asix;\n\nvoid dc_setfilt_asix(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n        /* Init our MAC address */\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR0);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n        CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR1);\n        CSR_WRITE_4(sc, DC_AX_FILTDATA,\n\t    *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/*\n\t * The ASIX chip has a special bit to enable reception\n\t * of broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);\n\tCSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[1]);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_setfilt_admtek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "913-966",
    "snippet": "void dc_setfilt_admtek(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Init our MAC address */\n\tCSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tCSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AL_MAR0, 0);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, hashes[1]);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t dc_crc_be",
      "void dc_setfilt_admtek"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AL_MAR1",
            "hashes[1]"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AL_MAR0",
            "hashes[0]"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_crc_be",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "dc_crc_be",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "808-831",
          "snippet": "u_int32_t dc_crc_be(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t dc_crc_be"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_be;\n\nu_int32_t dc_crc_be(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AL_MAR1",
            "0"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AL_MAR0",
            "0"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_ALLMULTI"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_ALLMULTI"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_PROMISC"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_PROMISC"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AL_PAR1",
            "*(u_int32_t *)(&sc->arpcom.ac_enaddr[4])"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_AL_PAR0",
            "*(u_int32_t *)(&sc->arpcom.ac_enaddr[0])"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_be;\nvoid dc_setfilt_admtek;\n\nvoid dc_setfilt_admtek(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Init our MAC address */\n\tCSR_WRITE_4(sc, DC_AL_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));\n\tCSR_WRITE_4(sc, DC_AL_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, DC_AL_MAR0, 0);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, 0);\n\n\t/*\n\t * If we're already in promisc or allmulti mode, we\n\t * don't have to bother programming the multicast filter.\n\t */\n\tif (ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI))\n\t\treturn;\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_be(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tCSR_WRITE_4(sc, DC_AL_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, DC_AL_MAR1, hashes[1]);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_setfilt_21143",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "843-911",
    "snippet": "void dc_setfilt_21143(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*sframe;\n\tu_int32_t\t\th, *sp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ti = sc->dc_cdata.dc_tx_prod;\n\tDC_INC(sc->dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);\n\tsc->dc_cdata.dc_tx_cnt++;\n\tsframe = &sc->dc_ldata->dc_tx_list[i];\n\tsp = (u_int32_t *)&sc->dc_cdata.dc_sbuf;\n\tbzero((char *)sp, DC_SFRAME_LEN);\n\n\tsframe->dc_data = vtophys(&sc->dc_cdata.dc_sbuf);\n\tsframe->dc_ctl = DC_SFRAME_LEN | DC_TXCTL_SETUP | DC_TXCTL_TLINK |\n\t    DC_FILTER_HASHPERF | DC_TXCTL_FINT;\n\n\tsc->dc_cdata.dc_tx_chain[i] = (struct mbuf *)&sc->dc_cdata.dc_sbuf;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_le(sc, enm->enm_addrlo);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t}\n\n\t/* Set our MAC address */\n\tsp[39] = ((u_int16_t *)sc->arpcom.ac_enaddr)[0];\n\tsp[40] = ((u_int16_t *)sc->arpcom.ac_enaddr)[1];\n\tsp[41] = ((u_int16_t *)sc->arpcom.ac_enaddr)[2];\n\n\tsframe->dc_status = DC_TXSTAT_OWN;\n\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * The PNIC takes an exceedingly long time to process its\n\t * setup frame; wait 10ms after posting the setup frame\n\t * before proceeding, just so it has time to swallow its\n\t * medicine.\n\t */\n\tDELAY(10000);\n\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t dc_crc_le",
      "void dc_setfilt_21143"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10000"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_TXSTART",
            "0xFFFFFFFF"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_crc_le",
          "args": [
            "sc",
            "(caddr_t)&etherbroadcastaddr"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "dc_crc_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "784-803",
          "snippet": "u_int32_t dc_crc_le(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? DC_POLY : 0);\n\t}\n\n\t/* The hash table on the PNIC II is only 128 bits wide. */\n\tif (DC_IS_PNICII(sc))\n\t\treturn (crc & ((1 << DC_BITS_PNIC_II) - 1));\n\n\treturn (crc & ((1 << DC_BITS) - 1));\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define DC_BITS_PNIC_II\t7",
            "#define DC_BITS\t\t9",
            "#define DC_POLY\t\t0xEDB88320"
          ],
          "globals_used": [
            "u_int32_t dc_crc_le"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define DC_BITS_PNIC_II\t7\n#define DC_BITS\t\t9\n#define DC_POLY\t\t0xEDB88320\n\nu_int32_t dc_crc_le;\n\nu_int32_t dc_crc_le(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? DC_POLY : 0);\n\t}\n\n\t/* The hash table on the PNIC II is only 128 bits wide. */\n\tif (DC_IS_PNICII(sc))\n\t\treturn (crc & ((1 << DC_BITS_PNIC_II) - 1));\n\n\treturn (crc & ((1 << DC_BITS) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_ALLMULTI"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_ALLMULTI"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_PROMISC"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_NETCFG",
            "DC_NETCFG_RX_PROMISC"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->dc_cdata.dc_sbuf"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)sp",
            "DC_SFRAME_LEN"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_INC",
          "args": [
            "sc->dc_cdata.dc_tx_prod",
            "DC_TX_LIST_CNT"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_le;\nvoid dc_setfilt_21143;\n\nvoid dc_setfilt_21143(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tstruct dc_desc\t\t*sframe;\n\tu_int32_t\t\th, *sp;\n\tstruct arpcom\t\t*ac = &sc->arpcom;\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tifp = &sc->arpcom.ac_if;\n\n\ti = sc->dc_cdata.dc_tx_prod;\n\tDC_INC(sc->dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);\n\tsc->dc_cdata.dc_tx_cnt++;\n\tsframe = &sc->dc_ldata->dc_tx_list[i];\n\tsp = (u_int32_t *)&sc->dc_cdata.dc_sbuf;\n\tbzero((char *)sp, DC_SFRAME_LEN);\n\n\tsframe->dc_data = vtophys(&sc->dc_cdata.dc_sbuf);\n\tsframe->dc_ctl = DC_SFRAME_LEN | DC_TXCTL_SETUP | DC_TXCTL_TLINK |\n\t    DC_FILTER_HASHPERF | DC_TXCTL_FINT;\n\n\tsc->dc_cdata.dc_tx_chain[i] = (struct mbuf *)&sc->dc_cdata.dc_sbuf;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);\n\n\tif (ifp->if_flags & IFF_ALLMULTI)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\telse\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);\n\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = dc_crc_le(sc, enm->enm_addrlo);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\th = dc_crc_le(sc, (caddr_t)&etherbroadcastaddr);\n\t\tsp[h >> 4] |= 1 << (h & 0xF);\n\t}\n\n\t/* Set our MAC address */\n\tsp[39] = ((u_int16_t *)sc->arpcom.ac_enaddr)[0];\n\tsp[40] = ((u_int16_t *)sc->arpcom.ac_enaddr)[1];\n\tsp[41] = ((u_int16_t *)sc->arpcom.ac_enaddr)[2];\n\n\tsframe->dc_status = DC_TXSTAT_OWN;\n\tCSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);\n\n\t/*\n\t * The PNIC takes an exceedingly long time to process its\n\t * setup frame; wait 10ms after posting the setup frame\n\t * before proceeding, just so it has time to swallow its\n\t * medicine.\n\t */\n\tDELAY(10000);\n\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_crc_be",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "808-831",
    "snippet": "u_int32_t dc_crc_be(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t dc_crc_be"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t dc_crc_be;\n\nu_int32_t dc_crc_be(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}"
  },
  {
    "function_name": "dc_crc_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "784-803",
    "snippet": "u_int32_t dc_crc_le(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? DC_POLY : 0);\n\t}\n\n\t/* The hash table on the PNIC II is only 128 bits wide. */\n\tif (DC_IS_PNICII(sc))\n\t\treturn (crc & ((1 << DC_BITS_PNIC_II) - 1));\n\n\treturn (crc & ((1 << DC_BITS) - 1));\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define DC_BITS_PNIC_II\t7",
      "#define DC_BITS\t\t9",
      "#define DC_POLY\t\t0xEDB88320"
    ],
    "globals_used": [
      "u_int32_t dc_crc_le"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_IS_PNICII",
          "args": [
            "sc"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define DC_BITS_PNIC_II\t7\n#define DC_BITS\t\t9\n#define DC_POLY\t\t0xEDB88320\n\nu_int32_t dc_crc_le;\n\nu_int32_t dc_crc_le(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? DC_POLY : 0);\n\t}\n\n\t/* The hash table on the PNIC II is only 128 bits wide. */\n\tif (DC_IS_PNICII(sc))\n\t\treturn (crc & ((1 << DC_BITS_PNIC_II) - 1));\n\n\treturn (crc & ((1 << DC_BITS) - 1));\n}"
  },
  {
    "function_name": "dc_miibus_statchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "758-778",
    "snippet": "void dc_miibus_statchg(self)\n\tstruct device *self;\n{\n\tstruct dc_softc *sc = (struct dc_softc *)self;\n\tstruct mii_data *mii;\n\tstruct ifmedia *ifm;\n\n\tif (DC_IS_ADMTEK(sc))\n\t\treturn;\n\tmii = &sc->sc_mii;\n\tifm = &mii->mii_media;\n\tif (DC_IS_DAVICOM(sc) && IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1) {\n\t\tdc_setcfg(sc, ifm->ifm_media);\n\t\tsc->dc_if_media = ifm->ifm_media;\n\t} else {\n\t\tdc_setcfg(sc, mii->mii_media_active);\n\t\tsc->dc_if_media = mii->mii_media_active;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_miibus_statchg",
      "void dc_setcfg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_setcfg",
          "args": [
            "sc",
            "mii->mii_media_active"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "dc_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "1061-1165",
          "snippet": "void dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_setcfg;\n\nvoid dc_setcfg(sc, media)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tint\t\t\ti, restart = 0;\n\tu_int32_t\t\tisr;\n\n\tif (IFM_SUBTYPE(media) == IFM_NONE)\n\t\treturn;\n\n\tif (CSR_READ_4(sc, DC_NETCFG) & (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON)) {\n\t\trestart = 1;\n\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON|DC_NETCFG_RX_ON));\n\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(10);\n\t\t\tisr = CSR_READ_4(sc, DC_ISR);\n\t\t\tif (isr & DC_ISR_TX_IDLE ||\n\t\t\t    (isr & DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == DC_TIMEOUT)\n\t\t\tprintf(\"dc%d: failed to force tx and \"\n\t\t\t\t\"rx to idle state\\n\", sc->dc_unit);\n\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t\t    DC_NETCFG_SCRAMBLER));\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL|\n\t\t\t    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER);\n\t\t}\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);\n\t\tif (sc->dc_pmode == DC_PMODE_MII) {\n\t\t\tDC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS|\n\t\t\t    DC_NETCFG_PORTSEL|DC_NETCFG_SCRAMBLER));\n\t\t\tif (sc->dc_type == DC_TYPE_98713)\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t\tif (!DC_IS_DAVICOM(sc))\n\t\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);\n\t\t} else {\n\t\t\tif (DC_IS_PNIC(sc)) {\n\t\t\t\tDC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);\n\t\t\t\tDC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);\n\t\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);\n\t\t\t}\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a Davicom DM9102A card with a DM9801 HomePNA\n\t * PHY and we want HomePNA mode, set the portsel bit to turn\n\t * on the external MII port.\n\t */\n\tif (DC_IS_DAVICOM(sc)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_HPNA_1) {\n\t\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t\tsc->dc_link = 1;\n\t\t} else {\n\t\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t} else {\n\t\tDC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);\n\t\tif (sc->dc_pmode == DC_PMODE_SYM && DC_IS_PNIC(sc))\n\t\t\tDC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);\n\t}\n\n\tif (restart)\n\t\tDC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON|DC_NETCFG_RX_ON);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_DAVICOM",
          "args": [
            "sc"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_ADMTEK",
          "args": [
            "sc"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_miibus_statchg;\nvoid dc_setcfg;\n\nvoid dc_miibus_statchg(self)\n\tstruct device *self;\n{\n\tstruct dc_softc *sc = (struct dc_softc *)self;\n\tstruct mii_data *mii;\n\tstruct ifmedia *ifm;\n\n\tif (DC_IS_ADMTEK(sc))\n\t\treturn;\n\tmii = &sc->sc_mii;\n\tifm = &mii->mii_media;\n\tif (DC_IS_DAVICOM(sc) && IFM_SUBTYPE(ifm->ifm_media) == IFM_HPNA_1) {\n\t\tdc_setcfg(sc, ifm->ifm_media);\n\t\tsc->dc_if_media = ifm->ifm_media;\n\t} else {\n\t\tdc_setcfg(sc, mii->mii_media_active);\n\t\tsc->dc_if_media = mii->mii_media_active;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_miibus_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "689-756",
    "snippet": "void dc_miibus_writereg(self, phy, reg, data)\n\tstruct device\t\t*self;\n\tint\t\t\tphy, reg, data;\n{\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)self;\n\tstruct dc_mii_frame\tframe;\n\tint\t\t\ti, phy_reg;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tif (DC_IS_ADMTEK(sc) && phy != DC_ADMTEK_PHYADDR)\n\t\treturn;\n\n\tif (DC_IS_PNIC(sc)) {\n\t\tCSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_WRITE |\n\t\t    (phy << 23) | (reg << 10) | data);\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tif (!(CSR_READ_4(sc, DC_PN_MII) & DC_PN_MII_BUSY))\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (DC_IS_COMET(sc)) {\n\t\tswitch(reg) {\n\t\tcase MII_BMCR:\n\t\t\tphy_reg = DC_AL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\tphy_reg = DC_AL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\t\tphy_reg = DC_AL_VENID;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR2:\n\t\t\tphy_reg = DC_AL_DEVID;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\tphy_reg = DC_AL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\tphy_reg = DC_AL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\tphy_reg = DC_AL_ANER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"dc%d: phy_write: bad phy register %x\\n\",\n\t\t\t    sc->dc_unit, reg);\n\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\n\t\tCSR_WRITE_4(sc, phy_reg, data);\n\t\treturn;\n\t}\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tphy_reg = CSR_READ_4(sc, DC_NETCFG);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);\n\tdc_mii_writereg(sc, &frame);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_mii_writereg",
      "void dc_miibus_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_NETCFG",
            "phy_reg"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_mii_writereg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "541-576",
          "snippet": "int dc_mii_writereg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_WRITEOP;\n\tframe->mii_turnaround = DC_MII_TURNAROUND;\n\n\t/*\n\t * Sync the PHYs.\n\t */\t\n\tdc_mii_sync(sc);\n\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\tdc_mii_send(sc, frame->mii_turnaround, 2);\n\tdc_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit",
            "void dc_mii_sync",
            "void dc_mii_send",
            "int dc_mii_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_sync;\nvoid dc_mii_send;\nint dc_mii_writereg;\n\nint dc_mii_writereg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_WRITEOP;\n\tframe->mii_turnaround = DC_MII_TURNAROUND;\n\n\t/*\n\t * Sync the PHYs.\n\t */\t\n\tdc_mii_sync(sc);\n\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\tdc_mii_send(sc, frame->mii_turnaround, 2);\n\tdc_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_NETCFG",
            "phy_reg & ~DC_NETCFG_PORTSEL"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_NETCFG"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "phy_reg",
            "data"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: phy_write: bad phy register %x\\n\"",
            "sc->dc_unit",
            "reg"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_COMET",
          "args": [
            "sc"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_PN_MII"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_PN_MII",
            "DC_PN_MIIOPCODE_WRITE |\n\t\t    (phy << 23) | (reg << 10) | data"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_ADMTEK",
          "args": [
            "sc"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_mii_writereg;\nvoid dc_miibus_writereg;\n\nvoid dc_miibus_writereg(self, phy, reg, data)\n\tstruct device\t\t*self;\n\tint\t\t\tphy, reg, data;\n{\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)self;\n\tstruct dc_mii_frame\tframe;\n\tint\t\t\ti, phy_reg;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tif (DC_IS_ADMTEK(sc) && phy != DC_ADMTEK_PHYADDR)\n\t\treturn;\n\n\tif (DC_IS_PNIC(sc)) {\n\t\tCSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_WRITE |\n\t\t    (phy << 23) | (reg << 10) | data);\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tif (!(CSR_READ_4(sc, DC_PN_MII) & DC_PN_MII_BUSY))\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (DC_IS_COMET(sc)) {\n\t\tswitch(reg) {\n\t\tcase MII_BMCR:\n\t\t\tphy_reg = DC_AL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\tphy_reg = DC_AL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\t\tphy_reg = DC_AL_VENID;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR2:\n\t\t\tphy_reg = DC_AL_DEVID;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\tphy_reg = DC_AL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\tphy_reg = DC_AL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\tphy_reg = DC_AL_ANER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"dc%d: phy_write: bad phy register %x\\n\",\n\t\t\t    sc->dc_unit, reg);\n\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\n\t\tCSR_WRITE_4(sc, phy_reg, data);\n\t\treturn;\n\t}\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tphy_reg = CSR_READ_4(sc, DC_NETCFG);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);\n\tdc_mii_writereg(sc, &frame);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_miibus_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "578-687",
    "snippet": "int dc_miibus_readreg(self, phy, reg)\n\tstruct device\t\t*self;\n\tint\t\t\tphy, reg;\n{\n\tstruct dc_mii_frame\tframe;\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)self;\n\tint\t\t\ti, rval, phy_reg;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\t/*\n\t * Note: both the AL981 and AN985 have internal PHYs,\n\t * however the AL981 provides direct access to the PHY\n\t * registers while the AN985 uses a serial MII interface.\n\t * The AN985's MII interface is also buggy in that you\n\t * can read from any MII address (0 to 31), but only address 1\n\t * behaves normally. To deal with both cases, we pretend\n\t * that the PHY is at MII address 1.\n\t */\n\tif (DC_IS_ADMTEK(sc) && phy != DC_ADMTEK_PHYADDR)\n\t\treturn(0);\n\n\tif (sc->dc_pmode == DC_PMODE_SYM) {\n\t\tif (phy == (MII_NPHY - 1)) {\n\t\t\tswitch(reg) {\n\t\t\tcase MII_BMSR:\n\t\t\t/*\n\t\t\t * Fake something to make the probe\n\t\t\t * code think there's a PHY here.\n\t\t\t */\n\t\t\t\treturn(BMSR_MEDIAMASK);\n\t\t\t\tbreak;\n\t\t\tcase MII_PHYIDR1:\n\t\t\t\tif (DC_IS_PNIC(sc))\n\t\t\t\t\treturn(PCI_VENDOR_LITEON);\n\t\t\t\treturn(PCI_VENDOR_DEC);\n\t\t\t\tbreak;\n\t\t\tcase MII_PHYIDR2:\n\t\t\t\tif (DC_IS_PNIC(sc))\n\t\t\t\t\treturn(PCI_PRODUCT_LITEON_PNIC);\n\t\t\t\treturn(PCI_PRODUCT_DEC_21142);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\treturn(0);\n\t}\n\n\tif (DC_IS_PNIC(sc)) {\n\t\tCSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_READ |\n\t\t    (phy << 23) | (reg << 18));\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(1);\n\t\t\trval = CSR_READ_4(sc, DC_PN_MII);\n\t\t\tif (!(rval & DC_PN_MII_BUSY)) {\n\t\t\t\trval &= 0xFFFF;\n\t\t\t\treturn(rval == 0xFFFF ? 0 : rval);\n\t\t\t}\n\t\t}\n\t\treturn(0);\n\t}\n\n\tif (DC_IS_COMET(sc)) {\n\t\tswitch(reg) {\n\t\tcase MII_BMCR:\n\t\t\tphy_reg = DC_AL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\tphy_reg = DC_AL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\t\tphy_reg = DC_AL_VENID;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR2:\n\t\t\tphy_reg = DC_AL_DEVID;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\tphy_reg = DC_AL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\tphy_reg = DC_AL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\tphy_reg = DC_AL_ANER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"dc%d: phy_read: bad phy register %x\\n\",\n\t\t\t    sc->dc_unit, reg);\n\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\n\t\trval = CSR_READ_4(sc, phy_reg) & 0x0000FFFF;\n\n\t\tif (rval == 0xFFFF)\n\t\t\treturn(0);\n\t\treturn(rval);\n\t}\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tphy_reg = CSR_READ_4(sc, DC_NETCFG);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);\n\tdc_mii_readreg(sc, &frame);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg);\n\n\treturn(frame.mii_data);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_mii_readreg",
      "int dc_miibus_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_NETCFG",
            "phy_reg"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_mii_readreg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "469-536",
          "snippet": "int dc_mii_readreg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Sync the PHYs.\n\t */\n\tdc_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\n#ifdef notdef\n\t/* Idle bit */\n\tdc_mii_writebit(sc, 1);\n\tdc_mii_writebit(sc, 0);\n#endif\n\n\t/* Check for ack */\n\tack = dc_mii_readbit(sc);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tdc_mii_readbit(sc);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tif (!ack) {\n\t\t\tif (dc_mii_readbit(sc))\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t}\n\nfail:\n\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit",
            "int dc_mii_readbit",
            "void dc_mii_sync",
            "void dc_mii_send",
            "int dc_mii_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nint dc_mii_readbit;\nvoid dc_mii_sync;\nvoid dc_mii_send;\nint dc_mii_readreg;\n\nint dc_mii_readreg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Sync the PHYs.\n\t */\n\tdc_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\n#ifdef notdef\n\t/* Idle bit */\n\tdc_mii_writebit(sc, 1);\n\tdc_mii_writebit(sc, 0);\n#endif\n\n\t/* Check for ack */\n\tack = dc_mii_readbit(sc);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tdc_mii_readbit(sc);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tif (!ack) {\n\t\t\tif (dc_mii_readbit(sc))\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t}\n\nfail:\n\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_NETCFG",
            "phy_reg & ~DC_NETCFG_PORTSEL"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_NETCFG"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "phy_reg"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dc%d: phy_read: bad phy register %x\\n\"",
            "sc->dc_unit",
            "reg"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_COMET",
          "args": [
            "sc"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_PN_MII"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_PN_MII",
            "DC_PN_MIIOPCODE_READ |\n\t\t    (phy << 23) | (reg << 18)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_ADMTEK",
          "args": [
            "sc"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_mii_readreg;\nint dc_miibus_readreg;\n\nint dc_miibus_readreg(self, phy, reg)\n\tstruct device\t\t*self;\n\tint\t\t\tphy, reg;\n{\n\tstruct dc_mii_frame\tframe;\n\tstruct dc_softc\t\t*sc = (struct dc_softc *)self;\n\tint\t\t\ti, rval, phy_reg;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\t/*\n\t * Note: both the AL981 and AN985 have internal PHYs,\n\t * however the AL981 provides direct access to the PHY\n\t * registers while the AN985 uses a serial MII interface.\n\t * The AN985's MII interface is also buggy in that you\n\t * can read from any MII address (0 to 31), but only address 1\n\t * behaves normally. To deal with both cases, we pretend\n\t * that the PHY is at MII address 1.\n\t */\n\tif (DC_IS_ADMTEK(sc) && phy != DC_ADMTEK_PHYADDR)\n\t\treturn(0);\n\n\tif (sc->dc_pmode == DC_PMODE_SYM) {\n\t\tif (phy == (MII_NPHY - 1)) {\n\t\t\tswitch(reg) {\n\t\t\tcase MII_BMSR:\n\t\t\t/*\n\t\t\t * Fake something to make the probe\n\t\t\t * code think there's a PHY here.\n\t\t\t */\n\t\t\t\treturn(BMSR_MEDIAMASK);\n\t\t\t\tbreak;\n\t\t\tcase MII_PHYIDR1:\n\t\t\t\tif (DC_IS_PNIC(sc))\n\t\t\t\t\treturn(PCI_VENDOR_LITEON);\n\t\t\t\treturn(PCI_VENDOR_DEC);\n\t\t\t\tbreak;\n\t\t\tcase MII_PHYIDR2:\n\t\t\t\tif (DC_IS_PNIC(sc))\n\t\t\t\t\treturn(PCI_PRODUCT_LITEON_PNIC);\n\t\t\t\treturn(PCI_PRODUCT_DEC_21142);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\treturn(0);\n\t}\n\n\tif (DC_IS_PNIC(sc)) {\n\t\tCSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_READ |\n\t\t    (phy << 23) | (reg << 18));\n\t\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\t\tDELAY(1);\n\t\t\trval = CSR_READ_4(sc, DC_PN_MII);\n\t\t\tif (!(rval & DC_PN_MII_BUSY)) {\n\t\t\t\trval &= 0xFFFF;\n\t\t\t\treturn(rval == 0xFFFF ? 0 : rval);\n\t\t\t}\n\t\t}\n\t\treturn(0);\n\t}\n\n\tif (DC_IS_COMET(sc)) {\n\t\tswitch(reg) {\n\t\tcase MII_BMCR:\n\t\t\tphy_reg = DC_AL_BMCR;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\tphy_reg = DC_AL_BMSR;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR1:\n\t\t\tphy_reg = DC_AL_VENID;\n\t\t\tbreak;\n\t\tcase MII_PHYIDR2:\n\t\t\tphy_reg = DC_AL_DEVID;\n\t\t\tbreak;\n\t\tcase MII_ANAR:\n\t\t\tphy_reg = DC_AL_ANAR;\n\t\t\tbreak;\n\t\tcase MII_ANLPAR:\n\t\t\tphy_reg = DC_AL_LPAR;\n\t\t\tbreak;\n\t\tcase MII_ANER:\n\t\t\tphy_reg = DC_AL_ANER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"dc%d: phy_read: bad phy register %x\\n\",\n\t\t\t    sc->dc_unit, reg);\n\t\t\treturn(0);\n\t\t\tbreak;\n\t\t}\n\n\t\trval = CSR_READ_4(sc, phy_reg) & 0x0000FFFF;\n\n\t\tif (rval == 0xFFFF)\n\t\t\treturn(0);\n\t\treturn(rval);\n\t}\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tphy_reg = CSR_READ_4(sc, DC_NETCFG);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg & ~DC_NETCFG_PORTSEL);\n\tdc_mii_readreg(sc, &frame);\n\tCSR_WRITE_4(sc, DC_NETCFG, phy_reg);\n\n\treturn(frame.mii_data);\n}"
  },
  {
    "function_name": "dc_mii_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "541-576",
    "snippet": "int dc_mii_writereg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_WRITEOP;\n\tframe->mii_turnaround = DC_MII_TURNAROUND;\n\n\t/*\n\t * Sync the PHYs.\n\t */\t\n\tdc_mii_sync(sc);\n\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\tdc_mii_send(sc, frame->mii_turnaround, 2);\n\tdc_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_mii_writebit",
      "void dc_mii_sync",
      "void dc_mii_send",
      "int dc_mii_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_mii_writebit",
          "args": [
            "sc",
            "0"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_writebit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "404-418",
          "snippet": "void dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\n\nvoid dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_mii_send",
          "args": [
            "sc",
            "frame->mii_data",
            "16"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "455-464",
          "snippet": "void dc_mii_send(sc, bits, cnt)\n\tstruct dc_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1)\n\t\tdc_mii_writebit(sc, bits & i);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit",
            "void dc_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_send;\n\nvoid dc_mii_send(sc, bits, cnt)\n\tstruct dc_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1)\n\t\tdc_mii_writebit(sc, bits & i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_mii_sync",
          "args": [
            "sc"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "439-450",
          "snippet": "void dc_mii_sync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tfor (i = 0; i < 32; i++)\n\t\tdc_mii_writebit(sc, 1);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit",
            "void dc_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_sync;\n\nvoid dc_mii_sync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tfor (i = 0; i < 32; i++)\n\t\tdc_mii_writebit(sc, 1);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_sync;\nvoid dc_mii_send;\nint dc_mii_writereg;\n\nint dc_mii_writereg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_WRITEOP;\n\tframe->mii_turnaround = DC_MII_TURNAROUND;\n\n\t/*\n\t * Sync the PHYs.\n\t */\t\n\tdc_mii_sync(sc);\n\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\tdc_mii_send(sc, frame->mii_turnaround, 2);\n\tdc_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_mii_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "469-536",
    "snippet": "int dc_mii_readreg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Sync the PHYs.\n\t */\n\tdc_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\n#ifdef notdef\n\t/* Idle bit */\n\tdc_mii_writebit(sc, 1);\n\tdc_mii_writebit(sc, 0);\n#endif\n\n\t/* Check for ack */\n\tack = dc_mii_readbit(sc);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tdc_mii_readbit(sc);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tif (!ack) {\n\t\t\tif (dc_mii_readbit(sc))\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t}\n\nfail:\n\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_mii_writebit",
      "int dc_mii_readbit",
      "void dc_mii_sync",
      "void dc_mii_send",
      "int dc_mii_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_mii_writebit",
          "args": [
            "sc",
            "0"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_writebit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "404-418",
          "snippet": "void dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\n\nvoid dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_mii_readbit",
          "args": [
            "sc"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_readbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "423-434",
          "snippet": "int dc_mii_readbit(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_READ|DC_SIO_MII_DIR);\n\tCSR_READ_4(sc, DC_SIO);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_MII_DATAIN)\n\t\treturn(1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int dc_mii_readbit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_mii_readbit;\n\nint dc_mii_readbit(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_READ|DC_SIO_MII_DIR);\n\tCSR_READ_4(sc, DC_SIO);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_MII_DATAIN)\n\t\treturn(1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_mii_send",
          "args": [
            "sc",
            "frame->mii_regaddr",
            "5"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "455-464",
          "snippet": "void dc_mii_send(sc, bits, cnt)\n\tstruct dc_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1)\n\t\tdc_mii_writebit(sc, bits & i);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit",
            "void dc_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_send;\n\nvoid dc_mii_send(sc, bits, cnt)\n\tstruct dc_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1)\n\t\tdc_mii_writebit(sc, bits & i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_mii_sync",
          "args": [
            "sc"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "439-450",
          "snippet": "void dc_mii_sync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tfor (i = 0; i < 32; i++)\n\t\tdc_mii_writebit(sc, 1);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit",
            "void dc_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_sync;\n\nvoid dc_mii_sync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tfor (i = 0; i < 32; i++)\n\t\tdc_mii_writebit(sc, 1);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nint dc_mii_readbit;\nvoid dc_mii_sync;\nvoid dc_mii_send;\nint dc_mii_readreg;\n\nint dc_mii_readreg(sc, frame)\n\tstruct dc_softc\t\t*sc;\n\tstruct dc_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = DC_MII_STARTDELIM;\n\tframe->mii_opcode = DC_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Sync the PHYs.\n\t */\n\tdc_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tdc_mii_send(sc, frame->mii_stdelim, 2);\n\tdc_mii_send(sc, frame->mii_opcode, 2);\n\tdc_mii_send(sc, frame->mii_phyaddr, 5);\n\tdc_mii_send(sc, frame->mii_regaddr, 5);\n\n#ifdef notdef\n\t/* Idle bit */\n\tdc_mii_writebit(sc, 1);\n\tdc_mii_writebit(sc, 0);\n#endif\n\n\t/* Check for ack */\n\tack = dc_mii_readbit(sc);\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tdc_mii_readbit(sc);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tif (!ack) {\n\t\t\tif (dc_mii_readbit(sc))\n\t\t\t\tframe->mii_data |= i;\n\t\t}\n\t}\n\nfail:\n\n\tdc_mii_writebit(sc, 0);\n\tdc_mii_writebit(sc, 0);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_mii_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "455-464",
    "snippet": "void dc_mii_send(sc, bits, cnt)\n\tstruct dc_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1)\n\t\tdc_mii_writebit(sc, bits & i);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_mii_writebit",
      "void dc_mii_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_mii_writebit",
          "args": [
            "sc",
            "bits & i"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_writebit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "404-418",
          "snippet": "void dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\n\nvoid dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_send;\n\nvoid dc_mii_send(sc, bits, cnt)\n\tstruct dc_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1)\n\t\tdc_mii_writebit(sc, bits & i);\n}"
  },
  {
    "function_name": "dc_mii_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "439-450",
    "snippet": "void dc_mii_sync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tfor (i = 0; i < 32; i++)\n\t\tdc_mii_writebit(sc, 1);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_mii_writebit",
      "void dc_mii_sync"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_mii_writebit",
          "args": [
            "sc",
            "1"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "dc_mii_writebit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "404-418",
          "snippet": "void dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_mii_writebit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\n\nvoid dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_ROMCTL_WRITE"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\nvoid dc_mii_sync;\n\nvoid dc_mii_sync(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tfor (i = 0; i < 32; i++)\n\t\tdc_mii_writebit(sc, 1);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_mii_readbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "423-434",
    "snippet": "int dc_mii_readbit(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_READ|DC_SIO_MII_DIR);\n\tCSR_READ_4(sc, DC_SIO);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_MII_DATAIN)\n\t\treturn(1);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int dc_mii_readbit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_SIO"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_MII_CLK"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_MII_CLK"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_SIO"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_ROMCTL_READ|DC_SIO_MII_DIR"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint dc_mii_readbit;\n\nint dc_mii_readbit(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_READ|DC_SIO_MII_DIR);\n\tCSR_READ_4(sc, DC_SIO);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_MII_DATAIN)\n\t\treturn(1);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "dc_mii_writebit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "404-418",
    "snippet": "void dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_mii_writebit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_MII_CLK"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_MII_CLK"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_ROMCTL_WRITE"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_mii_writebit;\n\nvoid dc_mii_writebit(sc, bit)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\tbit;\n{\n\tif (bit)\n\t\tCSR_WRITE_4(sc, DC_SIO,\n\t\t    DC_SIO_ROMCTL_WRITE|DC_SIO_MII_DATAOUT);\n\telse\n\t\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_ROMCTL_WRITE);\n\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_MII_CLK);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "372-395",
    "snippet": "void dc_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (DC_IS_PNIC(sc))\n\t\t\tdc_eeprom_getword_pnic(sc, off + i, &word);\n\t\telse\n\t\t\tdc_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_eeprom_getword",
      "void dc_eeprom_getword_pnic",
      "void dc_read_eeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "word"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_eeprom_getword",
          "args": [
            "sc",
            "off + i",
            "&word"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "dc_eeprom_getword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "322-367",
          "snippet": "void dc_eeprom_getword(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Force EEPROM to idle state. */\n\tdc_eeprom_idle(sc);\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO,  DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\tdc_eeprom_putbyte(sc, addr);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tdc_eeprom_idle(sc);\n\n\t*dest = word;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay",
            "void dc_eeprom_idle",
            "void dc_eeprom_putbyte",
            "void dc_eeprom_getword"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\nvoid dc_eeprom_idle;\nvoid dc_eeprom_putbyte;\nvoid dc_eeprom_getword;\n\nvoid dc_eeprom_getword(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Force EEPROM to idle state. */\n\tdc_eeprom_idle(sc);\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO,  DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\tdc_eeprom_putbyte(sc, addr);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tdc_eeprom_idle(sc);\n\n\t*dest = word;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_eeprom_getword_pnic",
          "args": [
            "sc",
            "off + i",
            "&word"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dc_eeprom_getword_pnic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "297-317",
          "snippet": "void dc_eeprom_getword_pnic(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int32_t\t\tr;\n\n\tCSR_WRITE_4(sc, DC_PN_SIOCTL, DC_PN_EEOPCODE_READ|addr);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tr = CSR_READ_4(sc, DC_SIO);\n\t\tif (!(r & DC_PN_SIOCTL_BUSY)) {\n\t\t\t*dest = (u_int16_t)(r & 0xFFFF);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_eeprom_getword_pnic"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_eeprom_getword_pnic;\n\nvoid dc_eeprom_getword_pnic(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int32_t\t\tr;\n\n\tCSR_WRITE_4(sc, DC_PN_SIOCTL, DC_PN_EEOPCODE_READ|addr);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tr = CSR_READ_4(sc, DC_SIO);\n\t\tif (!(r & DC_PN_SIOCTL_BUSY)) {\n\t\t\t*dest = (u_int16_t)(r & 0xFFFF);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_IS_PNIC",
          "args": [
            "sc"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_eeprom_getword;\nvoid dc_eeprom_getword_pnic;\nvoid dc_read_eeprom;\n\nvoid dc_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct dc_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (DC_IS_PNIC(sc))\n\t\t\tdc_eeprom_getword_pnic(sc, off + i, &word);\n\t\telse\n\t\t\tdc_eeprom_getword(sc, off + i, &word);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_eeprom_getword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "322-367",
    "snippet": "void dc_eeprom_getword(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Force EEPROM to idle state. */\n\tdc_eeprom_idle(sc);\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO,  DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\tdc_eeprom_putbyte(sc, addr);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tdc_eeprom_idle(sc);\n\n\t*dest = word;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_delay",
      "void dc_eeprom_idle",
      "void dc_eeprom_putbyte",
      "void dc_eeprom_getword"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_eeprom_idle",
          "args": [
            "sc"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "dc_eeprom_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "224-252",
          "snippet": "void dc_eeprom_idle(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\tfor (i = 0; i < 25; i++) {\n\t\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\tCSR_WRITE_4(sc, DC_SIO, 0x00000000);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay",
            "void dc_eeprom_idle"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\nvoid dc_eeprom_idle;\n\nvoid dc_eeprom_idle(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\tfor (i = 0; i < 25; i++) {\n\t\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\tCSR_WRITE_4(sc, DC_SIO, 0x00000000);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_delay",
          "args": [
            "sc"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "DC_SIO_EE_CLK"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_SIO"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "DC_SIO_EE_CLK"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_eeprom_putbyte",
          "args": [
            "sc",
            "addr"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "dc_eeprom_putbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "257-290",
          "snippet": "void dc_eeprom_putbyte(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\t/*\n\t * The AN985 has a 93C66 EEPROM on it instead of\n\t * a 93C46. It uses a different bit sequence for\n\t * specifying the \"read\" opcode.\n\t */\n\tif (DC_IS_CENTAUR(sc))\n\t\td = addr | (DC_EECMD_READ << 2);\n\telse\n\t\td = addr | DC_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tSIO_SET(DC_SIO_EE_DATAIN);\n\t\t} else {\n\t\t\tSIO_CLR(DC_SIO_EE_DATAIN);\n\t\t}\n\t\tdc_delay(sc);\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay",
            "void dc_eeprom_putbyte"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\nvoid dc_eeprom_putbyte;\n\nvoid dc_eeprom_putbyte(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\t/*\n\t * The AN985 has a 93C66 EEPROM on it instead of\n\t * a 93C46. It uses a different bit sequence for\n\t * specifying the \"read\" opcode.\n\t */\n\tif (DC_IS_CENTAUR(sc))\n\t\td = addr | (DC_EECMD_READ << 2);\n\telse\n\t\td = addr | DC_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tSIO_SET(DC_SIO_EE_DATAIN);\n\t\t} else {\n\t\t\tSIO_CLR(DC_SIO_EE_DATAIN);\n\t\t}\n\t\tdc_delay(sc);\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CS"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CLK"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_ROMCTL_READ"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EESEL"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\nvoid dc_eeprom_idle;\nvoid dc_eeprom_putbyte;\nvoid dc_eeprom_getword;\n\nvoid dc_eeprom_getword(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int16_t\t\tword = 0;\n\n\t/* Force EEPROM to idle state. */\n\tdc_eeprom_idle(sc);\n\n\t/* Enter EEPROM access mode. */\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO,  DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\t/*\n\t * Send address of word we want to read.\n\t */\n\tdc_eeprom_putbyte(sc, addr);\n\n\t/*\n\t * Start reading bits from EEPROM.\n\t */\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tif (CSR_READ_4(sc, DC_SIO) & DC_SIO_EE_DATAOUT)\n\t\t\tword |= i;\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\t/* Turn off EEPROM access mode. */\n\tdc_eeprom_idle(sc);\n\n\t*dest = word;\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_eeprom_getword_pnic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "297-317",
    "snippet": "void dc_eeprom_getword_pnic(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int32_t\t\tr;\n\n\tCSR_WRITE_4(sc, DC_PN_SIOCTL, DC_PN_EEOPCODE_READ|addr);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tr = CSR_READ_4(sc, DC_SIO);\n\t\tif (!(r & DC_PN_SIOCTL_BUSY)) {\n\t\t\t*dest = (u_int16_t)(r & 0xFFFF);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_eeprom_getword_pnic"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "r & 0xFFFF"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_SIO"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_PN_SIOCTL",
            "DC_PN_EEOPCODE_READ|addr"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_eeprom_getword_pnic;\n\nvoid dc_eeprom_getword_pnic(sc, addr, dest)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n\tu_int16_t\t\t*dest;\n{\n\tregister int\t\ti;\n\tu_int32_t\t\tr;\n\n\tCSR_WRITE_4(sc, DC_PN_SIOCTL, DC_PN_EEOPCODE_READ|addr);\n\n\tfor (i = 0; i < DC_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tr = CSR_READ_4(sc, DC_SIO);\n\t\tif (!(r & DC_PN_SIOCTL_BUSY)) {\n\t\t\t*dest = (u_int16_t)(r & 0xFFFF);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_eeprom_putbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "257-290",
    "snippet": "void dc_eeprom_putbyte(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\t/*\n\t * The AN985 has a 93C66 EEPROM on it instead of\n\t * a 93C46. It uses a different bit sequence for\n\t * specifying the \"read\" opcode.\n\t */\n\tif (DC_IS_CENTAUR(sc))\n\t\td = addr | (DC_EECMD_READ << 2);\n\telse\n\t\td = addr | DC_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tSIO_SET(DC_SIO_EE_DATAIN);\n\t\t} else {\n\t\t\tSIO_CLR(DC_SIO_EE_DATAIN);\n\t\t}\n\t\tdc_delay(sc);\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_delay",
      "void dc_eeprom_putbyte"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_delay",
          "args": [
            "sc"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "DC_SIO_EE_CLK"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "DC_SIO_EE_CLK"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "DC_SIO_EE_DATAIN"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "DC_SIO_EE_DATAIN"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_IS_CENTAUR",
          "args": [
            "sc"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\nvoid dc_eeprom_putbyte;\n\nvoid dc_eeprom_putbyte(sc, addr)\n\tstruct dc_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tregister int\t\td, i;\n\n\t/*\n\t * The AN985 has a 93C66 EEPROM on it instead of\n\t * a 93C46. It uses a different bit sequence for\n\t * specifying the \"read\" opcode.\n\t */\n\tif (DC_IS_CENTAUR(sc))\n\t\td = addr | (DC_EECMD_READ << 2);\n\telse\n\t\td = addr | DC_EECMD_READ;\n\n\t/*\n\t * Feed in each bit and strobe the clock.\n\t */\n\tfor (i = 0x400; i; i >>= 1) {\n\t\tif (d & i) {\n\t\t\tSIO_SET(DC_SIO_EE_DATAIN);\n\t\t} else {\n\t\t\tSIO_CLR(DC_SIO_EE_DATAIN);\n\t\t}\n\t\tdc_delay(sc);\n\t\tSIO_SET(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tSIO_CLR(DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_eeprom_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "224-252",
    "snippet": "void dc_eeprom_idle(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\tfor (i = 0; i < 25; i++) {\n\t\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\tCSR_WRITE_4(sc, DC_SIO, 0x00000000);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_delay",
      "void dc_eeprom_idle"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_SIO",
            "0x00000000"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_delay",
          "args": [
            "sc"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CS"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CLK"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CLK"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CLK"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CS"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_CLRBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EE_CLK"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DC_SETBIT",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_ROMCTL_READ"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "DC_SIO",
            "DC_SIO_EESEL"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\nvoid dc_eeprom_idle;\n\nvoid dc_eeprom_idle(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tCSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\n\tfor (i = 0; i < 25; i++) {\n\t\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t\tDC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\t\tdc_delay(sc);\n\t}\n\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);\n\tdc_delay(sc);\n\tDC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CS);\n\tdc_delay(sc);\n\tCSR_WRITE_4(sc, DC_SIO, 0x00000000);\n\n\treturn;\n}"
  },
  {
    "function_name": "dc_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
    "lines": "215-222",
    "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
    "includes": [
      "#include <dev/ic/dcreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void dc_delay"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "DC_BUSCTL"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
  }
]