[
  {
    "function_name": "pss_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1416-1596",
    "snippet": "int\npss_query_devinfo(addr, dip)\n    void *addr;\n    mixer_devinfo_t *dip;\n{\n    DPRINTF((\"pss_query_devinfo: index=%d\\n\", dip->index));\n\n    switch(dip->index) {\n    case PSS_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_LINE_IN_LVL:\t/* line/CD */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_MON_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_MASTER_VOL:\t/* master volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_OUTPUT_MODE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_MASTER_TREBLE:\t/* master treble */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNtreble);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNtreble);\n\tbreak;\n\n    case PSS_MASTER_BASS:\t/* master bass */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNbass);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNbass);\n\tbreak;\n\n    case PSS_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case PSS_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case PSS_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case PSS_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\t\n    case PSS_MIC_IN_MUTE:\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_MIC_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case PSS_LINE_IN_MUTE:\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case PSS_DAC_MUTE:\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\n    case PSS_OUTPUT_MODE:\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_MASTER_VOL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmode);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNmono);\n\tdip->un.e.member[0].ord = PSS_SPKR_MONO;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNstereo);\n\tdip->un.e.member[1].ord = PSS_SPKR_STEREO;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNpseudo);\n\tdip->un.e.member[2].ord = PSS_SPKR_PSEUDO;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNspatial);\n\tdip->un.e.member[3].ord = PSS_SPKR_SPATIAL;\n\tbreak;\n\n    case PSS_RECORD_SOURCE:\n\tdip->mixer_class = PSS_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 3;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\tdip->un.e.member[0].ord = PSS_MIC_IN_LVL;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNcd);\n\tdip->un.e.member[1].ord = PSS_LINE_IN_LVL;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = PSS_DAC_LVL;\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define PSS_OUTPUT_CLASS\t16",
      "#define PSS_MONITOR_CLASS\t15",
      "#define PSS_RECORD_CLASS\t14",
      "#define PSS_INPUT_CLASS\t\t13",
      "#define PSS_RECORD_SOURCE\t12",
      "#define \tPSS_SPKR_SPATIAL 3",
      "#define \tPSS_SPKR_PSEUDO\t2",
      "#define \tPSS_SPKR_STEREO\t1",
      "#define \tPSS_SPKR_MONO\t0",
      "#define PSS_OUTPUT_MODE\t\t11",
      "#define PSS_DAC_MUTE\t\t10",
      "#define PSS_LINE_IN_MUTE\t9",
      "#define PSS_MIC_IN_MUTE\t\t8",
      "#define PSS_MASTER_BASS\t\t7",
      "#define PSS_MASTER_TREBLE\t6",
      "#define PSS_MASTER_VOL\t\t5",
      "#define PSS_MON_LVL\t\t4",
      "#define PSS_REC_LVL\t\t3",
      "#define PSS_DAC_LVL\t\t2",
      "#define PSS_LINE_IN_LVL\t\t1",
      "#define PSS_MIC_IN_LVL\t\t0"
    ],
    "globals_used": [
      "int\tpss_query_devinfo"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name)"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[2].label.name",
            "AudioNdac"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNcd"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNmicrophone"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[3].label.name",
            "AudioNspatial"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[2].label.name",
            "AudioNpseudo"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNstereo"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNmono"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmode"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmute"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCrecord"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCmonitor"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCinputs"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCoutputs"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNbass"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNbass"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNtreble"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNtreble"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmaster"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmonitor"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNrecord"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNdac"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNcd"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_query_devinfo: index=%d\\n\", dip->index)"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define PSS_OUTPUT_CLASS\t16\n#define PSS_MONITOR_CLASS\t15\n#define PSS_RECORD_CLASS\t14\n#define PSS_INPUT_CLASS\t\t13\n#define PSS_RECORD_SOURCE\t12\n#define \tPSS_SPKR_SPATIAL 3\n#define \tPSS_SPKR_PSEUDO\t2\n#define \tPSS_SPKR_STEREO\t1\n#define \tPSS_SPKR_MONO\t0\n#define PSS_OUTPUT_MODE\t\t11\n#define PSS_DAC_MUTE\t\t10\n#define PSS_LINE_IN_MUTE\t9\n#define PSS_MIC_IN_MUTE\t\t8\n#define PSS_MASTER_BASS\t\t7\n#define PSS_MASTER_TREBLE\t6\n#define PSS_MASTER_VOL\t\t5\n#define PSS_MON_LVL\t\t4\n#define PSS_REC_LVL\t\t3\n#define PSS_DAC_LVL\t\t2\n#define PSS_LINE_IN_LVL\t\t1\n#define PSS_MIC_IN_LVL\t\t0\n\nint\tpss_query_devinfo;\n\nint\npss_query_devinfo(addr, dip)\n    void *addr;\n    mixer_devinfo_t *dip;\n{\n    DPRINTF((\"pss_query_devinfo: index=%d\\n\", dip->index));\n\n    switch(dip->index) {\n    case PSS_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_LINE_IN_LVL:\t/* line/CD */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_MON_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_MASTER_VOL:\t/* master volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = PSS_OUTPUT_MODE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case PSS_MASTER_TREBLE:\t/* master treble */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNtreble);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNtreble);\n\tbreak;\n\n    case PSS_MASTER_BASS:\t/* master bass */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNbass);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNbass);\n\tbreak;\n\n    case PSS_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case PSS_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case PSS_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case PSS_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = PSS_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\t\n    case PSS_MIC_IN_MUTE:\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_MIC_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case PSS_LINE_IN_MUTE:\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case PSS_DAC_MUTE:\n\tdip->mixer_class = PSS_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\n    case PSS_OUTPUT_MODE:\n\tdip->mixer_class = PSS_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_MASTER_VOL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmode);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNmono);\n\tdip->un.e.member[0].ord = PSS_SPKR_MONO;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNstereo);\n\tdip->un.e.member[1].ord = PSS_SPKR_STEREO;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNpseudo);\n\tdip->un.e.member[2].ord = PSS_SPKR_PSEUDO;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNspatial);\n\tdip->un.e.member[3].ord = PSS_SPKR_SPATIAL;\n\tbreak;\n\n    case PSS_RECORD_SOURCE:\n\tdip->mixer_class = PSS_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = PSS_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 3;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNmicrophone);\n\tdip->un.e.member[0].ord = PSS_MIC_IN_LVL;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNcd);\n\tdip->un.e.member[1].ord = PSS_LINE_IN_LVL;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = PSS_DAC_LVL;\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\n    return 0;\n}"
  },
  {
    "function_name": "pss_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1362-1414",
    "snippet": "int\npss_mixer_get_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n    struct pss_softc *sc = ac->parent;\n    struct ad1848_volume vol;\n    u_char eq;\n    int error = ad1848_mixer_get_port(ac, mappings, nummap, cp);\n\n    if (error != ENXIO)\n      return (error);\n\n    error = EINVAL;\n\n    switch (cp->dev) {\n    case PSS_MASTER_VOL:\t/* master volume */\n\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t    error = pss_get_master_gain(sc, &vol);\n\t    if (!error)\n\t\tad1848_from_vol(cp, &vol);\n\t}\n\tbreak;\n\n    case PSS_MASTER_TREBLE:\t/* master treble */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {\n\t    error = pss_get_treble(sc, &eq);\n\t    if (!error)\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = eq;\n\t}\n\tbreak;\n\n    case PSS_MASTER_BASS:\t/* master bass */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {\n\t    error = pss_get_bass(sc, &eq);\n\t    if (!error)\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = eq;\n\t}\n\tbreak;\n\n    case PSS_OUTPUT_MODE:\n\tif (cp->type == AUDIO_MIXER_ENUM)\n\t    error = pss_get_master_mode(sc, &cp->un.ord);\n\tbreak;\n\n    default:\n\terror = ENXIO;\n\tbreak;\n    }\n\n    return(error);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define PSS_OUTPUT_MODE\t\t11",
      "#define PSS_MASTER_BASS\t\t7",
      "#define PSS_MASTER_TREBLE\t6",
      "#define PSS_MASTER_VOL\t\t5"
    ],
    "globals_used": [
      "int\tpss_mixer_get_port",
      "int\tpss_get_master_gain",
      "int\tpss_get_master_mode",
      "int\tpss_get_treble",
      "int\tpss_get_bass",
      "static ad1848_devmap_t mappings[] = {\n{ PSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ PSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ PSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ PSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ PSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};",
      "static int nummap = sizeof(mappings) / sizeof(mappings[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_get_master_mode",
          "args": [
            "sc",
            "&cp->un.ord"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "pss_get_master_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1218-1225",
          "snippet": "int\npss_get_master_mode(sc, mode)\n    struct pss_softc *sc;\n    u_int *mode;\n{\n    *mode = sc->master_mode;\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_get_master_mode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_master_mode;\n\nint\npss_get_master_mode(sc, mode)\n    struct pss_softc *sc;\n    u_int *mode;\n{\n    *mode = sc->master_mode;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_get_bass",
          "args": [
            "sc",
            "&eq"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "pss_get_bass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1236-1243",
          "snippet": "int\npss_get_bass(sc, bp)\n    struct pss_softc *sc;\n    u_char *bp;\n{\n    *bp = sc->monitor_bass;\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_get_bass"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_bass;\n\nint\npss_get_bass(sc, bp)\n    struct pss_softc *sc;\n    u_char *bp;\n{\n    *bp = sc->monitor_bass;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_get_treble",
          "args": [
            "sc",
            "&eq"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "pss_get_treble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1227-1234",
          "snippet": "int\npss_get_treble(sc, tp)\n    struct pss_softc *sc;\n    u_char *tp;\n{\n    *tp = sc->monitor_treble;\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_get_treble"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_treble;\n\nint\npss_get_treble(sc, tp)\n    struct pss_softc *sc;\n    u_char *tp;\n{\n    *tp = sc->monitor_treble;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_from_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_from_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "162-177",
          "snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_get_master_gain",
          "args": [
            "sc",
            "&vol"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "pss_get_master_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1209-1216",
          "snippet": "int\npss_get_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->master_volume;\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_get_master_gain"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_master_gain;\n\nint\npss_get_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->master_volume;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_get_port",
          "args": [
            "ac",
            "mappings",
            "nummap",
            "cp"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "793-865",
          "snippet": "int     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define PSS_OUTPUT_MODE\t\t11\n#define PSS_MASTER_BASS\t\t7\n#define PSS_MASTER_TREBLE\t6\n#define PSS_MASTER_VOL\t\t5\n\nint\tpss_mixer_get_port;\nint\tpss_get_master_gain;\nint\tpss_get_master_mode;\nint\tpss_get_treble;\nint\tpss_get_bass;\nstatic ad1848_devmap_t mappings[] = {\n{ PSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ PSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ PSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ PSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ PSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};\nstatic int nummap = sizeof(mappings) / sizeof(mappings[0]);\n\nint\npss_mixer_get_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n    struct pss_softc *sc = ac->parent;\n    struct ad1848_volume vol;\n    u_char eq;\n    int error = ad1848_mixer_get_port(ac, mappings, nummap, cp);\n\n    if (error != ENXIO)\n      return (error);\n\n    error = EINVAL;\n\n    switch (cp->dev) {\n    case PSS_MASTER_VOL:\t/* master volume */\n\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t    error = pss_get_master_gain(sc, &vol);\n\t    if (!error)\n\t\tad1848_from_vol(cp, &vol);\n\t}\n\tbreak;\n\n    case PSS_MASTER_TREBLE:\t/* master treble */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {\n\t    error = pss_get_treble(sc, &eq);\n\t    if (!error)\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = eq;\n\t}\n\tbreak;\n\n    case PSS_MASTER_BASS:\t/* master bass */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {\n\t    error = pss_get_bass(sc, &eq);\n\t    if (!error)\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = eq;\n\t}\n\tbreak;\n\n    case PSS_OUTPUT_MODE:\n\tif (cp->type == AUDIO_MIXER_ENUM)\n\t    error = pss_get_master_mode(sc, &cp->un.ord);\n\tbreak;\n\n    default:\n\terror = ENXIO;\n\tbreak;\n    }\n\n    return(error);\n}"
  },
  {
    "function_name": "pss_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1318-1360",
    "snippet": "int\npss_mixer_set_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n    struct pss_softc *sc = ac->parent;\n    struct ad1848_volume vol;\n    int error = ad1848_mixer_set_port(ac, mappings, nummap, cp);\n    \n    if (error != ENXIO)\n      return (error);\n\n    switch (cp->dev) {\n    case PSS_MASTER_VOL:\t/* master volume */\n\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t    if (ad1848_to_vol(cp, &vol))\n\t\terror = pss_set_master_gain(sc, &vol);\n\t}\n\tbreak;\n\n    case PSS_OUTPUT_MODE:\n\tif (cp->type == AUDIO_MIXER_ENUM)\n\t    error = pss_set_master_mode(sc, cp->un.ord);\n\tbreak;\n\n    case PSS_MASTER_TREBLE:\t/* master treble */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1)\n\t    error = pss_set_treble(sc, (u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\tbreak;\n\n    case PSS_MASTER_BASS:\t/* master bass */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1)\n\t    error = pss_set_bass(sc, (u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\tbreak;\n\n    default:\n\t    return ENXIO;\n\t    /*NOTREACHED*/\n    }\n    \n    return 0;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define PSS_OUTPUT_MODE\t\t11",
      "#define PSS_MASTER_BASS\t\t7",
      "#define PSS_MASTER_TREBLE\t6",
      "#define PSS_MASTER_VOL\t\t5"
    ],
    "globals_used": [
      "int\tpss_mixer_set_port",
      "int\tpss_set_master_gain",
      "int\tpss_set_master_mode",
      "int\tpss_set_treble",
      "int\tpss_set_bass",
      "static ad1848_devmap_t mappings[] = {\n{ PSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ PSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ PSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ PSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ PSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};",
      "static int nummap = sizeof(mappings) / sizeof(mappings[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_set_bass",
          "args": [
            "sc",
            "(u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_bass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1188-1207",
          "snippet": "int\npss_set_bass(sc, bass)\n    struct pss_softc *sc;\n    u_int bass;\n{\n    DPRINTF((\"pss_set_bass: %d\\n\", bass));\n\n#ifdef PSS_DSP\n    if (bass > PHILLIPS_BASS_MAX)\n\tbass = PHILLIPS_BASS_MAX;\n    if (bass < PHILLIPS_BASS_MIN)\n\tbass = PHILLIPS_BASS_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP));\n#endif\n\n    sc->monitor_bass = bass;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_set_bass"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_bass;\n\nint\npss_set_bass(sc, bass)\n    struct pss_softc *sc;\n    u_int bass;\n{\n    DPRINTF((\"pss_set_bass: %d\\n\", bass));\n\n#ifdef PSS_DSP\n    if (bass > PHILLIPS_BASS_MAX)\n\tbass = PHILLIPS_BASS_MAX;\n    if (bass < PHILLIPS_BASS_MIN)\n\tbass = PHILLIPS_BASS_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP));\n#endif\n\n    sc->monitor_bass = bass;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_set_treble",
          "args": [
            "sc",
            "(u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_treble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1167-1186",
          "snippet": "int\npss_set_treble(sc, treb)\n    struct pss_softc *sc;\n    u_int treb;\n{\n    DPRINTF((\"pss_set_treble: %d\\n\", treb));\n\n#ifdef PSS_DSP\n    if (treb > PHILLIPS_TREBLE_MAX)\n\ttreb = PHILLIPS_TREBLE_MAX;\n    if (treb < PHILLIPS_TREBLE_MIN)\n\ttreb = PHILLIPS_TREBLE_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP));\n#endif\n\n    sc->monitor_treble = treb;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_set_treble"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_treble;\n\nint\npss_set_treble(sc, treb)\n    struct pss_softc *sc;\n    u_int treb;\n{\n    DPRINTF((\"pss_set_treble: %d\\n\", treb));\n\n#ifdef PSS_DSP\n    if (treb > PHILLIPS_TREBLE_MAX)\n\ttreb = PHILLIPS_TREBLE_MAX;\n    if (treb < PHILLIPS_TREBLE_MIN)\n\ttreb = PHILLIPS_TREBLE_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP));\n#endif\n\n    sc->monitor_treble = treb;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_set_master_mode",
          "args": [
            "sc",
            "cp->un.ord"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_master_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1137-1165",
          "snippet": "int\npss_set_master_mode(sc, mode)\n    struct pss_softc *sc;\n    int mode;\n{\n    short phillips_mode;\n\n    DPRINTF((\"pss_set_master_mode: %d\\n\", mode));\n\t\n    if (mode == PSS_SPKR_STEREO)\n\tphillips_mode = PSS_STEREO;\n    else if (mode == PSS_SPKR_PSEUDO)\n\tphillips_mode = PSS_PSEUDO;\n    else if (mode == PSS_SPKR_SPATIAL)\n\tphillips_mode = PSS_SPATIAL;\n    else if (mode == PSS_SPKR_MONO)\n\tphillips_mode = PSS_MONO;\n    else\n\treturn (EINVAL);\n    \n#ifdef PSS_DSP\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_SWITCH | mode);\n#endif\n\n    sc->master_mode = mode;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define \tPSS_SPKR_SPATIAL 3",
            "#define \tPSS_SPKR_PSEUDO\t2",
            "#define \tPSS_SPKR_STEREO\t1",
            "#define \tPSS_SPKR_MONO\t0"
          ],
          "globals_used": [
            "int\tpss_set_master_mode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define \tPSS_SPKR_SPATIAL 3\n#define \tPSS_SPKR_PSEUDO\t2\n#define \tPSS_SPKR_STEREO\t1\n#define \tPSS_SPKR_MONO\t0\n\nint\tpss_set_master_mode;\n\nint\npss_set_master_mode(sc, mode)\n    struct pss_softc *sc;\n    int mode;\n{\n    short phillips_mode;\n\n    DPRINTF((\"pss_set_master_mode: %d\\n\", mode));\n\t\n    if (mode == PSS_SPKR_STEREO)\n\tphillips_mode = PSS_STEREO;\n    else if (mode == PSS_SPKR_PSEUDO)\n\tphillips_mode = PSS_PSEUDO;\n    else if (mode == PSS_SPKR_SPATIAL)\n\tphillips_mode = PSS_SPATIAL;\n    else if (mode == PSS_SPKR_MONO)\n\tphillips_mode = PSS_MONO;\n    else\n\treturn (EINVAL);\n    \n#ifdef PSS_DSP\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_SWITCH | mode);\n#endif\n\n    sc->master_mode = mode;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_set_master_gain",
          "args": [
            "sc",
            "&vol"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_master_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1110-1135",
          "snippet": "int\npss_set_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    DPRINTF((\"pss_set_master_gain: %d:%d\\n\", gp->left, gp->right));\n\t\n#ifdef PSS_DSP\n    if (gp->left > PHILLIPS_VOL_MAX)\n\tgp->left = PHILLIPS_VOL_MAX;\n    if (gp->left < PHILLIPS_VOL_MIN)\n\tgp->left = PHILLIPS_VOL_MIN;\n    if (gp->right > PHILLIPS_VOL_MAX)\n\tgp->right = PHILLIPS_VOL_MAX;\n    if (gp->right < PHILLIPS_VOL_MIN)\n\tgp->right = PHILLIPS_VOL_MIN;\n\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_LEFT|(PHILLIPS_VOL_CONSTANT + gp->left / PHILLIPS_VOL_STEP));\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP));\n#endif\n\n    sc->master_volume = *gp;\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_set_master_gain"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_master_gain;\n\nint\npss_set_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    DPRINTF((\"pss_set_master_gain: %d:%d\\n\", gp->left, gp->right));\n\t\n#ifdef PSS_DSP\n    if (gp->left > PHILLIPS_VOL_MAX)\n\tgp->left = PHILLIPS_VOL_MAX;\n    if (gp->left < PHILLIPS_VOL_MIN)\n\tgp->left = PHILLIPS_VOL_MIN;\n    if (gp->right > PHILLIPS_VOL_MAX)\n\tgp->right = PHILLIPS_VOL_MAX;\n    if (gp->right < PHILLIPS_VOL_MIN)\n\tgp->right = PHILLIPS_VOL_MIN;\n\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_LEFT|(PHILLIPS_VOL_CONSTANT + gp->left / PHILLIPS_VOL_STEP));\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP));\n#endif\n\n    sc->master_volume = *gp;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_to_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_to_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "145-160",
          "snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_set_port",
          "args": [
            "ac",
            "mappings",
            "nummap",
            "cp"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "867-934",
          "snippet": "int     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define PSS_OUTPUT_MODE\t\t11\n#define PSS_MASTER_BASS\t\t7\n#define PSS_MASTER_TREBLE\t6\n#define PSS_MASTER_VOL\t\t5\n\nint\tpss_mixer_set_port;\nint\tpss_set_master_gain;\nint\tpss_set_master_mode;\nint\tpss_set_treble;\nint\tpss_set_bass;\nstatic ad1848_devmap_t mappings[] = {\n{ PSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },\n{ PSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },\n{ PSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },\n{ PSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },\n{ PSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },\n{ PSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },\n{ PSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};\nstatic int nummap = sizeof(mappings) / sizeof(mappings[0]);\n\nint\npss_mixer_set_port(addr, cp)\n    void *addr;\n    mixer_ctrl_t *cp;\n{\n    struct ad1848_softc *ac = addr;\n    struct pss_softc *sc = ac->parent;\n    struct ad1848_volume vol;\n    int error = ad1848_mixer_set_port(ac, mappings, nummap, cp);\n    \n    if (error != ENXIO)\n      return (error);\n\n    switch (cp->dev) {\n    case PSS_MASTER_VOL:\t/* master volume */\n\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t    if (ad1848_to_vol(cp, &vol))\n\t\terror = pss_set_master_gain(sc, &vol);\n\t}\n\tbreak;\n\n    case PSS_OUTPUT_MODE:\n\tif (cp->type == AUDIO_MIXER_ENUM)\n\t    error = pss_set_master_mode(sc, cp->un.ord);\n\tbreak;\n\n    case PSS_MASTER_TREBLE:\t/* master treble */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1)\n\t    error = pss_set_treble(sc, (u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\tbreak;\n\n    case PSS_MASTER_BASS:\t/* master bass */\n\tif (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1)\n\t    error = pss_set_bass(sc, (u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);\n\tbreak;\n\n    default:\n\t    return ENXIO;\n\t    /*NOTREACHED*/\n    }\n    \n    return 0;\n}"
  },
  {
    "function_name": "pss_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1293-1302",
    "snippet": "int\npss_getdev(addr, retp)\n    void *addr;\n    struct audio_device *retp;\n{\n    DPRINTF((\"pss_getdev: retp=%p\\n\", retp));\n\n    *retp = pss_device;\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_getdev",
      "struct audio_device pss_device = {\n\t\"pss,ad1848\",\n\t\"\",\n\t\"PSS\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_getdev: retp=%p\\n\", retp)"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_getdev;\nstruct audio_device pss_device = {\n\t\"pss,ad1848\",\n\t\"\",\n\t\"PSS\"\n};\n\nint\npss_getdev(addr, retp)\n    void *addr;\n    struct audio_device *retp;\n{\n    DPRINTF((\"pss_getdev: retp=%p\\n\", retp));\n\n    *retp = pss_device;\n    return 0;\n}"
  },
  {
    "function_name": "mpuintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1277-1290",
    "snippet": "int\nmpuintr(arg)\n\tvoid *arg;\n{\n    struct mpu_softc *sc = arg;\n    u_char sr;\n    \n    sr = inb(sc->sc_iobase+MIDI_STATUS_REG);\n\n    printf(\"mpuintr: sc=%p sr=%x\\n\", sc, sr);\n\n    /* XXX Need to clear intr */\n    return 1;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"mpuintr: sc=%p sr=%x\\n\"",
            "sc",
            "sr"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase+MIDI_STATUS_REG"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nmpuintr(arg)\n\tvoid *arg;\n{\n    struct mpu_softc *sc = arg;\n    u_char sr;\n    \n    sr = inb(sc->sc_iobase+MIDI_STATUS_REG);\n\n    printf(\"mpuintr: sc=%p sr=%x\\n\", sc, sr);\n\n    /* XXX Need to clear intr */\n    return 1;\n}"
  },
  {
    "function_name": "pssintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1253-1274",
    "snippet": "int\npssintr(arg)\n\tvoid *arg;\n{\n    struct pss_softc *sc = arg;\n    u_short sr;\n    \n    sr = inw(sc->sc_iobase+PSS_STATUS);\n    \n    DPRINTF((\"pssintr: sc=%p st=%x\\n\", sc, sr));\n\n    /* Acknowledge intr */\n    outw(sc->sc_iobase+PSS_IRQ_ACK, 0);\n    \n    /* Is it one of ours ? */\n    if (sr & (PSS_WRITE_EMPTY|PSS_READ_FULL|PSS_IRQ|PSS_DMQ_TC)) {\n\t/* XXX do something */\n\treturn 1;\n    }\n    \n    return 0;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpssintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+PSS_IRQ_ACK",
            "0"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pssintr: sc=%p st=%x\\n\", sc, sr)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_STATUS"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpssintr;\n\nint\npssintr(arg)\n\tvoid *arg;\n{\n    struct pss_softc *sc = arg;\n    u_short sr;\n    \n    sr = inw(sc->sc_iobase+PSS_STATUS);\n    \n    DPRINTF((\"pssintr: sc=%p st=%x\\n\", sc, sr));\n\n    /* Acknowledge intr */\n    outw(sc->sc_iobase+PSS_IRQ_ACK, 0);\n    \n    /* Is it one of ours ? */\n    if (sr & (PSS_WRITE_EMPTY|PSS_READ_FULL|PSS_IRQ|PSS_DMQ_TC)) {\n\t/* XXX do something */\n\treturn 1;\n    }\n    \n    return 0;\n}"
  },
  {
    "function_name": "pss_speaker_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1245-1251",
    "snippet": "int\npss_speaker_ctl(addr, newstate)\n    void *addr;\n    int newstate;\n{\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_speaker_ctl"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_speaker_ctl;\n\nint\npss_speaker_ctl(addr, newstate)\n    void *addr;\n    int newstate;\n{\n    return(0);\n}"
  },
  {
    "function_name": "pss_get_bass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1236-1243",
    "snippet": "int\npss_get_bass(sc, bp)\n    struct pss_softc *sc;\n    u_char *bp;\n{\n    *bp = sc->monitor_bass;\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_get_bass"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_bass;\n\nint\npss_get_bass(sc, bp)\n    struct pss_softc *sc;\n    u_char *bp;\n{\n    *bp = sc->monitor_bass;\n    return(0);\n}"
  },
  {
    "function_name": "pss_get_treble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1227-1234",
    "snippet": "int\npss_get_treble(sc, tp)\n    struct pss_softc *sc;\n    u_char *tp;\n{\n    *tp = sc->monitor_treble;\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_get_treble"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_treble;\n\nint\npss_get_treble(sc, tp)\n    struct pss_softc *sc;\n    u_char *tp;\n{\n    *tp = sc->monitor_treble;\n    return(0);\n}"
  },
  {
    "function_name": "pss_get_master_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1218-1225",
    "snippet": "int\npss_get_master_mode(sc, mode)\n    struct pss_softc *sc;\n    u_int *mode;\n{\n    *mode = sc->master_mode;\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_get_master_mode"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_master_mode;\n\nint\npss_get_master_mode(sc, mode)\n    struct pss_softc *sc;\n    u_int *mode;\n{\n    *mode = sc->master_mode;\n    return(0);\n}"
  },
  {
    "function_name": "pss_get_master_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1209-1216",
    "snippet": "int\npss_get_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->master_volume;\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_get_master_gain"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_get_master_gain;\n\nint\npss_get_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    *gp = sc->master_volume;\n    return(0);\n}"
  },
  {
    "function_name": "pss_set_bass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1188-1207",
    "snippet": "int\npss_set_bass(sc, bass)\n    struct pss_softc *sc;\n    u_int bass;\n{\n    DPRINTF((\"pss_set_bass: %d\\n\", bass));\n\n#ifdef PSS_DSP\n    if (bass > PHILLIPS_BASS_MAX)\n\tbass = PHILLIPS_BASS_MAX;\n    if (bass < PHILLIPS_BASS_MIN)\n\tbass = PHILLIPS_BASS_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP));\n#endif\n\n    sc->monitor_bass = bass;\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_set_bass"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_dspwrite",
          "args": [
            "sc",
            "MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP)"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "pss_dspwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "296-318",
          "snippet": "void\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_set_bass: %d\\n\", bass)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_bass;\n\nint\npss_set_bass(sc, bass)\n    struct pss_softc *sc;\n    u_int bass;\n{\n    DPRINTF((\"pss_set_bass: %d\\n\", bass));\n\n#ifdef PSS_DSP\n    if (bass > PHILLIPS_BASS_MAX)\n\tbass = PHILLIPS_BASS_MAX;\n    if (bass < PHILLIPS_BASS_MIN)\n\tbass = PHILLIPS_BASS_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP));\n#endif\n\n    sc->monitor_bass = bass;\n\n    return(0);\n}"
  },
  {
    "function_name": "pss_set_treble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1167-1186",
    "snippet": "int\npss_set_treble(sc, treb)\n    struct pss_softc *sc;\n    u_int treb;\n{\n    DPRINTF((\"pss_set_treble: %d\\n\", treb));\n\n#ifdef PSS_DSP\n    if (treb > PHILLIPS_TREBLE_MAX)\n\ttreb = PHILLIPS_TREBLE_MAX;\n    if (treb < PHILLIPS_TREBLE_MIN)\n\ttreb = PHILLIPS_TREBLE_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP));\n#endif\n\n    sc->monitor_treble = treb;\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_set_treble"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_dspwrite",
          "args": [
            "sc",
            "MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP)"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "pss_dspwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "296-318",
          "snippet": "void\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_set_treble: %d\\n\", treb)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_treble;\n\nint\npss_set_treble(sc, treb)\n    struct pss_softc *sc;\n    u_int treb;\n{\n    DPRINTF((\"pss_set_treble: %d\\n\", treb));\n\n#ifdef PSS_DSP\n    if (treb > PHILLIPS_TREBLE_MAX)\n\ttreb = PHILLIPS_TREBLE_MAX;\n    if (treb < PHILLIPS_TREBLE_MIN)\n\ttreb = PHILLIPS_TREBLE_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP));\n#endif\n\n    sc->monitor_treble = treb;\n\n    return(0);\n}"
  },
  {
    "function_name": "pss_set_master_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1137-1165",
    "snippet": "int\npss_set_master_mode(sc, mode)\n    struct pss_softc *sc;\n    int mode;\n{\n    short phillips_mode;\n\n    DPRINTF((\"pss_set_master_mode: %d\\n\", mode));\n\t\n    if (mode == PSS_SPKR_STEREO)\n\tphillips_mode = PSS_STEREO;\n    else if (mode == PSS_SPKR_PSEUDO)\n\tphillips_mode = PSS_PSEUDO;\n    else if (mode == PSS_SPKR_SPATIAL)\n\tphillips_mode = PSS_SPATIAL;\n    else if (mode == PSS_SPKR_MONO)\n\tphillips_mode = PSS_MONO;\n    else\n\treturn (EINVAL);\n    \n#ifdef PSS_DSP\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_SWITCH | mode);\n#endif\n\n    sc->master_mode = mode;\n\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define \tPSS_SPKR_SPATIAL 3",
      "#define \tPSS_SPKR_PSEUDO\t2",
      "#define \tPSS_SPKR_STEREO\t1",
      "#define \tPSS_SPKR_MONO\t0"
    ],
    "globals_used": [
      "int\tpss_set_master_mode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_dspwrite",
          "args": [
            "sc",
            "MASTER_SWITCH | mode"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "pss_dspwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "296-318",
          "snippet": "void\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_set_master_mode: %d\\n\", mode)"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define \tPSS_SPKR_SPATIAL 3\n#define \tPSS_SPKR_PSEUDO\t2\n#define \tPSS_SPKR_STEREO\t1\n#define \tPSS_SPKR_MONO\t0\n\nint\tpss_set_master_mode;\n\nint\npss_set_master_mode(sc, mode)\n    struct pss_softc *sc;\n    int mode;\n{\n    short phillips_mode;\n\n    DPRINTF((\"pss_set_master_mode: %d\\n\", mode));\n\t\n    if (mode == PSS_SPKR_STEREO)\n\tphillips_mode = PSS_STEREO;\n    else if (mode == PSS_SPKR_PSEUDO)\n\tphillips_mode = PSS_PSEUDO;\n    else if (mode == PSS_SPKR_SPATIAL)\n\tphillips_mode = PSS_SPATIAL;\n    else if (mode == PSS_SPKR_MONO)\n\tphillips_mode = PSS_MONO;\n    else\n\treturn (EINVAL);\n    \n#ifdef PSS_DSP\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_SWITCH | mode);\n#endif\n\n    sc->master_mode = mode;\n\n    return(0);\n}"
  },
  {
    "function_name": "pss_set_master_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1110-1135",
    "snippet": "int\npss_set_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    DPRINTF((\"pss_set_master_gain: %d:%d\\n\", gp->left, gp->right));\n\t\n#ifdef PSS_DSP\n    if (gp->left > PHILLIPS_VOL_MAX)\n\tgp->left = PHILLIPS_VOL_MAX;\n    if (gp->left < PHILLIPS_VOL_MIN)\n\tgp->left = PHILLIPS_VOL_MIN;\n    if (gp->right > PHILLIPS_VOL_MAX)\n\tgp->right = PHILLIPS_VOL_MAX;\n    if (gp->right < PHILLIPS_VOL_MIN)\n\tgp->right = PHILLIPS_VOL_MIN;\n\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_LEFT|(PHILLIPS_VOL_CONSTANT + gp->left / PHILLIPS_VOL_STEP));\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP));\n#endif\n\n    sc->master_volume = *gp;\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_set_master_gain"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_dspwrite",
          "args": [
            "sc",
            "MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP)"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "pss_dspwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "296-318",
          "snippet": "void\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_set_master_gain: %d:%d\\n\", gp->left, gp->right)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_master_gain;\n\nint\npss_set_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    DPRINTF((\"pss_set_master_gain: %d:%d\\n\", gp->left, gp->right));\n\t\n#ifdef PSS_DSP\n    if (gp->left > PHILLIPS_VOL_MAX)\n\tgp->left = PHILLIPS_VOL_MAX;\n    if (gp->left < PHILLIPS_VOL_MIN)\n\tgp->left = PHILLIPS_VOL_MIN;\n    if (gp->right > PHILLIPS_VOL_MAX)\n\tgp->right = PHILLIPS_VOL_MAX;\n    if (gp->right < PHILLIPS_VOL_MIN)\n\tgp->right = PHILLIPS_VOL_MIN;\n\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_LEFT|(PHILLIPS_VOL_CONSTANT + gp->left / PHILLIPS_VOL_STEP));\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP));\n#endif\n\n    sc->master_volume = *gp;\n    return(0);\n}"
  },
  {
    "function_name": "pcdattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1087-1106",
    "snippet": "void\npcdattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct pcd_softc *sc = (struct pcd_softc *)self;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    int iobase = cf->cf_iobase;\n    \n    /*\n     * The pss driver simply enables the cd interface. The CD\n     * appropriate driver - scsi (aic6360) or Sony needs to be\n     * used after this to handle the device.\n     */\n    sc->sc_iobase = iobase;\n\n    /* XXX might use pssprint func ?? */\n    printf(\" port 0x%x/%d irq %d\\n\",\n\t   sc->sc_iobase, 2, cf->cf_irq);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" port 0x%x/%d irq %d\\n\"",
            "sc->sc_iobase",
            "2",
            "cf->cf_irq"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\npcdattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct pcd_softc *sc = (struct pcd_softc *)self;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    int iobase = cf->cf_iobase;\n    \n    /*\n     * The pss driver simply enables the cd interface. The CD\n     * appropriate driver - scsi (aic6360) or Sony needs to be\n     * used after this to handle the device.\n     */\n    sc->sc_iobase = iobase;\n\n    /* XXX might use pssprint func ?? */\n    printf(\" port 0x%x/%d irq %d\\n\",\n\t   sc->sc_iobase, 2, cf->cf_irq);\n}"
  },
  {
    "function_name": "mpuattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1067-1085",
    "snippet": "void\nmpuattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct mpu_softc *sc = (struct mpu_softc *)self;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    isa_chipset_tag_t ic = aux;\t\t\t\t/* XXX */\n    int iobase = cf->cf_iobase;\n\n    sc->sc_iobase = iobase;\n\n    sc->sc_ih = isa_intr_establish(ic, cf->cf_irq, IST_EDGE, IPL_AUDIO,\n        mpuintr, sc, sc->sc_dev.dv_xname);\n\n    /* XXX might use pssprint func ?? */\n    printf(\" port 0x%x/%d irq %d\\n\",\n\t   sc->sc_iobase, MIDI_NPORT, cf->cf_irq);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" port 0x%x/%d irq %d\\n\"",
            "sc->sc_iobase",
            "MIDI_NPORT",
            "cf->cf_irq"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ic",
            "cf->cf_irq",
            "IST_EDGE",
            "IPL_AUDIO",
            "mpuintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nmpuattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct mpu_softc *sc = (struct mpu_softc *)self;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    isa_chipset_tag_t ic = aux;\t\t\t\t/* XXX */\n    int iobase = cf->cf_iobase;\n\n    sc->sc_iobase = iobase;\n\n    sc->sc_ih = isa_intr_establish(ic, cf->cf_irq, IST_EDGE, IPL_AUDIO,\n        mpuintr, sc, sc->sc_dev.dv_xname);\n\n    /* XXX might use pssprint func ?? */\n    printf(\" port 0x%x/%d irq %d\\n\",\n\t   sc->sc_iobase, MIDI_NPORT, cf->cf_irq);\n}"
  },
  {
    "function_name": "spattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1043-1064",
    "snippet": "void\nspattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct ad1848_softc *sc = (struct ad1848_softc *)self;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    isa_chipset_tag_t ic = aux;\t\t\t\t/* XXX */\n    int iobase = cf->cf_iobase;\n\n    sc->sc_iobase = iobase;\n    sc->sc_drq = cf->cf_drq;\n\n    sc->sc_ih = isa_intr_establish(ic, cf->cf_irq, IST_EDGE, IPL_AUDIO,\n\tad1848_intr, sc, sc->sc_dev.dv_xname);\n\n    sc->sc_isa = parent->dv_parent;\n\n    ad1848_attach(sc);\n\n    printf(\"\\n\");\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tspattach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_attach",
          "args": [
            "sc"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "502-577",
          "snippet": "void\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};",
            "void\tad1848_reset",
            "static int ad_read",
            "static void ad_write",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};\nvoid\tad1848_reset;\nstatic int ad_read;\nstatic void ad_write;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\n\nvoid\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ic",
            "cf->cf_irq",
            "IST_EDGE",
            "IPL_AUDIO",
            "ad1848_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tspattach;\n\nvoid\nspattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct ad1848_softc *sc = (struct ad1848_softc *)self;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    isa_chipset_tag_t ic = aux;\t\t\t\t/* XXX */\n    int iobase = cf->cf_iobase;\n\n    sc->sc_iobase = iobase;\n    sc->sc_drq = cf->cf_drq;\n\n    sc->sc_ih = isa_intr_establish(ic, cf->cf_irq, IST_EDGE, IPL_AUDIO,\n\tad1848_intr, sc, sc->sc_dev.dv_xname);\n\n    sc->sc_isa = parent->dv_parent;\n\n    ad1848_attach(sc);\n\n    printf(\"\\n\");\n}"
  },
  {
    "function_name": "pssattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "1010-1041",
    "snippet": "void\npssattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct pss_softc *sc = (struct pss_softc *)self;\n    struct isa_attach_args *ia = (struct isa_attach_args *)aux;\n    int iobase = ia->ia_iobase;\n    u_char vers;\n    struct ad1848_volume vol = {150, 150};\n    \n    sc->sc_iobase = iobase;\n    sc->sc_drq = ia->ia_drq;\n\n    /* Setup interrupt handler for PSS */\n    sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE, IPL_AUDIO,\n\tpssintr, sc, sc->sc_dev.dv_xname);\n\n    vers = (inw(sc->sc_iobase+PSS_ID_VERS)&0xff) - 1;\n    printf(\": ESC614%c\\n\", (vers > 0)?'A'+vers:' ');\n    \n    (void)config_found(self, ia->ia_ic, NULL);\t\t/* XXX */\n\n    sc->out_port = PSS_MASTER_VOL;\n\n    (void)pss_set_master_mode(sc, PSS_SPKR_STEREO);\n    (void)pss_set_master_gain(sc, &vol);\n    (void)pss_set_treble(sc, AUDIO_MAX_GAIN/2);\n    (void)pss_set_bass(sc, AUDIO_MAX_GAIN/2);\n\n    audio_attach_mi(&pss_audio_if, sc->ad1848_sc, &sc->ad1848_sc->sc_dev);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define \tPSS_SPKR_STEREO\t1",
      "#define PSS_MASTER_VOL\t\t5"
    ],
    "globals_used": [
      "void\tpssattach",
      "int\tpssintr",
      "int\tpss_set_master_gain",
      "int\tpss_set_master_mode",
      "int\tpss_set_treble",
      "int\tpss_set_bass",
      "struct audio_hw_if pss_audio_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tpss_speaker_ctl,\n\tpss_getdev,\n\tNULL,\n\tpss_mixer_set_port,\n\tpss_mixer_get_port,\n\tpss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n        ad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "&pss_audio_if",
            "sc->ad1848_sc",
            "&sc->ad1848_sc->sc_dev"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_set_bass",
          "args": [
            "sc",
            "AUDIO_MAX_GAIN/2"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_bass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1188-1207",
          "snippet": "int\npss_set_bass(sc, bass)\n    struct pss_softc *sc;\n    u_int bass;\n{\n    DPRINTF((\"pss_set_bass: %d\\n\", bass));\n\n#ifdef PSS_DSP\n    if (bass > PHILLIPS_BASS_MAX)\n\tbass = PHILLIPS_BASS_MAX;\n    if (bass < PHILLIPS_BASS_MIN)\n\tbass = PHILLIPS_BASS_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP));\n#endif\n\n    sc->monitor_bass = bass;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_set_bass"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_bass;\n\nint\npss_set_bass(sc, bass)\n    struct pss_softc *sc;\n    u_int bass;\n{\n    DPRINTF((\"pss_set_bass: %d\\n\", bass));\n\n#ifdef PSS_DSP\n    if (bass > PHILLIPS_BASS_MAX)\n\tbass = PHILLIPS_BASS_MAX;\n    if (bass < PHILLIPS_BASS_MIN)\n\tbass = PHILLIPS_BASS_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP));\n#endif\n\n    sc->monitor_bass = bass;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_set_treble",
          "args": [
            "sc",
            "AUDIO_MAX_GAIN/2"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_treble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1167-1186",
          "snippet": "int\npss_set_treble(sc, treb)\n    struct pss_softc *sc;\n    u_int treb;\n{\n    DPRINTF((\"pss_set_treble: %d\\n\", treb));\n\n#ifdef PSS_DSP\n    if (treb > PHILLIPS_TREBLE_MAX)\n\ttreb = PHILLIPS_TREBLE_MAX;\n    if (treb < PHILLIPS_TREBLE_MIN)\n\ttreb = PHILLIPS_TREBLE_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP));\n#endif\n\n    sc->monitor_treble = treb;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_set_treble"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_treble;\n\nint\npss_set_treble(sc, treb)\n    struct pss_softc *sc;\n    u_int treb;\n{\n    DPRINTF((\"pss_set_treble: %d\\n\", treb));\n\n#ifdef PSS_DSP\n    if (treb > PHILLIPS_TREBLE_MAX)\n\ttreb = PHILLIPS_TREBLE_MAX;\n    if (treb < PHILLIPS_TREBLE_MIN)\n\ttreb = PHILLIPS_TREBLE_MIN;\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP));\n#endif\n\n    sc->monitor_treble = treb;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_set_master_gain",
          "args": [
            "sc",
            "&vol"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_master_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1110-1135",
          "snippet": "int\npss_set_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    DPRINTF((\"pss_set_master_gain: %d:%d\\n\", gp->left, gp->right));\n\t\n#ifdef PSS_DSP\n    if (gp->left > PHILLIPS_VOL_MAX)\n\tgp->left = PHILLIPS_VOL_MAX;\n    if (gp->left < PHILLIPS_VOL_MIN)\n\tgp->left = PHILLIPS_VOL_MIN;\n    if (gp->right > PHILLIPS_VOL_MAX)\n\tgp->right = PHILLIPS_VOL_MAX;\n    if (gp->right < PHILLIPS_VOL_MIN)\n\tgp->right = PHILLIPS_VOL_MIN;\n\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_LEFT|(PHILLIPS_VOL_CONSTANT + gp->left / PHILLIPS_VOL_STEP));\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP));\n#endif\n\n    sc->master_volume = *gp;\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_set_master_gain"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_set_master_gain;\n\nint\npss_set_master_gain(sc, gp)\n    struct pss_softc *sc;\n    struct ad1848_volume *gp;\n{\n    DPRINTF((\"pss_set_master_gain: %d:%d\\n\", gp->left, gp->right));\n\t\n#ifdef PSS_DSP\n    if (gp->left > PHILLIPS_VOL_MAX)\n\tgp->left = PHILLIPS_VOL_MAX;\n    if (gp->left < PHILLIPS_VOL_MIN)\n\tgp->left = PHILLIPS_VOL_MIN;\n    if (gp->right > PHILLIPS_VOL_MAX)\n\tgp->right = PHILLIPS_VOL_MAX;\n    if (gp->right < PHILLIPS_VOL_MIN)\n\tgp->right = PHILLIPS_VOL_MIN;\n\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_LEFT|(PHILLIPS_VOL_CONSTANT + gp->left / PHILLIPS_VOL_STEP));\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP));\n#endif\n\n    sc->master_volume = *gp;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_set_master_mode",
          "args": [
            "sc",
            "PSS_SPKR_STEREO"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "pss_set_master_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "1137-1165",
          "snippet": "int\npss_set_master_mode(sc, mode)\n    struct pss_softc *sc;\n    int mode;\n{\n    short phillips_mode;\n\n    DPRINTF((\"pss_set_master_mode: %d\\n\", mode));\n\t\n    if (mode == PSS_SPKR_STEREO)\n\tphillips_mode = PSS_STEREO;\n    else if (mode == PSS_SPKR_PSEUDO)\n\tphillips_mode = PSS_PSEUDO;\n    else if (mode == PSS_SPKR_SPATIAL)\n\tphillips_mode = PSS_SPATIAL;\n    else if (mode == PSS_SPKR_MONO)\n\tphillips_mode = PSS_MONO;\n    else\n\treturn (EINVAL);\n    \n#ifdef PSS_DSP\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_SWITCH | mode);\n#endif\n\n    sc->master_mode = mode;\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define \tPSS_SPKR_SPATIAL 3",
            "#define \tPSS_SPKR_PSEUDO\t2",
            "#define \tPSS_SPKR_STEREO\t1",
            "#define \tPSS_SPKR_MONO\t0"
          ],
          "globals_used": [
            "int\tpss_set_master_mode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define \tPSS_SPKR_SPATIAL 3\n#define \tPSS_SPKR_PSEUDO\t2\n#define \tPSS_SPKR_STEREO\t1\n#define \tPSS_SPKR_MONO\t0\n\nint\tpss_set_master_mode;\n\nint\npss_set_master_mode(sc, mode)\n    struct pss_softc *sc;\n    int mode;\n{\n    short phillips_mode;\n\n    DPRINTF((\"pss_set_master_mode: %d\\n\", mode));\n\t\n    if (mode == PSS_SPKR_STEREO)\n\tphillips_mode = PSS_STEREO;\n    else if (mode == PSS_SPKR_PSEUDO)\n\tphillips_mode = PSS_PSEUDO;\n    else if (mode == PSS_SPKR_SPATIAL)\n\tphillips_mode = PSS_SPATIAL;\n    else if (mode == PSS_SPKR_MONO)\n\tphillips_mode = PSS_MONO;\n    else\n\treturn (EINVAL);\n    \n#ifdef PSS_DSP\n    pss_dspwrite(sc, SET_MASTER_COMMAND);\n    pss_dspwrite(sc, MASTER_SWITCH | mode);\n#endif\n\n    sc->master_mode = mode;\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "ia->ia_ic",
            "NULL"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": ESC614%c\\n\"",
            "(vers > 0)?'A'+vers:' '"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_ID_VERS"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_AUDIO",
            "pssintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define \tPSS_SPKR_STEREO\t1\n#define PSS_MASTER_VOL\t\t5\n\nvoid\tpssattach;\nint\tpssintr;\nint\tpss_set_master_gain;\nint\tpss_set_master_mode;\nint\tpss_set_treble;\nint\tpss_set_bass;\nstruct audio_hw_if pss_audio_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tpss_speaker_ctl,\n\tpss_getdev,\n\tNULL,\n\tpss_mixer_set_port,\n\tpss_mixer_get_port,\n\tpss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n        ad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};\n\nvoid\npssattach(parent, self, aux)\n    struct device *parent, *self;\n    void *aux;\n{\n    struct pss_softc *sc = (struct pss_softc *)self;\n    struct isa_attach_args *ia = (struct isa_attach_args *)aux;\n    int iobase = ia->ia_iobase;\n    u_char vers;\n    struct ad1848_volume vol = {150, 150};\n    \n    sc->sc_iobase = iobase;\n    sc->sc_drq = ia->ia_drq;\n\n    /* Setup interrupt handler for PSS */\n    sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE, IPL_AUDIO,\n\tpssintr, sc, sc->sc_dev.dv_xname);\n\n    vers = (inw(sc->sc_iobase+PSS_ID_VERS)&0xff) - 1;\n    printf(\": ESC614%c\\n\", (vers > 0)?'A'+vers:' ');\n    \n    (void)config_found(self, ia->ia_ic, NULL);\t\t/* XXX */\n\n    sc->out_port = PSS_MASTER_VOL;\n\n    (void)pss_set_master_mode(sc, PSS_SPKR_STEREO);\n    (void)pss_set_master_gain(sc, &vol);\n    (void)pss_set_treble(sc, AUDIO_MAX_GAIN/2);\n    (void)pss_set_bass(sc, AUDIO_MAX_GAIN/2);\n\n    audio_attach_mi(&pss_audio_if, sc->ad1848_sc, &sc->ad1848_sc->sc_dev);\n}"
  },
  {
    "function_name": "pcdprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "954-1003",
    "snippet": "int\npcdprobe(parent, match, aux)\n    struct device *parent;\n    void *match, *aux;\n{\n    struct pcd_softc *sc = match;\n    struct pss_softc *pc = (void *) parent;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    u_short val;\n    \n    sc->sc_iobase = cf->cf_iobase;\n\n    pss_setaddr(sc->sc_iobase, pc->sc_iobase+CD_CONFIG);\n\n    /* Set the correct irq polarity. */\n    val = inw(pc->sc_iobase+CD_CONFIG);\n    outw(pc->sc_iobase+CD_CONFIG, 0);\n    val &= CD_POL_MASK;\n    val |= CD_POL_BIT;\t/* XXX if (pol) */\n    outw(pc->sc_iobase+CD_CONFIG, val);\n    \n    if (cf->cf_irq == IRQUNK) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t    if (pss_testirq(pc, i) != 0)\n\t\tbreak;\n\t}\n\tif (i == 16) {\n\t    printf(\"pcd: unable to locate free IRQ channel for CD\\n\");\n\t    return 0;\n\t}\n\telse {\n\t    cf->cf_irq = i;\n\t    sc->sc_irq = i;\n\t    DPRINTF((\"pcd: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tsc->sc_irq = cf->cf_irq;\n\n\tif (pss_testirq(pc, sc->sc_irq) == 0) {\n\t    printf(\"pcd: configured CD IRQ unavailable (%d)\\n\", sc->sc_irq);\n\t    return 0;\n\t}\n\treturn 1;\n    }\n    pss_setint(sc->sc_irq, pc->sc_iobase+CD_CONFIG);\n    \n    return 1;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpss_setaddr",
      "int\tpss_setint",
      "int\tpss_testirq"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_setint",
          "args": [
            "sc->sc_irq",
            "pc->sc_iobase+CD_CONFIG"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "339-388",
          "snippet": "int\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_setint"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_setint;\n\nint\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pcd: configured CD IRQ unavailable (%d)\\n\"",
            "sc->sc_irq"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_testirq",
          "args": [
            "pc",
            "sc->sc_irq"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "pss_testirq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "442-508",
          "snippet": "int\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_testirq"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testirq;\n\nint\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcd: found IRQ %d free\\n\", i)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pc->sc_iobase+CD_CONFIG",
            "val"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pc->sc_iobase+CD_CONFIG",
            "0"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pc->sc_iobase+CD_CONFIG"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pss_setaddr",
          "args": [
            "sc->sc_iobase",
            "pc->sc_iobase+CD_CONFIG"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "321-332",
          "snippet": "void\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpss_setaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpss_setaddr;\n\nvoid\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpss_setaddr;\nint\tpss_setint;\nint\tpss_testirq;\n\nint\npcdprobe(parent, match, aux)\n    struct device *parent;\n    void *match, *aux;\n{\n    struct pcd_softc *sc = match;\n    struct pss_softc *pc = (void *) parent;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    u_short val;\n    \n    sc->sc_iobase = cf->cf_iobase;\n\n    pss_setaddr(sc->sc_iobase, pc->sc_iobase+CD_CONFIG);\n\n    /* Set the correct irq polarity. */\n    val = inw(pc->sc_iobase+CD_CONFIG);\n    outw(pc->sc_iobase+CD_CONFIG, 0);\n    val &= CD_POL_MASK;\n    val |= CD_POL_BIT;\t/* XXX if (pol) */\n    outw(pc->sc_iobase+CD_CONFIG, val);\n    \n    if (cf->cf_irq == IRQUNK) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t    if (pss_testirq(pc, i) != 0)\n\t\tbreak;\n\t}\n\tif (i == 16) {\n\t    printf(\"pcd: unable to locate free IRQ channel for CD\\n\");\n\t    return 0;\n\t}\n\telse {\n\t    cf->cf_irq = i;\n\t    sc->sc_irq = i;\n\t    DPRINTF((\"pcd: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tsc->sc_irq = cf->cf_irq;\n\n\tif (pss_testirq(pc, sc->sc_irq) == 0) {\n\t    printf(\"pcd: configured CD IRQ unavailable (%d)\\n\", sc->sc_irq);\n\t    return 0;\n\t}\n\treturn 1;\n    }\n    pss_setint(sc->sc_irq, pc->sc_iobase+CD_CONFIG);\n    \n    return 1;\n}"
  },
  {
    "function_name": "mpuprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "909-952",
    "snippet": "int\nmpuprobe(parent, match, aux)\n    struct device *parent;\n    void *match, *aux;\n{\n    struct mpu_softc *sc = match;\n    struct pss_softc *pc = (void *) parent;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n\n    /* Check if midi is enabled; if it is check the interrupt */\n    sc->sc_iobase = cf->cf_iobase;\n\n    if (cf->cf_irq == IRQUNK) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t    if (pss_testirq(pc, i) != 0)\n\t\tbreak;\n\t}\n\tif (i == 16) {\n\t    printf(\"mpu: unable to locate free IRQ channel for MIDI\\n\");\n\t    return 0;\n\t}\n\telse {\n\t    cf->cf_irq = i;\n\t    sc->sc_irq = i;\n\t    DPRINTF((\"mpu: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tsc->sc_irq = cf->cf_irq;\n    \n\tif (pss_testirq(pc, sc->sc_irq) == 0) {\n\t    printf(\"pss: configured MIDI IRQ unavailable (%d)\\n\", sc->sc_irq);\n\t    return 0;\n\t}\n    }\n\n    outw(pc->sc_iobase+MIDI_CONFIG,0);\n    DPRINTF((\"pss: mpu port 0x%x irq %d\\n\", sc->sc_iobase, sc->sc_irq));\n    pss_setaddr(sc->sc_iobase, pc->sc_iobase+MIDI_CONFIG);\n    pss_setint(sc->sc_irq, pc->sc_iobase+MIDI_CONFIG);\n\n    return 1;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpss_setaddr",
      "int\tpss_setint",
      "int\tpss_testirq"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_setint",
          "args": [
            "sc->sc_irq",
            "pc->sc_iobase+MIDI_CONFIG"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "339-388",
          "snippet": "int\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_setint"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_setint;\n\nint\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_setaddr",
          "args": [
            "sc->sc_iobase",
            "pc->sc_iobase+MIDI_CONFIG"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "321-332",
          "snippet": "void\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpss_setaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpss_setaddr;\n\nvoid\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: mpu port 0x%x irq %d\\n\", sc->sc_iobase, sc->sc_irq)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pc->sc_iobase+MIDI_CONFIG",
            "0"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pss: configured MIDI IRQ unavailable (%d)\\n\"",
            "sc->sc_irq"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_testirq",
          "args": [
            "pc",
            "sc->sc_irq"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "pss_testirq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "442-508",
          "snippet": "int\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_testirq"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testirq;\n\nint\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mpu: found IRQ %d free\\n\", i)"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpss_setaddr;\nint\tpss_setint;\nint\tpss_testirq;\n\nint\nmpuprobe(parent, match, aux)\n    struct device *parent;\n    void *match, *aux;\n{\n    struct mpu_softc *sc = match;\n    struct pss_softc *pc = (void *) parent;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n\n    /* Check if midi is enabled; if it is check the interrupt */\n    sc->sc_iobase = cf->cf_iobase;\n\n    if (cf->cf_irq == IRQUNK) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t    if (pss_testirq(pc, i) != 0)\n\t\tbreak;\n\t}\n\tif (i == 16) {\n\t    printf(\"mpu: unable to locate free IRQ channel for MIDI\\n\");\n\t    return 0;\n\t}\n\telse {\n\t    cf->cf_irq = i;\n\t    sc->sc_irq = i;\n\t    DPRINTF((\"mpu: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tsc->sc_irq = cf->cf_irq;\n    \n\tif (pss_testirq(pc, sc->sc_irq) == 0) {\n\t    printf(\"pss: configured MIDI IRQ unavailable (%d)\\n\", sc->sc_irq);\n\t    return 0;\n\t}\n    }\n\n    outw(pc->sc_iobase+MIDI_CONFIG,0);\n    DPRINTF((\"pss: mpu port 0x%x irq %d\\n\", sc->sc_iobase, sc->sc_irq));\n    pss_setaddr(sc->sc_iobase, pc->sc_iobase+MIDI_CONFIG);\n    pss_setint(sc->sc_irq, pc->sc_iobase+MIDI_CONFIG);\n\n    return 1;\n}"
  },
  {
    "function_name": "spprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "812-906",
    "snippet": "int\nspprobe(parent, match, aux)\n    struct device *parent;\n    void *match, *aux;\n{\n    struct ad1848_softc *sc = match;\n    struct pss_softc *pc = (void *) parent;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    struct isa_attach_args *ia = aux;\n    u_char bits;\n    int i;\n\n    sc->sc_iot = ia->ia_iot;\n    sc->sc_iobase = cf->cf_iobase + WSS_CODEC;\n    \n    /* Set WSS io address */\n    pss_setaddr(cf->cf_iobase, pc->sc_iobase+PSS_WSS_CONFIG);\n\n    /* Is there an ad1848 chip at the WSS iobase ? */\n    if (ad1848_probe(sc) == 0) {\n\tDPRINTF((\"sp: no ad1848 ? iobase=%x\\n\", sc->sc_iobase));\n\treturn 0;\n    }\n\t\n    /* Setup WSS interrupt and DMA if auto */\n    if (cf->cf_irq == IRQUNK) {\n\n\t/* Find unused IRQ for WSS */\n\tfor (i = 0; i < 12; i++) {\n\t    if (wss_interrupt_bits[i] != 0xff) {\n\t\tif (pss_testirq(pc, i))\n\t\t    break;\n\t    }\n\t}\n\tif (i == 12) {\n\t    DPRINTF((\"sp: unable to locate free IRQ for WSS\\n\"));\n\t    return 0;\n\t}\n\telse {\n\t    cf->cf_irq = i;\n\t    sc->sc_irq = i;\n\t    DPRINTF((\"sp: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tsc->sc_irq = cf->cf_irq;\n\tif (pss_testirq(pc, sc->sc_irq) == 0) {\n\t    DPRINTF((\"sp: configured IRQ unavailable (%d)\\n\", sc->sc_irq));\n\t    return 0;\n\t}\n    }\n\n    if (cf->cf_drq == DRQUNK) {\n\t/* Find unused DMA channel for WSS */\n\tfor (i = 0; i < 4; i++) {\n\t    if (wss_dma_bits[i]) {\n\t\tif (pss_testdma(pc, i))\n\t\t    break;\n\t    }\n\t}\n\tif (i == 4) {\n\t    DPRINTF((\"sp: unable to locate free DMA channel for WSS\\n\"));\n\t    return 0;\n\t}\n\telse {\n\t    sc->sc_drq = cf->cf_drq = i;\n\t    DPRINTF((\"sp: found DMA %d free\\n\", i));\n\t}\n    }\n    else {\n\tif (pss_testdma(pc, sc->sc_drq) == 0) {\n\t    DPRINTF((\"sp: configured DMA channel unavailable (%d)\\n\", sc->sc_drq));\n\t    return 0;\n\t}\n\tsc->sc_drq = cf->cf_drq;\n    }\n    sc->sc_recdrq = sc->sc_drq;\n\n    /* Set WSS config registers */\n    if ((bits = wss_interrupt_bits[sc->sc_irq]) == 0xff) {\n\tDPRINTF((\"sp: invalid interrupt configuration (irq=%d)\\n\", sc->sc_irq));\n\treturn 0;\n    }\n\n    outb(sc->sc_iobase+WSS_CONFIG, (bits | 0x40));\n    if ((inb(sc->sc_iobase+WSS_STATUS) & 0x40) == 0)\t/* XXX What do these bits mean ? */\n\tDPRINTF((\"sp: IRQ %x\\n\", inb(sc->sc_iobase+WSS_STATUS)));\n    \n    outb(sc->sc_iobase+WSS_CONFIG, (bits | wss_dma_bits[sc->sc_drq]));\n\n    pc->ad1848_sc = sc;\n    sc->parent = pc;\n    \n    return 1;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tspprobe",
      "void\tpss_setaddr",
      "int\tpss_testirq",
      "int\tpss_testdma",
      "static u_char wss_interrupt_bits[16] = {\n    0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x08,\n    0xff, 0x10, 0x18, 0x20,\n    0xff, 0xff, 0xff, 0xff\n};",
      "static u_char wss_dma_bits[4] = {1, 2, 0, 3};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase+WSS_CONFIG",
            "(bits | wss_dma_bits[sc->sc_drq])"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: IRQ %x\\n\", inb(sc->sc_iobase+WSS_STATUS))"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase+WSS_STATUS"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: invalid interrupt configuration (irq=%d)\\n\", sc->sc_irq)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: configured DMA channel unavailable (%d)\\n\", sc->sc_drq)"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pss_testdma",
          "args": [
            "pc",
            "sc->sc_drq"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "pss_testdma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "516-578",
          "snippet": "int\npss_testdma(sc, dmaNum)\n\tstruct pss_softc *sc;\n\tint dmaNum;\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int i, ret;\n\n    switch (dmaNum) {\n    case 0:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the DMA channel is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 3; i++) {\n\tval = inw(config);\n\tif (val & DMA_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the DMA bits */\n    val = inw(config);\n    val &= DMA_TEST_BIT_MASK & DMA_MASK;\n    outw(config, val);\n    return(ret);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_testdma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testdma;\n\nint\npss_testdma(sc, dmaNum)\n\tstruct pss_softc *sc;\n\tint dmaNum;\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int i, ret;\n\n    switch (dmaNum) {\n    case 0:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the DMA channel is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 3; i++) {\n\tval = inw(config);\n\tif (val & DMA_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the DMA bits */\n    val = inw(config);\n    val &= DMA_TEST_BIT_MASK & DMA_MASK;\n    outw(config, val);\n    return(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: found DMA %d free\\n\", i)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: unable to locate free DMA channel for WSS\\n\")"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: configured IRQ unavailable (%d)\\n\", sc->sc_irq)"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pss_testirq",
          "args": [
            "pc",
            "sc->sc_irq"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "pss_testirq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "442-508",
          "snippet": "int\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_testirq"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testirq;\n\nint\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: found IRQ %d free\\n\", i)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: unable to locate free IRQ for WSS\\n\")"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sp: no ad1848 ? iobase=%x\\n\", sc->sc_iobase)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_probe",
          "args": [
            "sc"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "303-488",
          "snippet": "int\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_setaddr",
          "args": [
            "cf->cf_iobase",
            "pc->sc_iobase+PSS_WSS_CONFIG"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "321-332",
          "snippet": "void\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpss_setaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpss_setaddr;\n\nvoid\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tspprobe;\nvoid\tpss_setaddr;\nint\tpss_testirq;\nint\tpss_testdma;\nstatic u_char wss_interrupt_bits[16] = {\n    0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x08,\n    0xff, 0x10, 0x18, 0x20,\n    0xff, 0xff, 0xff, 0xff\n};\nstatic u_char wss_dma_bits[4] = {1, 2, 0, 3};\n\nint\nspprobe(parent, match, aux)\n    struct device *parent;\n    void *match, *aux;\n{\n    struct ad1848_softc *sc = match;\n    struct pss_softc *pc = (void *) parent;\n    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;\n    struct isa_attach_args *ia = aux;\n    u_char bits;\n    int i;\n\n    sc->sc_iot = ia->ia_iot;\n    sc->sc_iobase = cf->cf_iobase + WSS_CODEC;\n    \n    /* Set WSS io address */\n    pss_setaddr(cf->cf_iobase, pc->sc_iobase+PSS_WSS_CONFIG);\n\n    /* Is there an ad1848 chip at the WSS iobase ? */\n    if (ad1848_probe(sc) == 0) {\n\tDPRINTF((\"sp: no ad1848 ? iobase=%x\\n\", sc->sc_iobase));\n\treturn 0;\n    }\n\t\n    /* Setup WSS interrupt and DMA if auto */\n    if (cf->cf_irq == IRQUNK) {\n\n\t/* Find unused IRQ for WSS */\n\tfor (i = 0; i < 12; i++) {\n\t    if (wss_interrupt_bits[i] != 0xff) {\n\t\tif (pss_testirq(pc, i))\n\t\t    break;\n\t    }\n\t}\n\tif (i == 12) {\n\t    DPRINTF((\"sp: unable to locate free IRQ for WSS\\n\"));\n\t    return 0;\n\t}\n\telse {\n\t    cf->cf_irq = i;\n\t    sc->sc_irq = i;\n\t    DPRINTF((\"sp: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tsc->sc_irq = cf->cf_irq;\n\tif (pss_testirq(pc, sc->sc_irq) == 0) {\n\t    DPRINTF((\"sp: configured IRQ unavailable (%d)\\n\", sc->sc_irq));\n\t    return 0;\n\t}\n    }\n\n    if (cf->cf_drq == DRQUNK) {\n\t/* Find unused DMA channel for WSS */\n\tfor (i = 0; i < 4; i++) {\n\t    if (wss_dma_bits[i]) {\n\t\tif (pss_testdma(pc, i))\n\t\t    break;\n\t    }\n\t}\n\tif (i == 4) {\n\t    DPRINTF((\"sp: unable to locate free DMA channel for WSS\\n\"));\n\t    return 0;\n\t}\n\telse {\n\t    sc->sc_drq = cf->cf_drq = i;\n\t    DPRINTF((\"sp: found DMA %d free\\n\", i));\n\t}\n    }\n    else {\n\tif (pss_testdma(pc, sc->sc_drq) == 0) {\n\t    DPRINTF((\"sp: configured DMA channel unavailable (%d)\\n\", sc->sc_drq));\n\t    return 0;\n\t}\n\tsc->sc_drq = cf->cf_drq;\n    }\n    sc->sc_recdrq = sc->sc_drq;\n\n    /* Set WSS config registers */\n    if ((bits = wss_interrupt_bits[sc->sc_irq]) == 0xff) {\n\tDPRINTF((\"sp: invalid interrupt configuration (irq=%d)\\n\", sc->sc_irq));\n\treturn 0;\n    }\n\n    outb(sc->sc_iobase+WSS_CONFIG, (bits | 0x40));\n    if ((inb(sc->sc_iobase+WSS_STATUS) & 0x40) == 0)\t/* XXX What do these bits mean ? */\n\tDPRINTF((\"sp: IRQ %x\\n\", inb(sc->sc_iobase+WSS_STATUS)));\n    \n    outb(sc->sc_iobase+WSS_CONFIG, (bits | wss_dma_bits[sc->sc_drq]));\n\n    pc->ad1848_sc = sc;\n    sc->parent = pc;\n    \n    return 1;\n}"
  },
  {
    "function_name": "pssprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "711-807",
    "snippet": "int\npssprobe(parent, self, aux)\n    struct device *parent;\n    void *self;\n    void *aux;\n{\n    struct pss_softc *sc = self;\n    struct isa_attach_args *ia = aux;\n    int iobase = ia->ia_iobase;\n    \n    if (!PSS_BASE_VALID(iobase)) {\n\tDPRINTF((\"pss: configured iobase %x invalid\\n\", iobase));\n\treturn 0;\n    }\n\n    /* Need to probe for iobase when IOBASEUNK {0x220 0x240} */\n    if (iobase == IOBASEUNK) {\n\n\tiobase = 0x220;\n\tif ((inw(iobase+PSS_ID_VERS) & 0xff00) == 0x4500)\n\t    goto pss_found;\n\n\tiobase = 0x240;\n\tif ((inw(iobase+PSS_ID_VERS) & 0xff00) == 0x4500)\n\t    goto pss_found;\n\n\tDPRINTF((\"pss: no PSS found (at 0x220 or 0x240)\\n\"));\n\treturn 0;\n    }\n    else if ((inw(iobase+PSS_ID_VERS) & 0xff00) != 0x4500) {\n\tDPRINTF((\"pss: not a PSS - %x\\n\", inw(iobase+PSS_ID_VERS)));\n\treturn 0;\n    }\n\npss_found:\n    sc->sc_iobase = iobase;\n\n    /* Clear WSS config */\n    pss_setaddr(WSS_BASE_ADDRESS, sc->sc_iobase+PSS_WSS_CONFIG); /* XXX! */\n    outb(WSS_BASE_ADDRESS+WSS_CONFIG, 0);\n\n    /* Clear config registers (POR reset state) */\n    outw(sc->sc_iobase+PSS_CONFIG, 0);\n    outw(sc->sc_iobase+PSS_WSS_CONFIG, 0);\n    outw(sc->sc_iobase+SB_CONFIG, 0);\n    outw(sc->sc_iobase+MIDI_CONFIG, 0);\n    outw(sc->sc_iobase+CD_CONFIG, 0);\n\n    if (ia->ia_irq == IRQUNK) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t    if (pss_testirq(sc, i) != 0)\n\t\tbreak;\n\t}\n\tif (i == 16) {\n\t    DPRINTF((\"pss: unable to locate free IRQ channel\\n\"));\n\t    return 0;\n\t}\n\telse {\n\t    ia->ia_irq = i;\n\t    DPRINTF((\"pss: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tif (pss_testirq(sc, ia->ia_irq) == 0) {\n\t    DPRINTF((\"pss: configured IRQ unavailable (%d)\\n\", ia->ia_irq));\n\t    return 0;\n\t}\n    }\n\n    /* XXX Need to deal with DRQUNK */\n    if (pss_testdma(sc, ia->ia_drq) == 0) {\n\tDPRINTF((\"pss: configured DMA channel unavailable (%d)\\n\", ia->ia_drq));\n\treturn 0;\n    }\n      \n    ia->ia_iosize = PSS_NPORT;\n\n    /* Initialize PSS irq and dma */\n    pss_setint(ia->ia_irq, sc->sc_iobase+PSS_CONFIG);\n    pss_setdma(sc->sc_drq, sc->sc_iobase+PSS_CONFIG);\n\n#ifdef notyet\n    /* Setup the Game port */\n#ifdef PSS_GAMEPORT\n    DPRINTF((\"Turning Game Port On.\\n\"));\n    outw(sc->sc_iobase+PSS_STATUS, inw(sc->sc_iobase+PSS_STATUS) | GAME_BIT);\n#else\n    outw(sc->sc_iobase+PSS_STATUS, inw(sc->sc_iobase+PSS_STATUS) & GAME_BIT_MASK);\n#endif\n\n    /* Reset DSP */\n    pss_reset_dsp(sc);\n#endif /* notyet */\n\n    return 1;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WSS_BASE_ADDRESS 0x0530"
    ],
    "globals_used": [
      "int\tpssprobe",
      "void\tpss_setaddr",
      "int\tpss_setint",
      "int\tpss_setdma",
      "int\tpss_testirq",
      "int\tpss_testdma"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pss_reset_dsp",
          "args": [
            "sc"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "pss_reset_dsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "581-596",
          "snippet": "int\npss_reset_dsp(sc)\n\tstruct pss_softc *sc;\n{\n    u_long i;\n    int pss_base = sc->sc_iobase;\n\n    outw(pss_base+PSS_CONTROL, PSS_RESET);\n\n    for (i = 0; i < 32768; i++)\n\tinw(pss_base+PSS_CONTROL);\n \n    outw(pss_base+PSS_CONTROL, 0);\n\n    return 1;\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\npss_reset_dsp(sc)\n\tstruct pss_softc *sc;\n{\n    u_long i;\n    int pss_base = sc->sc_iobase;\n\n    outw(pss_base+PSS_CONTROL, PSS_RESET);\n\n    for (i = 0; i < 32768; i++)\n\tinw(pss_base+PSS_CONTROL);\n \n    outw(pss_base+PSS_CONTROL, 0);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+PSS_STATUS",
            "inw(sc->sc_iobase+PSS_STATUS) & GAME_BIT_MASK"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_STATUS"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+PSS_STATUS",
            "inw(sc->sc_iobase+PSS_STATUS) | GAME_BIT"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_STATUS"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"Turning Game Port On.\\n\")"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pss_setdma",
          "args": [
            "sc->sc_drq",
            "sc->sc_iobase+PSS_CONFIG"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setdma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "390-434",
          "snippet": "int\npss_setdma(dmaNum, configAddress)\n\tint dmaNum;\n\tint configAddress;\n{\n    int val;\n    \n    switch(dmaNum) {\n    case 0:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 1;\n    }\n    outw(configAddress, val);\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_setdma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_setdma;\n\nint\npss_setdma(dmaNum, configAddress)\n\tint dmaNum;\n\tint configAddress;\n{\n    int val;\n    \n    switch(dmaNum) {\n    case 0:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 1;\n    }\n    outw(configAddress, val);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_setint",
          "args": [
            "ia->ia_irq",
            "sc->sc_iobase+PSS_CONFIG"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "339-388",
          "snippet": "int\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_setint"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_setint;\n\nint\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: configured DMA channel unavailable (%d)\\n\", ia->ia_drq)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pss_testdma",
          "args": [
            "sc",
            "ia->ia_drq"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "pss_testdma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "516-578",
          "snippet": "int\npss_testdma(sc, dmaNum)\n\tstruct pss_softc *sc;\n\tint dmaNum;\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int i, ret;\n\n    switch (dmaNum) {\n    case 0:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the DMA channel is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 3; i++) {\n\tval = inw(config);\n\tif (val & DMA_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the DMA bits */\n    val = inw(config);\n    val &= DMA_TEST_BIT_MASK & DMA_MASK;\n    outw(config, val);\n    return(ret);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_testdma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testdma;\n\nint\npss_testdma(sc, dmaNum)\n\tstruct pss_softc *sc;\n\tint dmaNum;\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int i, ret;\n\n    switch (dmaNum) {\n    case 0:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the DMA channel is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 3; i++) {\n\tval = inw(config);\n\tif (val & DMA_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the DMA bits */\n    val = inw(config);\n    val &= DMA_TEST_BIT_MASK & DMA_MASK;\n    outw(config, val);\n    return(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: configured IRQ unavailable (%d)\\n\", ia->ia_irq)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pss_testirq",
          "args": [
            "sc",
            "ia->ia_irq"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "pss_testirq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "442-508",
          "snippet": "int\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpss_testirq"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testirq;\n\nint\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: found IRQ %d free\\n\", i)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: unable to locate free IRQ channel\\n\")"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+CD_CONFIG",
            "0"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+MIDI_CONFIG",
            "0"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+SB_CONFIG",
            "0"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+PSS_WSS_CONFIG",
            "0"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->sc_iobase+PSS_CONFIG",
            "0"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "WSS_BASE_ADDRESS+WSS_CONFIG",
            "0"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pss_setaddr",
          "args": [
            "WSS_BASE_ADDRESS",
            "sc->sc_iobase+PSS_WSS_CONFIG"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "pss_setaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "321-332",
          "snippet": "void\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpss_setaddr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpss_setaddr;\n\nvoid\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: not a PSS - %x\\n\", inw(iobase+PSS_ID_VERS))"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase+PSS_ID_VERS"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase+PSS_ID_VERS"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: no PSS found (at 0x220 or 0x240)\\n\")"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase+PSS_ID_VERS"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase+PSS_ID_VERS"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: configured iobase %x invalid\\n\", iobase)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PSS_BASE_VALID",
          "args": [
            "iobase"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WSS_BASE_ADDRESS 0x0530\n\nint\tpssprobe;\nvoid\tpss_setaddr;\nint\tpss_setint;\nint\tpss_setdma;\nint\tpss_testirq;\nint\tpss_testdma;\n\nint\npssprobe(parent, self, aux)\n    struct device *parent;\n    void *self;\n    void *aux;\n{\n    struct pss_softc *sc = self;\n    struct isa_attach_args *ia = aux;\n    int iobase = ia->ia_iobase;\n    \n    if (!PSS_BASE_VALID(iobase)) {\n\tDPRINTF((\"pss: configured iobase %x invalid\\n\", iobase));\n\treturn 0;\n    }\n\n    /* Need to probe for iobase when IOBASEUNK {0x220 0x240} */\n    if (iobase == IOBASEUNK) {\n\n\tiobase = 0x220;\n\tif ((inw(iobase+PSS_ID_VERS) & 0xff00) == 0x4500)\n\t    goto pss_found;\n\n\tiobase = 0x240;\n\tif ((inw(iobase+PSS_ID_VERS) & 0xff00) == 0x4500)\n\t    goto pss_found;\n\n\tDPRINTF((\"pss: no PSS found (at 0x220 or 0x240)\\n\"));\n\treturn 0;\n    }\n    else if ((inw(iobase+PSS_ID_VERS) & 0xff00) != 0x4500) {\n\tDPRINTF((\"pss: not a PSS - %x\\n\", inw(iobase+PSS_ID_VERS)));\n\treturn 0;\n    }\n\npss_found:\n    sc->sc_iobase = iobase;\n\n    /* Clear WSS config */\n    pss_setaddr(WSS_BASE_ADDRESS, sc->sc_iobase+PSS_WSS_CONFIG); /* XXX! */\n    outb(WSS_BASE_ADDRESS+WSS_CONFIG, 0);\n\n    /* Clear config registers (POR reset state) */\n    outw(sc->sc_iobase+PSS_CONFIG, 0);\n    outw(sc->sc_iobase+PSS_WSS_CONFIG, 0);\n    outw(sc->sc_iobase+SB_CONFIG, 0);\n    outw(sc->sc_iobase+MIDI_CONFIG, 0);\n    outw(sc->sc_iobase+CD_CONFIG, 0);\n\n    if (ia->ia_irq == IRQUNK) {\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t    if (pss_testirq(sc, i) != 0)\n\t\tbreak;\n\t}\n\tif (i == 16) {\n\t    DPRINTF((\"pss: unable to locate free IRQ channel\\n\"));\n\t    return 0;\n\t}\n\telse {\n\t    ia->ia_irq = i;\n\t    DPRINTF((\"pss: found IRQ %d free\\n\", i));\n\t}\n    }\n    else {\n\tif (pss_testirq(sc, ia->ia_irq) == 0) {\n\t    DPRINTF((\"pss: configured IRQ unavailable (%d)\\n\", ia->ia_irq));\n\t    return 0;\n\t}\n    }\n\n    /* XXX Need to deal with DRQUNK */\n    if (pss_testdma(sc, ia->ia_drq) == 0) {\n\tDPRINTF((\"pss: configured DMA channel unavailable (%d)\\n\", ia->ia_drq));\n\treturn 0;\n    }\n      \n    ia->ia_iosize = PSS_NPORT;\n\n    /* Initialize PSS irq and dma */\n    pss_setint(ia->ia_irq, sc->sc_iobase+PSS_CONFIG);\n    pss_setdma(sc->sc_drq, sc->sc_iobase+PSS_CONFIG);\n\n#ifdef notyet\n    /* Setup the Game port */\n#ifdef PSS_GAMEPORT\n    DPRINTF((\"Turning Game Port On.\\n\"));\n    outw(sc->sc_iobase+PSS_STATUS, inw(sc->sc_iobase+PSS_STATUS) | GAME_BIT);\n#else\n    outw(sc->sc_iobase+PSS_STATUS, inw(sc->sc_iobase+PSS_STATUS) & GAME_BIT_MASK);\n#endif\n\n    /* Reset DSP */\n    pss_reset_dsp(sc);\n#endif /* notyet */\n\n    return 1;\n}"
  },
  {
    "function_name": "pss_dump_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "693-705",
    "snippet": "void\npss_dump_regs(sc)\n\tstruct pss_softc *sc;\n{\n\n    printf(\"PSS regs: status=%04x vers=%04x \",\n\t   (u_short)inw(sc->sc_iobase+PSS_STATUS),\n\t   (u_short)inw(sc->sc_iobase+PSS_ID_VERS));\n\t\n    printf(\"config=%04x wss_config=%04x\\n\",\n\t   (u_short)inw(sc->sc_iobase+PSS_CONFIG),\n\t   (u_short)inw(sc->sc_iobase+PSS_WSS_CONFIG));\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"config=%04x wss_config=%04x\\n\"",
            "(u_short)inw(sc->sc_iobase+PSS_CONFIG)",
            "(u_short)inw(sc->sc_iobase+PSS_WSS_CONFIG)"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_WSS_CONFIG"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_CONFIG"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_ID_VERS"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase+PSS_STATUS"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\npss_dump_regs(sc)\n\tstruct pss_softc *sc;\n{\n\n    printf(\"PSS regs: status=%04x vers=%04x \",\n\t   (u_short)inw(sc->sc_iobase+PSS_STATUS),\n\t   (u_short)inw(sc->sc_iobase+PSS_ID_VERS));\n\t\n    printf(\"config=%04x wss_config=%04x\\n\",\n\t   (u_short)inw(sc->sc_iobase+PSS_CONFIG),\n\t   (u_short)inw(sc->sc_iobase+PSS_WSS_CONFIG));\n}"
  },
  {
    "function_name": "wss_dump_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "684-691",
    "snippet": "void\nwss_dump_regs(sc)\n\tstruct ad1848_softc *sc;\n{\n\n    printf(\"WSS reg: status=%02x\\n\",\n\t   (u_char)inb(sc->sc_iobase-WSS_CODEC+WSS_STATUS));\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WSS reg: status=%02x\\n\"",
            "(u_char)inb(sc->sc_iobase-WSS_CODEC+WSS_STATUS)"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase-WSS_CODEC+WSS_STATUS"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwss_dump_regs(sc)\n\tstruct ad1848_softc *sc;\n{\n\n    printf(\"WSS reg: status=%02x\\n\",\n\t   (u_char)inb(sc->sc_iobase-WSS_CODEC+WSS_STATUS));\n}"
  },
  {
    "function_name": "pss_download_dsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "609-680",
    "snippet": "int\npss_download_dsp(sc, block, size)\n\tstruct pss_softc *sc;\n\tu_char *block;\n\tint size;\n{\n    int i, val, count;\n    int pss_base = sc->sc_iobase;\n    \n    DPRINTF((\"pss: downloading boot code...\"));\n\n    /* Warn DSP software that a boot is coming */\n    outw(pss_base+PSS_DATA, 0x00fe);\n\n    for (i = 0; i < 32768; i++)\n\tif (inw(pss_base+PSS_DATA) == 0x5500)\n\t    break;\n    outw(pss_base+PSS_DATA, *block++);\n\n    pss_reset_dsp(sc);\n\n    DPRINTF((\"start \"));\n\n    count = 1;\n    while(1) {\n\tint j;\n\tfor (j=0; j<327670; j++) {\n\t    /* Wait for BG to appear */\n\t    if (inw(pss_base+PSS_STATUS) & PSS_FLAG3)\n\t\tbreak;\n \t}\n \n\tif (j==327670) {\n\t    /* It's ok we timed out when the file was empty */\n\t    if (count >= size)\n\t\tbreak;\n\t    else {\n\t\tprintf(\"\\npss: DownLoad timeout problems, byte %d=%d\\n\",\n\t\t       count, size);\n\t\treturn 0;\n \t    }\n \t}\n\t/* Send the next byte */\n\toutw(pss_base+PSS_DATA, *block++);\n\tcount++;\n    }\n\n    outw(pss_base+PSS_DATA, 0);\n    for (i = 0; i < 32768; i++)\n\t(void) inw(pss_base+PSS_STATUS);\n\n    DPRINTF((\"downloaded\\n\"));\n\n    for (i = 0; i < 32768; i++) {\n\tval = inw(pss_base+PSS_STATUS);\n\tif (val & PSS_READ_FULL)\n\t    break;\n    }\n\n    /* now read the version */\n    for (i = 0; i < 32000; i++) {\n\tval = inw(pss_base+PSS_STATUS);\n\tif (val & PSS_READ_FULL)\n\t    break;\n    }\n    if (i == 32000)\n\treturn 0;\n\n    (void) inw(pss_base+PSS_DATA);\n\n    return 1;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_DATA"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_STATUS"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_STATUS"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"downloaded\\n\")"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_STATUS"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pss_base+PSS_DATA",
            "0"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pss_base+PSS_DATA",
            "*block++"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\npss: DownLoad timeout problems, byte %d=%d\\n\"",
            "count",
            "size"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_STATUS"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"start \")"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pss_reset_dsp",
          "args": [
            "sc"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "pss_reset_dsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
          "lines": "581-596",
          "snippet": "int\npss_reset_dsp(sc)\n\tstruct pss_softc *sc;\n{\n    u_long i;\n    int pss_base = sc->sc_iobase;\n\n    outw(pss_base+PSS_CONTROL, PSS_RESET);\n\n    for (i = 0; i < 32768; i++)\n\tinw(pss_base+PSS_CONTROL);\n \n    outw(pss_base+PSS_CONTROL, 0);\n\n    return 1;\n}",
          "includes": [
            "#include <dev/isa/pssreg.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\npss_reset_dsp(sc)\n\tstruct pss_softc *sc;\n{\n    u_long i;\n    int pss_base = sc->sc_iobase;\n\n    outw(pss_base+PSS_CONTROL, PSS_RESET);\n\n    for (i = 0; i < 32768; i++)\n\tinw(pss_base+PSS_CONTROL);\n \n    outw(pss_base+PSS_CONTROL, 0);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pss_base+PSS_DATA",
            "*block++"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_DATA"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pss_base+PSS_DATA",
            "0x00fe"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss: downloading boot code...\")"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\npss_download_dsp(sc, block, size)\n\tstruct pss_softc *sc;\n\tu_char *block;\n\tint size;\n{\n    int i, val, count;\n    int pss_base = sc->sc_iobase;\n    \n    DPRINTF((\"pss: downloading boot code...\"));\n\n    /* Warn DSP software that a boot is coming */\n    outw(pss_base+PSS_DATA, 0x00fe);\n\n    for (i = 0; i < 32768; i++)\n\tif (inw(pss_base+PSS_DATA) == 0x5500)\n\t    break;\n    outw(pss_base+PSS_DATA, *block++);\n\n    pss_reset_dsp(sc);\n\n    DPRINTF((\"start \"));\n\n    count = 1;\n    while(1) {\n\tint j;\n\tfor (j=0; j<327670; j++) {\n\t    /* Wait for BG to appear */\n\t    if (inw(pss_base+PSS_STATUS) & PSS_FLAG3)\n\t\tbreak;\n \t}\n \n\tif (j==327670) {\n\t    /* It's ok we timed out when the file was empty */\n\t    if (count >= size)\n\t\tbreak;\n\t    else {\n\t\tprintf(\"\\npss: DownLoad timeout problems, byte %d=%d\\n\",\n\t\t       count, size);\n\t\treturn 0;\n \t    }\n \t}\n\t/* Send the next byte */\n\toutw(pss_base+PSS_DATA, *block++);\n\tcount++;\n    }\n\n    outw(pss_base+PSS_DATA, 0);\n    for (i = 0; i < 32768; i++)\n\t(void) inw(pss_base+PSS_STATUS);\n\n    DPRINTF((\"downloaded\\n\"));\n\n    for (i = 0; i < 32768; i++) {\n\tval = inw(pss_base+PSS_STATUS);\n\tif (val & PSS_READ_FULL)\n\t    break;\n    }\n\n    /* now read the version */\n    for (i = 0; i < 32000; i++) {\n\tval = inw(pss_base+PSS_STATUS);\n\tif (val & PSS_READ_FULL)\n\t    break;\n    }\n    if (i == 32000)\n\treturn 0;\n\n    (void) inw(pss_base+PSS_DATA);\n\n    return 1;\n}"
  },
  {
    "function_name": "pss_reset_dsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "581-596",
    "snippet": "int\npss_reset_dsp(sc)\n\tstruct pss_softc *sc;\n{\n    u_long i;\n    int pss_base = sc->sc_iobase;\n\n    outw(pss_base+PSS_CONTROL, PSS_RESET);\n\n    for (i = 0; i < 32768; i++)\n\tinw(pss_base+PSS_CONTROL);\n \n    outw(pss_base+PSS_CONTROL, 0);\n\n    return 1;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pss_base+PSS_CONTROL",
            "0"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_CONTROL"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pss_base+PSS_CONTROL",
            "PSS_RESET"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\npss_reset_dsp(sc)\n\tstruct pss_softc *sc;\n{\n    u_long i;\n    int pss_base = sc->sc_iobase;\n\n    outw(pss_base+PSS_CONTROL, PSS_RESET);\n\n    for (i = 0; i < 32768; i++)\n\tinw(pss_base+PSS_CONTROL);\n \n    outw(pss_base+PSS_CONTROL, 0);\n\n    return 1;\n}"
  },
  {
    "function_name": "pss_testdma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "516-578",
    "snippet": "int\npss_testdma(sc, dmaNum)\n\tstruct pss_softc *sc;\n\tint dmaNum;\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int i, ret;\n\n    switch (dmaNum) {\n    case 0:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the DMA channel is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 3; i++) {\n\tval = inw(config);\n\tif (val & DMA_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the DMA bits */\n    val = inw(config);\n    val &= DMA_TEST_BIT_MASK & DMA_MASK;\n    outw(config, val);\n    return(ret);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_testdma"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "config",
            "val"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "config",
            "val"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_testdma: invalid drq (%d)\\n\", dmaNum)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testdma;\n\nint\npss_testdma(sc, dmaNum)\n\tstruct pss_softc *sc;\n\tint dmaNum;\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int i, ret;\n\n    switch (dmaNum) {\n    case 0:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= DMA_MASK;\n\tval |= DMA_TEST_BIT | DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the DMA channel is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 3; i++) {\n\tval = inw(config);\n\tif (val & DMA_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the DMA bits */\n    val = inw(config);\n    val &= DMA_TEST_BIT_MASK & DMA_MASK;\n    outw(config, val);\n    return(ret);\n}"
  },
  {
    "function_name": "pss_testirq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "442-508",
    "snippet": "int\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_testirq"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "config",
            "val"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "config",
            "val"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_testirq: invalid irq (%d)\\n\", intNum)"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "config"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_testirq;\n\nint\npss_testirq(struct pss_softc *sc, int intNum)\n{\n    int config = sc->sc_iobase + PSS_CONFIG;\n    int val;\n    int ret;\n    int i;\n\n    /* Set the interrupt bits */\n    switch(intNum) {\n    case 3:\n\tval = inw(config);\n\tval &= INT_MASK;\t/* Special: 0 */\n\tbreak;\n    case 5:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(config);\n\tval &= INT_MASK;\n\tval |= INT_TEST_BIT | INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_testirq: invalid irq (%d)\\n\", intNum));\n\treturn 0;\n    }\n    outw(config, val);\n\n    /* Check if the interrupt is in use */\n    /* Do it a few times in case there is a delay */\n    ret = 0;\n    for (i = 0; i < 5; i++) {\n\tval = inw(config);\n\tif (val & INT_TEST_PASS) {\n\t    ret = 1;\n\t    break;\n\t}\n    }\n\n    /* Clear the Test bit and the interrupt bits */\n    val = inw(config);\n    val &= INT_TEST_BIT_MASK & INT_MASK;\n    outw(config, val);\n    return(ret);\n}"
  },
  {
    "function_name": "pss_setdma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "390-434",
    "snippet": "int\npss_setdma(dmaNum, configAddress)\n\tint dmaNum;\n\tint configAddress;\n{\n    int val;\n    \n    switch(dmaNum) {\n    case 0:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 1;\n    }\n    outw(configAddress, val);\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_setdma"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "configAddress",
            "val"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_setdma: invalid drq (%d)\\n\", dmaNum)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_setdma;\n\nint\npss_setdma(dmaNum, configAddress)\n\tint dmaNum;\n\tint configAddress;\n{\n    int val;\n    \n    switch(dmaNum) {\n    case 0:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_0_BITS;\n\tbreak;\n    case 1:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_1_BITS;\n\tbreak;\n    case 3:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_5_BITS;\n\tbreak;\n    case 6:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_6_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= DMA_MASK;\n\tval |= DMA_7_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setdma: invalid drq (%d)\\n\", dmaNum));\n\treturn 1;\n    }\n    outw(configAddress, val);\n    return 0;\n}"
  },
  {
    "function_name": "pss_setint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "339-388",
    "snippet": "int\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpss_setint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "configAddress",
            "val"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pss_setint: invalid irq (%d)\\n\", intNum)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddress"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpss_setint;\n\nint\npss_setint(intNum, configAddress)\n\tint intNum;\n\tint configAddress;\n{\n    int val;\n\n    switch(intNum) {\n    case 3:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_3_BITS;\n\tbreak;\n    case 5:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_5_BITS;\n\tbreak;\n    case 7:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_7_BITS;\n\tbreak;\n    case 9:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_9_BITS;\n\tbreak;\n    case 10:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_10_BITS;\n\tbreak;\n    case 11:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_11_BITS;\n\tbreak;\n    case 12:\n\tval = inw(configAddress);\n\tval &= INT_MASK;\n\tval |= INT_12_BITS;\n\tbreak;\n    default:\n\tDPRINTF((\"pss_setint: invalid irq (%d)\\n\", intNum));\n\treturn 1;\n    }\n    outw(configAddress,val);\n    return 0;\n}"
  },
  {
    "function_name": "pss_setaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "321-332",
    "snippet": "void\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpss_setaddr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "configAddr",
            "val"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "configAddr"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpss_setaddr;\n\nvoid\npss_setaddr(addr, configAddr)\n\tint addr;\n\tint configAddr;\n{\n    int val;\n    \n    val = inw(configAddr);\n    val &= ADDR_MASK;\n    val |= (addr << 4);\n    outw(configAddr,val);\n}"
  },
  {
    "function_name": "pss_dspwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pss.c",
    "lines": "296-318",
    "snippet": "void\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}",
    "includes": [
      "#include <dev/isa/pssreg.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/pio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pss: DSP Command (%04x) Timeout.\\n\"",
            "data"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "pss_base+PSS_DATA",
            "data"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "pss_base+PSS_STATUS"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pssreg.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\npss_dspwrite(sc, data)\n\tstruct pss_softc *sc;\n\tint data;\n{\n    int i;\n    int pss_base = sc->sc_iobase;\n\n    /*\n     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes\n     * called while interrupts are disabled. This means that the timer is\n     * disabled also. However the timeout situation is a abnormal condition.\n     * Normally the DSP should be ready to accept commands after just couple of\n     * loops.\n     */\n    for (i = 0; i < 5000000; i++) {\n\tif (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {\n\t    outw(pss_base+PSS_DATA, data);\n\t    return;\n\t}\n    }\n    printf (\"pss: DSP Command (%04x) Timeout.\\n\", data);\n}"
  }
]