[
  {
    "function_name": "isp_parse_nvram_2100",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "4652-4736",
    "snippet": "static void\nisp_parse_nvram_2100(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tunion {\n\t\tstruct {\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t\t\tu_int32_t hi32;\n\t\t\tu_int32_t lo32;\n#else\n\t\t\tu_int32_t lo32;\n\t\t\tu_int32_t hi32;\n#endif\n\t\t} wd;\n\t\tu_int64_t full64;\n\t} wwnstore;\n\n\twwnstore.full64 = ISP2100_NVRAM_NODE_NAME(nvram_data);\n\n\t/*\n\t * Broken PTI cards with nothing in the top nibble. Pah.\n\t */\n\tif ((wwnstore.wd.hi32 >> 28) == 0) {\n\t\twwnstore.wd.hi32 |= (2 << 28);\n\t\tCFGPRINTF(\"%s: (corrected) Adapter WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t} else {\n\t\tCFGPRINTF(\"%s: Adapter WWN 0x%08x%08x\\n\", isp->isp_name,\n\t\t    wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_nodewwn = wwnstore.full64;\n\n\t/*\n\t * If the Node WWN has 2 in the top nibble, we can\n\t * authoritatively construct a Port WWN by adding\n\t * our unit number (plus one to make it nonzero) and\n\t * putting it into bits 59..56. If the top nibble isn't\n\t * 2, then we just set them identically.\n\t */\n\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn |\n\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t} else {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn;\n\t}\n\twwnstore.full64 = ISP2100_NVRAM_BOOT_NODE_NAME(nvram_data);\n\tif (wwnstore.full64 != 0) {\n\t\tPRINTF(\"%s: BOOT DEVICE WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_maxalloc =\n\t\tISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);\n\tfcp->isp_maxfrmlen =\n\t\tISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);\n\tfcp->isp_retry_delay =\n\t\tISP2100_NVRAM_RETRY_DELAY(nvram_data);\n\tfcp->isp_retry_count =\n\t\tISP2100_NVRAM_RETRY_COUNT(nvram_data);\n\tfcp->isp_loopid =\n\t\tISP2100_NVRAM_HARDLOOPID(nvram_data);\n\tfcp->isp_execthrottle =\n\t\tISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);\n\tfcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"  Max IOCB Allocation = %d\\n\",\n\t\t    fcp->isp_maxalloc);\n\t\tPRINTF(\"     Max Frame Length = %d\\n\",\n\t\t    fcp->isp_maxfrmlen);\n\t\tPRINTF(\"   Execution Throttle = %d\\n\",\n\t\t    fcp->isp_execthrottle);\n\t\tPRINTF(\"          Retry Count = %d\\n\",\n\t\t    fcp->isp_retry_count);\n\t\tPRINTF(\"          Retry Delay = %d\\n\",\n\t\t    fcp->isp_retry_delay);\n\t\tPRINTF(\"         Hard Loop ID = %d\\n\",\n\t\t    fcp->isp_loopid);\n\t\tPRINTF(\"              Options = 0x%x\\n\",\n\t\t    fcp->isp_fwoptions);\n\t\tPRINTF(\"          HBA Options = 0x%x\\n\",\n\t\t    ISP2100_NVRAM_HBA_OPTIONS(nvram_data));\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tnvram_data\t_n._x"
    ],
    "globals_used": [
      "static void isp_parse_nvram_2100"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"          HBA Options = 0x%x\\n\"",
            "ISP2100_NVRAM_HBA_OPTIONS(nvram_data)"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_HBA_OPTIONS",
          "args": [
            "nvram_data"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"              Options = 0x%x\\n\"",
            "fcp->isp_fwoptions"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"         Hard Loop ID = %d\\n\"",
            "fcp->isp_loopid"
          ],
          "line": 4729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"          Retry Delay = %d\\n\"",
            "fcp->isp_retry_delay"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"          Retry Count = %d\\n\"",
            "fcp->isp_retry_count"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"   Execution Throttle = %d\\n\"",
            "fcp->isp_execthrottle"
          ],
          "line": 4723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"     Max Frame Length = %d\\n\"",
            "fcp->isp_maxfrmlen"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"  Max IOCB Allocation = %d\\n\"",
            "fcp->isp_maxalloc"
          ],
          "line": 4719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: NVRAM values:\\n\"",
            "isp->isp_name"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_OPTIONS",
          "args": [
            "nvram_data"
          ],
          "line": 4716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_EXECUTION_THROTTLE",
          "args": [
            "nvram_data"
          ],
          "line": 4715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_HARDLOOPID",
          "args": [
            "nvram_data"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_RETRY_COUNT",
          "args": [
            "nvram_data"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_RETRY_DELAY",
          "args": [
            "nvram_data"
          ],
          "line": 4709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_MAXFRAMELENGTH",
          "args": [
            "nvram_data"
          ],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_MAXIOCBALLOCATION",
          "args": [
            "nvram_data"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: BOOT DEVICE WWN 0x%08x%08x\\n\"",
            "isp->isp_name",
            "wwnstore.wd.hi32",
            "wwnstore.wd.lo32"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_BOOT_NODE_NAME",
          "args": [
            "nvram_data"
          ],
          "line": 4699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "isp->isp_unit+1"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Adapter WWN 0x%08x%08x\\n\"",
            "isp->isp_name",
            "wwnstore.wd.hi32",
            "wwnstore.wd.lo32"
          ],
          "line": 4681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: (corrected) Adapter WWN 0x%08x%08x\\n\"",
            "isp->isp_name",
            "wwnstore.wd.hi32",
            "wwnstore.wd.lo32"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP2100_NVRAM_NODE_NAME",
          "args": [
            "nvram_data"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_2100;\n\nstatic void\nisp_parse_nvram_2100(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tunion {\n\t\tstruct {\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t\t\tu_int32_t hi32;\n\t\t\tu_int32_t lo32;\n#else\n\t\t\tu_int32_t lo32;\n\t\t\tu_int32_t hi32;\n#endif\n\t\t} wd;\n\t\tu_int64_t full64;\n\t} wwnstore;\n\n\twwnstore.full64 = ISP2100_NVRAM_NODE_NAME(nvram_data);\n\n\t/*\n\t * Broken PTI cards with nothing in the top nibble. Pah.\n\t */\n\tif ((wwnstore.wd.hi32 >> 28) == 0) {\n\t\twwnstore.wd.hi32 |= (2 << 28);\n\t\tCFGPRINTF(\"%s: (corrected) Adapter WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t} else {\n\t\tCFGPRINTF(\"%s: Adapter WWN 0x%08x%08x\\n\", isp->isp_name,\n\t\t    wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_nodewwn = wwnstore.full64;\n\n\t/*\n\t * If the Node WWN has 2 in the top nibble, we can\n\t * authoritatively construct a Port WWN by adding\n\t * our unit number (plus one to make it nonzero) and\n\t * putting it into bits 59..56. If the top nibble isn't\n\t * 2, then we just set them identically.\n\t */\n\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn |\n\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t} else {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn;\n\t}\n\twwnstore.full64 = ISP2100_NVRAM_BOOT_NODE_NAME(nvram_data);\n\tif (wwnstore.full64 != 0) {\n\t\tPRINTF(\"%s: BOOT DEVICE WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_maxalloc =\n\t\tISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);\n\tfcp->isp_maxfrmlen =\n\t\tISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);\n\tfcp->isp_retry_delay =\n\t\tISP2100_NVRAM_RETRY_DELAY(nvram_data);\n\tfcp->isp_retry_count =\n\t\tISP2100_NVRAM_RETRY_COUNT(nvram_data);\n\tfcp->isp_loopid =\n\t\tISP2100_NVRAM_HARDLOOPID(nvram_data);\n\tfcp->isp_execthrottle =\n\t\tISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);\n\tfcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"  Max IOCB Allocation = %d\\n\",\n\t\t    fcp->isp_maxalloc);\n\t\tPRINTF(\"     Max Frame Length = %d\\n\",\n\t\t    fcp->isp_maxfrmlen);\n\t\tPRINTF(\"   Execution Throttle = %d\\n\",\n\t\t    fcp->isp_execthrottle);\n\t\tPRINTF(\"          Retry Count = %d\\n\",\n\t\t    fcp->isp_retry_count);\n\t\tPRINTF(\"          Retry Delay = %d\\n\",\n\t\t    fcp->isp_retry_delay);\n\t\tPRINTF(\"         Hard Loop ID = %d\\n\",\n\t\t    fcp->isp_loopid);\n\t\tPRINTF(\"              Options = 0x%x\\n\",\n\t\t    fcp->isp_fwoptions);\n\t\tPRINTF(\"          HBA Options = 0x%x\\n\",\n\t\t    ISP2100_NVRAM_HBA_OPTIONS(nvram_data));\n\t}\n}"
  },
  {
    "function_name": "isp_parse_nvram_12160",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "4527-4650",
    "snippet": "static void\nisp_parse_nvram_12160(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tint i;\n\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold =\n\t    ISP12160_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id = \n\t    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP12160_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP12160_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP12160_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP12160_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP12160_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP12160 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP12160_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP12160_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP12160_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP12160_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP12160_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP12160_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP12160_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP12160_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle %d Offset %d \"\n\t\t\t    \"Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tnvram_data\t_n._x"
    ],
    "globals_used": [
      "static void isp_parse_nvram_12160"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"   Target %d: Ena %d Throttle %d Offset %d \"\n\t\t\t    \"Period %d Flags 0x%x\\n\"",
            "i",
            "sdp->isp_devparam[i].dev_enable",
            "sdp->isp_devparam[i].exc_throttle",
            "sdp->isp_devparam[i].sync_offset",
            "sdp->isp_devparam[i].sync_period",
            "sdp->isp_devparam[i].dev_flags"
          ],
          "line": 4641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_DISC",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_PARITY",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_WIDE",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_SYNC",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_TQING",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\"",
            "isp->isp_name",
            "i",
            "bus"
          ],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_ARQ",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\"",
            "isp->isp_name",
            "i",
            "bus"
          ],
          "line": 4621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_QFRZ",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_RENEG",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_SYNC_PERIOD",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_SYNC_OFFSET",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_EXEC_THROTTLE",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_TGT_DEVICE_ENABLE",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"       Cmd DMA Burst Enable = %s\\n\"",
            "sdp->isp_cmd_dma_burst_enable? tru : not"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"  Data Line Active Negation = %s\\n\"",
            "sdp->isp_data_line_active_neg? tru : not"
          ],
          "line": 4602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    REQ/ACK Active Negation = %s\\n\"",
            "sdp->isp_req_ack_active_neg? tru : not"
          ],
          "line": 4600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"           Async Data Setup = 0x%x\\n\"",
            "sdp->isp_async_data_setup"
          ],
          "line": 4598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"            Max Queue Depth = %d\\n\"",
            "sdp->isp_max_queue_depth"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"          Selection Timeout = %d\\n\"",
            "sdp->isp_selection_timeout"
          ],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"              Tag Age Limit = %d\\n\"",
            "sdp->isp_tag_aging"
          ],
          "line": 4592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"                Retry Delay = %d\\n\"",
            "sdp->isp_retry_delay"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"                Retry Count = %d\\n\"",
            "sdp->isp_retry_count"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"            Bus Reset Delay = %d\\n\"",
            "sdp->isp_bus_reset_delay"
          ],
          "line": 4586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"             Fifo Threshold = 0x%x\\n\"",
            "sdp->isp_fifo_threshold"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"               Initiator ID = %d\\n\"",
            "sdp->isp_initiator_id"
          ],
          "line": 4582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ISP12160 bus %d NVRAM values:\\n\"",
            "isp->isp_name",
            "bus"
          ],
          "line": 4580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_MAX_QUEUE_DEPTH",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_SELECTION_TIMEOUT",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_BURST_ENABLE",
          "args": [
            "nvram_data"
          ],
          "line": 4571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_BURST_ENABLE",
          "args": [
            "nvram_data"
          ],
          "line": 4568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_BUS_RETRY_DELAY",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_BUS_RETRY_COUNT",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_BUS_RESET_DELAY",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_INITIATOR_ID",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP12160_NVRAM_FIFO_THRESHOLD",
          "args": [
            "nvram_data"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_12160;\n\nstatic void\nisp_parse_nvram_12160(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tint i;\n\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold =\n\t    ISP12160_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id = \n\t    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP12160_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP12160_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP12160_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP12160_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP12160_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP12160 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP12160_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP12160_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP12160_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP12160_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP12160_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP12160_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP12160_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP12160_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle %d Offset %d \"\n\t\t\t    \"Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "isp_parse_nvram_1080",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "4401-4525",
    "snippet": "static void\nisp_parse_nvram_1080(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tint i;\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold = \n\t    ISP1080_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id =\n\t    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP1080_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP1080_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP1080_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP1080_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP1080_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP1080 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP1080_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP1080_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP1080_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP1080_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP1080_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP1080_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP1080_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP1080_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle \"\n\t\t\t    \"%d Offset %d Period %d Flags \"\n\t\t\t    \"0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tnvram_data\t_n._x"
    ],
    "globals_used": [
      "static void isp_parse_nvram_1080"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"   Target %d: Ena %d Throttle \"\n\t\t\t    \"%d Offset %d Period %d Flags \"\n\t\t\t    \"0x%x\\n\"",
            "i",
            "sdp->isp_devparam[i].dev_enable",
            "sdp->isp_devparam[i].exc_throttle",
            "sdp->isp_devparam[i].sync_offset",
            "sdp->isp_devparam[i].sync_period",
            "sdp->isp_devparam[i].dev_flags"
          ],
          "line": 4515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_DISC",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_PARITY",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_WIDE",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_SYNC",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_TQING",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\"",
            "isp->isp_name",
            "i",
            "bus"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_ARQ",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\"",
            "isp->isp_name",
            "i",
            "bus"
          ],
          "line": 4493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_QFRZ",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_RENEG",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_SYNC_PERIOD",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_SYNC_OFFSET",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_EXEC_THROTTLE",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_TGT_DEVICE_ENABLE",
          "args": [
            "nvram_data",
            "i",
            "bus"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"       Cmd DMA Burst Enable = %s\\n\"",
            "sdp->isp_cmd_dma_burst_enable? tru : not"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"  Data Line Active Negation = %s\\n\"",
            "sdp->isp_data_line_active_neg? tru : not"
          ],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    REQ/ACK Active Negation = %s\\n\"",
            "sdp->isp_req_ack_active_neg? tru : not"
          ],
          "line": 4473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"           Async Data Setup = 0x%x\\n\"",
            "sdp->isp_async_data_setup"
          ],
          "line": 4471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"            Max Queue Depth = %d\\n\"",
            "sdp->isp_max_queue_depth"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"          Selection Timeout = %d\\n\"",
            "sdp->isp_selection_timeout"
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"              Tag Age Limit = %d\\n\"",
            "sdp->isp_tag_aging"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"                Retry Delay = %d\\n\"",
            "sdp->isp_retry_delay"
          ],
          "line": 4463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"                Retry Count = %d\\n\"",
            "sdp->isp_retry_count"
          ],
          "line": 4461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"            Bus Reset Delay = %d\\n\"",
            "sdp->isp_bus_reset_delay"
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"             Fifo Threshold = 0x%x\\n\"",
            "sdp->isp_fifo_threshold"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"               Initiator ID = %d\\n\"",
            "sdp->isp_initiator_id"
          ],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ISP1080 bus %d NVRAM values:\\n\"",
            "isp->isp_name",
            "bus"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_MAX_QUEUE_DEPTH",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_SELECTION_TIMEOUT",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_BURST_ENABLE",
          "args": [
            "nvram_data"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_BURST_ENABLE",
          "args": [
            "nvram_data"
          ],
          "line": 4441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_BUS_RETRY_DELAY",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_BUS_RETRY_COUNT",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_BUS_RESET_DELAY",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_INITIATOR_ID",
          "args": [
            "nvram_data",
            "bus"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP1080_NVRAM_FIFO_THRESHOLD",
          "args": [
            "nvram_data"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_1080;\n\nstatic void\nisp_parse_nvram_1080(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tint i;\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold = \n\t    ISP1080_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id =\n\t    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP1080_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP1080_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP1080_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP1080_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP1080_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP1080 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP1080_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP1080_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP1080_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP1080_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP1080_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP1080_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP1080_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP1080_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle \"\n\t\t\t    \"%d Offset %d Period %d Flags \"\n\t\t\t    \"0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "isp_parse_nvram_1020",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "4248-4399",
    "snippet": "static void\nisp_parse_nvram_1020(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tint i;\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\n\tsdp->isp_fifo_threshold =\n\t\tISP_NVRAM_FIFO_THRESHOLD(nvram_data) |\n\t\t(ISP_NVRAM_FIFO_THRESHOLD_128(nvram_data) << 2);\n\n\tsdp->isp_initiator_id =\n\t\tISP_NVRAM_INITIATOR_ID(nvram_data);\n\n\tsdp->isp_bus_reset_delay =\n\t\tISP_NVRAM_BUS_RESET_DELAY(nvram_data);\n\n\tsdp->isp_retry_count =\n\t\tISP_NVRAM_BUS_RETRY_COUNT(nvram_data);\n\n\tsdp->isp_retry_delay =\n\t\tISP_NVRAM_BUS_RETRY_DELAY(nvram_data);\n\n\tsdp->isp_async_data_setup =\n\t\tISP_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data);\n\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tif (sdp->isp_async_data_setup < 9) {\n\t\t\tsdp->isp_async_data_setup = 9;\n\t\t}\n\t} else {\n\t\tif (sdp->isp_async_data_setup != 6) {\n\t\t\tsdp->isp_async_data_setup = 6;\n\t\t}\n\t}\n\n\tsdp->isp_req_ack_active_neg =\n\t\tISP_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_line_active_neg =\n\t\tISP_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t\tISP_NVRAM_DATA_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t\tISP_NVRAM_CMD_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_tag_aging =\n\t\tISP_NVRAM_TAG_AGE_LIMIT(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t\tISP_NVRAM_SELECTION_TIMEOUT(nvram_data);\n\n\tsdp->isp_max_queue_depth =\n\t\tISP_NVRAM_MAX_QUEUE_DEPTH(nvram_data);\n\n\tisp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"      Data DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_data_dma_burst_enabl? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t\tPRINTF(\"                  Fast MTTR = %s\\n\",\n\t\t    isp->isp_fast_mttr? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t\tISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, i);\n\n\t\tif (isp->isp_type < ISP_HA_SCSI_1040) {\n\t\t\t/*\n\t\t\t * If we're not ultra, we can't possibly\n\t\t\t * be a shorter period than this.\n\t\t\t */\n\t\t\tif (sdp->isp_devparam[i].sync_period < 0x19) {\n\t\t\t\tsdp->isp_devparam[i].sync_period =\n\t\t\t\t    0x19;\n\t\t\t}\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0xc) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\t\t    0x0c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0x8) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset = 0x8;\n\t\t\t}\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP_NVRAM_TGT_RENEG(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP_NVRAM_TGT_QFRZ(nvram_data, i)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP_NVRAM_TGT_ARQ(nvram_data, i) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tif (ISP_NVRAM_TGT_TQING(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP_NVRAM_TGT_SYNC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP_NVRAM_TGT_WIDE(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP_NVRAM_TGT_PARITY(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP_NVRAM_TGT_DISC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0; /* we don't know */\n\t\tif (isp->isp_dblev > 2) {\n\t\t\tPRINTF(\"   Target %d: Enabled %d Throttle %d \"\n\t\t\t    \"Offset %d Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tnvram_data\t_n._x"
    ],
    "globals_used": [
      "static void isp_parse_nvram_1020"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"   Target %d: Enabled %d Throttle %d \"\n\t\t\t    \"Offset %d Period %d Flags 0x%x\\n\"",
            "i",
            "sdp->isp_devparam[i].dev_enable",
            "sdp->isp_devparam[i].exc_throttle",
            "sdp->isp_devparam[i].sync_offset",
            "sdp->isp_devparam[i].sync_period",
            "sdp->isp_devparam[i].dev_flags"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_DISC",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_PARITY",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_WIDE",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_SYNC",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_TQING",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: not disabling ARQ option for \"\n\t\t\t    \"target %d\\n\"",
            "isp->isp_name",
            "i"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_ARQ",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: not supporting QFRZ option for \"\n\t\t\t    \"target %d\\n\"",
            "isp->isp_name",
            "i"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_QFRZ",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_RENEG",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_SYNC_PERIOD",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_SYNC_OFFSET",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_EXEC_THROTTLE",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TGT_DEVICE_ENABLE",
          "args": [
            "nvram_data",
            "i"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"                  Fast MTTR = %s\\n\"",
            "isp->isp_fast_mttr? tru : not"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"       Cmd DMA Burst Enable = %s\\n\"",
            "sdp->isp_cmd_dma_burst_enable? tru : not"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"      Data DMA Burst Enable = %s\\n\"",
            "sdp->isp_data_dma_burst_enabl? tru : not"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"  Data Line Active Negation = %s\\n\"",
            "sdp->isp_data_line_active_neg? tru : not"
          ],
          "line": 4329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    REQ/ACK Active Negation = %s\\n\"",
            "sdp->isp_req_ack_active_neg? tru : not"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"           Async Data Setup = 0x%x\\n\"",
            "sdp->isp_async_data_setup"
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"            Max Queue Depth = %d\\n\"",
            "sdp->isp_max_queue_depth"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"          Selection Timeout = %d\\n\"",
            "sdp->isp_selection_timeout"
          ],
          "line": 4321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"              Tag Age Limit = %d\\n\"",
            "sdp->isp_tag_aging"
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"                Retry Delay = %d\\n\"",
            "sdp->isp_retry_delay"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"                Retry Count = %d\\n\"",
            "sdp->isp_retry_count"
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"            Bus Reset Delay = %d\\n\"",
            "sdp->isp_bus_reset_delay"
          ],
          "line": 4313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"             Fifo Threshold = 0x%x\\n\"",
            "sdp->isp_fifo_threshold"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: NVRAM values:\\n\"",
            "isp->isp_name"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_FAST_MTTR_ENABLE",
          "args": [
            "nvram_data"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_MAX_QUEUE_DEPTH",
          "args": [
            "nvram_data"
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_SELECTION_TIMEOUT",
          "args": [
            "nvram_data"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_TAG_AGE_LIMIT",
          "args": [
            "nvram_data"
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_CMD_DMA_BURST_ENABLE",
          "args": [
            "nvram_data"
          ],
          "line": 4297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_DATA_DMA_BURST_ENABLE",
          "args": [
            "nvram_data"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_DATA_LINE_ACTIVE_NEGATION",
          "args": [
            "nvram_data"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_REQ_ACK_ACTIVE_NEGATION",
          "args": [
            "nvram_data"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_ASYNC_DATA_SETUP_TIME",
          "args": [
            "nvram_data"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_BUS_RETRY_DELAY",
          "args": [
            "nvram_data"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_BUS_RETRY_COUNT",
          "args": [
            "nvram_data"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_BUS_RESET_DELAY",
          "args": [
            "nvram_data"
          ],
          "line": 4266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_INITIATOR_ID",
          "args": [
            "nvram_data"
          ],
          "line": 4263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_FIFO_THRESHOLD_128",
          "args": [
            "nvram_data"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_FIFO_THRESHOLD",
          "args": [
            "nvram_data"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_1020;\n\nstatic void\nisp_parse_nvram_1020(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tint i;\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\n\tsdp->isp_fifo_threshold =\n\t\tISP_NVRAM_FIFO_THRESHOLD(nvram_data) |\n\t\t(ISP_NVRAM_FIFO_THRESHOLD_128(nvram_data) << 2);\n\n\tsdp->isp_initiator_id =\n\t\tISP_NVRAM_INITIATOR_ID(nvram_data);\n\n\tsdp->isp_bus_reset_delay =\n\t\tISP_NVRAM_BUS_RESET_DELAY(nvram_data);\n\n\tsdp->isp_retry_count =\n\t\tISP_NVRAM_BUS_RETRY_COUNT(nvram_data);\n\n\tsdp->isp_retry_delay =\n\t\tISP_NVRAM_BUS_RETRY_DELAY(nvram_data);\n\n\tsdp->isp_async_data_setup =\n\t\tISP_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data);\n\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tif (sdp->isp_async_data_setup < 9) {\n\t\t\tsdp->isp_async_data_setup = 9;\n\t\t}\n\t} else {\n\t\tif (sdp->isp_async_data_setup != 6) {\n\t\t\tsdp->isp_async_data_setup = 6;\n\t\t}\n\t}\n\n\tsdp->isp_req_ack_active_neg =\n\t\tISP_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_line_active_neg =\n\t\tISP_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t\tISP_NVRAM_DATA_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t\tISP_NVRAM_CMD_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_tag_aging =\n\t\tISP_NVRAM_TAG_AGE_LIMIT(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t\tISP_NVRAM_SELECTION_TIMEOUT(nvram_data);\n\n\tsdp->isp_max_queue_depth =\n\t\tISP_NVRAM_MAX_QUEUE_DEPTH(nvram_data);\n\n\tisp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"      Data DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_data_dma_burst_enabl? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t\tPRINTF(\"                  Fast MTTR = %s\\n\",\n\t\t    isp->isp_fast_mttr? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t\tISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, i);\n\n\t\tif (isp->isp_type < ISP_HA_SCSI_1040) {\n\t\t\t/*\n\t\t\t * If we're not ultra, we can't possibly\n\t\t\t * be a shorter period than this.\n\t\t\t */\n\t\t\tif (sdp->isp_devparam[i].sync_period < 0x19) {\n\t\t\t\tsdp->isp_devparam[i].sync_period =\n\t\t\t\t    0x19;\n\t\t\t}\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0xc) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\t\t    0x0c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0x8) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset = 0x8;\n\t\t\t}\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP_NVRAM_TGT_RENEG(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP_NVRAM_TGT_QFRZ(nvram_data, i)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP_NVRAM_TGT_ARQ(nvram_data, i) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tif (ISP_NVRAM_TGT_TQING(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP_NVRAM_TGT_SYNC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP_NVRAM_TGT_WIDE(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP_NVRAM_TGT_PARITY(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP_NVRAM_TGT_DISC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0; /* we don't know */\n\t\tif (isp->isp_dblev > 2) {\n\t\t\tPRINTF(\"   Target %d: Enabled %d Throttle %d \"\n\t\t\t    \"Offset %d Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "isp_rdnvram_word",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "4180-4246",
    "snippet": "static void\nisp_rdnvram_word(isp, wo, rp)\n\tstruct ispsoftc *isp;\n\tint wo;\n\tu_int16_t *rp;\n{\n\tint i, cbits;\n\tu_int16_t bit, rqst;\n\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\tSYS_DELAY(2);\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\tSYS_DELAY(2);\n\n\tif (IS_FC(isp)) {\n\t\two &= ((ISP2100_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else if (IS_ULTRA2(isp)) {\n\t\two &= ((ISP1080_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else {\n\t\two &= ((ISP_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 6) | wo;\n\t\tcbits = 8;\n\t}\n\n\t/*\n\t * Clock the word select request out...\n\t */\n\tfor (i = cbits; i >= 0; i--) {\n\t\tif ((rqst >> i) & 1) {\n\t\t\tbit = BIU_NVRAM_SELECT | BIU_NVRAM_DATAOUT;\n\t\t} else {\n\t\t\tbit = BIU_NVRAM_SELECT;\n\t\t}\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit | BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t}\n\t/*\n\t * Now read the result back in (bits come back in MSB format).\n\t */\n\t*rp = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tu_int16_t rv;\n\t\t*rp <<= 1;\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\trv = ISP_READ(isp, BIU_NVRAM);\n\t\tif (rv & BIU_NVRAM_DATAIN) {\n\t\t\t*rp |= 1;\n\t\t}\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\t\tSYS_DELAY(2);\n\t}\n\tISP_WRITE(isp, BIU_NVRAM, 0);\n\tSYS_DELAY(2);\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t*rp = ((*rp >> 8) | ((*rp & 0xff) << 8));\n#endif\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_rdnvram_word"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "0"
          ],
          "line": 4241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "BIU_NVRAM_SELECT"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_NVRAM"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "bit"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "bit | BIU_NVRAM_CLOCK"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "bit"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ULTRA2",
          "args": [
            "isp"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 4194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "2"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_NVRAM",
            "BIU_NVRAM_SELECT"
          ],
          "line": 4189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_rdnvram_word;\n\nstatic void\nisp_rdnvram_word(isp, wo, rp)\n\tstruct ispsoftc *isp;\n\tint wo;\n\tu_int16_t *rp;\n{\n\tint i, cbits;\n\tu_int16_t bit, rqst;\n\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\tSYS_DELAY(2);\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\tSYS_DELAY(2);\n\n\tif (IS_FC(isp)) {\n\t\two &= ((ISP2100_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else if (IS_ULTRA2(isp)) {\n\t\two &= ((ISP1080_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else {\n\t\two &= ((ISP_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 6) | wo;\n\t\tcbits = 8;\n\t}\n\n\t/*\n\t * Clock the word select request out...\n\t */\n\tfor (i = cbits; i >= 0; i--) {\n\t\tif ((rqst >> i) & 1) {\n\t\t\tbit = BIU_NVRAM_SELECT | BIU_NVRAM_DATAOUT;\n\t\t} else {\n\t\t\tbit = BIU_NVRAM_SELECT;\n\t\t}\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit | BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t}\n\t/*\n\t * Now read the result back in (bits come back in MSB format).\n\t */\n\t*rp = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tu_int16_t rv;\n\t\t*rp <<= 1;\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\trv = ISP_READ(isp, BIU_NVRAM);\n\t\tif (rv & BIU_NVRAM_DATAIN) {\n\t\t\t*rp |= 1;\n\t\t}\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\t\tSYS_DELAY(2);\n\t}\n\tISP_WRITE(isp, BIU_NVRAM, 0);\n\tSYS_DELAY(2);\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t*rp = ((*rp >> 8) | ((*rp & 0xff) << 8));\n#endif\n}"
  },
  {
    "function_name": "isp_read_nvram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "4105-4178",
    "snippet": "static int\nisp_read_nvram(isp)\n\tstruct ispsoftc *isp;\n{\n\tint i, amt;\n\tu_int8_t csum, minversion;\n\tunion {\n\t\tu_int8_t _x[ISP2100_NVRAM_SIZE];\n\t\tu_int16_t _s[ISP2100_NVRAM_SIZE>>1];\n\t} _n;\n#define\tnvram_data\t_n._x\n#define\tnvram_words\t_n._s\n\n\tif (IS_FC(isp)) {\n\t\tamt = ISP2100_NVRAM_SIZE;\n\t\tminversion = 1;\n\t} else if (IS_ULTRA2(isp)) {\n\t\tamt = ISP1080_NVRAM_SIZE;\n\t\tminversion = 0;\n\t} else {\n\t\tamt = ISP_NVRAM_SIZE;\n\t\tminversion = 2;\n\t}\n\n\t/*\n\t * Just read the first two words first to see if we have a valid\n\t * NVRAM to continue reading the rest with.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tif (nvram_data[0] != 'I' || nvram_data[1] != 'S' ||\n\t    nvram_data[2] != 'P') {\n\t\tif (isp->isp_bustype != ISP_BT_SBUS) {\n\t\t\tPRINTF(\"%s: invalid NVRAM header (%x,%x,%x,%x)\\n\",\n\t\t\t    isp->isp_name, nvram_data[0], nvram_data[1],\n\t\t\t    nvram_data[2], nvram_data[3]);\n\t\t}\n\t\treturn (-1);\n\t}\n\tfor (i = 2; i < amt>>1; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tfor (csum = 0, i = 0; i < amt; i++) {\n\t\tcsum += nvram_data[i];\n\t}\n\tif (csum != 0) {\n\t\tPRINTF(\"%s: invalid NVRAM checksum\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tif (ISP_NVRAM_VERSION(nvram_data) < minversion) {\n\t\tPRINTF(\"%s: version %d NVRAM not understood\\n\", isp->isp_name,\n\t\t    ISP_NVRAM_VERSION(nvram_data));\n\t\treturn (-1);\n\t}\n\n\tif (IS_ULTRA3(isp)) {\n\t\tisp_parse_nvram_12160(isp, 0, nvram_data);\n\t\tisp_parse_nvram_12160(isp, 1, nvram_data);\n\t} else if (IS_1080(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t} else if (IS_1280(isp) || IS_1240(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t\tisp_parse_nvram_1080(isp, 1, nvram_data);\n\t} else if (IS_SCSI(isp)) {\n\t\tisp_parse_nvram_1020(isp, nvram_data);\n\t} else {\n\t\tisp_parse_nvram_2100(isp, nvram_data);\n\t}\n\tIDPRINTF(3, (\"%s: NVRAM is valid\\n\", isp->isp_name));\n\treturn (0);\n#undef\tnvram_data\n#undef\tnvram_words\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tnvram_words\t_n._s",
      "#define\tnvram_data\t_n._x"
    ],
    "globals_used": [
      "static int isp_read_nvram",
      "static void isp_rdnvram_word",
      "static void isp_parse_nvram_1020",
      "static void isp_parse_nvram_1080",
      "static void isp_parse_nvram_12160",
      "static void isp_parse_nvram_2100"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: NVRAM is valid\\n\", isp->isp_name)"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_parse_nvram_2100",
          "args": [
            "isp",
            "nvram_data"
          ],
          "line": 4172
        },
        "resolved": true,
        "details": {
          "function_name": "isp_parse_nvram_2100",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4652-4736",
          "snippet": "static void\nisp_parse_nvram_2100(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tunion {\n\t\tstruct {\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t\t\tu_int32_t hi32;\n\t\t\tu_int32_t lo32;\n#else\n\t\t\tu_int32_t lo32;\n\t\t\tu_int32_t hi32;\n#endif\n\t\t} wd;\n\t\tu_int64_t full64;\n\t} wwnstore;\n\n\twwnstore.full64 = ISP2100_NVRAM_NODE_NAME(nvram_data);\n\n\t/*\n\t * Broken PTI cards with nothing in the top nibble. Pah.\n\t */\n\tif ((wwnstore.wd.hi32 >> 28) == 0) {\n\t\twwnstore.wd.hi32 |= (2 << 28);\n\t\tCFGPRINTF(\"%s: (corrected) Adapter WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t} else {\n\t\tCFGPRINTF(\"%s: Adapter WWN 0x%08x%08x\\n\", isp->isp_name,\n\t\t    wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_nodewwn = wwnstore.full64;\n\n\t/*\n\t * If the Node WWN has 2 in the top nibble, we can\n\t * authoritatively construct a Port WWN by adding\n\t * our unit number (plus one to make it nonzero) and\n\t * putting it into bits 59..56. If the top nibble isn't\n\t * 2, then we just set them identically.\n\t */\n\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn |\n\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t} else {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn;\n\t}\n\twwnstore.full64 = ISP2100_NVRAM_BOOT_NODE_NAME(nvram_data);\n\tif (wwnstore.full64 != 0) {\n\t\tPRINTF(\"%s: BOOT DEVICE WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_maxalloc =\n\t\tISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);\n\tfcp->isp_maxfrmlen =\n\t\tISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);\n\tfcp->isp_retry_delay =\n\t\tISP2100_NVRAM_RETRY_DELAY(nvram_data);\n\tfcp->isp_retry_count =\n\t\tISP2100_NVRAM_RETRY_COUNT(nvram_data);\n\tfcp->isp_loopid =\n\t\tISP2100_NVRAM_HARDLOOPID(nvram_data);\n\tfcp->isp_execthrottle =\n\t\tISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);\n\tfcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"  Max IOCB Allocation = %d\\n\",\n\t\t    fcp->isp_maxalloc);\n\t\tPRINTF(\"     Max Frame Length = %d\\n\",\n\t\t    fcp->isp_maxfrmlen);\n\t\tPRINTF(\"   Execution Throttle = %d\\n\",\n\t\t    fcp->isp_execthrottle);\n\t\tPRINTF(\"          Retry Count = %d\\n\",\n\t\t    fcp->isp_retry_count);\n\t\tPRINTF(\"          Retry Delay = %d\\n\",\n\t\t    fcp->isp_retry_delay);\n\t\tPRINTF(\"         Hard Loop ID = %d\\n\",\n\t\t    fcp->isp_loopid);\n\t\tPRINTF(\"              Options = 0x%x\\n\",\n\t\t    fcp->isp_fwoptions);\n\t\tPRINTF(\"          HBA Options = 0x%x\\n\",\n\t\t    ISP2100_NVRAM_HBA_OPTIONS(nvram_data));\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tnvram_data\t_n._x"
          ],
          "globals_used": [
            "static void isp_parse_nvram_2100"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_2100;\n\nstatic void\nisp_parse_nvram_2100(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tunion {\n\t\tstruct {\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t\t\tu_int32_t hi32;\n\t\t\tu_int32_t lo32;\n#else\n\t\t\tu_int32_t lo32;\n\t\t\tu_int32_t hi32;\n#endif\n\t\t} wd;\n\t\tu_int64_t full64;\n\t} wwnstore;\n\n\twwnstore.full64 = ISP2100_NVRAM_NODE_NAME(nvram_data);\n\n\t/*\n\t * Broken PTI cards with nothing in the top nibble. Pah.\n\t */\n\tif ((wwnstore.wd.hi32 >> 28) == 0) {\n\t\twwnstore.wd.hi32 |= (2 << 28);\n\t\tCFGPRINTF(\"%s: (corrected) Adapter WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t} else {\n\t\tCFGPRINTF(\"%s: Adapter WWN 0x%08x%08x\\n\", isp->isp_name,\n\t\t    wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_nodewwn = wwnstore.full64;\n\n\t/*\n\t * If the Node WWN has 2 in the top nibble, we can\n\t * authoritatively construct a Port WWN by adding\n\t * our unit number (plus one to make it nonzero) and\n\t * putting it into bits 59..56. If the top nibble isn't\n\t * 2, then we just set them identically.\n\t */\n\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn |\n\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t} else {\n\t\tfcp->isp_portwwn = fcp->isp_nodewwn;\n\t}\n\twwnstore.full64 = ISP2100_NVRAM_BOOT_NODE_NAME(nvram_data);\n\tif (wwnstore.full64 != 0) {\n\t\tPRINTF(\"%s: BOOT DEVICE WWN 0x%08x%08x\\n\",\n\t\t    isp->isp_name, wwnstore.wd.hi32, wwnstore.wd.lo32);\n\t}\n\tfcp->isp_maxalloc =\n\t\tISP2100_NVRAM_MAXIOCBALLOCATION(nvram_data);\n\tfcp->isp_maxfrmlen =\n\t\tISP2100_NVRAM_MAXFRAMELENGTH(nvram_data);\n\tfcp->isp_retry_delay =\n\t\tISP2100_NVRAM_RETRY_DELAY(nvram_data);\n\tfcp->isp_retry_count =\n\t\tISP2100_NVRAM_RETRY_COUNT(nvram_data);\n\tfcp->isp_loopid =\n\t\tISP2100_NVRAM_HARDLOOPID(nvram_data);\n\tfcp->isp_execthrottle =\n\t\tISP2100_NVRAM_EXECUTION_THROTTLE(nvram_data);\n\tfcp->isp_fwoptions = ISP2100_NVRAM_OPTIONS(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"  Max IOCB Allocation = %d\\n\",\n\t\t    fcp->isp_maxalloc);\n\t\tPRINTF(\"     Max Frame Length = %d\\n\",\n\t\t    fcp->isp_maxfrmlen);\n\t\tPRINTF(\"   Execution Throttle = %d\\n\",\n\t\t    fcp->isp_execthrottle);\n\t\tPRINTF(\"          Retry Count = %d\\n\",\n\t\t    fcp->isp_retry_count);\n\t\tPRINTF(\"          Retry Delay = %d\\n\",\n\t\t    fcp->isp_retry_delay);\n\t\tPRINTF(\"         Hard Loop ID = %d\\n\",\n\t\t    fcp->isp_loopid);\n\t\tPRINTF(\"              Options = 0x%x\\n\",\n\t\t    fcp->isp_fwoptions);\n\t\tPRINTF(\"          HBA Options = 0x%x\\n\",\n\t\t    ISP2100_NVRAM_HBA_OPTIONS(nvram_data));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_parse_nvram_1020",
          "args": [
            "isp",
            "nvram_data"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "isp_parse_nvram_1020",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4248-4399",
          "snippet": "static void\nisp_parse_nvram_1020(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tint i;\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\n\tsdp->isp_fifo_threshold =\n\t\tISP_NVRAM_FIFO_THRESHOLD(nvram_data) |\n\t\t(ISP_NVRAM_FIFO_THRESHOLD_128(nvram_data) << 2);\n\n\tsdp->isp_initiator_id =\n\t\tISP_NVRAM_INITIATOR_ID(nvram_data);\n\n\tsdp->isp_bus_reset_delay =\n\t\tISP_NVRAM_BUS_RESET_DELAY(nvram_data);\n\n\tsdp->isp_retry_count =\n\t\tISP_NVRAM_BUS_RETRY_COUNT(nvram_data);\n\n\tsdp->isp_retry_delay =\n\t\tISP_NVRAM_BUS_RETRY_DELAY(nvram_data);\n\n\tsdp->isp_async_data_setup =\n\t\tISP_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data);\n\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tif (sdp->isp_async_data_setup < 9) {\n\t\t\tsdp->isp_async_data_setup = 9;\n\t\t}\n\t} else {\n\t\tif (sdp->isp_async_data_setup != 6) {\n\t\t\tsdp->isp_async_data_setup = 6;\n\t\t}\n\t}\n\n\tsdp->isp_req_ack_active_neg =\n\t\tISP_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_line_active_neg =\n\t\tISP_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t\tISP_NVRAM_DATA_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t\tISP_NVRAM_CMD_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_tag_aging =\n\t\tISP_NVRAM_TAG_AGE_LIMIT(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t\tISP_NVRAM_SELECTION_TIMEOUT(nvram_data);\n\n\tsdp->isp_max_queue_depth =\n\t\tISP_NVRAM_MAX_QUEUE_DEPTH(nvram_data);\n\n\tisp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"      Data DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_data_dma_burst_enabl? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t\tPRINTF(\"                  Fast MTTR = %s\\n\",\n\t\t    isp->isp_fast_mttr? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t\tISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, i);\n\n\t\tif (isp->isp_type < ISP_HA_SCSI_1040) {\n\t\t\t/*\n\t\t\t * If we're not ultra, we can't possibly\n\t\t\t * be a shorter period than this.\n\t\t\t */\n\t\t\tif (sdp->isp_devparam[i].sync_period < 0x19) {\n\t\t\t\tsdp->isp_devparam[i].sync_period =\n\t\t\t\t    0x19;\n\t\t\t}\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0xc) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\t\t    0x0c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0x8) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset = 0x8;\n\t\t\t}\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP_NVRAM_TGT_RENEG(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP_NVRAM_TGT_QFRZ(nvram_data, i)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP_NVRAM_TGT_ARQ(nvram_data, i) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tif (ISP_NVRAM_TGT_TQING(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP_NVRAM_TGT_SYNC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP_NVRAM_TGT_WIDE(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP_NVRAM_TGT_PARITY(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP_NVRAM_TGT_DISC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0; /* we don't know */\n\t\tif (isp->isp_dblev > 2) {\n\t\t\tPRINTF(\"   Target %d: Enabled %d Throttle %d \"\n\t\t\t    \"Offset %d Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tnvram_data\t_n._x"
          ],
          "globals_used": [
            "static void isp_parse_nvram_1020"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_1020;\n\nstatic void\nisp_parse_nvram_1020(isp, nvram_data)\n\tstruct ispsoftc *isp;\n\tu_int8_t *nvram_data;\n{\n\tint i;\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\n\tsdp->isp_fifo_threshold =\n\t\tISP_NVRAM_FIFO_THRESHOLD(nvram_data) |\n\t\t(ISP_NVRAM_FIFO_THRESHOLD_128(nvram_data) << 2);\n\n\tsdp->isp_initiator_id =\n\t\tISP_NVRAM_INITIATOR_ID(nvram_data);\n\n\tsdp->isp_bus_reset_delay =\n\t\tISP_NVRAM_BUS_RESET_DELAY(nvram_data);\n\n\tsdp->isp_retry_count =\n\t\tISP_NVRAM_BUS_RETRY_COUNT(nvram_data);\n\n\tsdp->isp_retry_delay =\n\t\tISP_NVRAM_BUS_RETRY_DELAY(nvram_data);\n\n\tsdp->isp_async_data_setup =\n\t\tISP_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data);\n\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tif (sdp->isp_async_data_setup < 9) {\n\t\t\tsdp->isp_async_data_setup = 9;\n\t\t}\n\t} else {\n\t\tif (sdp->isp_async_data_setup != 6) {\n\t\t\tsdp->isp_async_data_setup = 6;\n\t\t}\n\t}\n\n\tsdp->isp_req_ack_active_neg =\n\t\tISP_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_line_active_neg =\n\t\tISP_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t\tISP_NVRAM_DATA_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t\tISP_NVRAM_CMD_DMA_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_tag_aging =\n\t\tISP_NVRAM_TAG_AGE_LIMIT(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t\tISP_NVRAM_SELECTION_TIMEOUT(nvram_data);\n\n\tsdp->isp_max_queue_depth =\n\t\tISP_NVRAM_MAX_QUEUE_DEPTH(nvram_data);\n\n\tisp->isp_fast_mttr = ISP_NVRAM_FAST_MTTR_ENABLE(nvram_data);\n\tif (isp->isp_dblev > 2) {\n\t\tPRINTF(\"%s: NVRAM values:\\n\", isp->isp_name);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"      Data DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_data_dma_burst_enabl? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t\tPRINTF(\"                  Fast MTTR = %s\\n\",\n\t\t    isp->isp_fast_mttr? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t\tISP_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP_NVRAM_TGT_SYNC_OFFSET(nvram_data, i);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP_NVRAM_TGT_SYNC_PERIOD(nvram_data, i);\n\n\t\tif (isp->isp_type < ISP_HA_SCSI_1040) {\n\t\t\t/*\n\t\t\t * If we're not ultra, we can't possibly\n\t\t\t * be a shorter period than this.\n\t\t\t */\n\t\t\tif (sdp->isp_devparam[i].sync_period < 0x19) {\n\t\t\t\tsdp->isp_devparam[i].sync_period =\n\t\t\t\t    0x19;\n\t\t\t}\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0xc) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\t\t    0x0c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sdp->isp_devparam[i].sync_offset > 0x8) {\n\t\t\t\tsdp->isp_devparam[i].sync_offset = 0x8;\n\t\t\t}\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP_NVRAM_TGT_RENEG(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP_NVRAM_TGT_QFRZ(nvram_data, i)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP_NVRAM_TGT_ARQ(nvram_data, i) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, i);\n\t\t}\n\t\tif (ISP_NVRAM_TGT_TQING(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP_NVRAM_TGT_SYNC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP_NVRAM_TGT_WIDE(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP_NVRAM_TGT_PARITY(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP_NVRAM_TGT_DISC(nvram_data, i))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0; /* we don't know */\n\t\tif (isp->isp_dblev > 2) {\n\t\t\tPRINTF(\"   Target %d: Enabled %d Throttle %d \"\n\t\t\t    \"Offset %d Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 4169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_parse_nvram_1080",
          "args": [
            "isp",
            "1",
            "nvram_data"
          ],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "isp_parse_nvram_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4401-4525",
          "snippet": "static void\nisp_parse_nvram_1080(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tint i;\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold = \n\t    ISP1080_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id =\n\t    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP1080_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP1080_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP1080_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP1080_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP1080_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP1080 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP1080_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP1080_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP1080_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP1080_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP1080_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP1080_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP1080_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP1080_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle \"\n\t\t\t    \"%d Offset %d Period %d Flags \"\n\t\t\t    \"0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tnvram_data\t_n._x"
          ],
          "globals_used": [
            "static void isp_parse_nvram_1080"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_1080;\n\nstatic void\nisp_parse_nvram_1080(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tint i;\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold = \n\t    ISP1080_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id =\n\t    ISP1080_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP1080_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP1080_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP1080_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP1080_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP1080_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP1080_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP1080_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP1080_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP1080_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP1080 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP1080_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP1080_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP1080_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP1080_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP1080_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP1080_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP1080_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\",\n\t\t\t    isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP1080_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP1080_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP1080_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP1080_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP1080_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle \"\n\t\t\t    \"%d Offset %d Period %d Flags \"\n\t\t\t    \"0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_1240",
          "args": [
            "isp"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_1280",
          "args": [
            "isp"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_1080",
          "args": [
            "isp"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_parse_nvram_12160",
          "args": [
            "isp",
            "1",
            "nvram_data"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "isp_parse_nvram_12160",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4527-4650",
          "snippet": "static void\nisp_parse_nvram_12160(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tint i;\n\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold =\n\t    ISP12160_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id = \n\t    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP12160_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP12160_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP12160_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP12160_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP12160_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP12160 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP12160_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP12160_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP12160_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP12160_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP12160_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP12160_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP12160_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP12160_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle %d Offset %d \"\n\t\t\t    \"Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tnvram_data\t_n._x"
          ],
          "globals_used": [
            "static void isp_parse_nvram_12160"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_data\t_n._x\n\nstatic void isp_parse_nvram_12160;\n\nstatic void\nisp_parse_nvram_12160(isp, bus, nvram_data)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tu_int8_t *nvram_data;\n{\n\tstatic char *tru = \"true\";\n\tstatic char *not = \"false\";\n\tsdparam *sdp = (sdparam *) isp->isp_param;\n\tint i;\n\n\tsdp += bus;\n\n\tsdp->isp_fifo_threshold =\n\t    ISP12160_NVRAM_FIFO_THRESHOLD(nvram_data);\n\n\tsdp->isp_initiator_id = \n\t    ISP12160_NVRAM_INITIATOR_ID(nvram_data, bus);\n\n\tsdp->isp_bus_reset_delay =\n\t    ISP12160_NVRAM_BUS_RESET_DELAY(nvram_data, bus);\n\n\tsdp->isp_retry_count =\n\t    ISP12160_NVRAM_BUS_RETRY_COUNT(nvram_data, bus);\n\n\tsdp->isp_retry_delay =\n\t    ISP12160_NVRAM_BUS_RETRY_DELAY(nvram_data, bus);\n\n\tsdp->isp_async_data_setup =\n\t    ISP12160_NVRAM_ASYNC_DATA_SETUP_TIME(nvram_data,\n\t    bus);\n\n\tsdp->isp_req_ack_active_neg =\n\t    ISP12160_NVRAM_REQ_ACK_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_line_active_neg =\n\t    ISP12160_NVRAM_DATA_LINE_ACTIVE_NEGATION(nvram_data,\n\t    bus);\n\n\tsdp->isp_data_dma_burst_enabl =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_cmd_dma_burst_enable =\n\t    ISP12160_NVRAM_BURST_ENABLE(nvram_data);\n\n\tsdp->isp_selection_timeout =\n\t    ISP12160_NVRAM_SELECTION_TIMEOUT(nvram_data, bus);\n\n\tsdp->isp_max_queue_depth =\n\t     ISP12160_NVRAM_MAX_QUEUE_DEPTH(nvram_data, bus);\n\n\tif (isp->isp_dblev >= 3) {\n\t\tPRINTF(\"%s: ISP12160 bus %d NVRAM values:\\n\",\n\t\t    isp->isp_name, bus);\n\t\tPRINTF(\"               Initiator ID = %d\\n\",\n\t\t    sdp->isp_initiator_id);\n\t\tPRINTF(\"             Fifo Threshold = 0x%x\\n\",\n\t\t    sdp->isp_fifo_threshold);\n\t\tPRINTF(\"            Bus Reset Delay = %d\\n\",\n\t\t    sdp->isp_bus_reset_delay);\n\t\tPRINTF(\"                Retry Count = %d\\n\",\n\t\t    sdp->isp_retry_count);\n\t\tPRINTF(\"                Retry Delay = %d\\n\",\n\t\t    sdp->isp_retry_delay);\n\t\tPRINTF(\"              Tag Age Limit = %d\\n\",\n\t\t    sdp->isp_tag_aging);\n\t\tPRINTF(\"          Selection Timeout = %d\\n\",\n\t\t    sdp->isp_selection_timeout);\n\t\tPRINTF(\"            Max Queue Depth = %d\\n\",\n\t\t    sdp->isp_max_queue_depth);\n\t\tPRINTF(\"           Async Data Setup = 0x%x\\n\",\n\t\t    sdp->isp_async_data_setup);\n\t\tPRINTF(\"    REQ/ACK Active Negation = %s\\n\",\n\t\t    sdp->isp_req_ack_active_neg? tru : not);\n\t\tPRINTF(\"  Data Line Active Negation = %s\\n\",\n\t\t    sdp->isp_data_line_active_neg? tru : not);\n\t\tPRINTF(\"       Cmd DMA Burst Enable = %s\\n\",\n\t\t    sdp->isp_cmd_dma_burst_enable? tru : not);\n\t}\n\n\tfor (i = 0; i < MAX_TARGETS; i++) {\n\t\tsdp->isp_devparam[i].dev_enable =\n\t\t    ISP12160_NVRAM_TGT_DEVICE_ENABLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].exc_throttle =\n\t\t\tISP12160_NVRAM_TGT_EXEC_THROTTLE(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_offset =\n\t\t\tISP12160_NVRAM_TGT_SYNC_OFFSET(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].sync_period =\n\t\t\tISP12160_NVRAM_TGT_SYNC_PERIOD(nvram_data, i, bus);\n\t\tsdp->isp_devparam[i].dev_flags = 0;\n\t\tif (ISP12160_NVRAM_TGT_RENEG(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_RENEG;\n\t\tif (ISP12160_NVRAM_TGT_QFRZ(nvram_data, i, bus)) {\n\t\t\tPRINTF(\"%s: not supporting QFRZ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tsdp->isp_devparam[i].dev_flags |= DPARM_ARQ;\n\t\tif (ISP12160_NVRAM_TGT_ARQ(nvram_data, i, bus) == 0) {\n\t\t\tPRINTF(\"%s: not disabling ARQ option \"\n\t\t\t    \"for target %d bus %d\\n\", isp->isp_name, i, bus);\n\t\t}\n\t\tif (ISP12160_NVRAM_TGT_TQING(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_TQING;\n\t\tif (ISP12160_NVRAM_TGT_SYNC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_SYNC;\n\t\tif (ISP12160_NVRAM_TGT_WIDE(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_WIDE;\n\t\tif (ISP12160_NVRAM_TGT_PARITY(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_PARITY;\n\t\tif (ISP12160_NVRAM_TGT_DISC(nvram_data, i, bus))\n\t\t\tsdp->isp_devparam[i].dev_flags |= DPARM_DISC;\n\t\tsdp->isp_devparam[i].cur_dflags = 0;\n\t\tif (isp->isp_dblev >= 3) {\n\t\t\tPRINTF(\"   Target %d: Ena %d Throttle %d Offset %d \"\n\t\t\t    \"Period %d Flags 0x%x\\n\", i,\n\t\t\t    sdp->isp_devparam[i].dev_enable,\n\t\t\t    sdp->isp_devparam[i].exc_throttle,\n\t\t\t    sdp->isp_devparam[i].sync_offset,\n\t\t\t    sdp->isp_devparam[i].sync_period,\n\t\t\t    sdp->isp_devparam[i].dev_flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ULTRA3",
          "args": [
            "isp"
          ],
          "line": 4161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: version %d NVRAM not understood\\n\"",
            "isp->isp_name",
            "ISP_NVRAM_VERSION(nvram_data)"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_VERSION",
          "args": [
            "nvram_data"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NVRAM_VERSION",
          "args": [
            "nvram_data"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: invalid NVRAM checksum\\n\"",
            "isp->isp_name"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_rdnvram_word",
          "args": [
            "isp",
            "i",
            "&nvram_words[i]"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "isp_rdnvram_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4180-4246",
          "snippet": "static void\nisp_rdnvram_word(isp, wo, rp)\n\tstruct ispsoftc *isp;\n\tint wo;\n\tu_int16_t *rp;\n{\n\tint i, cbits;\n\tu_int16_t bit, rqst;\n\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\tSYS_DELAY(2);\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\tSYS_DELAY(2);\n\n\tif (IS_FC(isp)) {\n\t\two &= ((ISP2100_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else if (IS_ULTRA2(isp)) {\n\t\two &= ((ISP1080_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else {\n\t\two &= ((ISP_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 6) | wo;\n\t\tcbits = 8;\n\t}\n\n\t/*\n\t * Clock the word select request out...\n\t */\n\tfor (i = cbits; i >= 0; i--) {\n\t\tif ((rqst >> i) & 1) {\n\t\t\tbit = BIU_NVRAM_SELECT | BIU_NVRAM_DATAOUT;\n\t\t} else {\n\t\t\tbit = BIU_NVRAM_SELECT;\n\t\t}\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit | BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t}\n\t/*\n\t * Now read the result back in (bits come back in MSB format).\n\t */\n\t*rp = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tu_int16_t rv;\n\t\t*rp <<= 1;\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\trv = ISP_READ(isp, BIU_NVRAM);\n\t\tif (rv & BIU_NVRAM_DATAIN) {\n\t\t\t*rp |= 1;\n\t\t}\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\t\tSYS_DELAY(2);\n\t}\n\tISP_WRITE(isp, BIU_NVRAM, 0);\n\tSYS_DELAY(2);\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t*rp = ((*rp >> 8) | ((*rp & 0xff) << 8));\n#endif\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_rdnvram_word"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_rdnvram_word;\n\nstatic void\nisp_rdnvram_word(isp, wo, rp)\n\tstruct ispsoftc *isp;\n\tint wo;\n\tu_int16_t *rp;\n{\n\tint i, cbits;\n\tu_int16_t bit, rqst;\n\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\tSYS_DELAY(2);\n\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\tSYS_DELAY(2);\n\n\tif (IS_FC(isp)) {\n\t\two &= ((ISP2100_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else if (IS_ULTRA2(isp)) {\n\t\two &= ((ISP1080_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 8) | wo;\n\t\tcbits = 10;\n\t} else {\n\t\two &= ((ISP_NVRAM_SIZE >> 1) - 1);\n\t\trqst = (ISP_NVRAM_READ << 6) | wo;\n\t\tcbits = 8;\n\t}\n\n\t/*\n\t * Clock the word select request out...\n\t */\n\tfor (i = cbits; i >= 0; i--) {\n\t\tif ((rqst >> i) & 1) {\n\t\t\tbit = BIU_NVRAM_SELECT | BIU_NVRAM_DATAOUT;\n\t\t} else {\n\t\t\tbit = BIU_NVRAM_SELECT;\n\t\t}\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit | BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, bit);\n\t\tSYS_DELAY(2);\n\t}\n\t/*\n\t * Now read the result back in (bits come back in MSB format).\n\t */\n\t*rp = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tu_int16_t rv;\n\t\t*rp <<= 1;\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT|BIU_NVRAM_CLOCK);\n\t\tSYS_DELAY(2);\n\t\trv = ISP_READ(isp, BIU_NVRAM);\n\t\tif (rv & BIU_NVRAM_DATAIN) {\n\t\t\t*rp |= 1;\n\t\t}\n\t\tSYS_DELAY(2);\n\t\tISP_WRITE(isp, BIU_NVRAM, BIU_NVRAM_SELECT);\n\t\tSYS_DELAY(2);\n\t}\n\tISP_WRITE(isp, BIU_NVRAM, 0);\n\tSYS_DELAY(2);\n#if\tBYTE_ORDER == BIG_ENDIAN\n\t*rp = ((*rp >> 8) | ((*rp & 0xff) << 8));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: invalid NVRAM header (%x,%x,%x,%x)\\n\"",
            "isp->isp_name",
            "nvram_data[0]",
            "nvram_data[1]",
            "nvram_data[2]",
            "nvram_data[3]"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ULTRA2",
          "args": [
            "isp"
          ],
          "line": 4121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_words\t_n._s\n#define\tnvram_data\t_n._x\n\nstatic int isp_read_nvram;\nstatic void isp_rdnvram_word;\nstatic void isp_parse_nvram_1020;\nstatic void isp_parse_nvram_1080;\nstatic void isp_parse_nvram_12160;\nstatic void isp_parse_nvram_2100;\n\nstatic int\nisp_read_nvram(isp)\n\tstruct ispsoftc *isp;\n{\n\tint i, amt;\n\tu_int8_t csum, minversion;\n\tunion {\n\t\tu_int8_t _x[ISP2100_NVRAM_SIZE];\n\t\tu_int16_t _s[ISP2100_NVRAM_SIZE>>1];\n\t} _n;\n#define\tnvram_data\t_n._x\n#define\tnvram_words\t_n._s\n\n\tif (IS_FC(isp)) {\n\t\tamt = ISP2100_NVRAM_SIZE;\n\t\tminversion = 1;\n\t} else if (IS_ULTRA2(isp)) {\n\t\tamt = ISP1080_NVRAM_SIZE;\n\t\tminversion = 0;\n\t} else {\n\t\tamt = ISP_NVRAM_SIZE;\n\t\tminversion = 2;\n\t}\n\n\t/*\n\t * Just read the first two words first to see if we have a valid\n\t * NVRAM to continue reading the rest with.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tif (nvram_data[0] != 'I' || nvram_data[1] != 'S' ||\n\t    nvram_data[2] != 'P') {\n\t\tif (isp->isp_bustype != ISP_BT_SBUS) {\n\t\t\tPRINTF(\"%s: invalid NVRAM header (%x,%x,%x,%x)\\n\",\n\t\t\t    isp->isp_name, nvram_data[0], nvram_data[1],\n\t\t\t    nvram_data[2], nvram_data[3]);\n\t\t}\n\t\treturn (-1);\n\t}\n\tfor (i = 2; i < amt>>1; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tfor (csum = 0, i = 0; i < amt; i++) {\n\t\tcsum += nvram_data[i];\n\t}\n\tif (csum != 0) {\n\t\tPRINTF(\"%s: invalid NVRAM checksum\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tif (ISP_NVRAM_VERSION(nvram_data) < minversion) {\n\t\tPRINTF(\"%s: version %d NVRAM not understood\\n\", isp->isp_name,\n\t\t    ISP_NVRAM_VERSION(nvram_data));\n\t\treturn (-1);\n\t}\n\n\tif (IS_ULTRA3(isp)) {\n\t\tisp_parse_nvram_12160(isp, 0, nvram_data);\n\t\tisp_parse_nvram_12160(isp, 1, nvram_data);\n\t} else if (IS_1080(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t} else if (IS_1280(isp) || IS_1240(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t\tisp_parse_nvram_1080(isp, 1, nvram_data);\n\t} else if (IS_SCSI(isp)) {\n\t\tisp_parse_nvram_1020(isp, nvram_data);\n\t} else {\n\t\tisp_parse_nvram_2100(isp, nvram_data);\n\t}\n\tIDPRINTF(3, (\"%s: NVRAM is valid\\n\", isp->isp_name));\n\treturn (0);\n#undef\tnvram_data\n#undef\tnvram_words\n}"
  },
  {
    "function_name": "isp_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "4063-4100",
    "snippet": "void\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XS_CMD_DONE",
          "args": [
            "xs"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BUSRESET"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_XFRLEN",
          "args": [
            "xs"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_DMAFREE",
          "args": [
            "isp",
            "xs",
            "handle"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_XFRLEN",
          "args": [
            "xs"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_destroy_handle",
          "args": [
            "isp",
            "handle"
          ],
          "line": 4090
        },
        "resolved": true,
        "details": {
          "function_name": "isp_destroy_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "237-245",
          "snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_find_xs",
          "args": [
            "isp",
            "handle"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "isp_find_xs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "209-219",
          "snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_restart cannot restart ISP\\n\"",
            "isp->isp_name"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_init",
          "args": [
            "isp"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "isp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "647-664",
          "snippet": "void\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_scsi_init",
            "static void isp_fibre_init",
            "static void isp_setdfltparm"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_init;\nstatic void isp_fibre_init;\nstatic void isp_setdfltparm;\n\nvoid\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_reset",
          "args": [
            "isp"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "isp_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "111-639",
          "snippet": "void\nisp_reset(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tint loops, i, dodnld = 1;\n\tchar *revname;\n\n\tisp->isp_state = ISP_NILSTATE;\n\n\t/*\n\t * Basic types (SCSI, FibreChannel and PCI or SBus)\n\t * have been set in the MD code. We figure out more\n\t * here.\n\t */\n\tisp->isp_dblev = DFLT_DBLEVEL;\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\t/*\n\t * Get the current running firmware revision out of the\n\t * chip before we hit it over the head (if this is our\n\t * first time through). Note that we store this as the\n\t * 'ROM' firmware revision- which it may not be. In any\n\t * case, we don't really use this yet, but we may in\n\t * the future.\n\t */\n\tif (isp->isp_touched == 0) {\n\t\t/*\n\t\t * Just in case it was paused...\n\t\t */\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\t/*\n\t\t * If this fails, it probably means we're running\n\t\t * an old prom, if anything at all...\n\t\t */\n\t\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\t\tisp->isp_romfw_rev[0] = mbs.param[1];\n\t\t\tisp->isp_romfw_rev[1] = mbs.param[2];\n\t\t\tisp->isp_romfw_rev[2] = mbs.param[3];\n\t\t}\n\t\tisp->isp_touched = 1;\n\t}\n\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Put the board into PAUSE mode (so we can read the SXP registers).\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\n\tif (IS_FC(isp)) {\n\t\trevname = \"2X00\";\n\t\tswitch (isp->isp_type) {\n\t\tcase ISP_HA_FC_2100:\n\t\t\trevname[1] = '1';\n\t\t\tbreak;\n\t\tcase ISP_HA_FC_2200:\n\t\t\trevname[1] = '2';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_1240(isp)) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\trevname = \"1240\";\n\t\tisp->isp_clock = 60;\n\t\tsdp->isp_ultramode = 1;\n\t\tsdp++;\n\t\tsdp->isp_ultramode = 1;\n\t\t/*\n\t\t * XXX: Should probably do some bus sensing.\n\t\t */\n\t} else if (IS_ULTRA2(isp)) {\n\t\tstatic char *m = \"%s: bus %d is in %s Mode\\n\";\n\t\tu_int16_t l;\n\t\tsdparam *sdp = isp->isp_param;\n\n\t\tisp->isp_clock = 100;\n\n\t\tif (IS_1280(isp))\n\t\t\trevname = \"1280\";\n\t\telse if (IS_1080(isp))\n\t\t\trevname = \"1080\";\n\t\telse if (IS_12160(isp))\n\t\t\trevname = \"12160\";\n\t\telse\n\t\t\trevname = \"<UNKLVD>\";\n\n\t\tl = ISP_READ(isp, SXP_PINS_DIFF) & ISP1080_MODE_MASK;\n\t\tswitch (l) {\n\t\tcase ISP1080_LVD_MODE:\n\t\t\tsdp->isp_lvdmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"LVD\");\n\t\t\tbreak;\n\t\tcase ISP1080_HVD_MODE:\n\t\t\tsdp->isp_diffmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Differential\");\n\t\t\tbreak;\n\t\tcase ISP1080_SE_MODE:\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Single-Ended\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t    isp->isp_name, 0, l);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tsdp++;\n\t\t\tl = ISP_READ(isp, SXP_PINS_DIFF|SXP_BANK1_SELECT);\n\t\t\tl &= ISP1080_MODE_MASK;\n\t\t\tswitch(l) {\n\t\t\tcase ISP1080_LVD_MODE:\n\t\t\t\tsdp->isp_lvdmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"LVD\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_HVD_MODE:\n\t\t\t\tsdp->isp_diffmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Differential\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_SE_MODE:\n\t\t\t\tsdp->isp_ultramode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Single-Ended\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, 1, l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\ti = ISP_READ(isp, BIU_CONF0) & BIU_CONF0_HW_MASK;\n\t\tswitch (i) {\n\t\tdefault:\n\t\t\tPRINTF(\"%s: unknown chip rev. 0x%x- assuming a 1020\\n\",\n\t\t\t    isp->isp_name, i);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\trevname = \"1020\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/*\n\t\t\t * Some 1020A chips are Ultra Capable, but don't\n\t\t\t * run the clock rate up for that unless told to\n\t\t\t * do so by the Ultra Capable bits being set.\n\t\t\t */\n\t\t\trevname = \"1020A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020A;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trevname = \"1040\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trevname = \"1040A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040A;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevname = \"1040B\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040B;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 6: \n\t\t\trevname = \"1040C\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040C;\n\t\t\tisp->isp_clock = 60;\n                        break; \n\t\t}\n\t\t/*\n\t\t * Now, while we're at it, gather info about ultra\n\t\t * and/or differential mode.\n\t\t */\n\t\tif (ISP_READ(isp, SXP_PINS_DIFF) & SXP_PINS_DIFF_MODE) {\n\t\t\tCFGPRINTF(\"%s: Differential Mode\\n\", isp->isp_name);\n\t\t\tsdp->isp_diffmode = 1;\n\t\t} else {\n\t\t\tsdp->isp_diffmode = 0;\n\t\t}\n\t\ti = ISP_READ(isp, RISC_PSR);\n\t\tif (isp->isp_bustype == ISP_BT_SBUS) {\n\t\t\ti &= RISC_PSR_SBUS_ULTRA;\n\t\t} else {\n\t\t\ti &= RISC_PSR_PCI_ULTRA;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tCFGPRINTF(\"%s: Ultra Mode Capable\\n\", isp->isp_name);\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\t/*\n\t\t\t * If we're in Ultra Mode, we have to be 60Mhz clock-\n\t\t\t * even for the SBus version.\n\t\t\t */\n\t\t\tisp->isp_clock = 60;\n\t\t} else {\n\t\t\tsdp->isp_ultramode = 0;\n\t\t\t/*\n\t\t\t * Clock is known. Gronk.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Machine dependent clock (if set) overrides\n\t\t * our generic determinations.\n\t\t */\n\t\tif (isp->isp_mdvec->dv_clock) {\n\t\t\tif (isp->isp_mdvec->dv_clock < isp->isp_clock) {\n\t\t\t\tisp->isp_clock = isp->isp_mdvec->dv_clock;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * Do MD specific pre initialization\n\t */\n\tISP_RESET0(isp);\n\nagain:\n\n\t/*\n\t * Hit the chip over the head with hammer,\n\t * and give the ISP a chance to recover.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n#if\t0\n\t\tPRINTF(\"%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t    isp->isp_name, ISP_READ(isp, OUTMAILBOX0),\n\t\t    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2),\n\t\t    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4),\n\t\t    ISP_READ(isp, OUTMAILBOX5));\n#endif\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\t\tISP_WRITE(isp, DDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\n\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, TDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, RDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t}\n\n\t/*\n\t * Wait for ISP to be ready to go...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!(ISP_READ(isp, BIU2100_CSR) & BIU2100_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tisp_dumpregs(isp, \"chip reset timed out\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_CONF1, 0);\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, 0);\n\t}\n\n\t/*\n\t * Reset RISC Processor\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RESET);\n\tSYS_DELAY(100);\n\n\t/*\n\t * Establish some initial burst rate stuff.\n\t * (only for the 1XX0 boards). This really should\n\t * be done later after fetching from NVRAM.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tu_int16_t tmp = isp->isp_mdvec->dv_conf1;\n\t\t/*\n\t\t * Busted FIFO. Turn off all but burst enables.\n\t\t */\n\t\tif (isp->isp_type == ISP_HA_SCSI_1040A) {\n\t\t\ttmp &= BIU_BURST_ENABLE;\n\t\t}\n\t\tISP_SETBITS(isp, BIU_CONF1, tmp);\n\t\tif (tmp & BIU_BURST_ENABLE) {\n\t\t\tISP_SETBITS(isp, CDMA_CONF, DMA_ENABLE_BURST);\n\t\t\tISP_SETBITS(isp, DDMA_CONF, DMA_ENABLE_BURST);\n\t\t}\n#ifdef\tPTI_CARDS\n\t\tif (((sdparam *) isp->isp_param)->isp_ultramode) {\n\t\t\twhile (ISP_READ(isp, RISC_MTR) != 0x1313) {\n\t\t\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_STEP);\n\t\t\t}\n\t\t} else {\n\t\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n\t\t}\n\t\t/*\n\t\t * PTI specific register\n\t\t */\n\t\tISP_WRITE(isp, RISC_EMB, DUAL_BANK)\n#else\n\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n#endif\n\t} else {\n\t\tISP_WRITE(isp, RISC_MTR2100, 0x1212);\n\t}\n\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE); /* release paused processor */\n\n\t/*\n\t * Do MD specific post initialization\n\t */\n\tISP_RESET1(isp);\n\n\t/*\n\t * Wait for everything to finish firing up...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\twhile (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: MBOX_BUSY never cleared on reset\\n\",\n\t\t\t    isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Up until this point we've done everything by just reading or\n\t * setting registers. From this point on we rely on at least *some*\n\t * kind of firmware running in the card.\n\t */\n\n\t/*\n\t * Do some sanity checking.\n\t */\n\tmbs.param[0] = MBOX_NO_OP;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"NOP test failed\");\n\t\treturn;\n\t}\n\n\tif (IS_SCSI(isp)) {\n\t\tmbs.param[0] = MBOX_MAILBOX_REG_TEST;\n\t\tmbs.param[1] = 0xdead;\n\t\tmbs.param[2] = 0xbeef;\n\t\tmbs.param[3] = 0xffff;\n\t\tmbs.param[4] = 0x1111;\n\t\tmbs.param[5] = 0xa5a5;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp,\n\t\t\t\t\"Mailbox Register test didn't complete\");\n\t\t\treturn;\n\t\t}\n\t\tif (mbs.param[1] != 0xdead || mbs.param[2] != 0xbeef ||\n\t\t    mbs.param[3] != 0xffff || mbs.param[4] != 0x1111 ||\n\t\t    mbs.param[5] != 0xa5a5) {\n\t\t\tisp_dumpregs(isp, \"Register Test Failed\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\t/*\n\t * Download new Firmware, unless requested not to do so.\n\t * This is made slightly trickier in some cases where the\n\t * firmware of the ROM revision is newer than the revision\n\t * compiled into the driver. So, where we used to compare\n\t * versions of our f/w and the ROM f/w, now we just see\n\t * whether we have f/w at all and whether a config flag\n\t * has disabled our download.\n\t */\n\tif ((isp->isp_mdvec->dv_ispfw == NULL) ||\n\t    (isp->isp_confopts & ISP_CFG_NORELOAD)) {\n\t\tdodnld = 0;\n\t}\n\n\tif (dodnld) {\n\t\tu_int16_t fwlen  = isp->isp_mdvec->dv_fwlen;\n\t\tif (fwlen == 0)\n\t\t\tfwlen = isp->isp_mdvec->dv_ispfw[3]; /* usually here */\n\t\tfor (i = 0; i < fwlen; i++) {\n\t\t\tmbs.param[0] = MBOX_WRITE_RAM_WORD;\n\t\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg + i;\n\t\t\tmbs.param[2] = isp->isp_mdvec->dv_ispfw[i];\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: F/W download failed at word %d\\n\",\n\t\t\t\t    isp->isp_name, i);\n\t\t\t\tdodnld = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Verify that it downloaded correctly.\n\t\t */\n\t\tmbs.param[0] = MBOX_VERIFY_CHECKSUM;\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"ram checksum failure\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tIDPRINTF(3, (\"%s: skipping f/w download\\n\", isp->isp_name));\n\t}\n\n\t/*\n\t * Now start it rolling.\n\t *\n\t * If we didn't actually download f/w,\n\t * we still need to (re)start it.\n\t */\n\n\tmbs.param[0] = MBOX_EXEC_FIRMWARE;\n\tif (isp->isp_mdvec->dv_codeorg)\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\telse\n\t\tmbs.param[1] = 0x1000;\n\tisp_mboxcmd(isp, &mbs);\n\n\tif (IS_SCSI(isp)) {\n\t\t/*\n\t\t * Set CLOCK RATE, but only if asked to.\n\t\t */\n\t\tif (isp->isp_clock) {\n\t\t\tmbs.param[0] = MBOX_SET_CLOCK_RATE;\n\t\t\tmbs.param[1] = isp->isp_clock;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"failed to set clockrate (0x%x)\\n\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\t/* but continue */\n\t\t\t}\n\t\t}\n\t}\n\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"could not get f/w started (0x%x)\\n\", mbs.param[0]);\n\t\treturn;\n\t}\n\tCFGPRINTF(\"%s: Board Revision %s, %s F/W Revision %d.%d.%d\\n\",\n\t    isp->isp_name, revname, dodnld? \"loaded\" : \"resident\",\n\t    mbs.param[1], mbs.param[2], mbs.param[3]);\n\tif (IS_FC(isp)) {\n\t\tif (ISP_READ(isp, BIU2100_CSR) & BIU2100_PCI64) {\n\t\t\tCFGPRINTF(\"%s: in 64-Bit PCI slot\\n\", isp->isp_name);\n\t\t}\n\t}\n\n\tisp->isp_fwrev[0] = mbs.param[1];\n\tisp->isp_fwrev[1] = mbs.param[2];\n\tisp->isp_fwrev[2] = mbs.param[3];\n\tif (isp->isp_romfw_rev[0] || isp->isp_romfw_rev[1] ||\n\t    isp->isp_romfw_rev[2]) {\n\t\tCFGPRINTF(\"%s: Last F/W revision was %d.%d.%d\\n\", isp->isp_name,\n\t\t    isp->isp_romfw_rev[0], isp->isp_romfw_rev[1],\n\t\t    isp->isp_romfw_rev[2]);\n\t}\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: could not GET FIRMWARE STATUS\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_maxcmds = mbs.param[2];\n\tCFGPRINTF(\"%s: %d max I/O commands supported\\n\",\n\t    isp->isp_name, mbs.param[2]);\n\tisp_fw_state(isp);\n\n\t/*\n\t * Set up DMA for the request and result mailboxes.\n\t */\n\tif (ISP_MBOXDMASETUP(isp) != 0) {\n\t\tPRINTF(\"%s: can't setup dma mailboxes\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_state = ISP_RESETSTATE;\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static void isp_fw_state",
            "static void isp_dumpregs",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic void isp_fw_state;\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\n\nvoid\nisp_reset(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tint loops, i, dodnld = 1;\n\tchar *revname;\n\n\tisp->isp_state = ISP_NILSTATE;\n\n\t/*\n\t * Basic types (SCSI, FibreChannel and PCI or SBus)\n\t * have been set in the MD code. We figure out more\n\t * here.\n\t */\n\tisp->isp_dblev = DFLT_DBLEVEL;\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\t/*\n\t * Get the current running firmware revision out of the\n\t * chip before we hit it over the head (if this is our\n\t * first time through). Note that we store this as the\n\t * 'ROM' firmware revision- which it may not be. In any\n\t * case, we don't really use this yet, but we may in\n\t * the future.\n\t */\n\tif (isp->isp_touched == 0) {\n\t\t/*\n\t\t * Just in case it was paused...\n\t\t */\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\t/*\n\t\t * If this fails, it probably means we're running\n\t\t * an old prom, if anything at all...\n\t\t */\n\t\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\t\tisp->isp_romfw_rev[0] = mbs.param[1];\n\t\t\tisp->isp_romfw_rev[1] = mbs.param[2];\n\t\t\tisp->isp_romfw_rev[2] = mbs.param[3];\n\t\t}\n\t\tisp->isp_touched = 1;\n\t}\n\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Put the board into PAUSE mode (so we can read the SXP registers).\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\n\tif (IS_FC(isp)) {\n\t\trevname = \"2X00\";\n\t\tswitch (isp->isp_type) {\n\t\tcase ISP_HA_FC_2100:\n\t\t\trevname[1] = '1';\n\t\t\tbreak;\n\t\tcase ISP_HA_FC_2200:\n\t\t\trevname[1] = '2';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_1240(isp)) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\trevname = \"1240\";\n\t\tisp->isp_clock = 60;\n\t\tsdp->isp_ultramode = 1;\n\t\tsdp++;\n\t\tsdp->isp_ultramode = 1;\n\t\t/*\n\t\t * XXX: Should probably do some bus sensing.\n\t\t */\n\t} else if (IS_ULTRA2(isp)) {\n\t\tstatic char *m = \"%s: bus %d is in %s Mode\\n\";\n\t\tu_int16_t l;\n\t\tsdparam *sdp = isp->isp_param;\n\n\t\tisp->isp_clock = 100;\n\n\t\tif (IS_1280(isp))\n\t\t\trevname = \"1280\";\n\t\telse if (IS_1080(isp))\n\t\t\trevname = \"1080\";\n\t\telse if (IS_12160(isp))\n\t\t\trevname = \"12160\";\n\t\telse\n\t\t\trevname = \"<UNKLVD>\";\n\n\t\tl = ISP_READ(isp, SXP_PINS_DIFF) & ISP1080_MODE_MASK;\n\t\tswitch (l) {\n\t\tcase ISP1080_LVD_MODE:\n\t\t\tsdp->isp_lvdmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"LVD\");\n\t\t\tbreak;\n\t\tcase ISP1080_HVD_MODE:\n\t\t\tsdp->isp_diffmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Differential\");\n\t\t\tbreak;\n\t\tcase ISP1080_SE_MODE:\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Single-Ended\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t    isp->isp_name, 0, l);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tsdp++;\n\t\t\tl = ISP_READ(isp, SXP_PINS_DIFF|SXP_BANK1_SELECT);\n\t\t\tl &= ISP1080_MODE_MASK;\n\t\t\tswitch(l) {\n\t\t\tcase ISP1080_LVD_MODE:\n\t\t\t\tsdp->isp_lvdmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"LVD\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_HVD_MODE:\n\t\t\t\tsdp->isp_diffmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Differential\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_SE_MODE:\n\t\t\t\tsdp->isp_ultramode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Single-Ended\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, 1, l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\ti = ISP_READ(isp, BIU_CONF0) & BIU_CONF0_HW_MASK;\n\t\tswitch (i) {\n\t\tdefault:\n\t\t\tPRINTF(\"%s: unknown chip rev. 0x%x- assuming a 1020\\n\",\n\t\t\t    isp->isp_name, i);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\trevname = \"1020\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/*\n\t\t\t * Some 1020A chips are Ultra Capable, but don't\n\t\t\t * run the clock rate up for that unless told to\n\t\t\t * do so by the Ultra Capable bits being set.\n\t\t\t */\n\t\t\trevname = \"1020A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020A;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trevname = \"1040\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trevname = \"1040A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040A;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevname = \"1040B\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040B;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 6: \n\t\t\trevname = \"1040C\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040C;\n\t\t\tisp->isp_clock = 60;\n                        break; \n\t\t}\n\t\t/*\n\t\t * Now, while we're at it, gather info about ultra\n\t\t * and/or differential mode.\n\t\t */\n\t\tif (ISP_READ(isp, SXP_PINS_DIFF) & SXP_PINS_DIFF_MODE) {\n\t\t\tCFGPRINTF(\"%s: Differential Mode\\n\", isp->isp_name);\n\t\t\tsdp->isp_diffmode = 1;\n\t\t} else {\n\t\t\tsdp->isp_diffmode = 0;\n\t\t}\n\t\ti = ISP_READ(isp, RISC_PSR);\n\t\tif (isp->isp_bustype == ISP_BT_SBUS) {\n\t\t\ti &= RISC_PSR_SBUS_ULTRA;\n\t\t} else {\n\t\t\ti &= RISC_PSR_PCI_ULTRA;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tCFGPRINTF(\"%s: Ultra Mode Capable\\n\", isp->isp_name);\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\t/*\n\t\t\t * If we're in Ultra Mode, we have to be 60Mhz clock-\n\t\t\t * even for the SBus version.\n\t\t\t */\n\t\t\tisp->isp_clock = 60;\n\t\t} else {\n\t\t\tsdp->isp_ultramode = 0;\n\t\t\t/*\n\t\t\t * Clock is known. Gronk.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Machine dependent clock (if set) overrides\n\t\t * our generic determinations.\n\t\t */\n\t\tif (isp->isp_mdvec->dv_clock) {\n\t\t\tif (isp->isp_mdvec->dv_clock < isp->isp_clock) {\n\t\t\t\tisp->isp_clock = isp->isp_mdvec->dv_clock;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * Do MD specific pre initialization\n\t */\n\tISP_RESET0(isp);\n\nagain:\n\n\t/*\n\t * Hit the chip over the head with hammer,\n\t * and give the ISP a chance to recover.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n#if\t0\n\t\tPRINTF(\"%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t    isp->isp_name, ISP_READ(isp, OUTMAILBOX0),\n\t\t    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2),\n\t\t    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4),\n\t\t    ISP_READ(isp, OUTMAILBOX5));\n#endif\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\t\tISP_WRITE(isp, DDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\n\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, TDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, RDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t}\n\n\t/*\n\t * Wait for ISP to be ready to go...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!(ISP_READ(isp, BIU2100_CSR) & BIU2100_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tisp_dumpregs(isp, \"chip reset timed out\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_CONF1, 0);\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, 0);\n\t}\n\n\t/*\n\t * Reset RISC Processor\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RESET);\n\tSYS_DELAY(100);\n\n\t/*\n\t * Establish some initial burst rate stuff.\n\t * (only for the 1XX0 boards). This really should\n\t * be done later after fetching from NVRAM.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tu_int16_t tmp = isp->isp_mdvec->dv_conf1;\n\t\t/*\n\t\t * Busted FIFO. Turn off all but burst enables.\n\t\t */\n\t\tif (isp->isp_type == ISP_HA_SCSI_1040A) {\n\t\t\ttmp &= BIU_BURST_ENABLE;\n\t\t}\n\t\tISP_SETBITS(isp, BIU_CONF1, tmp);\n\t\tif (tmp & BIU_BURST_ENABLE) {\n\t\t\tISP_SETBITS(isp, CDMA_CONF, DMA_ENABLE_BURST);\n\t\t\tISP_SETBITS(isp, DDMA_CONF, DMA_ENABLE_BURST);\n\t\t}\n#ifdef\tPTI_CARDS\n\t\tif (((sdparam *) isp->isp_param)->isp_ultramode) {\n\t\t\twhile (ISP_READ(isp, RISC_MTR) != 0x1313) {\n\t\t\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_STEP);\n\t\t\t}\n\t\t} else {\n\t\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n\t\t}\n\t\t/*\n\t\t * PTI specific register\n\t\t */\n\t\tISP_WRITE(isp, RISC_EMB, DUAL_BANK)\n#else\n\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n#endif\n\t} else {\n\t\tISP_WRITE(isp, RISC_MTR2100, 0x1212);\n\t}\n\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE); /* release paused processor */\n\n\t/*\n\t * Do MD specific post initialization\n\t */\n\tISP_RESET1(isp);\n\n\t/*\n\t * Wait for everything to finish firing up...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\twhile (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: MBOX_BUSY never cleared on reset\\n\",\n\t\t\t    isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Up until this point we've done everything by just reading or\n\t * setting registers. From this point on we rely on at least *some*\n\t * kind of firmware running in the card.\n\t */\n\n\t/*\n\t * Do some sanity checking.\n\t */\n\tmbs.param[0] = MBOX_NO_OP;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"NOP test failed\");\n\t\treturn;\n\t}\n\n\tif (IS_SCSI(isp)) {\n\t\tmbs.param[0] = MBOX_MAILBOX_REG_TEST;\n\t\tmbs.param[1] = 0xdead;\n\t\tmbs.param[2] = 0xbeef;\n\t\tmbs.param[3] = 0xffff;\n\t\tmbs.param[4] = 0x1111;\n\t\tmbs.param[5] = 0xa5a5;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp,\n\t\t\t\t\"Mailbox Register test didn't complete\");\n\t\t\treturn;\n\t\t}\n\t\tif (mbs.param[1] != 0xdead || mbs.param[2] != 0xbeef ||\n\t\t    mbs.param[3] != 0xffff || mbs.param[4] != 0x1111 ||\n\t\t    mbs.param[5] != 0xa5a5) {\n\t\t\tisp_dumpregs(isp, \"Register Test Failed\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\t/*\n\t * Download new Firmware, unless requested not to do so.\n\t * This is made slightly trickier in some cases where the\n\t * firmware of the ROM revision is newer than the revision\n\t * compiled into the driver. So, where we used to compare\n\t * versions of our f/w and the ROM f/w, now we just see\n\t * whether we have f/w at all and whether a config flag\n\t * has disabled our download.\n\t */\n\tif ((isp->isp_mdvec->dv_ispfw == NULL) ||\n\t    (isp->isp_confopts & ISP_CFG_NORELOAD)) {\n\t\tdodnld = 0;\n\t}\n\n\tif (dodnld) {\n\t\tu_int16_t fwlen  = isp->isp_mdvec->dv_fwlen;\n\t\tif (fwlen == 0)\n\t\t\tfwlen = isp->isp_mdvec->dv_ispfw[3]; /* usually here */\n\t\tfor (i = 0; i < fwlen; i++) {\n\t\t\tmbs.param[0] = MBOX_WRITE_RAM_WORD;\n\t\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg + i;\n\t\t\tmbs.param[2] = isp->isp_mdvec->dv_ispfw[i];\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: F/W download failed at word %d\\n\",\n\t\t\t\t    isp->isp_name, i);\n\t\t\t\tdodnld = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Verify that it downloaded correctly.\n\t\t */\n\t\tmbs.param[0] = MBOX_VERIFY_CHECKSUM;\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"ram checksum failure\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tIDPRINTF(3, (\"%s: skipping f/w download\\n\", isp->isp_name));\n\t}\n\n\t/*\n\t * Now start it rolling.\n\t *\n\t * If we didn't actually download f/w,\n\t * we still need to (re)start it.\n\t */\n\n\tmbs.param[0] = MBOX_EXEC_FIRMWARE;\n\tif (isp->isp_mdvec->dv_codeorg)\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\telse\n\t\tmbs.param[1] = 0x1000;\n\tisp_mboxcmd(isp, &mbs);\n\n\tif (IS_SCSI(isp)) {\n\t\t/*\n\t\t * Set CLOCK RATE, but only if asked to.\n\t\t */\n\t\tif (isp->isp_clock) {\n\t\t\tmbs.param[0] = MBOX_SET_CLOCK_RATE;\n\t\t\tmbs.param[1] = isp->isp_clock;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"failed to set clockrate (0x%x)\\n\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\t/* but continue */\n\t\t\t}\n\t\t}\n\t}\n\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"could not get f/w started (0x%x)\\n\", mbs.param[0]);\n\t\treturn;\n\t}\n\tCFGPRINTF(\"%s: Board Revision %s, %s F/W Revision %d.%d.%d\\n\",\n\t    isp->isp_name, revname, dodnld? \"loaded\" : \"resident\",\n\t    mbs.param[1], mbs.param[2], mbs.param[3]);\n\tif (IS_FC(isp)) {\n\t\tif (ISP_READ(isp, BIU2100_CSR) & BIU2100_PCI64) {\n\t\t\tCFGPRINTF(\"%s: in 64-Bit PCI slot\\n\", isp->isp_name);\n\t\t}\n\t}\n\n\tisp->isp_fwrev[0] = mbs.param[1];\n\tisp->isp_fwrev[1] = mbs.param[2];\n\tisp->isp_fwrev[2] = mbs.param[3];\n\tif (isp->isp_romfw_rev[0] || isp->isp_romfw_rev[1] ||\n\t    isp->isp_romfw_rev[2]) {\n\t\tCFGPRINTF(\"%s: Last F/W revision was %d.%d.%d\\n\", isp->isp_name,\n\t\t    isp->isp_romfw_rev[0], isp->isp_romfw_rev[1],\n\t\t    isp->isp_romfw_rev[2]);\n\t}\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: could not GET FIRMWARE STATUS\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_maxcmds = mbs.param[2];\n\tCFGPRINTF(\"%s: %d max I/O commands supported\\n\",\n\t    isp->isp_name, mbs.param[2]);\n\tisp_fw_state(isp);\n\n\t/*\n\t * Set up DMA for the request and result mailboxes.\n\t */\n\tif (ISP_MBOXDMASETUP(isp) != 0) {\n\t\tPRINTF(\"%s: can't setup dma mailboxes\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_state = ISP_RESETSTATE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nvoid\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}"
  },
  {
    "function_name": "isp_setdfltparm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3856-4053",
    "snippet": "static void\nisp_setdfltparm(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = (fcparam *) isp->isp_param;\n\t\tfcp += channel;\n\t\tif (fcp->isp_gotdparms) {\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_gotdparms = 1;\n\t\tfcp->isp_maxfrmlen = ICB_DFLT_FRMLEN;\n\t\tfcp->isp_maxalloc = ICB_DFLT_ALLOC;\n\t\tfcp->isp_execthrottle = ICB_DFLT_THROTTLE;\n\t\tfcp->isp_retry_delay = ICB_DFLT_RDELAY;\n\t\tfcp->isp_retry_count = ICB_DFLT_RCOUNT;\n\t\t/* Platform specific.... */\n\t\tfcp->isp_loopid = DEFAULT_LOOPID(isp);\n\t\tfcp->isp_nodewwn = DEFAULT_WWN(isp);\n\t\tfcp->isp_portwwn = 0;\n\t\t/*\n\t\t * Now try and read NVRAM\n\t\t */\n\t\tif ((isp->isp_confopts & (ISP_CFG_NONVRAM|ISP_CFG_OWNWWN)) ||\n\t\t    (isp_read_nvram(isp))) {\n\t\t\tPRINTF(\"%s: using Node WWN 0x%08x%08x\\n\",\n\t\t\t    isp->isp_name, (u_int32_t)(fcp->isp_nodewwn >> 32),\n\t\t\t    (u_int32_t)(fcp->isp_nodewwn & 0xffffffff));\n\t\t}\n\t\treturn;\n\t}\n\n\tsdp = (sdparam *) isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Been there, done that, got the T-shirt...\n\t */\n\tif (sdp->isp_gotdparms) {\n\t\treturn;\n\t}\n\tsdp->isp_gotdparms = 1;\n\n\t/*\n\t * If we've not been told to avoid reading NVRAM, try and read it.\n\t * If we're successful reading it, we can return since NVRAM will\n\t * tell us the right thing to do. Otherwise, establish some reasonable\n\t * defaults.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tif (isp_read_nvram(isp) == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Now try and see whether we have specific values for them.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tmbs.param[0] = MBOX_GET_ACT_NEG_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(2, (\"could not GET ACT NEG STATE\\n\"));\n\t\t\tsdp->isp_req_ack_active_neg = 1;\n\t\t\tsdp->isp_data_line_active_neg = 1;\n\t\t} else {\n\t\t\tsdp->isp_req_ack_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 4) & 0x1;\n\t\t\tsdp->isp_data_line_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 5) & 0x1;\n\t\t}\n\t} else {\n\t\tsdp->isp_req_ack_active_neg = 1;\n\t\tsdp->isp_data_line_active_neg = 1;\n\t}\n\n\tIDPRINTF(3, (\"%s: defaulting bus %d REQ/ACK Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_req_ack_active_neg));\n\tIDPRINTF(3, (\"%s: defaulting bus %d DATA Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_data_line_active_neg));\n\n\t/*\n\t * The trick here is to establish a default for the default (honk!)\n\t * state (dev_flags). Then try and get the current status from\n\t * the card to fill in the current state. We don't, in fact, set\n\t * the default to the SAFE default state- that's not the goal state.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].cur_offset = 0;\n\t\tsdp->isp_devparam[tgt].cur_period = 0;\n\t\tsdp->isp_devparam[tgt].dev_flags = DPARM_DEFAULT;\n\t\tsdp->isp_devparam[tgt].cur_dflags = 0;\n\t\t/*\n\t\t * We default to Wide/Fast for versions less than a 1040\n\t\t * (unless it's SBus).\n\t\t */\n\t\tif ((isp->isp_bustype == ISP_BT_SBUS &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1020A) ||\n\t\t    (isp->isp_bustype == ISP_BT_PCI &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1040) ||\n\t\t    (isp->isp_clock && isp->isp_clock < 60)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t} else if (IS_ULTRA2(isp)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_40M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_40M_SYNCPARMS & 0xff;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_20M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_20M_SYNCPARMS & 0xff;\n\t\t}\n\n\t\t/*\n\t\t * Don't get current target parameters if we've been\n\t\t * told not to use NVRAM- it's really the same thing.\n\t\t */\n\t\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = tgt << 8;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].dev_flags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\n\t\t\t/*\n\t\t\t * The maximum period we can really see\n\t\t\t * here is 100 (decimal), or 400 ns.\n\t\t\t * For some unknown reason we sometimes\n\t\t\t * get back wildass numbers from the\n\t\t\t * boot device's parameters (alpha only).\n\t\t\t */\n\t\t\tif ((mbs.param[3] & 0xff) <= 0x64) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    mbs.param[3] & 0xff;\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    mbs.param[3] >> 8;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * It is not safe to run Ultra Mode with a clock < 60.\n\t\t\t */\n\t\t\tif (((isp->isp_clock && isp->isp_clock < 60) ||\n\t\t\t    (isp->isp_type < ISP_HA_SCSI_1020A)) &&\n\t\t\t    (sdp->isp_devparam[tgt].sync_period <=\n\t\t\t    (ISP_20M_SYNCPARMS & 0xff))) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t\t}\n\t\t}\n\t\tIDPRINTF(3, (\"%s: bus %d tgt %d flags %x offset %x period %x\\n\",\n\t\t    isp->isp_name, channel, tgt,\n\t\t    sdp->isp_devparam[tgt].dev_flags,\n\t\t    sdp->isp_devparam[tgt].sync_offset,\n\t\t    sdp->isp_devparam[tgt].sync_period));\n\t}\n\n\t/*\n\t * Establish default some more default parameters.\n\t */\n\tsdp->isp_cmd_dma_burst_enable = 1;\n\tsdp->isp_data_dma_burst_enabl = 1;\n\tsdp->isp_fifo_threshold = 0;\n\tsdp->isp_initiator_id = 7;\n\t/* XXXX This is probably based upon clock XXXX */\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tsdp->isp_async_data_setup = 9;\n\t} else {\n\t\tsdp->isp_async_data_setup = 6;\n\t}\n\tsdp->isp_selection_timeout = 250;\n\tsdp->isp_max_queue_depth = MAXISPREQUEST;\n\tsdp->isp_tag_aging = 8;\n\tsdp->isp_bus_reset_delay = 3;\n\tsdp->isp_retry_count = 2;\n\tsdp->isp_retry_delay = 2;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].exc_throttle = 16;\n\t\tsdp->isp_devparam[tgt].dev_enable = 1;\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_mboxcmd",
      "static void isp_setdfltparm",
      "static int isp_read_nvram"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: bus %d tgt %d flags %x offset %x period %x\\n\",\n\t\t    isp->isp_name, channel, tgt,\n\t\t    sdp->isp_devparam[tgt].dev_flags,\n\t\t    sdp->isp_devparam[tgt].sync_offset,\n\t\t    sdp->isp_devparam[tgt].sync_period)"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ULTRA2",
          "args": [
            "isp"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: defaulting bus %d DATA Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_data_line_active_neg)"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: defaulting bus %d REQ/ACK Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_req_ack_active_neg)"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"could not GET ACT NEG STATE\\n\")"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_read_nvram",
          "args": [
            "isp"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "isp_read_nvram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4105-4178",
          "snippet": "static int\nisp_read_nvram(isp)\n\tstruct ispsoftc *isp;\n{\n\tint i, amt;\n\tu_int8_t csum, minversion;\n\tunion {\n\t\tu_int8_t _x[ISP2100_NVRAM_SIZE];\n\t\tu_int16_t _s[ISP2100_NVRAM_SIZE>>1];\n\t} _n;\n#define\tnvram_data\t_n._x\n#define\tnvram_words\t_n._s\n\n\tif (IS_FC(isp)) {\n\t\tamt = ISP2100_NVRAM_SIZE;\n\t\tminversion = 1;\n\t} else if (IS_ULTRA2(isp)) {\n\t\tamt = ISP1080_NVRAM_SIZE;\n\t\tminversion = 0;\n\t} else {\n\t\tamt = ISP_NVRAM_SIZE;\n\t\tminversion = 2;\n\t}\n\n\t/*\n\t * Just read the first two words first to see if we have a valid\n\t * NVRAM to continue reading the rest with.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tif (nvram_data[0] != 'I' || nvram_data[1] != 'S' ||\n\t    nvram_data[2] != 'P') {\n\t\tif (isp->isp_bustype != ISP_BT_SBUS) {\n\t\t\tPRINTF(\"%s: invalid NVRAM header (%x,%x,%x,%x)\\n\",\n\t\t\t    isp->isp_name, nvram_data[0], nvram_data[1],\n\t\t\t    nvram_data[2], nvram_data[3]);\n\t\t}\n\t\treturn (-1);\n\t}\n\tfor (i = 2; i < amt>>1; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tfor (csum = 0, i = 0; i < amt; i++) {\n\t\tcsum += nvram_data[i];\n\t}\n\tif (csum != 0) {\n\t\tPRINTF(\"%s: invalid NVRAM checksum\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tif (ISP_NVRAM_VERSION(nvram_data) < minversion) {\n\t\tPRINTF(\"%s: version %d NVRAM not understood\\n\", isp->isp_name,\n\t\t    ISP_NVRAM_VERSION(nvram_data));\n\t\treturn (-1);\n\t}\n\n\tif (IS_ULTRA3(isp)) {\n\t\tisp_parse_nvram_12160(isp, 0, nvram_data);\n\t\tisp_parse_nvram_12160(isp, 1, nvram_data);\n\t} else if (IS_1080(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t} else if (IS_1280(isp) || IS_1240(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t\tisp_parse_nvram_1080(isp, 1, nvram_data);\n\t} else if (IS_SCSI(isp)) {\n\t\tisp_parse_nvram_1020(isp, nvram_data);\n\t} else {\n\t\tisp_parse_nvram_2100(isp, nvram_data);\n\t}\n\tIDPRINTF(3, (\"%s: NVRAM is valid\\n\", isp->isp_name));\n\treturn (0);\n#undef\tnvram_data\n#undef\tnvram_words\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tnvram_words\t_n._s",
            "#define\tnvram_data\t_n._x"
          ],
          "globals_used": [
            "static int isp_read_nvram",
            "static void isp_rdnvram_word",
            "static void isp_parse_nvram_1020",
            "static void isp_parse_nvram_1080",
            "static void isp_parse_nvram_12160",
            "static void isp_parse_nvram_2100"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tnvram_words\t_n._s\n#define\tnvram_data\t_n._x\n\nstatic int isp_read_nvram;\nstatic void isp_rdnvram_word;\nstatic void isp_parse_nvram_1020;\nstatic void isp_parse_nvram_1080;\nstatic void isp_parse_nvram_12160;\nstatic void isp_parse_nvram_2100;\n\nstatic int\nisp_read_nvram(isp)\n\tstruct ispsoftc *isp;\n{\n\tint i, amt;\n\tu_int8_t csum, minversion;\n\tunion {\n\t\tu_int8_t _x[ISP2100_NVRAM_SIZE];\n\t\tu_int16_t _s[ISP2100_NVRAM_SIZE>>1];\n\t} _n;\n#define\tnvram_data\t_n._x\n#define\tnvram_words\t_n._s\n\n\tif (IS_FC(isp)) {\n\t\tamt = ISP2100_NVRAM_SIZE;\n\t\tminversion = 1;\n\t} else if (IS_ULTRA2(isp)) {\n\t\tamt = ISP1080_NVRAM_SIZE;\n\t\tminversion = 0;\n\t} else {\n\t\tamt = ISP_NVRAM_SIZE;\n\t\tminversion = 2;\n\t}\n\n\t/*\n\t * Just read the first two words first to see if we have a valid\n\t * NVRAM to continue reading the rest with.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tif (nvram_data[0] != 'I' || nvram_data[1] != 'S' ||\n\t    nvram_data[2] != 'P') {\n\t\tif (isp->isp_bustype != ISP_BT_SBUS) {\n\t\t\tPRINTF(\"%s: invalid NVRAM header (%x,%x,%x,%x)\\n\",\n\t\t\t    isp->isp_name, nvram_data[0], nvram_data[1],\n\t\t\t    nvram_data[2], nvram_data[3]);\n\t\t}\n\t\treturn (-1);\n\t}\n\tfor (i = 2; i < amt>>1; i++) {\n\t\tisp_rdnvram_word(isp, i, &nvram_words[i]);\n\t}\n\tfor (csum = 0, i = 0; i < amt; i++) {\n\t\tcsum += nvram_data[i];\n\t}\n\tif (csum != 0) {\n\t\tPRINTF(\"%s: invalid NVRAM checksum\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tif (ISP_NVRAM_VERSION(nvram_data) < minversion) {\n\t\tPRINTF(\"%s: version %d NVRAM not understood\\n\", isp->isp_name,\n\t\t    ISP_NVRAM_VERSION(nvram_data));\n\t\treturn (-1);\n\t}\n\n\tif (IS_ULTRA3(isp)) {\n\t\tisp_parse_nvram_12160(isp, 0, nvram_data);\n\t\tisp_parse_nvram_12160(isp, 1, nvram_data);\n\t} else if (IS_1080(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t} else if (IS_1280(isp) || IS_1240(isp)) {\n\t\tisp_parse_nvram_1080(isp, 0, nvram_data);\n\t\tisp_parse_nvram_1080(isp, 1, nvram_data);\n\t} else if (IS_SCSI(isp)) {\n\t\tisp_parse_nvram_1020(isp, nvram_data);\n\t} else {\n\t\tisp_parse_nvram_2100(isp, nvram_data);\n\t}\n\tIDPRINTF(3, (\"%s: NVRAM is valid\\n\", isp->isp_name));\n\treturn (0);\n#undef\tnvram_data\n#undef\tnvram_words\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: using Node WWN 0x%08x%08x\\n\"",
            "isp->isp_name",
            "(u_int32_t)(fcp->isp_nodewwn >> 32)",
            "(u_int32_t)(fcp->isp_nodewwn & 0xffffffff)"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fcp->isp_nodewwn & 0xffffffff"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fcp->isp_nodewwn >> 32"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_WWN",
          "args": [
            "isp"
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_LOOPID",
          "args": [
            "isp"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mboxcmd;\nstatic void isp_setdfltparm;\nstatic int isp_read_nvram;\n\nstatic void\nisp_setdfltparm(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = (fcparam *) isp->isp_param;\n\t\tfcp += channel;\n\t\tif (fcp->isp_gotdparms) {\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_gotdparms = 1;\n\t\tfcp->isp_maxfrmlen = ICB_DFLT_FRMLEN;\n\t\tfcp->isp_maxalloc = ICB_DFLT_ALLOC;\n\t\tfcp->isp_execthrottle = ICB_DFLT_THROTTLE;\n\t\tfcp->isp_retry_delay = ICB_DFLT_RDELAY;\n\t\tfcp->isp_retry_count = ICB_DFLT_RCOUNT;\n\t\t/* Platform specific.... */\n\t\tfcp->isp_loopid = DEFAULT_LOOPID(isp);\n\t\tfcp->isp_nodewwn = DEFAULT_WWN(isp);\n\t\tfcp->isp_portwwn = 0;\n\t\t/*\n\t\t * Now try and read NVRAM\n\t\t */\n\t\tif ((isp->isp_confopts & (ISP_CFG_NONVRAM|ISP_CFG_OWNWWN)) ||\n\t\t    (isp_read_nvram(isp))) {\n\t\t\tPRINTF(\"%s: using Node WWN 0x%08x%08x\\n\",\n\t\t\t    isp->isp_name, (u_int32_t)(fcp->isp_nodewwn >> 32),\n\t\t\t    (u_int32_t)(fcp->isp_nodewwn & 0xffffffff));\n\t\t}\n\t\treturn;\n\t}\n\n\tsdp = (sdparam *) isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Been there, done that, got the T-shirt...\n\t */\n\tif (sdp->isp_gotdparms) {\n\t\treturn;\n\t}\n\tsdp->isp_gotdparms = 1;\n\n\t/*\n\t * If we've not been told to avoid reading NVRAM, try and read it.\n\t * If we're successful reading it, we can return since NVRAM will\n\t * tell us the right thing to do. Otherwise, establish some reasonable\n\t * defaults.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tif (isp_read_nvram(isp) == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Now try and see whether we have specific values for them.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tmbs.param[0] = MBOX_GET_ACT_NEG_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(2, (\"could not GET ACT NEG STATE\\n\"));\n\t\t\tsdp->isp_req_ack_active_neg = 1;\n\t\t\tsdp->isp_data_line_active_neg = 1;\n\t\t} else {\n\t\t\tsdp->isp_req_ack_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 4) & 0x1;\n\t\t\tsdp->isp_data_line_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 5) & 0x1;\n\t\t}\n\t} else {\n\t\tsdp->isp_req_ack_active_neg = 1;\n\t\tsdp->isp_data_line_active_neg = 1;\n\t}\n\n\tIDPRINTF(3, (\"%s: defaulting bus %d REQ/ACK Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_req_ack_active_neg));\n\tIDPRINTF(3, (\"%s: defaulting bus %d DATA Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_data_line_active_neg));\n\n\t/*\n\t * The trick here is to establish a default for the default (honk!)\n\t * state (dev_flags). Then try and get the current status from\n\t * the card to fill in the current state. We don't, in fact, set\n\t * the default to the SAFE default state- that's not the goal state.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].cur_offset = 0;\n\t\tsdp->isp_devparam[tgt].cur_period = 0;\n\t\tsdp->isp_devparam[tgt].dev_flags = DPARM_DEFAULT;\n\t\tsdp->isp_devparam[tgt].cur_dflags = 0;\n\t\t/*\n\t\t * We default to Wide/Fast for versions less than a 1040\n\t\t * (unless it's SBus).\n\t\t */\n\t\tif ((isp->isp_bustype == ISP_BT_SBUS &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1020A) ||\n\t\t    (isp->isp_bustype == ISP_BT_PCI &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1040) ||\n\t\t    (isp->isp_clock && isp->isp_clock < 60)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t} else if (IS_ULTRA2(isp)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_40M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_40M_SYNCPARMS & 0xff;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_20M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_20M_SYNCPARMS & 0xff;\n\t\t}\n\n\t\t/*\n\t\t * Don't get current target parameters if we've been\n\t\t * told not to use NVRAM- it's really the same thing.\n\t\t */\n\t\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = tgt << 8;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].dev_flags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\n\t\t\t/*\n\t\t\t * The maximum period we can really see\n\t\t\t * here is 100 (decimal), or 400 ns.\n\t\t\t * For some unknown reason we sometimes\n\t\t\t * get back wildass numbers from the\n\t\t\t * boot device's parameters (alpha only).\n\t\t\t */\n\t\t\tif ((mbs.param[3] & 0xff) <= 0x64) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    mbs.param[3] & 0xff;\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    mbs.param[3] >> 8;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * It is not safe to run Ultra Mode with a clock < 60.\n\t\t\t */\n\t\t\tif (((isp->isp_clock && isp->isp_clock < 60) ||\n\t\t\t    (isp->isp_type < ISP_HA_SCSI_1020A)) &&\n\t\t\t    (sdp->isp_devparam[tgt].sync_period <=\n\t\t\t    (ISP_20M_SYNCPARMS & 0xff))) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t\t}\n\t\t}\n\t\tIDPRINTF(3, (\"%s: bus %d tgt %d flags %x offset %x period %x\\n\",\n\t\t    isp->isp_name, channel, tgt,\n\t\t    sdp->isp_devparam[tgt].dev_flags,\n\t\t    sdp->isp_devparam[tgt].sync_offset,\n\t\t    sdp->isp_devparam[tgt].sync_period));\n\t}\n\n\t/*\n\t * Establish default some more default parameters.\n\t */\n\tsdp->isp_cmd_dma_burst_enable = 1;\n\tsdp->isp_data_dma_burst_enabl = 1;\n\tsdp->isp_fifo_threshold = 0;\n\tsdp->isp_initiator_id = 7;\n\t/* XXXX This is probably based upon clock XXXX */\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tsdp->isp_async_data_setup = 9;\n\t} else {\n\t\tsdp->isp_async_data_setup = 6;\n\t}\n\tsdp->isp_selection_timeout = 250;\n\tsdp->isp_max_queue_depth = MAXISPREQUEST;\n\tsdp->isp_tag_aging = 8;\n\tsdp->isp_bus_reset_delay = 3;\n\tsdp->isp_retry_count = 2;\n\tsdp->isp_retry_delay = 2;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].exc_throttle = 16;\n\t\tsdp->isp_devparam[tgt].dev_enable = 1;\n\t}\n}"
  },
  {
    "function_name": "isp_update_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3760-3854",
    "snippet": "static void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_mboxcmd",
      "static void isp_update_bus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_NEW_TGT_PARAMS",
            "&get"
          ],
          "line": 3852
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\"",
            "isp->isp_name",
            "(get)? 'g' : 's'",
            "tgt"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff)"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus)"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mboxcmd;\nstatic void isp_update_bus;\n\nstatic void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}"
  },
  {
    "function_name": "isp_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3746-3758",
    "snippet": "static void\nisp_update(isp)\n\tstruct ispsoftc *isp;\n{\n\tint bus;\n\n\tfor (bus = 0; isp->isp_update != 0; bus++) {\n\t\tif (isp->isp_update & (1 << bus)) {\n\t\t\tisp_update_bus(isp, bus);\n\t\t\tisp->isp_update ^= (1 << bus);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_update",
      "static void isp_update_bus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_update_bus",
          "args": [
            "isp",
            "bus"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "isp_update_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3760-3854",
          "snippet": "static void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_mboxcmd",
            "static void isp_update_bus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mboxcmd;\nstatic void isp_update_bus;\n\nstatic void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_update;\nstatic void isp_update_bus;\n\nstatic void\nisp_update(isp)\n\tstruct ispsoftc *isp;\n{\n\tint bus;\n\n\tfor (bus = 0; isp->isp_update != 0; bus++) {\n\t\tif (isp->isp_update & (1 << bus)) {\n\t\t\tisp_update_bus(isp, bus);\n\t\t\tisp->isp_update ^= (1 << bus);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "isp_fw_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3695-3744",
    "snippet": "static void\nisp_fw_state(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tif (IS_FC(isp)) {\n\t\tint once = 0;\n\t\tfcparam *fcp = isp->isp_param;\nagain:\n\t\tmbs.param[0] = MBOX_GET_FW_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: isp_fw_state 0x%x\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase ASYNC_PDB_CHANGED:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_PDB_RCVD;\n\t\t\t\tgoto again;\n\t\t\tcase ASYNC_LIP_OCCURRED:\n\t\t\t\tfcp->isp_lipseq = mbs.param[1];\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_LOOP_UP:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_LIP_RCVD;\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ASYNC_LOOP_RESET:\n\t\t\tcase ASYNC_LOOP_DOWN:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_NIL;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_CHANGE_NOTIFY:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPRINTF(\"%s: GET FIRMWARE STATE failed (0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_fwstate = mbs.param[1];\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_fw_state",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: GET FIRMWARE STATE failed (0x%x)\\n\"",
            "isp->isp_name",
            "mbs.param[0]"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: isp_fw_state 0x%x\\n\", isp->isp_name,\n\t\t\t    mbs.param[0])"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fw_state;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_fw_state(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tif (IS_FC(isp)) {\n\t\tint once = 0;\n\t\tfcparam *fcp = isp->isp_param;\nagain:\n\t\tmbs.param[0] = MBOX_GET_FW_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: isp_fw_state 0x%x\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase ASYNC_PDB_CHANGED:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_PDB_RCVD;\n\t\t\t\tgoto again;\n\t\t\tcase ASYNC_LIP_OCCURRED:\n\t\t\t\tfcp->isp_lipseq = mbs.param[1];\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_LOOP_UP:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_LIP_RCVD;\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ASYNC_LOOP_RESET:\n\t\t\tcase ASYNC_LOOP_DOWN:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_NIL;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_CHANGE_NOTIFY:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPRINTF(\"%s: GET FIRMWARE STATE failed (0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_fwstate = mbs.param[1];\n\t}\n}"
  },
  {
    "function_name": "isp_dumpregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3659-3693",
    "snippet": "static void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_dumpregs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISP_DUMPREGS",
          "args": [
            "isp"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    mbox regs: %x %x %x %x %x\\n\"",
            "ISP_READ(isp, OUTMAILBOX0)",
            "ISP_READ(isp, OUTMAILBOX1)",
            "ISP_READ(isp, OUTMAILBOX2)",
            "ISP_READ(isp, OUTMAILBOX3)",
            "ISP_READ(isp, OUTMAILBOX4)"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX4"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX3"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX2"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX1"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_RELEASE"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\"",
            "ISP_READ(isp, SXP_INTERRUPT)",
            "ISP_READ(isp, SXP_GROSS_ERR)",
            "ISP_READ(isp, SXP_PINS_CTRL)"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "SXP_PINS_CTRL"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "SXP_GROSS_ERR"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "SXP_INTERRUPT"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\"",
            "ISP_READ(isp, DDMA_CONF)",
            "ISP_READ(isp, DDMA_STATUS)",
            "ISP_READ(isp, DDMA_FIFO_STS)"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "DDMA_FIFO_STS"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "DDMA_STATUS"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "DDMA_CONF"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\"",
            "ISP_READ(isp, CDMA_CONF)",
            "ISP_READ(isp, CDMA_STATUS)",
            "ISP_READ(isp, CDMA_FIFO_STS)"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "CDMA_FIFO_STS"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "CDMA_STATUS"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "CDMA_CONF"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_PAUSE"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"risc_hccr=%x\\n\"",
            "ISP_READ(isp, HCCR)"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "HCCR"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\" biu_icr=%x biu_isr=%x biu_sema=%x \"",
            "ISP_READ(isp, BIU_ICR)",
            "ISP_READ(isp, BIU_ISR)",
            "ISP_READ(isp, BIU_SEMA)"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_SEMA"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_ISR"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_ICR"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    biu_csr=%x\"",
            "ISP_READ(isp, BIU2100_CSR)"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU2100_CSR"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"    biu_conf1=%x\"",
            "ISP_READ(isp, BIU_CONF1)"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_CONF1"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: %s\\n\"",
            "isp->isp_name",
            "msg"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_dumpregs;\n\nstatic void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}"
  },
  {
    "function_name": "isp_lostcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3622-3657",
    "snippet": "void\nisp_lostcmd(isp, xs)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"couldn't GET FIRMWARE STATUS\");\n\t\treturn;\n\t}\n\tif (mbs.param[1]) {\n\t\tPRINTF(\"%s: %d commands on completion queue\\n\",\n\t\t    isp->isp_name, mbs.param[1]);\n\t}\n\tif (XS_NULL(xs))\n\t\treturn;\n\n\tmbs.param[0] = MBOX_GET_DEV_QUEUE_STATUS;\n\tmbs.param[1] = (XS_TGT(xs) << 8) | XS_LUN(xs); /* XXX: WHICH BUS? */\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"couldn't GET DEVICE QUEUE STATUS\");\n\t\treturn;\n\t}\n\tPRINTF(\"%s: lost command for target %d lun %d, %d active of %d, \"\n\t\t\"Queue State: %x\\n\", isp->isp_name, XS_TGT(xs),\n\t\tXS_LUN(xs), mbs.param[2], mbs.param[3], mbs.param[1]);\n\n\tisp_dumpregs(isp, \"lost command\");\n\t/*\n\t * XXX: Need to try and do something to recover.\n\t */\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_dumpregs",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_dumpregs",
          "args": [
            "isp",
            "\"lost command\""
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "isp_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3659-3693",
          "snippet": "static void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_dumpregs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_dumpregs;\n\nstatic void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: lost command for target %d lun %d, %d active of %d, \"\n\t\t\"Queue State: %x\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "mbs.param[2]",
            "mbs.param[3]",
            "mbs.param[1]"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NULL",
          "args": [
            "xs"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: %d commands on completion queue\\n\"",
            "isp->isp_name",
            "mbs.param[1]"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\n\nvoid\nisp_lostcmd(isp, xs)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"couldn't GET FIRMWARE STATUS\");\n\t\treturn;\n\t}\n\tif (mbs.param[1]) {\n\t\tPRINTF(\"%s: %d commands on completion queue\\n\",\n\t\t    isp->isp_name, mbs.param[1]);\n\t}\n\tif (XS_NULL(xs))\n\t\treturn;\n\n\tmbs.param[0] = MBOX_GET_DEV_QUEUE_STATUS;\n\tmbs.param[1] = (XS_TGT(xs) << 8) | XS_LUN(xs); /* XXX: WHICH BUS? */\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"couldn't GET DEVICE QUEUE STATUS\");\n\t\treturn;\n\t}\n\tPRINTF(\"%s: lost command for target %d lun %d, %d active of %d, \"\n\t\t\"Queue State: %x\\n\", isp->isp_name, XS_TGT(xs),\n\t\tXS_LUN(xs), mbs.param[2], mbs.param[3], mbs.param[1]);\n\n\tisp_dumpregs(isp, \"lost command\");\n\t/*\n\t * XXX: Need to try and do something to recover.\n\t */\n}"
  },
  {
    "function_name": "isp_mboxcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3242-3620",
    "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
      "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
    ],
    "globals_used": [
      "static int isp_parse_async",
      "static void isp_fastpost_complete",
      "static void isp_mboxcmd",
      "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: mbox cmd %x failed with error %x\\n\"",
            "isp->isp_name",
            "opcode",
            "mbp->param[0]"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\"",
            "isp->isp_name",
            "opcode"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\"",
            "isp->isp_name",
            "opcode"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: mbox cmd %x failed with TEST_FAILED\\n\"",
            "isp->isp_name",
            "opcode"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\"",
            "isp->isp_name",
            "opcode"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode)"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX1"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX2"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX3"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX4"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX5"
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX6"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX7"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX6"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_2200",
          "args": [
            "isp"
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX2"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX6"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX7"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_fastpost_complete",
          "args": [
            "isp",
            "fph"
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "isp_fastpost_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3087-3118",
          "snippet": "static void\nisp_fastpost_complete(isp, fph)\n\tstruct ispsoftc *isp;\n\tu_int32_t fph;\n{\n\tISP_SCSI_XFER_T *xs;\n\n\tif (fph < 1) {\n\t\treturn;\n\t}\n\txs = isp_find_xs(isp, fph);\n\tif (xs == NULL) {\n\t\tPRINTF(\"%s: command for fast posting handle 0x%x not found\\n\",\n\t\t    isp->isp_name, fph);\n\t\treturn;\n\t}\n\tisp_destroy_handle(isp, fph);\n\n\t/*\n\t * Since we don't have a result queue entry item,\n\t * we must believe that SCSI status is zero and\n\t * that all data transferred.\n\t */\n\tXS_RESID(xs) = 0;\n\tXS_STS(xs) = 0;\n\tif (XS_XFRLEN(xs)) {\n\t\tISP_DMAFREE(isp, xs, fph);\n\t}\n\tXS_CMD_DONE(xs);\n\tif (isp->isp_nactive)\n\t\tisp->isp_nactive--;\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_fastpost_complete"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fastpost_complete;\n\nstatic void\nisp_fastpost_complete(isp, fph)\n\tstruct ispsoftc *isp;\n\tu_int32_t fph;\n{\n\tISP_SCSI_XFER_T *xs;\n\n\tif (fph < 1) {\n\t\treturn;\n\t}\n\txs = isp_find_xs(isp, fph);\n\tif (xs == NULL) {\n\t\tPRINTF(\"%s: command for fast posting handle 0x%x not found\\n\",\n\t\t    isp->isp_name, fph);\n\t\treturn;\n\t}\n\tisp_destroy_handle(isp, fph);\n\n\t/*\n\t * Since we don't have a result queue entry item,\n\t * we must believe that SCSI status is zero and\n\t * that all data transferred.\n\t */\n\tXS_RESID(xs) = 0;\n\tXS_STS(xs) = 0;\n\tif (XS_XFRLEN(xs)) {\n\t\tISP_DMAFREE(isp, xs, fph);\n\t}\n\tXS_CMD_DONE(xs);\n\tif (isp->isp_nactive)\n\t\tisp->isp_nactive--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_parse_async",
          "args": [
            "isp",
            "(int) mbox"
          ],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "isp_parse_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2567-2797",
          "snippet": "static int\nisp_parse_async(isp, mbox)\n\tstruct ispsoftc *isp;\n\tint mbox;\n{\n\tint bus;\n\tu_int32_t fast_post_handle = 0;\n\n\tif (IS_DUALBUS(isp)) {\n\t\tbus = ISP_READ(isp, OUTMAILBOX6);\n\t} else {\n\t\tbus = 0;\n\t}\n\n\tswitch (mbox) {\n\tcase MBOX_COMMAND_COMPLETE:\t/* sometimes these show up */\n\t\tbreak;\n\tcase ASYNC_BUS_RESET:\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tisp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\tbreak;\n\tcase ASYNC_SYSTEM_ERROR:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tPRINTF(\"%s: Internal FW Error @ RISC Addr 0x%x\\n\",\n\t\t    isp->isp_name, mbox);\n\t\tisp_restart(isp);\n\t\t/* no point continuing after this */\n\t\treturn (-1);\n\n\tcase ASYNC_RQS_XFER_ERR:\n\t\tPRINTF(\"%s: Request Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_RSP_XFER_ERR:\n\t\tPRINTF(\"%s: Response Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_QWAKEUP:\n\t\t/*\n\t\t * We've just been notified that the Queue has woken up.\n\t\t * We don't need to be chatty about this- just unlatch things\n\t\t * and move on.\n\t\t */\n\t\tmbox = ISP_READ(isp, OUTMAILBOX4);\n\t\tbreak;\n\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tPRINTF(\"%s: timeout initiated SCSI bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_DEVICE_RESET:\n\t\tPRINTF(\"%s: device reset on bus %d\\n\", isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_EXTMSG_UNDERRUN:\n\t\tPRINTF(\"%s: extended message underrun\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_SCAM_INT:\n\t\tPRINTF(\"%s: SCAM interrupt\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_HUNG_SCSI:\n\t\tPRINTF(\"%s: stalled SCSI Bus after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\t/* XXX: Need to issue SCSI reset at this point */\n\t\tbreak;\n\n\tcase ASYNC_KILLED_BUS:\n\t\tPRINTF(\"%s: SCSI Bus reset after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_BUS_TRANSIT:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX2);\n\t\tswitch (mbox & 0x1c00) {\n\t\tcase SXP_PINS_LVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to LVD mode\\n\", isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 1;\n\t\t\tbreak;\n\t\tcase SXP_PINS_HVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to Differential mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tcase SXP_PINS_SE_MODE:\n\t\t\tPRINTF(\"%s: Transition to Single Ended mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: Transition to unknown mode 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * XXX: Set up to renegotiate again!\n\t\t */\n\t\t/* Can only be for a 1080... */\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tbreak;\n\n\tcase ASYNC_CMD_CMPLT:\n\t\tfast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\tIDPRINTF(4, (\"%s: fast post completion of %u\\n\", isp->isp_name,\n\t\t    fast_post_handle));\n\t\tbreak;\n\n\tcase ASYNC_CTIO_DONE:\n\t\t/* Should only occur when Fast Posting Set for 2100s */\n\t\tPRINTF(\"%s: CTIO done\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq =\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp->isp_sendmarker = 1;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(1, (\"%s: LIP occurred\\n\", isp->isp_name));\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_UP:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_UP, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_DOWN, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_RESET:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tPRINTF(\"%s: Loop RESET\\n\", isp->isp_name);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_PDB_CHANGED:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(2, (\"%s: Port Database Changed\\n\", isp->isp_name));\n\t\tbreak;\n\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tisp_mark_getpdb_all(isp);\n\t\t/*\n\t\t * Not correct, but it will force us to rescan the loop.\n\t\t */\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_async(isp, ISPASYNC_CHANGE_NOTIFY, NULL);\n\t\tbreak;\n\n\tcase ASYNC_PTPMODE:\n\t\tPRINTF(\"%s: Point-to-Point mode\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_CONNMODE:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tswitch (mbox) {\n\t\tcase ISP_CONN_LOOP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_PTP:\n\t\t\tPRINTF(\"%s: Loop -> Point-to-Point mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_BADLIP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode (1)\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_FATAL:\n\t\t\tPRINTF(\"%s: FATAL CONNECTION ERROR\\n\", isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\t/* no point continuing after this */\n\t\t\treturn (-1);\n\n\t\tcase ISP_CONN_LOOPBACK:\n\t\t\tPRINTF(\"%s: Looped Back in Point-to-Point mode\\n\",\n\t\t\t     isp->isp_name);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPRINTF(\"%s: unknown async code 0x%x\\n\", isp->isp_name, mbox);\n\t\tbreak;\n\t}\n\treturn (fast_post_handle);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_mark_getpdb_all"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_parse_async;\nstatic void isp_mark_getpdb_all;\n\nstatic int\nisp_parse_async(isp, mbox)\n\tstruct ispsoftc *isp;\n\tint mbox;\n{\n\tint bus;\n\tu_int32_t fast_post_handle = 0;\n\n\tif (IS_DUALBUS(isp)) {\n\t\tbus = ISP_READ(isp, OUTMAILBOX6);\n\t} else {\n\t\tbus = 0;\n\t}\n\n\tswitch (mbox) {\n\tcase MBOX_COMMAND_COMPLETE:\t/* sometimes these show up */\n\t\tbreak;\n\tcase ASYNC_BUS_RESET:\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tisp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\tbreak;\n\tcase ASYNC_SYSTEM_ERROR:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tPRINTF(\"%s: Internal FW Error @ RISC Addr 0x%x\\n\",\n\t\t    isp->isp_name, mbox);\n\t\tisp_restart(isp);\n\t\t/* no point continuing after this */\n\t\treturn (-1);\n\n\tcase ASYNC_RQS_XFER_ERR:\n\t\tPRINTF(\"%s: Request Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_RSP_XFER_ERR:\n\t\tPRINTF(\"%s: Response Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_QWAKEUP:\n\t\t/*\n\t\t * We've just been notified that the Queue has woken up.\n\t\t * We don't need to be chatty about this- just unlatch things\n\t\t * and move on.\n\t\t */\n\t\tmbox = ISP_READ(isp, OUTMAILBOX4);\n\t\tbreak;\n\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tPRINTF(\"%s: timeout initiated SCSI bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_DEVICE_RESET:\n\t\tPRINTF(\"%s: device reset on bus %d\\n\", isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_EXTMSG_UNDERRUN:\n\t\tPRINTF(\"%s: extended message underrun\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_SCAM_INT:\n\t\tPRINTF(\"%s: SCAM interrupt\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_HUNG_SCSI:\n\t\tPRINTF(\"%s: stalled SCSI Bus after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\t/* XXX: Need to issue SCSI reset at this point */\n\t\tbreak;\n\n\tcase ASYNC_KILLED_BUS:\n\t\tPRINTF(\"%s: SCSI Bus reset after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_BUS_TRANSIT:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX2);\n\t\tswitch (mbox & 0x1c00) {\n\t\tcase SXP_PINS_LVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to LVD mode\\n\", isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 1;\n\t\t\tbreak;\n\t\tcase SXP_PINS_HVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to Differential mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tcase SXP_PINS_SE_MODE:\n\t\t\tPRINTF(\"%s: Transition to Single Ended mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: Transition to unknown mode 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * XXX: Set up to renegotiate again!\n\t\t */\n\t\t/* Can only be for a 1080... */\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tbreak;\n\n\tcase ASYNC_CMD_CMPLT:\n\t\tfast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\tIDPRINTF(4, (\"%s: fast post completion of %u\\n\", isp->isp_name,\n\t\t    fast_post_handle));\n\t\tbreak;\n\n\tcase ASYNC_CTIO_DONE:\n\t\t/* Should only occur when Fast Posting Set for 2100s */\n\t\tPRINTF(\"%s: CTIO done\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq =\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp->isp_sendmarker = 1;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(1, (\"%s: LIP occurred\\n\", isp->isp_name));\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_UP:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_UP, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_DOWN, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_RESET:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tPRINTF(\"%s: Loop RESET\\n\", isp->isp_name);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_PDB_CHANGED:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(2, (\"%s: Port Database Changed\\n\", isp->isp_name));\n\t\tbreak;\n\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tisp_mark_getpdb_all(isp);\n\t\t/*\n\t\t * Not correct, but it will force us to rescan the loop.\n\t\t */\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_async(isp, ISPASYNC_CHANGE_NOTIFY, NULL);\n\t\tbreak;\n\n\tcase ASYNC_PTPMODE:\n\t\tPRINTF(\"%s: Point-to-Point mode\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_CONNMODE:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tswitch (mbox) {\n\t\tcase ISP_CONN_LOOP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_PTP:\n\t\t\tPRINTF(\"%s: Loop -> Point-to-Point mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_BADLIP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode (1)\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_FATAL:\n\t\t\tPRINTF(\"%s: FATAL CONNECTION ERROR\\n\", isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\t/* no point continuing after this */\n\t\t\treturn (-1);\n\n\t\tcase ISP_CONN_LOOPBACK:\n\t\t\tPRINTF(\"%s: Looped Back in Point-to-Point mode\\n\",\n\t\t\t     isp->isp_name);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPRINTF(\"%s: unknown async code 0x%x\\n\", isp->isp_name, mbox);\n\t\tbreak;\n\t}\n\treturn (fast_post_handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_mboxcmd timeout #4\\n\"",
            "isp->isp_name"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_mboxcmd timeout #3\\n\"",
            "isp->isp_name"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_SEMA"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_mboxcmd timeout #2\\n\"",
            "isp->isp_name"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "HCCR"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_SET_HOST_INT"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX0",
            "mbp->param[0]"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX1",
            "mbp->param[1]"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX2",
            "mbp->param[2]"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX3",
            "mbp->param[3]"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX4",
            "mbp->param[4]"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX5",
            "mbp->param[5]"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX6",
            "mbp->param[6]"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX7",
            "mbp->param[7]"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX2",
            "mbp->param[2]"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX6",
            "mbp->param[6]"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX7",
            "mbp->param[7]"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\"",
            "isp->isp_name"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "5",
            "(\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox)"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "5",
            "(\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph)"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_SEMA"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "HCCR"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "1"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: no parameters for %x\\n\"",
            "isp->isp_name",
            "mbp->param[0]"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LONIB",
          "args": [
            "mbpcnt[mbp->param[0]]"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HINIB",
          "args": [
            "mbpcnt[mbp->param[0]]"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad command %x\\n\"",
            "isp->isp_name",
            "mbp->param[0]"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "isp_fastpost_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "3087-3118",
    "snippet": "static void\nisp_fastpost_complete(isp, fph)\n\tstruct ispsoftc *isp;\n\tu_int32_t fph;\n{\n\tISP_SCSI_XFER_T *xs;\n\n\tif (fph < 1) {\n\t\treturn;\n\t}\n\txs = isp_find_xs(isp, fph);\n\tif (xs == NULL) {\n\t\tPRINTF(\"%s: command for fast posting handle 0x%x not found\\n\",\n\t\t    isp->isp_name, fph);\n\t\treturn;\n\t}\n\tisp_destroy_handle(isp, fph);\n\n\t/*\n\t * Since we don't have a result queue entry item,\n\t * we must believe that SCSI status is zero and\n\t * that all data transferred.\n\t */\n\tXS_RESID(xs) = 0;\n\tXS_STS(xs) = 0;\n\tif (XS_XFRLEN(xs)) {\n\t\tISP_DMAFREE(isp, xs, fph);\n\t}\n\tXS_CMD_DONE(xs);\n\tif (isp->isp_nactive)\n\t\tisp->isp_nactive--;\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_fastpost_complete"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XS_CMD_DONE",
          "args": [
            "xs"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_DMAFREE",
          "args": [
            "isp",
            "xs",
            "fph"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_XFRLEN",
          "args": [
            "xs"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_destroy_handle",
          "args": [
            "isp",
            "fph"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "isp_destroy_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "237-245",
          "snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: command for fast posting handle 0x%x not found\\n\"",
            "isp->isp_name",
            "fph"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_find_xs",
          "args": [
            "isp",
            "fph"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "isp_find_xs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "209-219",
          "snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fastpost_complete;\n\nstatic void\nisp_fastpost_complete(isp, fph)\n\tstruct ispsoftc *isp;\n\tu_int32_t fph;\n{\n\tISP_SCSI_XFER_T *xs;\n\n\tif (fph < 1) {\n\t\treturn;\n\t}\n\txs = isp_find_xs(isp, fph);\n\tif (xs == NULL) {\n\t\tPRINTF(\"%s: command for fast posting handle 0x%x not found\\n\",\n\t\t    isp->isp_name, fph);\n\t\treturn;\n\t}\n\tisp_destroy_handle(isp, fph);\n\n\t/*\n\t * Since we don't have a result queue entry item,\n\t * we must believe that SCSI status is zero and\n\t * that all data transferred.\n\t */\n\tXS_RESID(xs) = 0;\n\tXS_STS(xs) = 0;\n\tif (XS_XFRLEN(xs)) {\n\t\tISP_DMAFREE(isp, xs, fph);\n\t}\n\tXS_CMD_DONE(xs);\n\tif (isp->isp_nactive)\n\t\tisp->isp_nactive--;\n}"
  },
  {
    "function_name": "isp_parse_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "2835-3085",
    "snippet": "static void\nisp_parse_status(isp, sp, xs)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tswitch (sp->req_completion_status) {\n\tcase RQCS_COMPLETE:\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_INCOMPLETE:\n\t\tif ((sp->req_state_flags & RQSF_GOT_TARGET) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: Selection Timeout for %d.%d.%d\\n\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_CHANNEL(xs)));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn;\n\t\t}\n\t\tPRINTF(\"%s: command incomplete for %d.%d.%d, state 0x%x\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),\n\t\t    sp->req_state_flags);\n\t\tbreak;\n\n\tcase RQCS_DMA_ERROR:\n\t\tPRINTF(\"%s: DMA error for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_TRANSPORT_ERROR:\n\t\tPRINTF(\"%s: transport error for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp_prtstst(sp);\n\t\tbreak;\n\n\tcase RQCS_RESET_OCCURRED:\n\t\tIDPRINTF(1, (\"%s: bus reset destroyed command for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\treturn;\n\n\tcase RQCS_ABORTED:\n\t\tPRINTF(\"%s: command aborted for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_ABORTED);\n\t\treturn;\n\n\tcase RQCS_TIMEOUT:\n\t\tIDPRINTF(2, (\"%s: command timed out for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tXS_SETERR(xs, HBA_CMDTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_DATA_OVERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: data overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tXS_SETERR(xs, HBA_DATAOVR);\n\t\treturn;\n\n\tcase RQCS_COMMAND_OVERRUN:\n\t\tPRINTF(\"%s: command overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_STATUS_OVERRUN:\n\t\tPRINTF(\"%s: status overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_MESSAGE:\n\t\tPRINTF(\"%s: msg not COMMAND COMPLETE after status %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NO_MESSAGE_OUT:\n\t\tPRINTF(\"%s: No MESSAGE OUT phase after selection on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_EXT_ID_FAILED:\n\t\tPRINTF(\"%s: EXTENDED IDENTIFY failed %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_IDE_MSG_FAILED:\n\t\tPRINTF(\"%s: INITIATOR DETECTED ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ABORT_MSG_FAILED:\n\t\tPRINTF(\"%s: ABORT OPERATION rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_REJECT_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE REJECT rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NOP_MSG_FAILED:\n\t\tPRINTF(\"%s: NOP rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_PARITY_ERROR_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE PARITY ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DEVICE_RESET_MSG_FAILED:\n\t\tPRINTF(\"%s: BUS DEVICE RESET rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ID_MSG_FAILED:\n\t\tPRINTF(\"%s: IDENTIFY rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_UNEXP_BUS_FREE:\n\t\tPRINTF(\"%s: %d.%d.%d had an unexpected bus free\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DATA_UNDERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_XACT_ERR1:\n\t\tPRINTF(\"%s: HBA attempted queued transaction with disconnect \"\n\t\t    \"not set for %d.%d.%d\\n\", isp->isp_name, XS_CHANNEL(xs),\n\t\t    XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR2:\n\t\tPRINTF(\"%s: HBA attempted queued transaction to target \"\n\t\t    \"routine %d on target %d, bus %d\\n\", isp->isp_name,\n\t\t    XS_LUN(xs), XS_TGT(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR3:\n\t\tPRINTF(\"%s: HBA attempted queued transaction for target %d lun \"\n\t\t    \"%d on bus %d when queueing disabled\\n\", isp->isp_name,\n\t\t    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_ENTRY:\n\t\tPRINTF(\"%s: invalid IOCB entry type detected\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase RQCS_QUEUE_FULL:\n\t\tIDPRINTF(3, (\"%s: internal queues full for target %d lun %d \"\n\t\t    \"bus %d, status 0x%x\\n\", isp->isp_name, XS_TGT(xs),\n\t\t    XS_LUN(xs), XS_CHANNEL(xs), XS_STS(xs)));\n\t\t/*\n\t\t * If QFULL or some other status byte is set, then this\n\t\t * isn't an error, per se.\n\t\t */\n\t\tif (XS_STS(xs) != 0) {\n\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_PHASE_SKIPPED:\n\t\tPRINTF(\"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o \"\n\t\t    \"STATUS phase) for target %d lun %d bus %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_ARQS_FAILED:\n\t\tPRINTF(\"%s: Auto Request Sense failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\treturn;\n\n\tcase RQCS_WIDE_FAILED:\n\t\tPRINTF(\"%s: Wide Negotiation failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_WIDE;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_SYNCXFER_FAILED:\n\t\tPRINTF(\"%s: SDTR Message failed for target %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_SYNC;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_LVD_BUSERR:\n\t\tPRINTF(\"%s: Bad LVD condition while talking to %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_PORT_UNAVAILABLE:\n\t\t/*\n\t\t * No such port on the loop. Moral equivalent of SELTIMEO\n\t\t */\n\t\tIDPRINTF(3, (\"%s: Port Unavailable for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_LOGGED_OUT:\n\t\t/*\n\t\t * It was there (maybe)- treat as a selection timeout.\n\t\t */\n\t\tIDPRINTF(2, (\"%s: port logout for target %d\\n\",\n\t\t\tisp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_CHANGED:\n\t\tPRINTF(\"%s: port changed for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_BUSY:\n\t\tPRINTF(\"%s: port busy for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\treturn;\n\n\tdefault:\n\t\tPRINTF(\"%s: completion status 0x%x\\n\",\n\t\t    isp->isp_name, sp->req_completion_status);\n\t\tbreak;\n\t}\n\tXS_SETERR(xs, HBA_BOTCH);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_parse_status",
      "static void isp_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: completion status 0x%x\\n\"",
            "isp->isp_name",
            "sp->req_completion_status"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_TGTBSY"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: port busy for target %d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: port changed for target %d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"%s: port logout for target %d\\n\",\n\t\t\tisp->isp_name, XS_TGT(xs))"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: Port Unavailable for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs))"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Bad LVD condition while talking to %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "XS_CHANNEL(xs)"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: SDTR Message failed for target %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "XS_CHANNEL(xs)"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_NOERROR"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Wide Negotiation failed for %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "XS_CHANNEL(xs)"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Auto Request Sense failed for %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "XS_CHANNEL(xs)"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o \"\n\t\t    \"STATUS phase) for target %d lun %d bus %d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "XS_CHANNEL(xs)"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_NOERROR"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: internal queues full for target %d lun %d \"\n\t\t    \"bus %d, status 0x%x\\n\", isp->isp_name, XS_TGT(xs),\n\t\t    XS_LUN(xs), XS_CHANNEL(xs), XS_STS(xs))"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: invalid IOCB entry type detected\\n\"",
            "isp->isp_name"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: HBA attempted queued transaction for target %d lun \"\n\t\t    \"%d on bus %d when queueing disabled\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "XS_CHANNEL(xs)"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: HBA attempted queued transaction to target \"\n\t\t    \"routine %d on target %d, bus %d\\n\"",
            "isp->isp_name",
            "XS_LUN(xs)",
            "XS_TGT(xs)",
            "XS_CHANNEL(xs)"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: HBA attempted queued transaction with disconnect \"\n\t\t    \"not set for %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_NOERROR"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: %d.%d.%d had an unexpected bus free\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: IDENTIFY rejected by %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: BUS DEVICE RESET rejected by %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: MESSAGE PARITY ERROR rejected by %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: NOP rejected by %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: MESSAGE REJECT rejected by %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ABORT OPERATION rejected by %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: INITIATOR DETECTED ERROR rejected by %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: EXTENDED IDENTIFY failed %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: No MESSAGE OUT phase after selection on %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: msg not COMMAND COMPLETE after status %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: status overrun for command on %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: command overrun for command on %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_DATAOVR"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: data overrun for command on %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_CMDTIMEOUT"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"%s: command timed out for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs))"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_ABORTED"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: command aborted for %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BUSRESET"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: bus reset destroyed command for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs))"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_prtstst",
          "args": [
            "sp"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "isp_prtstst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "45-116",
          "snippet": "static INLINE void\nisp_prtstst(sp)\n\tispstatusreq_t *sp;\n{\n\tchar buf[172], *p = buf;\n\tsprintf(p, \"states->\");\n\tif (sp->req_state_flags & RQSF_GOT_BUS) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_BUS \");\n\t}\n\tif (sp->req_state_flags & RQSF_GOT_TARGET) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_TGT \");\n\t}\n\tif (sp->req_state_flags & RQSF_SENT_CDB) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"SENT_CDB \");\n\t}\n\tif (sp->req_state_flags & RQSF_XFRD_DATA) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"XFRD_DATA \");\n\t}\n\tif (sp->req_state_flags & RQSF_GOT_STATUS) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_STS \");\n\t}\n\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_SNS \");\n\t}\n\tif (sp->req_state_flags & RQSF_XFER_COMPLETE) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"XFR_CMPLT \");\n\t}\n\tp += strlen(p);\n\tsprintf(p, \"%s%s\", buf, \"\\n\");\n\tp += strlen(p);\n\tsprintf(p, \"%s%s\", buf, \"status->\");\n\tif (sp->req_status_flags & RQSTF_DISCONNECT) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Disconnect \");\n\t}\n\tif (sp->req_status_flags & RQSTF_SYNCHRONOUS) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Sync_xfr \");\n\t}\n\tif (sp->req_status_flags & RQSTF_PARITY_ERROR) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Parity \");\n\t}\n\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Bus_Reset \");\n\t}\n\tif (sp->req_status_flags & RQSTF_DEVICE_RESET) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Device_Reset \");\n\t}\n\tif (sp->req_status_flags & RQSTF_ABORTED) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Aborted \");\n\t}\n\tif (sp->req_status_flags & RQSTF_TIMEOUT) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Timeout \");\n\t}\n\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Negotiation \");\n\t}\n\tPRINTF(buf, \"%s\\n\", buf);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE void\nisp_prtstst(sp)\n\tispstatusreq_t *sp;\n{\n\tchar buf[172], *p = buf;\n\tsprintf(p, \"states->\");\n\tif (sp->req_state_flags & RQSF_GOT_BUS) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_BUS \");\n\t}\n\tif (sp->req_state_flags & RQSF_GOT_TARGET) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_TGT \");\n\t}\n\tif (sp->req_state_flags & RQSF_SENT_CDB) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"SENT_CDB \");\n\t}\n\tif (sp->req_state_flags & RQSF_XFRD_DATA) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"XFRD_DATA \");\n\t}\n\tif (sp->req_state_flags & RQSF_GOT_STATUS) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_STS \");\n\t}\n\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"GOT_SNS \");\n\t}\n\tif (sp->req_state_flags & RQSF_XFER_COMPLETE) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"XFR_CMPLT \");\n\t}\n\tp += strlen(p);\n\tsprintf(p, \"%s%s\", buf, \"\\n\");\n\tp += strlen(p);\n\tsprintf(p, \"%s%s\", buf, \"status->\");\n\tif (sp->req_status_flags & RQSTF_DISCONNECT) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Disconnect \");\n\t}\n\tif (sp->req_status_flags & RQSTF_SYNCHRONOUS) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Sync_xfr \");\n\t}\n\tif (sp->req_status_flags & RQSTF_PARITY_ERROR) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Parity \");\n\t}\n\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Bus_Reset \");\n\t}\n\tif (sp->req_status_flags & RQSTF_DEVICE_RESET) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Device_Reset \");\n\t}\n\tif (sp->req_status_flags & RQSTF_ABORTED) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Aborted \");\n\t}\n\tif (sp->req_status_flags & RQSTF_TIMEOUT) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Timeout \");\n\t}\n\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\tp += strlen(p);\n\t\tsprintf(p, \"%s%s\", buf, \"Negotiation \");\n\t}\n\tPRINTF(buf, \"%s\\n\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: transport error for %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: DMA error for command on %d.%d.%d\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: command incomplete for %d.%d.%d, state 0x%x\\n\"",
            "isp->isp_name",
            "XS_CHANNEL(xs)",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "sp->req_state_flags"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: Selection Timeout for %d.%d.%d\\n\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_CHANNEL(xs))"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_NOERROR"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_parse_status;\nstatic void isp_update;\n\nstatic void\nisp_parse_status(isp, sp, xs)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tswitch (sp->req_completion_status) {\n\tcase RQCS_COMPLETE:\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_INCOMPLETE:\n\t\tif ((sp->req_state_flags & RQSF_GOT_TARGET) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: Selection Timeout for %d.%d.%d\\n\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_CHANNEL(xs)));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn;\n\t\t}\n\t\tPRINTF(\"%s: command incomplete for %d.%d.%d, state 0x%x\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),\n\t\t    sp->req_state_flags);\n\t\tbreak;\n\n\tcase RQCS_DMA_ERROR:\n\t\tPRINTF(\"%s: DMA error for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_TRANSPORT_ERROR:\n\t\tPRINTF(\"%s: transport error for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp_prtstst(sp);\n\t\tbreak;\n\n\tcase RQCS_RESET_OCCURRED:\n\t\tIDPRINTF(1, (\"%s: bus reset destroyed command for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\treturn;\n\n\tcase RQCS_ABORTED:\n\t\tPRINTF(\"%s: command aborted for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_ABORTED);\n\t\treturn;\n\n\tcase RQCS_TIMEOUT:\n\t\tIDPRINTF(2, (\"%s: command timed out for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tXS_SETERR(xs, HBA_CMDTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_DATA_OVERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: data overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tXS_SETERR(xs, HBA_DATAOVR);\n\t\treturn;\n\n\tcase RQCS_COMMAND_OVERRUN:\n\t\tPRINTF(\"%s: command overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_STATUS_OVERRUN:\n\t\tPRINTF(\"%s: status overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_MESSAGE:\n\t\tPRINTF(\"%s: msg not COMMAND COMPLETE after status %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NO_MESSAGE_OUT:\n\t\tPRINTF(\"%s: No MESSAGE OUT phase after selection on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_EXT_ID_FAILED:\n\t\tPRINTF(\"%s: EXTENDED IDENTIFY failed %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_IDE_MSG_FAILED:\n\t\tPRINTF(\"%s: INITIATOR DETECTED ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ABORT_MSG_FAILED:\n\t\tPRINTF(\"%s: ABORT OPERATION rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_REJECT_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE REJECT rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NOP_MSG_FAILED:\n\t\tPRINTF(\"%s: NOP rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_PARITY_ERROR_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE PARITY ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DEVICE_RESET_MSG_FAILED:\n\t\tPRINTF(\"%s: BUS DEVICE RESET rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ID_MSG_FAILED:\n\t\tPRINTF(\"%s: IDENTIFY rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_UNEXP_BUS_FREE:\n\t\tPRINTF(\"%s: %d.%d.%d had an unexpected bus free\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DATA_UNDERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_XACT_ERR1:\n\t\tPRINTF(\"%s: HBA attempted queued transaction with disconnect \"\n\t\t    \"not set for %d.%d.%d\\n\", isp->isp_name, XS_CHANNEL(xs),\n\t\t    XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR2:\n\t\tPRINTF(\"%s: HBA attempted queued transaction to target \"\n\t\t    \"routine %d on target %d, bus %d\\n\", isp->isp_name,\n\t\t    XS_LUN(xs), XS_TGT(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR3:\n\t\tPRINTF(\"%s: HBA attempted queued transaction for target %d lun \"\n\t\t    \"%d on bus %d when queueing disabled\\n\", isp->isp_name,\n\t\t    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_ENTRY:\n\t\tPRINTF(\"%s: invalid IOCB entry type detected\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase RQCS_QUEUE_FULL:\n\t\tIDPRINTF(3, (\"%s: internal queues full for target %d lun %d \"\n\t\t    \"bus %d, status 0x%x\\n\", isp->isp_name, XS_TGT(xs),\n\t\t    XS_LUN(xs), XS_CHANNEL(xs), XS_STS(xs)));\n\t\t/*\n\t\t * If QFULL or some other status byte is set, then this\n\t\t * isn't an error, per se.\n\t\t */\n\t\tif (XS_STS(xs) != 0) {\n\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_PHASE_SKIPPED:\n\t\tPRINTF(\"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o \"\n\t\t    \"STATUS phase) for target %d lun %d bus %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_ARQS_FAILED:\n\t\tPRINTF(\"%s: Auto Request Sense failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\treturn;\n\n\tcase RQCS_WIDE_FAILED:\n\t\tPRINTF(\"%s: Wide Negotiation failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_WIDE;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_SYNCXFER_FAILED:\n\t\tPRINTF(\"%s: SDTR Message failed for target %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_SYNC;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_LVD_BUSERR:\n\t\tPRINTF(\"%s: Bad LVD condition while talking to %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_PORT_UNAVAILABLE:\n\t\t/*\n\t\t * No such port on the loop. Moral equivalent of SELTIMEO\n\t\t */\n\t\tIDPRINTF(3, (\"%s: Port Unavailable for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_LOGGED_OUT:\n\t\t/*\n\t\t * It was there (maybe)- treat as a selection timeout.\n\t\t */\n\t\tIDPRINTF(2, (\"%s: port logout for target %d\\n\",\n\t\t\tisp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_CHANGED:\n\t\tPRINTF(\"%s: port changed for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_BUSY:\n\t\tPRINTF(\"%s: port busy for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\treturn;\n\n\tdefault:\n\t\tPRINTF(\"%s: completion status 0x%x\\n\",\n\t\t    isp->isp_name, sp->req_completion_status);\n\t\tbreak;\n\t}\n\tXS_SETERR(xs, HBA_BOTCH);\n}"
  },
  {
    "function_name": "isp_handle_other_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "2805-2833",
    "snippet": "static int\nisp_handle_other_response(isp, sp, optrp)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tu_int16_t *optrp;\n{\n\tswitch (sp->req_header.rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\tcase RQSTYPE_CTIO:\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\tcase RQSTYPE_NOTIFY:\n\tcase RQSTYPE_NOTIFY_ACK:\n\tcase RQSTYPE_CTIO1:\n\tcase RQSTYPE_ATIO2:\n\tcase RQSTYPE_CTIO2:\n\tcase RQSTYPE_CTIO3:\n#ifdef\tISP_TARGET_MODE\n\t\treturn (isp_target_notify(isp, sp, optrp));\n#else\n\t\t/* FALLTHROUGH */\n#endif\n\tcase RQSTYPE_REQUEST:\n\tdefault:\n\t\tPRINTF(\"%s: unhandled response type 0x%x\\n\", isp->isp_name,\n\t\t    sp->req_header.rqs_entry_type);\n\t\treturn (-1);\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_handle_other_response"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: unhandled response type 0x%x\\n\"",
            "isp->isp_name",
            "sp->req_header.rqs_entry_type"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_target_notify",
          "args": [
            "isp",
            "sp",
            "optrp"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "isp_target_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "108-254",
          "snippet": "int\nisp_target_notify(isp, vptr, optrp)\n\tstruct ispsoftc *isp;\n\tvoid *vptr;\n\tu_int16_t *optrp;\n{\n\tu_int16_t status, seqid;\n\tunion {\n\t\tat_entry_t\t*atiop;\n\t\tat2_entry_t\t*at2iop;\n\t\tct_entry_t\t*ctiop;\n\t\tct2_entry_t\t*ct2iop;\n\t\tlun_entry_t\t*lunenp;\n\t\tin_entry_t\t*inotp;\n\t\tin_fcentry_t\t*inot_fcp;\n\t\tna_entry_t\t*nackp;\n\t\tna_fcentry_t\t*nack_fcp;\n\t\tisphdr_t\t*hp;\n\t\tvoid *\t\t*vp;\n#define\tatiop\t\tunp.atiop\n#define\tat2iop\t\tunp.at2iop\n#define\tctiop\t\tunp.ctiop\n#define\tct2iop\t\tunp.ct2iop\n#define\tlunenp\t\tunp.lunenp\n#define\tinotp\t\tunp.inotp\n#define\tinot_fcp\tunp.inot_fcp\n#define\tnackp\t\tunp.nackp\n#define\tnack_fcp\tunp.nack_fcp\n#define\thdrp\t\tunp.hp\n\t} unp;\n\tint bus, rval = 0;\n\n\tunp.vp = vptr;\n\n\tISP_TDQE(isp, \"isp_target_notify\", (int) *optrp, vptr);\n\n\tswitch(hdrp->rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\t\tisp_handle_atio(isp, atiop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tisp_handle_ctio(isp, ctiop);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tisp_handle_atio2(isp, at2iop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tisp_handle_ctio2(isp, ct2iop);\n\t\tbreak;\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY:\n\t\t/*\n\t\t * Either the ISP received a SCSI message it can't\n\t\t * handle, or it's returning an Immed. Notify entry\n\t\t * we sent. We can send Immed. Notify entries to\n\t\t * increment the firmware's resource count for them\n\t\t * (we set this initially in the Enable Lun entry).\n\t\t */\n\t\tbus = 0;\n\t\tif (IS_FC(isp)) {\n\t\t\tstatus = inot_fcp->in_status;\n\t\t\tseqid = inot_fcp->in_seqid;\n\t\t} else {\n\t\t\tstatus = inotp->in_status & 0xff;\n\t\t\tseqid = inotp->in_seqid;\n\t\t\tif (IS_DUALBUS(isp)) {\n\t\t\t\tbus = (inotp->in_iid & 0x80) >> 7;\n\t\t\t\tinotp->in_iid &= ~0x80;\n\t\t\t}\n\t\t}\n\t\tITDEBUG(2, (\"isp_target_notify: Immediate Notify, \"\n\t\t    \"status=0x%x seqid=0x%x\\n\", status, seqid));\n\t\tswitch (status) {\n\t\tcase IN_RESET:\n\t\t\t(void) isp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\t\tbreak;\n\t\tcase IN_MSG_RECEIVED:\n\t\tcase IN_IDE_RECEIVED:\n\t\t\tif (IS_FC(isp)) {\n\t\t\t\tisp_got_msg_fc(isp, bus, vptr);\n\t\t\t} else {\n\t\t\t\tisp_got_msg(isp, bus, vptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IN_RSRC_UNAVAIL:\n\t\t\tPRINTF(\"%s: Firmware out of ATIOs\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tcase IN_ABORT_TASK:\n\t\t\tPRINTF(\"%s: Abort Task for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_LOGOUT:\n\t\t\tPRINTF(\"%s: Port Logout for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_CHANGED:\n\t\t\tPRINTF(\"%s: Port Changed for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_GLOBAL_LOGO:\n\t\t\tPRINTF(\"%s: All ports logged out\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: bad status (0x%x) in isp_target_notify\\n\",\n\t\t\t    isp->isp_name, status);\n\t\t\tbreak;\n\t\t}\n\t\tisp_notify_ack(isp, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY_ACK:\n\t\t/*\n\t\t * The ISP is acknowledging our acknowledgement of an\n\t\t * Immediate Notify entry for some asynchronous event.\n\t\t */\n\t\tif (IS_FC(isp)) {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack status=0x%x seqid 0x%x\\n\",\n\t\t\t    isp->isp_name, nack_fcp->na_status,\n\t\t\t    nack_fcp->na_seqid));\n\t\t} else {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack event 0x%x status=0x%x \"\n\t\t\t    \"seqid 0x%x\\n\", isp->isp_name, nackp->na_event,\n\t\t\t    nackp->na_status, nackp->na_seqid));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown entry type 0x%x in isp_target_notify\",\n\t\t    isp->isp_name, hdrp->rqs_entry_type);\n\t\trval = -1;\n\t\tbreak;\n\t}\n#undef\tatiop\n#undef\tat2iop\n#undef\tctiop\n#undef\tct2iop\n#undef\tlunenp\n#undef\tinotp\n#undef\tinot_fcp\n#undef\tnackp\n#undef\tnack_fcp\n#undef\thdrp\n\treturn (rval);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\thdrp\t\tunp.hp",
            "#define\tnack_fcp\tunp.nack_fcp",
            "#define\tnackp\t\tunp.nackp",
            "#define\tinot_fcp\tunp.inot_fcp",
            "#define\tinotp\t\tunp.inotp",
            "#define\tlunenp\t\tunp.lunenp",
            "#define\tct2iop\t\tunp.ct2iop",
            "#define\tctiop\t\tunp.ctiop",
            "#define\tat2iop\t\tunp.at2iop",
            "#define\tatiop\t\tunp.atiop"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\thdrp\t\tunp.hp\n#define\tnack_fcp\tunp.nack_fcp\n#define\tnackp\t\tunp.nackp\n#define\tinot_fcp\tunp.inot_fcp\n#define\tinotp\t\tunp.inotp\n#define\tlunenp\t\tunp.lunenp\n#define\tct2iop\t\tunp.ct2iop\n#define\tctiop\t\tunp.ctiop\n#define\tat2iop\t\tunp.at2iop\n#define\tatiop\t\tunp.atiop\n\nint\nisp_target_notify(isp, vptr, optrp)\n\tstruct ispsoftc *isp;\n\tvoid *vptr;\n\tu_int16_t *optrp;\n{\n\tu_int16_t status, seqid;\n\tunion {\n\t\tat_entry_t\t*atiop;\n\t\tat2_entry_t\t*at2iop;\n\t\tct_entry_t\t*ctiop;\n\t\tct2_entry_t\t*ct2iop;\n\t\tlun_entry_t\t*lunenp;\n\t\tin_entry_t\t*inotp;\n\t\tin_fcentry_t\t*inot_fcp;\n\t\tna_entry_t\t*nackp;\n\t\tna_fcentry_t\t*nack_fcp;\n\t\tisphdr_t\t*hp;\n\t\tvoid *\t\t*vp;\n#define\tatiop\t\tunp.atiop\n#define\tat2iop\t\tunp.at2iop\n#define\tctiop\t\tunp.ctiop\n#define\tct2iop\t\tunp.ct2iop\n#define\tlunenp\t\tunp.lunenp\n#define\tinotp\t\tunp.inotp\n#define\tinot_fcp\tunp.inot_fcp\n#define\tnackp\t\tunp.nackp\n#define\tnack_fcp\tunp.nack_fcp\n#define\thdrp\t\tunp.hp\n\t} unp;\n\tint bus, rval = 0;\n\n\tunp.vp = vptr;\n\n\tISP_TDQE(isp, \"isp_target_notify\", (int) *optrp, vptr);\n\n\tswitch(hdrp->rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\t\tisp_handle_atio(isp, atiop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tisp_handle_ctio(isp, ctiop);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tisp_handle_atio2(isp, at2iop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tisp_handle_ctio2(isp, ct2iop);\n\t\tbreak;\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY:\n\t\t/*\n\t\t * Either the ISP received a SCSI message it can't\n\t\t * handle, or it's returning an Immed. Notify entry\n\t\t * we sent. We can send Immed. Notify entries to\n\t\t * increment the firmware's resource count for them\n\t\t * (we set this initially in the Enable Lun entry).\n\t\t */\n\t\tbus = 0;\n\t\tif (IS_FC(isp)) {\n\t\t\tstatus = inot_fcp->in_status;\n\t\t\tseqid = inot_fcp->in_seqid;\n\t\t} else {\n\t\t\tstatus = inotp->in_status & 0xff;\n\t\t\tseqid = inotp->in_seqid;\n\t\t\tif (IS_DUALBUS(isp)) {\n\t\t\t\tbus = (inotp->in_iid & 0x80) >> 7;\n\t\t\t\tinotp->in_iid &= ~0x80;\n\t\t\t}\n\t\t}\n\t\tITDEBUG(2, (\"isp_target_notify: Immediate Notify, \"\n\t\t    \"status=0x%x seqid=0x%x\\n\", status, seqid));\n\t\tswitch (status) {\n\t\tcase IN_RESET:\n\t\t\t(void) isp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\t\tbreak;\n\t\tcase IN_MSG_RECEIVED:\n\t\tcase IN_IDE_RECEIVED:\n\t\t\tif (IS_FC(isp)) {\n\t\t\t\tisp_got_msg_fc(isp, bus, vptr);\n\t\t\t} else {\n\t\t\t\tisp_got_msg(isp, bus, vptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IN_RSRC_UNAVAIL:\n\t\t\tPRINTF(\"%s: Firmware out of ATIOs\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tcase IN_ABORT_TASK:\n\t\t\tPRINTF(\"%s: Abort Task for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_LOGOUT:\n\t\t\tPRINTF(\"%s: Port Logout for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_CHANGED:\n\t\t\tPRINTF(\"%s: Port Changed for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_GLOBAL_LOGO:\n\t\t\tPRINTF(\"%s: All ports logged out\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: bad status (0x%x) in isp_target_notify\\n\",\n\t\t\t    isp->isp_name, status);\n\t\t\tbreak;\n\t\t}\n\t\tisp_notify_ack(isp, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY_ACK:\n\t\t/*\n\t\t * The ISP is acknowledging our acknowledgement of an\n\t\t * Immediate Notify entry for some asynchronous event.\n\t\t */\n\t\tif (IS_FC(isp)) {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack status=0x%x seqid 0x%x\\n\",\n\t\t\t    isp->isp_name, nack_fcp->na_status,\n\t\t\t    nack_fcp->na_seqid));\n\t\t} else {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack event 0x%x status=0x%x \"\n\t\t\t    \"seqid 0x%x\\n\", isp->isp_name, nackp->na_event,\n\t\t\t    nackp->na_status, nackp->na_seqid));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown entry type 0x%x in isp_target_notify\",\n\t\t    isp->isp_name, hdrp->rqs_entry_type);\n\t\trval = -1;\n\t\tbreak;\n\t}\n#undef\tatiop\n#undef\tat2iop\n#undef\tctiop\n#undef\tct2iop\n#undef\tlunenp\n#undef\tinotp\n#undef\tinot_fcp\n#undef\tnackp\n#undef\tnack_fcp\n#undef\thdrp\n\treturn (rval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_handle_other_response;\n\nstatic int\nisp_handle_other_response(isp, sp, optrp)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tu_int16_t *optrp;\n{\n\tswitch (sp->req_header.rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\tcase RQSTYPE_CTIO:\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\tcase RQSTYPE_NOTIFY:\n\tcase RQSTYPE_NOTIFY_ACK:\n\tcase RQSTYPE_CTIO1:\n\tcase RQSTYPE_ATIO2:\n\tcase RQSTYPE_CTIO2:\n\tcase RQSTYPE_CTIO3:\n#ifdef\tISP_TARGET_MODE\n\t\treturn (isp_target_notify(isp, sp, optrp));\n#else\n\t\t/* FALLTHROUGH */\n#endif\n\tcase RQSTYPE_REQUEST:\n\tdefault:\n\t\tPRINTF(\"%s: unhandled response type 0x%x\\n\", isp->isp_name,\n\t\t    sp->req_header.rqs_entry_type);\n\t\treturn (-1);\n\t}\n}"
  },
  {
    "function_name": "isp_parse_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "2567-2797",
    "snippet": "static int\nisp_parse_async(isp, mbox)\n\tstruct ispsoftc *isp;\n\tint mbox;\n{\n\tint bus;\n\tu_int32_t fast_post_handle = 0;\n\n\tif (IS_DUALBUS(isp)) {\n\t\tbus = ISP_READ(isp, OUTMAILBOX6);\n\t} else {\n\t\tbus = 0;\n\t}\n\n\tswitch (mbox) {\n\tcase MBOX_COMMAND_COMPLETE:\t/* sometimes these show up */\n\t\tbreak;\n\tcase ASYNC_BUS_RESET:\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tisp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\tbreak;\n\tcase ASYNC_SYSTEM_ERROR:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tPRINTF(\"%s: Internal FW Error @ RISC Addr 0x%x\\n\",\n\t\t    isp->isp_name, mbox);\n\t\tisp_restart(isp);\n\t\t/* no point continuing after this */\n\t\treturn (-1);\n\n\tcase ASYNC_RQS_XFER_ERR:\n\t\tPRINTF(\"%s: Request Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_RSP_XFER_ERR:\n\t\tPRINTF(\"%s: Response Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_QWAKEUP:\n\t\t/*\n\t\t * We've just been notified that the Queue has woken up.\n\t\t * We don't need to be chatty about this- just unlatch things\n\t\t * and move on.\n\t\t */\n\t\tmbox = ISP_READ(isp, OUTMAILBOX4);\n\t\tbreak;\n\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tPRINTF(\"%s: timeout initiated SCSI bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_DEVICE_RESET:\n\t\tPRINTF(\"%s: device reset on bus %d\\n\", isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_EXTMSG_UNDERRUN:\n\t\tPRINTF(\"%s: extended message underrun\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_SCAM_INT:\n\t\tPRINTF(\"%s: SCAM interrupt\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_HUNG_SCSI:\n\t\tPRINTF(\"%s: stalled SCSI Bus after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\t/* XXX: Need to issue SCSI reset at this point */\n\t\tbreak;\n\n\tcase ASYNC_KILLED_BUS:\n\t\tPRINTF(\"%s: SCSI Bus reset after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_BUS_TRANSIT:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX2);\n\t\tswitch (mbox & 0x1c00) {\n\t\tcase SXP_PINS_LVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to LVD mode\\n\", isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 1;\n\t\t\tbreak;\n\t\tcase SXP_PINS_HVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to Differential mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tcase SXP_PINS_SE_MODE:\n\t\t\tPRINTF(\"%s: Transition to Single Ended mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: Transition to unknown mode 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * XXX: Set up to renegotiate again!\n\t\t */\n\t\t/* Can only be for a 1080... */\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tbreak;\n\n\tcase ASYNC_CMD_CMPLT:\n\t\tfast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\tIDPRINTF(4, (\"%s: fast post completion of %u\\n\", isp->isp_name,\n\t\t    fast_post_handle));\n\t\tbreak;\n\n\tcase ASYNC_CTIO_DONE:\n\t\t/* Should only occur when Fast Posting Set for 2100s */\n\t\tPRINTF(\"%s: CTIO done\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq =\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp->isp_sendmarker = 1;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(1, (\"%s: LIP occurred\\n\", isp->isp_name));\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_UP:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_UP, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_DOWN, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_RESET:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tPRINTF(\"%s: Loop RESET\\n\", isp->isp_name);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_PDB_CHANGED:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(2, (\"%s: Port Database Changed\\n\", isp->isp_name));\n\t\tbreak;\n\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tisp_mark_getpdb_all(isp);\n\t\t/*\n\t\t * Not correct, but it will force us to rescan the loop.\n\t\t */\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_async(isp, ISPASYNC_CHANGE_NOTIFY, NULL);\n\t\tbreak;\n\n\tcase ASYNC_PTPMODE:\n\t\tPRINTF(\"%s: Point-to-Point mode\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_CONNMODE:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tswitch (mbox) {\n\t\tcase ISP_CONN_LOOP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_PTP:\n\t\t\tPRINTF(\"%s: Loop -> Point-to-Point mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_BADLIP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode (1)\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_FATAL:\n\t\t\tPRINTF(\"%s: FATAL CONNECTION ERROR\\n\", isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\t/* no point continuing after this */\n\t\t\treturn (-1);\n\n\t\tcase ISP_CONN_LOOPBACK:\n\t\t\tPRINTF(\"%s: Looped Back in Point-to-Point mode\\n\",\n\t\t\t     isp->isp_name);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPRINTF(\"%s: unknown async code 0x%x\\n\", isp->isp_name, mbox);\n\t\tbreak;\n\t}\n\treturn (fast_post_handle);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_parse_async",
      "static void isp_mark_getpdb_all"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: unknown async code 0x%x\\n\"",
            "isp->isp_name",
            "mbox"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Looped Back in Point-to-Point mode\\n\"",
            "isp->isp_name"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_restart",
          "args": [
            "isp"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "isp_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4063-4100",
          "snippet": "void\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nvoid\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: FATAL CONNECTION ERROR\\n\"",
            "isp->isp_name"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Point-to-Point -> Loop mode (1)\\n\"",
            "isp->isp_name"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Loop -> Point-to-Point mode\\n\"",
            "isp->isp_name"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Point-to-Point -> Loop mode\\n\"",
            "isp->isp_name"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX1"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Point-to-Point mode\\n\"",
            "isp->isp_name"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_CHANGE_NOTIFY",
            "NULL"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_mark_getpdb_all",
          "args": [
            "isp"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mark_getpdb_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1160-1169",
          "snippet": "static void\nisp_mark_getpdb_all(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tint i;\n\tfor (i = 0; i < MAX_FC_TARG; i++) {\n\t\tfcp->portdb[i].valid = 0;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_mark_getpdb_all"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mark_getpdb_all;\n\nstatic void\nisp_mark_getpdb_all(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tint i;\n\tfor (i = 0; i < MAX_FC_TARG; i++) {\n\t\tfcp->portdb[i].valid = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"%s: Port Database Changed\\n\", isp->isp_name)"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_target_async",
          "args": [
            "isp",
            "bus",
            "mbox"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "isp_target_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "483-539",
          "snippet": "void\nisp_target_async(isp, bus, event)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tint event;\n{\n\ttmd_event_t evt;\n\ttmd_msg_t msg;\n\n\tswitch (event) {\n\t/*\n\t * These three we handle here to propagate an effective bus reset\n\t * upstream, but these do not require any immediate notify actions\n\t * so we return when done.\n\t */\n\tcase ASYNC_LIP_OCCURRED:\n\tcase ASYNC_LOOP_UP:\n\tcase ASYNC_LOOP_DOWN:\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\treturn;\n\n\tcase ASYNC_LOOP_RESET:\n\tcase ASYNC_BUS_RESET:\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tif (IS_FC(isp)) {\n\t\t\treturn;\t/* we'll be getting an inotify instead */\n\t\t}\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\tbreak;\n\tcase ASYNC_DEVICE_RESET:\n\t\t/*\n\t\t * Bus Device Reset resets a specific target, so\n\t\t * we pass this as a synthesized message.\n\t\t */\n\t\tMEMZERO(&msg, sizeof msg);\n\t\tif (IS_FC(isp)) {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((fcparam *)isp->isp_param)->isp_loopid;\n\t\t} else {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((sdparam *)isp->isp_param)->isp_initiator_id;\n\t\t}\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: isp_target_async: unknown event 0x%x\\n\",\n\t\t    isp->isp_name, event);\n\t\tbreak;\n\t}\n\tisp_notify_ack(isp, NULL);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nvoid\nisp_target_async(isp, bus, event)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tint event;\n{\n\ttmd_event_t evt;\n\ttmd_msg_t msg;\n\n\tswitch (event) {\n\t/*\n\t * These three we handle here to propagate an effective bus reset\n\t * upstream, but these do not require any immediate notify actions\n\t * so we return when done.\n\t */\n\tcase ASYNC_LIP_OCCURRED:\n\tcase ASYNC_LOOP_UP:\n\tcase ASYNC_LOOP_DOWN:\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\treturn;\n\n\tcase ASYNC_LOOP_RESET:\n\tcase ASYNC_BUS_RESET:\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tif (IS_FC(isp)) {\n\t\t\treturn;\t/* we'll be getting an inotify instead */\n\t\t}\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\tbreak;\n\tcase ASYNC_DEVICE_RESET:\n\t\t/*\n\t\t * Bus Device Reset resets a specific target, so\n\t\t * we pass this as a synthesized message.\n\t\t */\n\t\tMEMZERO(&msg, sizeof msg);\n\t\tif (IS_FC(isp)) {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((fcparam *)isp->isp_param)->isp_loopid;\n\t\t} else {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((sdparam *)isp->isp_param)->isp_initiator_id;\n\t\t}\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: isp_target_async: unknown event 0x%x\\n\",\n\t\t    isp->isp_name, event);\n\t\tbreak;\n\t}\n\tisp_notify_ack(isp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Loop RESET\\n\"",
            "isp->isp_name"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: LIP occurred\\n\", isp->isp_name)"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX1"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: CTIO done\\n\"",
            "isp->isp_name"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "4",
            "(\"%s: fast post completion of %u\\n\", isp->isp_name,\n\t\t    fast_post_handle)"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX1"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX2"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Transition to unknown mode 0x%x\\n\"",
            "isp->isp_name",
            "mbox"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Transition to Single Ended mode\\n\"",
            "isp->isp_name"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Transition to Differential mode\\n\"",
            "isp->isp_name"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Transition to LVD mode\\n\"",
            "isp->isp_name"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX2"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: SCSI Bus reset after DATA Overrun\\n\"",
            "isp->isp_name"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: stalled SCSI Bus after DATA Overrun\\n\"",
            "isp->isp_name"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: SCAM interrupt\\n\"",
            "isp->isp_name"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: extended message underrun\\n\"",
            "isp->isp_name"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: device reset on bus %d\\n\"",
            "isp->isp_name",
            "bus"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: timeout initiated SCSI bus reset of bus %d\\n\"",
            "isp->isp_name",
            "bus"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX4"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Response Queue Transfer Error\\n\"",
            "isp->isp_name"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Request Queue Transfer Error\\n\"",
            "isp->isp_name"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Internal FW Error @ RISC Addr 0x%x\\n\"",
            "isp->isp_name",
            "mbox"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX1"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX6"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_parse_async;\nstatic void isp_mark_getpdb_all;\n\nstatic int\nisp_parse_async(isp, mbox)\n\tstruct ispsoftc *isp;\n\tint mbox;\n{\n\tint bus;\n\tu_int32_t fast_post_handle = 0;\n\n\tif (IS_DUALBUS(isp)) {\n\t\tbus = ISP_READ(isp, OUTMAILBOX6);\n\t} else {\n\t\tbus = 0;\n\t}\n\n\tswitch (mbox) {\n\tcase MBOX_COMMAND_COMPLETE:\t/* sometimes these show up */\n\t\tbreak;\n\tcase ASYNC_BUS_RESET:\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tisp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\tbreak;\n\tcase ASYNC_SYSTEM_ERROR:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tPRINTF(\"%s: Internal FW Error @ RISC Addr 0x%x\\n\",\n\t\t    isp->isp_name, mbox);\n\t\tisp_restart(isp);\n\t\t/* no point continuing after this */\n\t\treturn (-1);\n\n\tcase ASYNC_RQS_XFER_ERR:\n\t\tPRINTF(\"%s: Request Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_RSP_XFER_ERR:\n\t\tPRINTF(\"%s: Response Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_QWAKEUP:\n\t\t/*\n\t\t * We've just been notified that the Queue has woken up.\n\t\t * We don't need to be chatty about this- just unlatch things\n\t\t * and move on.\n\t\t */\n\t\tmbox = ISP_READ(isp, OUTMAILBOX4);\n\t\tbreak;\n\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tPRINTF(\"%s: timeout initiated SCSI bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_DEVICE_RESET:\n\t\tPRINTF(\"%s: device reset on bus %d\\n\", isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_EXTMSG_UNDERRUN:\n\t\tPRINTF(\"%s: extended message underrun\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_SCAM_INT:\n\t\tPRINTF(\"%s: SCAM interrupt\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_HUNG_SCSI:\n\t\tPRINTF(\"%s: stalled SCSI Bus after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\t/* XXX: Need to issue SCSI reset at this point */\n\t\tbreak;\n\n\tcase ASYNC_KILLED_BUS:\n\t\tPRINTF(\"%s: SCSI Bus reset after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_BUS_TRANSIT:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX2);\n\t\tswitch (mbox & 0x1c00) {\n\t\tcase SXP_PINS_LVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to LVD mode\\n\", isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 1;\n\t\t\tbreak;\n\t\tcase SXP_PINS_HVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to Differential mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tcase SXP_PINS_SE_MODE:\n\t\t\tPRINTF(\"%s: Transition to Single Ended mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: Transition to unknown mode 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * XXX: Set up to renegotiate again!\n\t\t */\n\t\t/* Can only be for a 1080... */\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tbreak;\n\n\tcase ASYNC_CMD_CMPLT:\n\t\tfast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\tIDPRINTF(4, (\"%s: fast post completion of %u\\n\", isp->isp_name,\n\t\t    fast_post_handle));\n\t\tbreak;\n\n\tcase ASYNC_CTIO_DONE:\n\t\t/* Should only occur when Fast Posting Set for 2100s */\n\t\tPRINTF(\"%s: CTIO done\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq =\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp->isp_sendmarker = 1;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(1, (\"%s: LIP occurred\\n\", isp->isp_name));\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_UP:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_UP, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_DOWN, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_RESET:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tPRINTF(\"%s: Loop RESET\\n\", isp->isp_name);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_PDB_CHANGED:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(2, (\"%s: Port Database Changed\\n\", isp->isp_name));\n\t\tbreak;\n\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tisp_mark_getpdb_all(isp);\n\t\t/*\n\t\t * Not correct, but it will force us to rescan the loop.\n\t\t */\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_async(isp, ISPASYNC_CHANGE_NOTIFY, NULL);\n\t\tbreak;\n\n\tcase ASYNC_PTPMODE:\n\t\tPRINTF(\"%s: Point-to-Point mode\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_CONNMODE:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tswitch (mbox) {\n\t\tcase ISP_CONN_LOOP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_PTP:\n\t\t\tPRINTF(\"%s: Loop -> Point-to-Point mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_BADLIP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode (1)\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_FATAL:\n\t\t\tPRINTF(\"%s: FATAL CONNECTION ERROR\\n\", isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\t/* no point continuing after this */\n\t\t\treturn (-1);\n\n\t\tcase ISP_CONN_LOOPBACK:\n\t\t\tPRINTF(\"%s: Looped Back in Point-to-Point mode\\n\",\n\t\t\t     isp->isp_name);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPRINTF(\"%s: unknown async code 0x%x\\n\", isp->isp_name, mbox);\n\t\tbreak;\n\t}\n\treturn (fast_post_handle);\n}"
  },
  {
    "function_name": "isp_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "2284-2561",
    "snippet": "int\nisp_intr(arg)\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *complist[RESULT_QUEUE_LEN], *xs;\n\tstruct ispsoftc *isp = arg;\n\tu_int16_t iptr, optr;\n\tu_int16_t isr, isrb, sema;\n\tint i, nlooked = 0, ndone = 0;\n\n\t/*\n\t * Well, if we've disabled interrupts, we may get a case where\n\t * isr isn't set, but sema is. In any case, debounce isr reads.\n\t */\n\tdo {\n\t\tisr = ISP_READ(isp, BIU_ISR);\n\t\tisrb = ISP_READ(isp, BIU_ISR);\n\t} while (isr != isrb);\n\tsema = ISP_READ(isp, BIU_SEMA) & 0x1;\n\tIDPRINTF(5, (\"%s: isp_intr isr %x sem %x\\n\", isp->isp_name, isr, sema));\n\tif (isr == 0) {\n\t\treturn (0);\n\t}\n\tif (!INT_PENDING(isp, isr)) {\n\t\tIDPRINTF(4, (\"%s: isp_intr isr=%x\\n\", isp->isp_name, isr));\n\t\treturn (0);\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tIDPRINTF(3, (\"%s: interrupt (isr=%x,sema=%x) when not ready\\n\",\n\t\t    isp->isp_name, isr, sema));\n\t\tISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\tif (sema) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox & 0x4000) {\n\t\t\tIDPRINTF(4, (\"%s: Command Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t} else {\n\t\t\tu_int32_t fhandle = isp_parse_async(isp, (int) mbox);\n\t\t\tIDPRINTF(4, (\"%s: Async Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t\tif (fhandle > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fhandle);\n\t\t\t}\n\t\t}\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt.\n\t */\n\toptr = isp->isp_residx;\n\tiptr = ISP_READ(isp, OUTMAILBOX5);\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\tif (optr == iptr) {\n\t\tIDPRINTF(4, (\"why intr? isr %x iptr %x optr %x\\n\",\n\t\t    isr, optr, iptr));\n\t}\n\n\twhile (optr != iptr) {\n\t\tispstatusreq_t *sp;\n\t\tu_int16_t oop;\n\t\tint buddaboom = 0;\n\n\t\tsp = (ispstatusreq_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);\n\t\toop = optr;\n\t\toptr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN);\n\t\tnlooked++;\n\t\tMemoryBarrier();\n\t\t/*\n\t\t * Do any appropriate unswizzling of what the Qlogic f/w has\n\t\t * written into memory so it makes sense to us. This is a\n\t\t * per-platform thing.\n\t\t */\n\t\tISP_UNSWIZZLE_RESPONSE(isp, sp);\n\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {\n\t\t\tif (isp_handle_other_response(isp, sp, &optr) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It really has to be a bounced request just copied\n\t\t\t * from the request queue to the response queue. If\n\t\t\t * not, something bad has happened.\n\t\t\t */\n\t\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_REQUEST) {\n\t\t\t\tPRINTF(\"%s: not RESPONSE in RESPONSE Queue \"\n\t\t\t\t    \"(type 0x%x) @ idx %d (next %d)\\n\",\n\t\t\t\t    isp->isp_name,\n\t\t\t\t    sp->req_header.rqs_entry_type, oop, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuddaboom = 1;\n\t\t}\n\n\t\tif (sp->req_header.rqs_flags & 0xf) {\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_CONTINUATION) {\n\t\t\t\tIDPRINTF(4, (\"%s: continuation segment\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\tIDPRINTF(2, (\"%s: internal queues full\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\t/*\n\t\t\t\t * We'll synthesize a QUEUE FULL message below.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADHEADER) {\n\t\t\t\tPRINTF(\"%s: bad header\\n\", isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADPACKET) {\n\t\t\t\tPRINTF(\"%s: bad request packet\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & _RQS_OFLAGS) {\n\t\t\t\tPRINTF(\"%s: unknown flags in response (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, sp->req_header.rqs_flags);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n#undef\t_RQS_OFLAGS\n\t\t}\n\t\tif (sp->req_handle > isp->isp_maxcmds || sp->req_handle < 1) {\n\t\t\tPRINTF(\"%s: bad request handle %d\\n\", isp->isp_name,\n\t\t\t    sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\txs = isp_find_xs(isp, sp->req_handle);\n\t\tif (xs == NULL) {\n\t\t\tPRINTF(\"%s: NULL xs in xflist (handle 0x%x)\\n\",\n\t\t\t    isp->isp_name, sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, sp->req_handle);\n\t\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tif (buddaboom) {\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t}\n\t\tXS_STS(xs) = sp->req_scsi_status & 0xff;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data,\n\t\t\t\t\tXS_SNSLEN(xs));\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t}\n\t\t\t/*\n\t\t\t * A new synchronous rate was negotiated for this\n\t\t\t * target. Mark state such that we'll go look up\n\t\t\t * that which has changed later.\n\t\t\t */\n\t\t\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_refresh = 1;\n\t\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t\t}\n\t\t} else {\n\t\t\tif (sp->req_scsi_status & RQCS_SV) {\n\t\t\t\tint amt = min(XS_SNSLEN(xs), sp->req_sense_len);\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t\tsp->req_state_flags |= RQSF_GOT_SENSE;\n\t\t\t} else if (XS_STS(xs) == SCSI_CHECK) {\n\t\t\t\tIDPRINTF(1, (\"%s: check condition with no sense\"\n\t\t\t\t    \" data\\n\", isp->isp_name));\n\t\t\t}\n\t\t}\n\t\tif (XS_NOERR(xs) && XS_STS(xs) == SCSI_BUSY) {\n\t\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\t}\n\n\t\tif (sp->req_header.rqs_entry_type == RQSTYPE_RESPONSE) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t    if (sp->req_completion_status != RQCS_COMPLETE) {\n\t\t\t\tisp_parse_status(isp, sp, xs);\n\t\t\t    } else {\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t    }\n\t\t\t}\n\t\t} else if (sp->req_header.rqs_entry_type == RQSTYPE_REQUEST) {\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\t/*\n\t\t\t\t * Force Queue Full status.\n\t\t\t\t */\n\t\t\t\tXS_STS(xs) = SCSI_QFULL;\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t} else if (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t} else {\n\t\t\tPRINTF(\"%s: unhandled respose queue type 0x%x\\n\",\n\t\t\t    isp->isp_name, sp->req_header.rqs_entry_type);\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t}\n\t\tif (IS_SCSI(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t} else if (sp->req_scsi_status & RQCS_RU) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tIDPRINTF(4, (\"%s: cnt %d rsd %d\\n\", isp->isp_name,\n\t\t\t\tXS_XFRLEN(xs), sp->req_resid));\n\t\t}\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, sp->req_handle);\n\t\t}\n\t\t/*\n\t\t * Let the platforms cope.\n\t\t */\n#if\t0\n\t\t/*\n\t\t * XXX: If we have a check condition, but no Sense Data,\n\t\t * XXX: mark it as an error (ARQ failed). We need to\n\t\t * XXX: to do a more distinct job because there may\n\t\t * XXX: cases where ARQ is disabled.\n\t\t */\n\t\tif (XS_STS(xs) == SCSI_CHECK && !(XS_IS_SNS_VALID(xs))) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tPRINTF(\"%s: ARQ failure for target %d lun %d\\n\",\n\t\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t\t\tXS_SETERR(xs, HBA_ARQFAIL);\n\t\t\t}\n\t\t}\n#endif\n\t\tif ((isp->isp_dblev >= 5) ||\n\t\t    (isp->isp_dblev > 2 && !XS_NOERR(xs))) {\n\t\t\tPRINTF(\"%s(%d.%d): FIN dl%d resid%d STS %x\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_XFRLEN(xs), XS_RESID(xs), XS_STS(xs));\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tPRINTF(\" Skey: %x\", XS_SNSKEY(xs));\n\t\t\t\tif (!(XS_IS_SNS_VALID(xs))) {\n\t\t\t\t\tPRINTF(\" BUT NOT SET\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tPRINTF(\" XS_ERR=0x%x\\n\", (unsigned int) XS_ERR(xs));\n\t\t}\n\n\t\tif (isp->isp_nactive > 0)\n\t\t    isp->isp_nactive--;\n\t\tcomplist[ndone++] = xs;\t/* defer completion call until later */\n\t}\n\n\t/*\n\t * If we looked at any commands, then it's valid to find out\n\t * what the outpointer is. It also is a trigger to update the\n\t * ISP's notion of what we've seen so far.\n\t */\n\tif (nlooked) {\n\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\tisp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\t}\n\tisp->isp_residx = optr;\n\tfor (i = 0; i < ndone; i++) {\n\t\txs = complist[i];\n\t\tif (xs) {\n\t\t\tXS_CMD_DONE(xs);\n\t\t}\n\t}\n\tENABLE_INTS(isp);\n\treturn (1);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)"
    ],
    "globals_used": [
      "static int isp_parse_async",
      "static int isp_handle_other_response",
      "static void isp_parse_status",
      "static void isp_fastpost_complete",
      "static void isp_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ENABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CMD_DONE",
          "args": [
            "xs"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX4"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX5",
            "optr"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\" XS_ERR=0x%x\\n\"",
            "(unsigned int) XS_ERR(xs)"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_ERR",
          "args": [
            "xs"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\" BUT NOT SET\""
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_IS_SNS_VALID",
          "args": [
            "xs"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\" Skey: %x\"",
            "XS_SNSKEY(xs)"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SNSKEY",
          "args": [
            "xs"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s(%d.%d): FIN dl%d resid%d STS %x\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)",
            "XS_XFRLEN(xs)",
            "XS_RESID(xs)",
            "XS_STS(xs)"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_XFRLEN",
          "args": [
            "xs"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_ARQFAIL"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ARQ failure for target %d lun %d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_IS_SNS_VALID",
          "args": [
            "xs"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_DMAFREE",
          "args": [
            "isp",
            "xs",
            "sp->req_handle"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_XFRLEN",
          "args": [
            "xs"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "4",
            "(\"%s: cnt %d rsd %d\\n\", isp->isp_name,\n\t\t\t\tXS_XFRLEN(xs), sp->req_resid)"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_XFRLEN",
          "args": [
            "xs"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: unhandled respose queue type 0x%x\\n\"",
            "isp->isp_name",
            "sp->req_header.rqs_entry_type"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_NOERROR"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_NOERROR"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_parse_status",
          "args": [
            "isp",
            "sp",
            "xs"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "isp_parse_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2835-3085",
          "snippet": "static void\nisp_parse_status(isp, sp, xs)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tswitch (sp->req_completion_status) {\n\tcase RQCS_COMPLETE:\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_INCOMPLETE:\n\t\tif ((sp->req_state_flags & RQSF_GOT_TARGET) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: Selection Timeout for %d.%d.%d\\n\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_CHANNEL(xs)));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn;\n\t\t}\n\t\tPRINTF(\"%s: command incomplete for %d.%d.%d, state 0x%x\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),\n\t\t    sp->req_state_flags);\n\t\tbreak;\n\n\tcase RQCS_DMA_ERROR:\n\t\tPRINTF(\"%s: DMA error for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_TRANSPORT_ERROR:\n\t\tPRINTF(\"%s: transport error for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp_prtstst(sp);\n\t\tbreak;\n\n\tcase RQCS_RESET_OCCURRED:\n\t\tIDPRINTF(1, (\"%s: bus reset destroyed command for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\treturn;\n\n\tcase RQCS_ABORTED:\n\t\tPRINTF(\"%s: command aborted for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_ABORTED);\n\t\treturn;\n\n\tcase RQCS_TIMEOUT:\n\t\tIDPRINTF(2, (\"%s: command timed out for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tXS_SETERR(xs, HBA_CMDTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_DATA_OVERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: data overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tXS_SETERR(xs, HBA_DATAOVR);\n\t\treturn;\n\n\tcase RQCS_COMMAND_OVERRUN:\n\t\tPRINTF(\"%s: command overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_STATUS_OVERRUN:\n\t\tPRINTF(\"%s: status overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_MESSAGE:\n\t\tPRINTF(\"%s: msg not COMMAND COMPLETE after status %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NO_MESSAGE_OUT:\n\t\tPRINTF(\"%s: No MESSAGE OUT phase after selection on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_EXT_ID_FAILED:\n\t\tPRINTF(\"%s: EXTENDED IDENTIFY failed %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_IDE_MSG_FAILED:\n\t\tPRINTF(\"%s: INITIATOR DETECTED ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ABORT_MSG_FAILED:\n\t\tPRINTF(\"%s: ABORT OPERATION rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_REJECT_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE REJECT rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NOP_MSG_FAILED:\n\t\tPRINTF(\"%s: NOP rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_PARITY_ERROR_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE PARITY ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DEVICE_RESET_MSG_FAILED:\n\t\tPRINTF(\"%s: BUS DEVICE RESET rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ID_MSG_FAILED:\n\t\tPRINTF(\"%s: IDENTIFY rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_UNEXP_BUS_FREE:\n\t\tPRINTF(\"%s: %d.%d.%d had an unexpected bus free\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DATA_UNDERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_XACT_ERR1:\n\t\tPRINTF(\"%s: HBA attempted queued transaction with disconnect \"\n\t\t    \"not set for %d.%d.%d\\n\", isp->isp_name, XS_CHANNEL(xs),\n\t\t    XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR2:\n\t\tPRINTF(\"%s: HBA attempted queued transaction to target \"\n\t\t    \"routine %d on target %d, bus %d\\n\", isp->isp_name,\n\t\t    XS_LUN(xs), XS_TGT(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR3:\n\t\tPRINTF(\"%s: HBA attempted queued transaction for target %d lun \"\n\t\t    \"%d on bus %d when queueing disabled\\n\", isp->isp_name,\n\t\t    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_ENTRY:\n\t\tPRINTF(\"%s: invalid IOCB entry type detected\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase RQCS_QUEUE_FULL:\n\t\tIDPRINTF(3, (\"%s: internal queues full for target %d lun %d \"\n\t\t    \"bus %d, status 0x%x\\n\", isp->isp_name, XS_TGT(xs),\n\t\t    XS_LUN(xs), XS_CHANNEL(xs), XS_STS(xs)));\n\t\t/*\n\t\t * If QFULL or some other status byte is set, then this\n\t\t * isn't an error, per se.\n\t\t */\n\t\tif (XS_STS(xs) != 0) {\n\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_PHASE_SKIPPED:\n\t\tPRINTF(\"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o \"\n\t\t    \"STATUS phase) for target %d lun %d bus %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_ARQS_FAILED:\n\t\tPRINTF(\"%s: Auto Request Sense failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\treturn;\n\n\tcase RQCS_WIDE_FAILED:\n\t\tPRINTF(\"%s: Wide Negotiation failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_WIDE;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_SYNCXFER_FAILED:\n\t\tPRINTF(\"%s: SDTR Message failed for target %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_SYNC;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_LVD_BUSERR:\n\t\tPRINTF(\"%s: Bad LVD condition while talking to %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_PORT_UNAVAILABLE:\n\t\t/*\n\t\t * No such port on the loop. Moral equivalent of SELTIMEO\n\t\t */\n\t\tIDPRINTF(3, (\"%s: Port Unavailable for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_LOGGED_OUT:\n\t\t/*\n\t\t * It was there (maybe)- treat as a selection timeout.\n\t\t */\n\t\tIDPRINTF(2, (\"%s: port logout for target %d\\n\",\n\t\t\tisp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_CHANGED:\n\t\tPRINTF(\"%s: port changed for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_BUSY:\n\t\tPRINTF(\"%s: port busy for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\treturn;\n\n\tdefault:\n\t\tPRINTF(\"%s: completion status 0x%x\\n\",\n\t\t    isp->isp_name, sp->req_completion_status);\n\t\tbreak;\n\t}\n\tXS_SETERR(xs, HBA_BOTCH);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_parse_status",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_parse_status;\nstatic void isp_update;\n\nstatic void\nisp_parse_status(isp, sp, xs)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tswitch (sp->req_completion_status) {\n\tcase RQCS_COMPLETE:\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_INCOMPLETE:\n\t\tif ((sp->req_state_flags & RQSF_GOT_TARGET) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: Selection Timeout for %d.%d.%d\\n\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_CHANNEL(xs)));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn;\n\t\t}\n\t\tPRINTF(\"%s: command incomplete for %d.%d.%d, state 0x%x\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs),\n\t\t    sp->req_state_flags);\n\t\tbreak;\n\n\tcase RQCS_DMA_ERROR:\n\t\tPRINTF(\"%s: DMA error for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_TRANSPORT_ERROR:\n\t\tPRINTF(\"%s: transport error for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp_prtstst(sp);\n\t\tbreak;\n\n\tcase RQCS_RESET_OCCURRED:\n\t\tIDPRINTF(1, (\"%s: bus reset destroyed command for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\treturn;\n\n\tcase RQCS_ABORTED:\n\t\tPRINTF(\"%s: command aborted for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\tXS_SETERR(xs, HBA_ABORTED);\n\t\treturn;\n\n\tcase RQCS_TIMEOUT:\n\t\tIDPRINTF(2, (\"%s: command timed out for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs)));\n\t\tXS_SETERR(xs, HBA_CMDTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_DATA_OVERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: data overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tXS_SETERR(xs, HBA_DATAOVR);\n\t\treturn;\n\n\tcase RQCS_COMMAND_OVERRUN:\n\t\tPRINTF(\"%s: command overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_STATUS_OVERRUN:\n\t\tPRINTF(\"%s: status overrun for command on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_MESSAGE:\n\t\tPRINTF(\"%s: msg not COMMAND COMPLETE after status %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NO_MESSAGE_OUT:\n\t\tPRINTF(\"%s: No MESSAGE OUT phase after selection on %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_EXT_ID_FAILED:\n\t\tPRINTF(\"%s: EXTENDED IDENTIFY failed %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_IDE_MSG_FAILED:\n\t\tPRINTF(\"%s: INITIATOR DETECTED ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ABORT_MSG_FAILED:\n\t\tPRINTF(\"%s: ABORT OPERATION rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_REJECT_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE REJECT rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_NOP_MSG_FAILED:\n\t\tPRINTF(\"%s: NOP rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_PARITY_ERROR_MSG_FAILED:\n\t\tPRINTF(\"%s: MESSAGE PARITY ERROR rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DEVICE_RESET_MSG_FAILED:\n\t\tPRINTF(\"%s: BUS DEVICE RESET rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_ID_MSG_FAILED:\n\t\tPRINTF(\"%s: IDENTIFY rejected by %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_UNEXP_BUS_FREE:\n\t\tPRINTF(\"%s: %d.%d.%d had an unexpected bus free\\n\",\n\t\t    isp->isp_name, XS_CHANNEL(xs), XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_DATA_UNDERRUN:\n\t\tif (IS_FC(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_XACT_ERR1:\n\t\tPRINTF(\"%s: HBA attempted queued transaction with disconnect \"\n\t\t    \"not set for %d.%d.%d\\n\", isp->isp_name, XS_CHANNEL(xs),\n\t\t    XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR2:\n\t\tPRINTF(\"%s: HBA attempted queued transaction to target \"\n\t\t    \"routine %d on target %d, bus %d\\n\", isp->isp_name,\n\t\t    XS_LUN(xs), XS_TGT(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_XACT_ERR3:\n\t\tPRINTF(\"%s: HBA attempted queued transaction for target %d lun \"\n\t\t    \"%d on bus %d when queueing disabled\\n\", isp->isp_name,\n\t\t    XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_BAD_ENTRY:\n\t\tPRINTF(\"%s: invalid IOCB entry type detected\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase RQCS_QUEUE_FULL:\n\t\tIDPRINTF(3, (\"%s: internal queues full for target %d lun %d \"\n\t\t    \"bus %d, status 0x%x\\n\", isp->isp_name, XS_TGT(xs),\n\t\t    XS_LUN(xs), XS_CHANNEL(xs), XS_STS(xs)));\n\t\t/*\n\t\t * If QFULL or some other status byte is set, then this\n\t\t * isn't an error, per se.\n\t\t */\n\t\tif (XS_STS(xs) != 0) {\n\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_PHASE_SKIPPED:\n\t\tPRINTF(\"%s: SCSI phase skipped (e.g., COMMAND COMPLETE w/o \"\n\t\t    \"STATUS phase) for target %d lun %d bus %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_ARQS_FAILED:\n\t\tPRINTF(\"%s: Auto Request Sense failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\treturn;\n\n\tcase RQCS_WIDE_FAILED:\n\t\tPRINTF(\"%s: Wide Negotiation failed for %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_WIDE;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\treturn;\n\n\tcase RQCS_SYNCXFER_FAILED:\n\t\tPRINTF(\"%s: SDTR Message failed for target %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tif (IS_SCSI(isp)) {\n\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_flags &= ~DPARM_SYNC;\n\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_update = 1;\n\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tbreak;\n\n\tcase RQCS_LVD_BUSERR:\n\t\tPRINTF(\"%s: Bad LVD condition while talking to %d.%d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs), XS_CHANNEL(xs));\n\t\tbreak;\n\n\tcase RQCS_PORT_UNAVAILABLE:\n\t\t/*\n\t\t * No such port on the loop. Moral equivalent of SELTIMEO\n\t\t */\n\t\tIDPRINTF(3, (\"%s: Port Unavailable for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_LOGGED_OUT:\n\t\t/*\n\t\t * It was there (maybe)- treat as a selection timeout.\n\t\t */\n\t\tIDPRINTF(2, (\"%s: port logout for target %d\\n\",\n\t\t\tisp->isp_name, XS_TGT(xs)));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_CHANGED:\n\t\tPRINTF(\"%s: port changed for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\treturn;\n\n\tcase RQCS_PORT_BUSY:\n\t\tPRINTF(\"%s: port busy for target %d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs));\n\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\treturn;\n\n\tdefault:\n\t\tPRINTF(\"%s: completion status 0x%x\\n\",\n\t\t    isp->isp_name, sp->req_completion_status);\n\t\tbreak;\n\t}\n\tXS_SETERR(xs, HBA_BOTCH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_TGTBSY"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: check condition with no sense\"\n\t\t\t\t    \" data\\n\", isp->isp_name)"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SNS_IS_VALID",
          "args": [
            "xs"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMCPY",
          "args": [
            "XS_SNSP(xs)",
            "sp->req_sense_data",
            "amt"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SNSP",
          "args": [
            "xs"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "XS_SNSLEN(xs)",
            "sp->req_sense_len"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_SNSLEN",
          "args": [
            "xs"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SNS_IS_VALID",
          "args": [
            "xs"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMCPY",
          "args": [
            "XS_SNSP(xs)",
            "sp->req_sense_data",
            "XS_SNSLEN(xs)"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SNSLEN",
          "args": [
            "xs"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SNSP",
          "args": [
            "xs"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_STS",
          "args": [
            "xs"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_destroy_handle",
          "args": [
            "isp",
            "sp->req_handle"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "isp_destroy_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "237-245",
          "snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX5",
            "optr"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: NULL xs in xflist (handle 0x%x)\\n\"",
            "isp->isp_name",
            "sp->req_handle"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_find_xs",
          "args": [
            "isp",
            "sp->req_handle"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "isp_find_xs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "209-219",
          "snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX5",
            "optr"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad request handle %d\\n\"",
            "isp->isp_name",
            "sp->req_handle"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: unknown flags in response (0x%x)\\n\"",
            "isp->isp_name",
            "sp->req_header.rqs_flags"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad request packet\\n\"",
            "isp->isp_name"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad header\\n\"",
            "isp->isp_name"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"%s: internal queues full\\n\",\n\t\t\t\t    isp->isp_name)"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX5",
            "optr"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "4",
            "(\"%s: continuation segment\\n\",\n\t\t\t\t    isp->isp_name)"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: not RESPONSE in RESPONSE Queue \"\n\t\t\t\t    \"(type 0x%x) @ idx %d (next %d)\\n\"",
            "isp->isp_name",
            "sp->req_header.rqs_entry_type",
            "oop",
            "optr"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_handle_other_response",
          "args": [
            "isp",
            "sp",
            "&optr"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "isp_handle_other_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2805-2833",
          "snippet": "static int\nisp_handle_other_response(isp, sp, optrp)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tu_int16_t *optrp;\n{\n\tswitch (sp->req_header.rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\tcase RQSTYPE_CTIO:\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\tcase RQSTYPE_NOTIFY:\n\tcase RQSTYPE_NOTIFY_ACK:\n\tcase RQSTYPE_CTIO1:\n\tcase RQSTYPE_ATIO2:\n\tcase RQSTYPE_CTIO2:\n\tcase RQSTYPE_CTIO3:\n#ifdef\tISP_TARGET_MODE\n\t\treturn (isp_target_notify(isp, sp, optrp));\n#else\n\t\t/* FALLTHROUGH */\n#endif\n\tcase RQSTYPE_REQUEST:\n\tdefault:\n\t\tPRINTF(\"%s: unhandled response type 0x%x\\n\", isp->isp_name,\n\t\t    sp->req_header.rqs_entry_type);\n\t\treturn (-1);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_handle_other_response"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_handle_other_response;\n\nstatic int\nisp_handle_other_response(isp, sp, optrp)\n\tstruct ispsoftc *isp;\n\tispstatusreq_t *sp;\n\tu_int16_t *optrp;\n{\n\tswitch (sp->req_header.rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\tcase RQSTYPE_CTIO:\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\tcase RQSTYPE_NOTIFY:\n\tcase RQSTYPE_NOTIFY_ACK:\n\tcase RQSTYPE_CTIO1:\n\tcase RQSTYPE_ATIO2:\n\tcase RQSTYPE_CTIO2:\n\tcase RQSTYPE_CTIO3:\n#ifdef\tISP_TARGET_MODE\n\t\treturn (isp_target_notify(isp, sp, optrp));\n#else\n\t\t/* FALLTHROUGH */\n#endif\n\tcase RQSTYPE_REQUEST:\n\tdefault:\n\t\tPRINTF(\"%s: unhandled response type 0x%x\\n\", isp->isp_name,\n\t\t    sp->req_header.rqs_entry_type);\n\t\treturn (-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_UNSWIZZLE_RESPONSE",
          "args": [
            "isp",
            "sp"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryBarrier",
          "args": [],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_NXT_QENTRY",
          "args": [
            "optr",
            "RESULT_QUEUE_LEN"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_QUEUE_ENTRY",
          "args": [
            "isp->isp_result",
            "optr"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "4",
            "(\"why intr? isr %x iptr %x optr %x\\n\",\n\t\t    isr, optr, iptr)"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX5"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_fastpost_complete",
          "args": [
            "isp",
            "fhandle"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "isp_fastpost_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3087-3118",
          "snippet": "static void\nisp_fastpost_complete(isp, fph)\n\tstruct ispsoftc *isp;\n\tu_int32_t fph;\n{\n\tISP_SCSI_XFER_T *xs;\n\n\tif (fph < 1) {\n\t\treturn;\n\t}\n\txs = isp_find_xs(isp, fph);\n\tif (xs == NULL) {\n\t\tPRINTF(\"%s: command for fast posting handle 0x%x not found\\n\",\n\t\t    isp->isp_name, fph);\n\t\treturn;\n\t}\n\tisp_destroy_handle(isp, fph);\n\n\t/*\n\t * Since we don't have a result queue entry item,\n\t * we must believe that SCSI status is zero and\n\t * that all data transferred.\n\t */\n\tXS_RESID(xs) = 0;\n\tXS_STS(xs) = 0;\n\tif (XS_XFRLEN(xs)) {\n\t\tISP_DMAFREE(isp, xs, fph);\n\t}\n\tXS_CMD_DONE(xs);\n\tif (isp->isp_nactive)\n\t\tisp->isp_nactive--;\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_fastpost_complete"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fastpost_complete;\n\nstatic void\nisp_fastpost_complete(isp, fph)\n\tstruct ispsoftc *isp;\n\tu_int32_t fph;\n{\n\tISP_SCSI_XFER_T *xs;\n\n\tif (fph < 1) {\n\t\treturn;\n\t}\n\txs = isp_find_xs(isp, fph);\n\tif (xs == NULL) {\n\t\tPRINTF(\"%s: command for fast posting handle 0x%x not found\\n\",\n\t\t    isp->isp_name, fph);\n\t\treturn;\n\t}\n\tisp_destroy_handle(isp, fph);\n\n\t/*\n\t * Since we don't have a result queue entry item,\n\t * we must believe that SCSI status is zero and\n\t * that all data transferred.\n\t */\n\tXS_RESID(xs) = 0;\n\tXS_STS(xs) = 0;\n\tif (XS_XFRLEN(xs)) {\n\t\tISP_DMAFREE(isp, xs, fph);\n\t}\n\tXS_CMD_DONE(xs);\n\tif (isp->isp_nactive)\n\t\tisp->isp_nactive--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "4",
            "(\"%s: Async Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox)"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_parse_async",
          "args": [
            "isp",
            "(int) mbox"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "isp_parse_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2567-2797",
          "snippet": "static int\nisp_parse_async(isp, mbox)\n\tstruct ispsoftc *isp;\n\tint mbox;\n{\n\tint bus;\n\tu_int32_t fast_post_handle = 0;\n\n\tif (IS_DUALBUS(isp)) {\n\t\tbus = ISP_READ(isp, OUTMAILBOX6);\n\t} else {\n\t\tbus = 0;\n\t}\n\n\tswitch (mbox) {\n\tcase MBOX_COMMAND_COMPLETE:\t/* sometimes these show up */\n\t\tbreak;\n\tcase ASYNC_BUS_RESET:\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tisp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\tbreak;\n\tcase ASYNC_SYSTEM_ERROR:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tPRINTF(\"%s: Internal FW Error @ RISC Addr 0x%x\\n\",\n\t\t    isp->isp_name, mbox);\n\t\tisp_restart(isp);\n\t\t/* no point continuing after this */\n\t\treturn (-1);\n\n\tcase ASYNC_RQS_XFER_ERR:\n\t\tPRINTF(\"%s: Request Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_RSP_XFER_ERR:\n\t\tPRINTF(\"%s: Response Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_QWAKEUP:\n\t\t/*\n\t\t * We've just been notified that the Queue has woken up.\n\t\t * We don't need to be chatty about this- just unlatch things\n\t\t * and move on.\n\t\t */\n\t\tmbox = ISP_READ(isp, OUTMAILBOX4);\n\t\tbreak;\n\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tPRINTF(\"%s: timeout initiated SCSI bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_DEVICE_RESET:\n\t\tPRINTF(\"%s: device reset on bus %d\\n\", isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_EXTMSG_UNDERRUN:\n\t\tPRINTF(\"%s: extended message underrun\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_SCAM_INT:\n\t\tPRINTF(\"%s: SCAM interrupt\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_HUNG_SCSI:\n\t\tPRINTF(\"%s: stalled SCSI Bus after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\t/* XXX: Need to issue SCSI reset at this point */\n\t\tbreak;\n\n\tcase ASYNC_KILLED_BUS:\n\t\tPRINTF(\"%s: SCSI Bus reset after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_BUS_TRANSIT:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX2);\n\t\tswitch (mbox & 0x1c00) {\n\t\tcase SXP_PINS_LVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to LVD mode\\n\", isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 1;\n\t\t\tbreak;\n\t\tcase SXP_PINS_HVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to Differential mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tcase SXP_PINS_SE_MODE:\n\t\t\tPRINTF(\"%s: Transition to Single Ended mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: Transition to unknown mode 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * XXX: Set up to renegotiate again!\n\t\t */\n\t\t/* Can only be for a 1080... */\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tbreak;\n\n\tcase ASYNC_CMD_CMPLT:\n\t\tfast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\tIDPRINTF(4, (\"%s: fast post completion of %u\\n\", isp->isp_name,\n\t\t    fast_post_handle));\n\t\tbreak;\n\n\tcase ASYNC_CTIO_DONE:\n\t\t/* Should only occur when Fast Posting Set for 2100s */\n\t\tPRINTF(\"%s: CTIO done\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq =\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp->isp_sendmarker = 1;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(1, (\"%s: LIP occurred\\n\", isp->isp_name));\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_UP:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_UP, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_DOWN, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_RESET:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tPRINTF(\"%s: Loop RESET\\n\", isp->isp_name);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_PDB_CHANGED:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(2, (\"%s: Port Database Changed\\n\", isp->isp_name));\n\t\tbreak;\n\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tisp_mark_getpdb_all(isp);\n\t\t/*\n\t\t * Not correct, but it will force us to rescan the loop.\n\t\t */\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_async(isp, ISPASYNC_CHANGE_NOTIFY, NULL);\n\t\tbreak;\n\n\tcase ASYNC_PTPMODE:\n\t\tPRINTF(\"%s: Point-to-Point mode\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_CONNMODE:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tswitch (mbox) {\n\t\tcase ISP_CONN_LOOP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_PTP:\n\t\t\tPRINTF(\"%s: Loop -> Point-to-Point mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_BADLIP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode (1)\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_FATAL:\n\t\t\tPRINTF(\"%s: FATAL CONNECTION ERROR\\n\", isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\t/* no point continuing after this */\n\t\t\treturn (-1);\n\n\t\tcase ISP_CONN_LOOPBACK:\n\t\t\tPRINTF(\"%s: Looped Back in Point-to-Point mode\\n\",\n\t\t\t     isp->isp_name);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPRINTF(\"%s: unknown async code 0x%x\\n\", isp->isp_name, mbox);\n\t\tbreak;\n\t}\n\treturn (fast_post_handle);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_mark_getpdb_all"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_parse_async;\nstatic void isp_mark_getpdb_all;\n\nstatic int\nisp_parse_async(isp, mbox)\n\tstruct ispsoftc *isp;\n\tint mbox;\n{\n\tint bus;\n\tu_int32_t fast_post_handle = 0;\n\n\tif (IS_DUALBUS(isp)) {\n\t\tbus = ISP_READ(isp, OUTMAILBOX6);\n\t} else {\n\t\tbus = 0;\n\t}\n\n\tswitch (mbox) {\n\tcase MBOX_COMMAND_COMPLETE:\t/* sometimes these show up */\n\t\tbreak;\n\tcase ASYNC_BUS_RESET:\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tisp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\tbreak;\n\tcase ASYNC_SYSTEM_ERROR:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tPRINTF(\"%s: Internal FW Error @ RISC Addr 0x%x\\n\",\n\t\t    isp->isp_name, mbox);\n\t\tisp_restart(isp);\n\t\t/* no point continuing after this */\n\t\treturn (-1);\n\n\tcase ASYNC_RQS_XFER_ERR:\n\t\tPRINTF(\"%s: Request Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_RSP_XFER_ERR:\n\t\tPRINTF(\"%s: Response Queue Transfer Error\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_QWAKEUP:\n\t\t/*\n\t\t * We've just been notified that the Queue has woken up.\n\t\t * We don't need to be chatty about this- just unlatch things\n\t\t * and move on.\n\t\t */\n\t\tmbox = ISP_READ(isp, OUTMAILBOX4);\n\t\tbreak;\n\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tPRINTF(\"%s: timeout initiated SCSI bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_DEVICE_RESET:\n\t\tPRINTF(\"%s: device reset on bus %d\\n\", isp->isp_name, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_EXTMSG_UNDERRUN:\n\t\tPRINTF(\"%s: extended message underrun\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_SCAM_INT:\n\t\tPRINTF(\"%s: SCAM interrupt\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_HUNG_SCSI:\n\t\tPRINTF(\"%s: stalled SCSI Bus after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\t/* XXX: Need to issue SCSI reset at this point */\n\t\tbreak;\n\n\tcase ASYNC_KILLED_BUS:\n\t\tPRINTF(\"%s: SCSI Bus reset after DATA Overrun\\n\",\n\t\t    isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_BUS_TRANSIT:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX2);\n\t\tswitch (mbox & 0x1c00) {\n\t\tcase SXP_PINS_LVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to LVD mode\\n\", isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 1;\n\t\t\tbreak;\n\t\tcase SXP_PINS_HVD_MODE:\n\t\t\tPRINTF(\"%s: Transition to Differential mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tcase SXP_PINS_SE_MODE:\n\t\t\tPRINTF(\"%s: Transition to Single Ended mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\t((sdparam *)isp->isp_param)->isp_diffmode = 0;\n\t\t\t((sdparam *)isp->isp_param)->isp_ultramode = 1;\n\t\t\t((sdparam *)isp->isp_param)->isp_lvdmode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: Transition to unknown mode 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * XXX: Set up to renegotiate again!\n\t\t */\n\t\t/* Can only be for a 1080... */\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tbreak;\n\n\tcase ASYNC_CMD_CMPLT:\n\t\tfast_post_handle = (ISP_READ(isp, OUTMAILBOX2) << 16) |\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\tIDPRINTF(4, (\"%s: fast post completion of %u\\n\", isp->isp_name,\n\t\t    fast_post_handle));\n\t\tbreak;\n\n\tcase ASYNC_CTIO_DONE:\n\t\t/* Should only occur when Fast Posting Set for 2100s */\n\t\tPRINTF(\"%s: CTIO done\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq =\n\t\t    ISP_READ(isp, OUTMAILBOX1);\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp->isp_sendmarker = 1;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(1, (\"%s: LIP occurred\\n\", isp->isp_name));\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_UP:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_UP, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tisp_async(isp, ISPASYNC_LOOP_DOWN, NULL);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_LOOP_RESET:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\tisp_mark_getpdb_all(isp);\n\t\tPRINTF(\"%s: Loop RESET\\n\", isp->isp_name);\n#ifdef\tISP_TARGET_MODE\n\t\tisp_target_async(isp, bus, mbox);\n#endif\n\t\tbreak;\n\n\tcase ASYNC_PDB_CHANGED:\n\t\tisp->isp_sendmarker = 1;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_mark_getpdb_all(isp);\n\t\tIDPRINTF(2, (\"%s: Port Database Changed\\n\", isp->isp_name));\n\t\tbreak;\n\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tisp_mark_getpdb_all(isp);\n\t\t/*\n\t\t * Not correct, but it will force us to rescan the loop.\n\t\t */\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tisp_async(isp, ISPASYNC_CHANGE_NOTIFY, NULL);\n\t\tbreak;\n\n\tcase ASYNC_PTPMODE:\n\t\tPRINTF(\"%s: Point-to-Point mode\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase ASYNC_CONNMODE:\n\t\tmbox = ISP_READ(isp, OUTMAILBOX1);\n\t\tswitch (mbox) {\n\t\tcase ISP_CONN_LOOP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_PTP:\n\t\t\tPRINTF(\"%s: Loop -> Point-to-Point mode\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_BADLIP:\n\t\t\tPRINTF(\"%s: Point-to-Point -> Loop mode (1)\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\tcase ISP_CONN_FATAL:\n\t\t\tPRINTF(\"%s: FATAL CONNECTION ERROR\\n\", isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\t/* no point continuing after this */\n\t\t\treturn (-1);\n\n\t\tcase ISP_CONN_LOOPBACK:\n\t\t\tPRINTF(\"%s: Looped Back in Point-to-Point mode\\n\",\n\t\t\t     isp->isp_name);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPRINTF(\"%s: unknown async code 0x%x\\n\", isp->isp_name, mbox);\n\t\tbreak;\n\t}\n\treturn (fast_post_handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "4",
            "(\"%s: Command Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox)"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_SEMA",
            "0"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_CLEAR_RISC_INT"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "INMAILBOX5",
            "ISP_READ(isp, OUTMAILBOX5)"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX5"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: interrupt (isr=%x,sema=%x) when not ready\\n\",\n\t\t    isp->isp_name, isr, sema)"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "4",
            "(\"%s: isp_intr isr=%x\\n\", isp->isp_name, isr)"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT_PENDING",
          "args": [
            "isp",
            "isr"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "5",
            "(\"%s: isp_intr isr %x sem %x\\n\", isp->isp_name, isr, sema)"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_SEMA"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_ISR"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_ISR"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\nstatic int isp_parse_async;\nstatic int isp_handle_other_response;\nstatic void isp_parse_status;\nstatic void isp_fastpost_complete;\nstatic void isp_update;\n\nint\nisp_intr(arg)\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *complist[RESULT_QUEUE_LEN], *xs;\n\tstruct ispsoftc *isp = arg;\n\tu_int16_t iptr, optr;\n\tu_int16_t isr, isrb, sema;\n\tint i, nlooked = 0, ndone = 0;\n\n\t/*\n\t * Well, if we've disabled interrupts, we may get a case where\n\t * isr isn't set, but sema is. In any case, debounce isr reads.\n\t */\n\tdo {\n\t\tisr = ISP_READ(isp, BIU_ISR);\n\t\tisrb = ISP_READ(isp, BIU_ISR);\n\t} while (isr != isrb);\n\tsema = ISP_READ(isp, BIU_SEMA) & 0x1;\n\tIDPRINTF(5, (\"%s: isp_intr isr %x sem %x\\n\", isp->isp_name, isr, sema));\n\tif (isr == 0) {\n\t\treturn (0);\n\t}\n\tif (!INT_PENDING(isp, isr)) {\n\t\tIDPRINTF(4, (\"%s: isp_intr isr=%x\\n\", isp->isp_name, isr));\n\t\treturn (0);\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tIDPRINTF(3, (\"%s: interrupt (isr=%x,sema=%x) when not ready\\n\",\n\t\t    isp->isp_name, isr, sema));\n\t\tISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\tif (sema) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox & 0x4000) {\n\t\t\tIDPRINTF(4, (\"%s: Command Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t} else {\n\t\t\tu_int32_t fhandle = isp_parse_async(isp, (int) mbox);\n\t\t\tIDPRINTF(4, (\"%s: Async Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t\tif (fhandle > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fhandle);\n\t\t\t}\n\t\t}\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt.\n\t */\n\toptr = isp->isp_residx;\n\tiptr = ISP_READ(isp, OUTMAILBOX5);\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\tif (optr == iptr) {\n\t\tIDPRINTF(4, (\"why intr? isr %x iptr %x optr %x\\n\",\n\t\t    isr, optr, iptr));\n\t}\n\n\twhile (optr != iptr) {\n\t\tispstatusreq_t *sp;\n\t\tu_int16_t oop;\n\t\tint buddaboom = 0;\n\n\t\tsp = (ispstatusreq_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);\n\t\toop = optr;\n\t\toptr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN);\n\t\tnlooked++;\n\t\tMemoryBarrier();\n\t\t/*\n\t\t * Do any appropriate unswizzling of what the Qlogic f/w has\n\t\t * written into memory so it makes sense to us. This is a\n\t\t * per-platform thing.\n\t\t */\n\t\tISP_UNSWIZZLE_RESPONSE(isp, sp);\n\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {\n\t\t\tif (isp_handle_other_response(isp, sp, &optr) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It really has to be a bounced request just copied\n\t\t\t * from the request queue to the response queue. If\n\t\t\t * not, something bad has happened.\n\t\t\t */\n\t\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_REQUEST) {\n\t\t\t\tPRINTF(\"%s: not RESPONSE in RESPONSE Queue \"\n\t\t\t\t    \"(type 0x%x) @ idx %d (next %d)\\n\",\n\t\t\t\t    isp->isp_name,\n\t\t\t\t    sp->req_header.rqs_entry_type, oop, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuddaboom = 1;\n\t\t}\n\n\t\tif (sp->req_header.rqs_flags & 0xf) {\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_CONTINUATION) {\n\t\t\t\tIDPRINTF(4, (\"%s: continuation segment\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\tIDPRINTF(2, (\"%s: internal queues full\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\t/*\n\t\t\t\t * We'll synthesize a QUEUE FULL message below.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADHEADER) {\n\t\t\t\tPRINTF(\"%s: bad header\\n\", isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADPACKET) {\n\t\t\t\tPRINTF(\"%s: bad request packet\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & _RQS_OFLAGS) {\n\t\t\t\tPRINTF(\"%s: unknown flags in response (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, sp->req_header.rqs_flags);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n#undef\t_RQS_OFLAGS\n\t\t}\n\t\tif (sp->req_handle > isp->isp_maxcmds || sp->req_handle < 1) {\n\t\t\tPRINTF(\"%s: bad request handle %d\\n\", isp->isp_name,\n\t\t\t    sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\txs = isp_find_xs(isp, sp->req_handle);\n\t\tif (xs == NULL) {\n\t\t\tPRINTF(\"%s: NULL xs in xflist (handle 0x%x)\\n\",\n\t\t\t    isp->isp_name, sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, sp->req_handle);\n\t\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tif (buddaboom) {\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t}\n\t\tXS_STS(xs) = sp->req_scsi_status & 0xff;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data,\n\t\t\t\t\tXS_SNSLEN(xs));\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t}\n\t\t\t/*\n\t\t\t * A new synchronous rate was negotiated for this\n\t\t\t * target. Mark state such that we'll go look up\n\t\t\t * that which has changed later.\n\t\t\t */\n\t\t\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_refresh = 1;\n\t\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t\t}\n\t\t} else {\n\t\t\tif (sp->req_scsi_status & RQCS_SV) {\n\t\t\t\tint amt = min(XS_SNSLEN(xs), sp->req_sense_len);\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t\tsp->req_state_flags |= RQSF_GOT_SENSE;\n\t\t\t} else if (XS_STS(xs) == SCSI_CHECK) {\n\t\t\t\tIDPRINTF(1, (\"%s: check condition with no sense\"\n\t\t\t\t    \" data\\n\", isp->isp_name));\n\t\t\t}\n\t\t}\n\t\tif (XS_NOERR(xs) && XS_STS(xs) == SCSI_BUSY) {\n\t\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\t}\n\n\t\tif (sp->req_header.rqs_entry_type == RQSTYPE_RESPONSE) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t    if (sp->req_completion_status != RQCS_COMPLETE) {\n\t\t\t\tisp_parse_status(isp, sp, xs);\n\t\t\t    } else {\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t    }\n\t\t\t}\n\t\t} else if (sp->req_header.rqs_entry_type == RQSTYPE_REQUEST) {\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\t/*\n\t\t\t\t * Force Queue Full status.\n\t\t\t\t */\n\t\t\t\tXS_STS(xs) = SCSI_QFULL;\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t} else if (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t} else {\n\t\t\tPRINTF(\"%s: unhandled respose queue type 0x%x\\n\",\n\t\t\t    isp->isp_name, sp->req_header.rqs_entry_type);\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t}\n\t\tif (IS_SCSI(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t} else if (sp->req_scsi_status & RQCS_RU) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tIDPRINTF(4, (\"%s: cnt %d rsd %d\\n\", isp->isp_name,\n\t\t\t\tXS_XFRLEN(xs), sp->req_resid));\n\t\t}\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, sp->req_handle);\n\t\t}\n\t\t/*\n\t\t * Let the platforms cope.\n\t\t */\n#if\t0\n\t\t/*\n\t\t * XXX: If we have a check condition, but no Sense Data,\n\t\t * XXX: mark it as an error (ARQ failed). We need to\n\t\t * XXX: to do a more distinct job because there may\n\t\t * XXX: cases where ARQ is disabled.\n\t\t */\n\t\tif (XS_STS(xs) == SCSI_CHECK && !(XS_IS_SNS_VALID(xs))) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tPRINTF(\"%s: ARQ failure for target %d lun %d\\n\",\n\t\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t\t\tXS_SETERR(xs, HBA_ARQFAIL);\n\t\t\t}\n\t\t}\n#endif\n\t\tif ((isp->isp_dblev >= 5) ||\n\t\t    (isp->isp_dblev > 2 && !XS_NOERR(xs))) {\n\t\t\tPRINTF(\"%s(%d.%d): FIN dl%d resid%d STS %x\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_XFRLEN(xs), XS_RESID(xs), XS_STS(xs));\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tPRINTF(\" Skey: %x\", XS_SNSKEY(xs));\n\t\t\t\tif (!(XS_IS_SNS_VALID(xs))) {\n\t\t\t\t\tPRINTF(\" BUT NOT SET\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tPRINTF(\" XS_ERR=0x%x\\n\", (unsigned int) XS_ERR(xs));\n\t\t}\n\n\t\tif (isp->isp_nactive > 0)\n\t\t    isp->isp_nactive--;\n\t\tcomplist[ndone++] = xs;\t/* defer completion call until later */\n\t}\n\n\t/*\n\t * If we looked at any commands, then it's valid to find out\n\t * what the outpointer is. It also is a trigger to update the\n\t * ISP's notion of what we've seen so far.\n\t */\n\tif (nlooked) {\n\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\tisp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\t}\n\tisp->isp_residx = optr;\n\tfor (i = 0; i < ndone; i++) {\n\t\txs = complist[i];\n\t\tif (xs) {\n\t\t\tXS_CMD_DONE(xs);\n\t\t}\n\t}\n\tENABLE_INTS(isp);\n\treturn (1);\n}"
  },
  {
    "function_name": "isp_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "2150-2275",
    "snippet": "int\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_fclink_test",
      "static int isp_pdb_sync",
      "static void isp_dumpregs",
      "static void isp_mboxcmd",
      "static void isp_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: cannot %sable target mode (0x%x)\\n\"",
            "isp->isp_name",
            "ena? \"en\" : \"dis\"",
            "mbs.param[0]"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_pdb_sync",
          "args": [
            "isp",
            "-1"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pdb_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1380-1795",
          "snippet": "static int\nisp_pdb_sync(isp, target)\n\tstruct ispsoftc *isp;\n\tint target;\n{\n\tstruct lportdb *lp, *tport;\n\tfcparam *fcp = isp->isp_param;\n\tisp_pdb_t pdb;\n\tint loopid, lim;\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * XXX: If we do this *after* building up our local port database,\n\t * XXX: the commands simply don't work.\n\t */\n\t/*\n\t * (Re)discover all fabric devices\n\t */\n\tif (fcp->isp_onfabric)\n\t\t(void) isp_scan_fabric(isp);\n#endif\n\n\n\t/*\n\t * Run through the local loop ports and get port database info\n\t * for each loop ID.\n\t *\n\t * There's a somewhat unexplained situation where the f/w passes back\n\t * the wrong database entity- if that happens, just restart (up to\n\t * FL_PORT_ID times).\n\t */\n\ttport = fcp->tport;\n\n\t/*\n\t * make sure the temp port database is clean...\n\t */\n\tMEMZERO((void *) tport, sizeof (tport));\n\tfor (lim = loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tlp = &tport[loopid];\n\t\tlp->node_wwn = isp_get_portname(isp, loopid, 1);\n\t\tif (lp->node_wwn == 0)\n\t\t\tcontinue;\n\t\tlp->port_wwn = isp_get_portname(isp, loopid, 0);\n\t\tif (lp->port_wwn == 0) {\n\t\t\tlp->node_wwn = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get an entry....\n\t\t */\n\t\tif (isp_getpdb(isp, loopid, &pdb) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the returned database element doesn't match what we\n\t\t * asked for, restart the process entirely (up to a point...).\n\t\t */\n\t\tif (pdb.pdb_loopid != loopid) {\n\t\t\tIDPRINTF(1, (\"%s: wankage (%d != %d)\\n\",\n\t\t\t    isp->isp_name, pdb.pdb_loopid, loopid));\n\t\t\tloopid = 0;\n\t\t\tif (lim++ < FL_PORT_ID) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPRINTF(\"%s: giving up on synchronizing the port \"\n\t\t\t    \"database\\n\", isp->isp_name);\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Save the pertinent info locally.\n\t\t */\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->loopid = pdb.pdb_loopid;\n\t\t/*\n\t\t * Do a quick check to see whether this matches the saved port\n\t\t * database for the same loopid. We do this here to save\n\t\t * searching later (if possible). Note that this fails over\n\t\t * time as things shuffle on the loop- we get the current\n\t\t * loop state (where loop id as an index matches loop id in\n\t\t * use) and then compare it to our saved database which\n\t\t * never shifts.\n\t\t */\n\t\tif (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {\n\t\t\tlp->valid = 1;\n\t\t}\n\t}\n\n\t/*\n\t * If we get this far, we've settled our differences with the f/w\n\t * and we can say that the loop state is ready.\n\t */\n\tfcp->isp_loopstate = LOOP_READY;\n\n\t/*\n\t * Mark all of the permanent local loop database entries as invalid.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tfcp->portdb[loopid].valid = 0;\n\t}\n\n\t/*\n\t * Now merge our local copy of the port database into our saved copy.\n\t * Notify the outer layers of new devices arriving.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tint i;\n\n\t\t/*\n\t\t * If we don't have a non-zero Port WWN, we're not here.\n\t\t */\n\t\tif (tport[loopid].port_wwn == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we've already marked our tmp copy as valid,\n\t\t * this means that we've decided that it's the\n\t\t * same as our saved data base. This didn't include\n\t\t * the 'valid' marking so we have set that here.\n\t\t */\n\t\tif (tport[loopid].valid) {\n\t\t\tfcp->portdb[loopid].valid = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For the purposes of deciding whether this is the\n\t\t * 'same' device or not, we only search for an identical\n\t\t * Port WWN. Node WWNs may or may not be the same as\n\t\t * the Port WWN, and there may be multiple different\n\t\t * Port WWNs with the same Node WWN. It would be chaos\n\t\t * to have multiple identical Port WWNs, so we don't\n\t\t * allow that.\n\t\t */\n\n\t\tfor (i = 0; i < FL_PORT_ID; i++) {\n\t\t\tint j;\n\t\t\tif (fcp->portdb[i].port_wwn == 0)\n\t\t\t\tcontinue;\n\t\t\tif (fcp->portdb[i].port_wwn != tport[loopid].port_wwn)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We found this WWN elsewhere- it's changed\n\t\t\t * loopids then. We don't change it's actual\n\t\t\t * position in our cached port database- we\n\t\t\t * just change the actual loop ID we'd use.\n\t\t\t */\n\t\t\tif (fcp->portdb[i].loopid != loopid) {\n\t\t\t\tPRINTF(\"%s: Target ID %d Loop 0x%x (Port 0x%x) \"\n\t\t\t\t    \"=> Loop 0x%x (Port 0x%x) \\n\",\n\t\t\t\t    isp->isp_name, i, fcp->portdb[i].loopid,\n\t\t\t\t    fcp->portdb[i].portid, loopid,\n\t\t\t\t    tport[loopid].portid);\n\t\t\t}\n\t\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\t\tfcp->portdb[i].loopid = loopid;\n\t\t\tfcp->portdb[i].valid = 1;\n\t\t\t/*\n\t\t\t * XXX: Should we also propagate roles in case they\n\t\t\t * XXX: changed?\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Now make sure this Port WWN doesn't exist elsewhere\n\t\t\t * in the port database.\n\t\t\t */\n\t\t\tfor (j = i+1; j < FL_PORT_ID; j++) {\n\t\t\t\tif (fcp->portdb[i].port_wwn !=\n\t\t\t\t    fcp->portdb[j].port_wwn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPRINTF(\"%s: Target ID %d Duplicates Target ID \"\n\t\t\t\t    \"%d- killing off both\\n\",\n\t\t\t\t    isp->isp_name, j, i);\n\t\t\t\t/*\n\t\t\t\t * Invalidate the 'old' *and* 'new' ones.\n\t\t\t\t * This is really harsh and not quite right,\n\t\t\t\t * but if this happens, we really don't know\n\t\t\t\t * who is what at this point.\n\t\t\t\t */\n\t\t\t\tfcp->portdb[i].valid = 0;\n\t\t\t\tfcp->portdb[j].valid = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't traverse the entire port database,\n\t\t * then we found (and remapped) an existing entry.\n\t\t * No need to notify anyone- go for the next one.\n\t\t */\n\t\tif (i < FL_PORT_ID) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We've not found this Port WWN anywhere. It's a new entry.\n\t\t * See if we can leave it where it is (with target == loopid).\n\t\t */\n\t\tif (fcp->portdb[loopid].port_wwn != 0) {\n\t\t\tfor (lim = 0; lim < FL_PORT_ID; lim++) {\n\t\t\t\tif (fcp->portdb[lim].port_wwn == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* \"Cannot Happen\" */\n\t\t\tif (lim == FL_PORT_ID) {\n\t\t\t\tPRINTF(\"%s: remap overflow?\\n\", isp->isp_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = lim;\n\t\t} else {\n\t\t\ti = loopid;\n\t\t}\n\n\t\t/*\n\t\t * NB:\tThe actual loopid we use here is loopid- we may\n\t\t *\tin fact be at a completely different index (target).\n\t\t */\n\t\tfcp->portdb[i].loopid = loopid;\n\t\tfcp->portdb[i].port_wwn = tport[loopid].port_wwn;\n\t\tfcp->portdb[i].node_wwn = tport[loopid].node_wwn;\n\t\tfcp->portdb[i].roles = tport[loopid].roles;\n\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\tfcp->portdb[i].valid = 1;\n\n\t\t/*\n\t\t * Tell the outside world we've arrived.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &i);\n\t}\n\n\t/*\n\t * Now find all previously used targets that are now invalid and\n\t * notify the outer layers that they're gone.\n\t */\n\tfor (lp = fcp->portdb; lp < &fcp->portdb[FL_PORT_ID]; lp++) {\n\t\tif (lp->valid || lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Tell the outside world we've gone away.\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\tMEMZERO((void *) lp, sizeof (*lp));\n\t}\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * Now log in any fabric devices\n\t */\n\tfor (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];\n\t     lp < &fcp->portdb[MAX_FC_TARG]; lp++) {\n\t\tu_int32_t portid;\n\t\tmbreg_t mbs;\n\n\t\t/*\n\t\t * Nothing here?\n\t\t */\n\t\tif (lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Don't try to log into yourself.\n\t\t */\n\t\tif ((portid = lp->portid) == fcp->isp_portid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Force a logout if we were logged in.\n\t\t */\n\t\tif (lp->valid) {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tlp->valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * And log in....\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\tlp->loopid = 0;\n\t\tlim = 0;\n\t\tdo {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGIN;\n\t\t\tmbs.param[1] = loopid << 8;\n\t\t\tif (IS_2200(isp)) {\n\t\t\t\t/* only issue a PLOGI if not logged in */\n\t\t\t\tmbs.param[1] |= 0x1;\n\t\t\t}\n\t\t\tmbs.param[2] = portid >> 16;\n\t\t\tmbs.param[3] = portid & 0xffff;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase MBOX_LOOP_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * Try the next available loop id.\n\t\t\t\t */\n\t\t\t\tloopid++;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_PORT_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * This port is already logged in.\n\t\t\t\t * Snaffle the loop id it's using.\n\t\t\t\t */\n\t\t\t\tif ((loopid = mbs.param[1]) == 0) {\n\t\t\t\t\tlim = -1;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_COMMAND_COMPLETE:\n\t\t\t\tlp->loopid = loopid;\n\t\t\t\tlim = 1;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_COMMAND_ERROR:\n\t\t\t\tPRINTF(\"%s: command error in PLOGI (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, mbs.param[1]);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_ALL_IDS_USED: /* We're outta IDs */\n\t\t\tdefault:\n\t\t\t\tlim = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (lim == 0 && loopid < MAX_FC_TARG);\n\t\tif (lim < 0)\n\t\t\tcontinue;\n\n\t\tlp->valid = 1;\n\t\tlp->fabdev = 1;\n\t\tif (isp_getpdb(isp, lp->loopid, &pdb) != 0) {\n\t\t\t/*\n\t\t\t * Be kind...\n\t\t\t */\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Faked PortID 0x%x into LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pdb.pdb_loopid != lp->loopid) {\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Wanked PortID 0x%x to LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\t/*\n\t\t * Check to make sure this all makes sense.\n\t\t */\n\t\tif (lp->node_wwn && lp->port_wwn) {\n\t\t\tloopid = lp - fcp->portdb;\n\t\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->fabdev = lp->valid = 0;\n\t\tPRINTF(\"%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\\n\",\n\t\t    isp->isp_name, loopid, lp->loopid, lp->portid);\n\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\tmbs.param[1] = lp->loopid << 8;\n\t\tmbs.param[2] = 0;\n\t\tmbs.param[3] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t}\n#endif\n\t/*\n\t * If we get here, we've for sure seen not only a valid loop\n\t * but know what is or isn't on it, so mark this for usage\n\t * in ispscsicmd.\n\t */\n\tfcp->loop_seen_once = 1;\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_getpdb",
            "static u_int64_t isp_get_portname",
            "static int isp_same_lportdb",
            "static int isp_pdb_sync",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic u_int64_t isp_get_portname;\nstatic int isp_same_lportdb;\nstatic int isp_pdb_sync;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_pdb_sync(isp, target)\n\tstruct ispsoftc *isp;\n\tint target;\n{\n\tstruct lportdb *lp, *tport;\n\tfcparam *fcp = isp->isp_param;\n\tisp_pdb_t pdb;\n\tint loopid, lim;\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * XXX: If we do this *after* building up our local port database,\n\t * XXX: the commands simply don't work.\n\t */\n\t/*\n\t * (Re)discover all fabric devices\n\t */\n\tif (fcp->isp_onfabric)\n\t\t(void) isp_scan_fabric(isp);\n#endif\n\n\n\t/*\n\t * Run through the local loop ports and get port database info\n\t * for each loop ID.\n\t *\n\t * There's a somewhat unexplained situation where the f/w passes back\n\t * the wrong database entity- if that happens, just restart (up to\n\t * FL_PORT_ID times).\n\t */\n\ttport = fcp->tport;\n\n\t/*\n\t * make sure the temp port database is clean...\n\t */\n\tMEMZERO((void *) tport, sizeof (tport));\n\tfor (lim = loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tlp = &tport[loopid];\n\t\tlp->node_wwn = isp_get_portname(isp, loopid, 1);\n\t\tif (lp->node_wwn == 0)\n\t\t\tcontinue;\n\t\tlp->port_wwn = isp_get_portname(isp, loopid, 0);\n\t\tif (lp->port_wwn == 0) {\n\t\t\tlp->node_wwn = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get an entry....\n\t\t */\n\t\tif (isp_getpdb(isp, loopid, &pdb) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the returned database element doesn't match what we\n\t\t * asked for, restart the process entirely (up to a point...).\n\t\t */\n\t\tif (pdb.pdb_loopid != loopid) {\n\t\t\tIDPRINTF(1, (\"%s: wankage (%d != %d)\\n\",\n\t\t\t    isp->isp_name, pdb.pdb_loopid, loopid));\n\t\t\tloopid = 0;\n\t\t\tif (lim++ < FL_PORT_ID) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPRINTF(\"%s: giving up on synchronizing the port \"\n\t\t\t    \"database\\n\", isp->isp_name);\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Save the pertinent info locally.\n\t\t */\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->loopid = pdb.pdb_loopid;\n\t\t/*\n\t\t * Do a quick check to see whether this matches the saved port\n\t\t * database for the same loopid. We do this here to save\n\t\t * searching later (if possible). Note that this fails over\n\t\t * time as things shuffle on the loop- we get the current\n\t\t * loop state (where loop id as an index matches loop id in\n\t\t * use) and then compare it to our saved database which\n\t\t * never shifts.\n\t\t */\n\t\tif (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {\n\t\t\tlp->valid = 1;\n\t\t}\n\t}\n\n\t/*\n\t * If we get this far, we've settled our differences with the f/w\n\t * and we can say that the loop state is ready.\n\t */\n\tfcp->isp_loopstate = LOOP_READY;\n\n\t/*\n\t * Mark all of the permanent local loop database entries as invalid.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tfcp->portdb[loopid].valid = 0;\n\t}\n\n\t/*\n\t * Now merge our local copy of the port database into our saved copy.\n\t * Notify the outer layers of new devices arriving.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tint i;\n\n\t\t/*\n\t\t * If we don't have a non-zero Port WWN, we're not here.\n\t\t */\n\t\tif (tport[loopid].port_wwn == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we've already marked our tmp copy as valid,\n\t\t * this means that we've decided that it's the\n\t\t * same as our saved data base. This didn't include\n\t\t * the 'valid' marking so we have set that here.\n\t\t */\n\t\tif (tport[loopid].valid) {\n\t\t\tfcp->portdb[loopid].valid = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For the purposes of deciding whether this is the\n\t\t * 'same' device or not, we only search for an identical\n\t\t * Port WWN. Node WWNs may or may not be the same as\n\t\t * the Port WWN, and there may be multiple different\n\t\t * Port WWNs with the same Node WWN. It would be chaos\n\t\t * to have multiple identical Port WWNs, so we don't\n\t\t * allow that.\n\t\t */\n\n\t\tfor (i = 0; i < FL_PORT_ID; i++) {\n\t\t\tint j;\n\t\t\tif (fcp->portdb[i].port_wwn == 0)\n\t\t\t\tcontinue;\n\t\t\tif (fcp->portdb[i].port_wwn != tport[loopid].port_wwn)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We found this WWN elsewhere- it's changed\n\t\t\t * loopids then. We don't change it's actual\n\t\t\t * position in our cached port database- we\n\t\t\t * just change the actual loop ID we'd use.\n\t\t\t */\n\t\t\tif (fcp->portdb[i].loopid != loopid) {\n\t\t\t\tPRINTF(\"%s: Target ID %d Loop 0x%x (Port 0x%x) \"\n\t\t\t\t    \"=> Loop 0x%x (Port 0x%x) \\n\",\n\t\t\t\t    isp->isp_name, i, fcp->portdb[i].loopid,\n\t\t\t\t    fcp->portdb[i].portid, loopid,\n\t\t\t\t    tport[loopid].portid);\n\t\t\t}\n\t\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\t\tfcp->portdb[i].loopid = loopid;\n\t\t\tfcp->portdb[i].valid = 1;\n\t\t\t/*\n\t\t\t * XXX: Should we also propagate roles in case they\n\t\t\t * XXX: changed?\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Now make sure this Port WWN doesn't exist elsewhere\n\t\t\t * in the port database.\n\t\t\t */\n\t\t\tfor (j = i+1; j < FL_PORT_ID; j++) {\n\t\t\t\tif (fcp->portdb[i].port_wwn !=\n\t\t\t\t    fcp->portdb[j].port_wwn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPRINTF(\"%s: Target ID %d Duplicates Target ID \"\n\t\t\t\t    \"%d- killing off both\\n\",\n\t\t\t\t    isp->isp_name, j, i);\n\t\t\t\t/*\n\t\t\t\t * Invalidate the 'old' *and* 'new' ones.\n\t\t\t\t * This is really harsh and not quite right,\n\t\t\t\t * but if this happens, we really don't know\n\t\t\t\t * who is what at this point.\n\t\t\t\t */\n\t\t\t\tfcp->portdb[i].valid = 0;\n\t\t\t\tfcp->portdb[j].valid = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't traverse the entire port database,\n\t\t * then we found (and remapped) an existing entry.\n\t\t * No need to notify anyone- go for the next one.\n\t\t */\n\t\tif (i < FL_PORT_ID) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We've not found this Port WWN anywhere. It's a new entry.\n\t\t * See if we can leave it where it is (with target == loopid).\n\t\t */\n\t\tif (fcp->portdb[loopid].port_wwn != 0) {\n\t\t\tfor (lim = 0; lim < FL_PORT_ID; lim++) {\n\t\t\t\tif (fcp->portdb[lim].port_wwn == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* \"Cannot Happen\" */\n\t\t\tif (lim == FL_PORT_ID) {\n\t\t\t\tPRINTF(\"%s: remap overflow?\\n\", isp->isp_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = lim;\n\t\t} else {\n\t\t\ti = loopid;\n\t\t}\n\n\t\t/*\n\t\t * NB:\tThe actual loopid we use here is loopid- we may\n\t\t *\tin fact be at a completely different index (target).\n\t\t */\n\t\tfcp->portdb[i].loopid = loopid;\n\t\tfcp->portdb[i].port_wwn = tport[loopid].port_wwn;\n\t\tfcp->portdb[i].node_wwn = tport[loopid].node_wwn;\n\t\tfcp->portdb[i].roles = tport[loopid].roles;\n\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\tfcp->portdb[i].valid = 1;\n\n\t\t/*\n\t\t * Tell the outside world we've arrived.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &i);\n\t}\n\n\t/*\n\t * Now find all previously used targets that are now invalid and\n\t * notify the outer layers that they're gone.\n\t */\n\tfor (lp = fcp->portdb; lp < &fcp->portdb[FL_PORT_ID]; lp++) {\n\t\tif (lp->valid || lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Tell the outside world we've gone away.\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\tMEMZERO((void *) lp, sizeof (*lp));\n\t}\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * Now log in any fabric devices\n\t */\n\tfor (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];\n\t     lp < &fcp->portdb[MAX_FC_TARG]; lp++) {\n\t\tu_int32_t portid;\n\t\tmbreg_t mbs;\n\n\t\t/*\n\t\t * Nothing here?\n\t\t */\n\t\tif (lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Don't try to log into yourself.\n\t\t */\n\t\tif ((portid = lp->portid) == fcp->isp_portid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Force a logout if we were logged in.\n\t\t */\n\t\tif (lp->valid) {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tlp->valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * And log in....\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\tlp->loopid = 0;\n\t\tlim = 0;\n\t\tdo {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGIN;\n\t\t\tmbs.param[1] = loopid << 8;\n\t\t\tif (IS_2200(isp)) {\n\t\t\t\t/* only issue a PLOGI if not logged in */\n\t\t\t\tmbs.param[1] |= 0x1;\n\t\t\t}\n\t\t\tmbs.param[2] = portid >> 16;\n\t\t\tmbs.param[3] = portid & 0xffff;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase MBOX_LOOP_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * Try the next available loop id.\n\t\t\t\t */\n\t\t\t\tloopid++;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_PORT_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * This port is already logged in.\n\t\t\t\t * Snaffle the loop id it's using.\n\t\t\t\t */\n\t\t\t\tif ((loopid = mbs.param[1]) == 0) {\n\t\t\t\t\tlim = -1;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_COMMAND_COMPLETE:\n\t\t\t\tlp->loopid = loopid;\n\t\t\t\tlim = 1;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_COMMAND_ERROR:\n\t\t\t\tPRINTF(\"%s: command error in PLOGI (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, mbs.param[1]);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_ALL_IDS_USED: /* We're outta IDs */\n\t\t\tdefault:\n\t\t\t\tlim = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (lim == 0 && loopid < MAX_FC_TARG);\n\t\tif (lim < 0)\n\t\t\tcontinue;\n\n\t\tlp->valid = 1;\n\t\tlp->fabdev = 1;\n\t\tif (isp_getpdb(isp, lp->loopid, &pdb) != 0) {\n\t\t\t/*\n\t\t\t * Be kind...\n\t\t\t */\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Faked PortID 0x%x into LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pdb.pdb_loopid != lp->loopid) {\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Wanked PortID 0x%x to LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\t/*\n\t\t * Check to make sure this all makes sense.\n\t\t */\n\t\tif (lp->node_wwn && lp->port_wwn) {\n\t\t\tloopid = lp - fcp->portdb;\n\t\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->fabdev = lp->valid = 0;\n\t\tPRINTF(\"%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\\n\",\n\t\t    isp->isp_name, loopid, lp->loopid, lp->portid);\n\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\tmbs.param[1] = lp->loopid << 8;\n\t\tmbs.param[2] = 0;\n\t\tmbs.param[3] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t}\n#endif\n\t/*\n\t * If we get here, we've for sure seen not only a valid loop\n\t * but know what is or isn't on it, so mark this for usage\n\t * in ispscsicmd.\n\t */\n\tfcp->loop_seen_once = 1;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_fclink_test",
          "args": [
            "isp",
            "FC_FW_READY_DELAY"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "isp_fclink_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1247-1352",
          "snippet": "static int\nisp_fclink_test(isp, waitdelay)\n\tstruct ispsoftc *isp;\n\tint waitdelay;\n{\n\tstatic char *toponames[] = {\n\t\t\"Private Loop\",\n\t\t\"FL Port\",\n\t\t\"N-Port to N-Port\",\n\t\t\"F Port\"\n\t};\n\tmbreg_t mbs;\n\tint count;\n\tu_int8_t lwfs;\n\tfcparam *fcp;\n#if\tdefined(ISP2100_FABRIC)\n\tisp_pdb_t pdb;\n#endif\n\tfcp = isp->isp_param;\n\n\t/*\n\t * Wait up to N microseconds for F/W to go to a ready state.\n\t */\n\tlwfs = FW_CONFIG_WAIT;\n\tfor (count = 0; count < waitdelay; count += 100) {\n\t\tisp_fw_state(isp);\n\t\tif (lwfs != fcp->isp_fwstate) {\n\t\t\tPRINTF(\"%s: Firmware State %s -> %s\\n\",\n\t\t\t    isp->isp_name, isp2100_fw_statename((int)lwfs),\n\t\t\t    isp2100_fw_statename((int)fcp->isp_fwstate));\n\t\t\tlwfs = fcp->isp_fwstate;\n\t\t}\n\t\tif (fcp->isp_fwstate == FW_READY) {\n\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\t/* wait 100 microseconds */\n\t}\n\n\t/*\n\t * If we haven't gone to 'ready' state, return.\n\t */\n\tif (fcp->isp_fwstate != FW_READY) {\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get our Loop ID (if possible). We really need to have it.\n\t */\n\tmbs.param[0] = MBOX_GET_LOOP_ID;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: GET LOOP ID failed\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tfcp->isp_loopid = mbs.param[1];\n\tif (IS_2200(isp)) {\n\t\tcount = (int) mbs.param[6];\n\t\tif (count < TOPO_NL_PORT || count > TOPO_PTP_STUB)\n\t\t\tcount = TOPO_PTP_STUB;\n\t\tfcp->isp_topo = count;\n\t} else {\n\t\tfcp->isp_topo = TOPO_NL_PORT;\n\t}\n\n\t/*\n\t * If we're not on a fabric, the low 8 bits will be our AL_PA.\n\t * If we're on a fabric, the low 8 bits will still be our AL_PA.\n\t */\n\tfcp->isp_alpa = mbs.param[2];\n#if\tdefined(ISP2100_FABRIC)\n\tfcp->isp_onfabric = 0;\n\tif (isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {\n\n\t\tif (IS_2100(isp))\n\t\t\tfcp->isp_topo = TOPO_FL_PORT;\n\n\t\tfcp->isp_portid = mbs.param[2] | (((int)mbs.param[3]) << 16);\n\t\tfcp->isp_onfabric = 1;\n\t\tCFGPRINTF(\"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State \"\n\t\t    \"0x%x topology '%s'\\n\", isp->isp_name, fcp->isp_loopid,\n\t\t    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,\n\t\t    toponames[fcp->isp_topo]);\n\n\t\t/*\n\t\t * Make sure we're logged out of all fabric devices.\n\t\t */\n\t\tfor (count = FC_SNS_ID+1; count < MAX_FC_TARG; count++) {\n\t\t\tstruct lportdb *lp = &fcp->portdb[count];\n\t\t\tif (lp->valid == 0 || lp->fabdev == 0)\n\t\t\t\tcontinue;\n\t\t\tPRINTF(\"%s: logging out target %d at Loop ID %d \"\n\t\t\t    \"(port id 0x%x)\\n\", isp->isp_name, count,\n\t\t\t    lp->loopid, lp->portid);\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t}\n\t} else\n#endif\n\tCFGPRINTF(\"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\\n\",\n\t    isp->isp_name, fcp->isp_loopid, fcp->isp_alpa, fcp->isp_loopstate,\n\t    toponames[fcp->isp_topo]);\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_getpdb",
            "static int isp_fclink_test",
            "static void isp_fw_state",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic int isp_fclink_test;\nstatic void isp_fw_state;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_fclink_test(isp, waitdelay)\n\tstruct ispsoftc *isp;\n\tint waitdelay;\n{\n\tstatic char *toponames[] = {\n\t\t\"Private Loop\",\n\t\t\"FL Port\",\n\t\t\"N-Port to N-Port\",\n\t\t\"F Port\"\n\t};\n\tmbreg_t mbs;\n\tint count;\n\tu_int8_t lwfs;\n\tfcparam *fcp;\n#if\tdefined(ISP2100_FABRIC)\n\tisp_pdb_t pdb;\n#endif\n\tfcp = isp->isp_param;\n\n\t/*\n\t * Wait up to N microseconds for F/W to go to a ready state.\n\t */\n\tlwfs = FW_CONFIG_WAIT;\n\tfor (count = 0; count < waitdelay; count += 100) {\n\t\tisp_fw_state(isp);\n\t\tif (lwfs != fcp->isp_fwstate) {\n\t\t\tPRINTF(\"%s: Firmware State %s -> %s\\n\",\n\t\t\t    isp->isp_name, isp2100_fw_statename((int)lwfs),\n\t\t\t    isp2100_fw_statename((int)fcp->isp_fwstate));\n\t\t\tlwfs = fcp->isp_fwstate;\n\t\t}\n\t\tif (fcp->isp_fwstate == FW_READY) {\n\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\t/* wait 100 microseconds */\n\t}\n\n\t/*\n\t * If we haven't gone to 'ready' state, return.\n\t */\n\tif (fcp->isp_fwstate != FW_READY) {\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get our Loop ID (if possible). We really need to have it.\n\t */\n\tmbs.param[0] = MBOX_GET_LOOP_ID;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: GET LOOP ID failed\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tfcp->isp_loopid = mbs.param[1];\n\tif (IS_2200(isp)) {\n\t\tcount = (int) mbs.param[6];\n\t\tif (count < TOPO_NL_PORT || count > TOPO_PTP_STUB)\n\t\t\tcount = TOPO_PTP_STUB;\n\t\tfcp->isp_topo = count;\n\t} else {\n\t\tfcp->isp_topo = TOPO_NL_PORT;\n\t}\n\n\t/*\n\t * If we're not on a fabric, the low 8 bits will be our AL_PA.\n\t * If we're on a fabric, the low 8 bits will still be our AL_PA.\n\t */\n\tfcp->isp_alpa = mbs.param[2];\n#if\tdefined(ISP2100_FABRIC)\n\tfcp->isp_onfabric = 0;\n\tif (isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {\n\n\t\tif (IS_2100(isp))\n\t\t\tfcp->isp_topo = TOPO_FL_PORT;\n\n\t\tfcp->isp_portid = mbs.param[2] | (((int)mbs.param[3]) << 16);\n\t\tfcp->isp_onfabric = 1;\n\t\tCFGPRINTF(\"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State \"\n\t\t    \"0x%x topology '%s'\\n\", isp->isp_name, fcp->isp_loopid,\n\t\t    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,\n\t\t    toponames[fcp->isp_topo]);\n\n\t\t/*\n\t\t * Make sure we're logged out of all fabric devices.\n\t\t */\n\t\tfor (count = FC_SNS_ID+1; count < MAX_FC_TARG; count++) {\n\t\t\tstruct lportdb *lp = &fcp->portdb[count];\n\t\t\tif (lp->valid == 0 || lp->fabdev == 0)\n\t\t\t\tcontinue;\n\t\t\tPRINTF(\"%s: logging out target %d at Loop ID %d \"\n\t\t\t    \"(port id 0x%x)\\n\", isp->isp_name, count,\n\t\t\t    lp->loopid, lp->portid);\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t}\n\t} else\n#endif\n\tCFGPRINTF(\"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\\n\",\n\t    isp->isp_name, fcp->isp_loopid, fcp->isp_alpa, fcp->isp_loopstate,\n\t    toponames[fcp->isp_topo]);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_update",
          "args": [
            "isp"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "isp_update_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3760-3854",
          "snippet": "static void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_mboxcmd",
            "static void isp_update_bus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mboxcmd;\nstatic void isp_update_bus;\n\nstatic void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: command for target %d lun %d was aborted\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_control MBOX_ABORT failure (code %x)\\n\"",
            "isp->isp_name",
            "mbs.param[0]"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\"",
            "isp->isp_name"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_find_handle",
          "args": [
            "isp",
            "xs"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "isp_find_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "221-235",
          "snippet": "static INLINE u_int32_t\nisp_find_handle(isp, xs)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tint i;\n\tif (xs != NULL) {\n\t\tfor (i = 0; i < isp->isp_maxcmds; i++) {\n\t\t\tif (isp->isp_xflist[i] == xs) {\n\t\t\t\treturn ((u_int32_t) i+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE u_int32_t\nisp_find_handle(isp, xs)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n{\n\tint i;\n\tif (xs != NULL) {\n\t\tfor (i = 0; i < isp->isp_maxcmds; i++) {\n\t\t\tif (isp->isp_xflist[i] == xs) {\n\t\t\t\treturn ((u_int32_t) i+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Target %d on Bus %d Reset Succeeded\\n\"",
            "isp->isp_name",
            "tgt",
            "bus"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\"",
            "isp->isp_name",
            "mbs.param[0]"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: driver initiated bus reset of bus %d\\n\"",
            "isp->isp_name",
            "bus"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_dumpregs",
          "args": [
            "isp",
            "\"isp_control SCSI bus reset failed\""
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "isp_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3659-3693",
          "snippet": "static void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_dumpregs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_dumpregs;\n\nstatic void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_control unknown control op %x\\n\"",
            "isp->isp_name",
            "ctl"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_fclink_test;\nstatic int isp_pdb_sync;\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\nstatic void isp_update;\n\nint\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}"
  },
  {
    "function_name": "ispscsicmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1862-2143",
    "snippet": "int32_t\nispscsicmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tu_int16_t iptr, optr;\n\tunion {\n\t\tispreq_t *_reqp;\n\t\tispreqt2_t *_t2reqp;\n\t} _u;\n#define\treqp\t_u._reqp\n#define\tt2reqp\t_u._t2reqp\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n\tint target, i;\n\n\tXS_INITERR(xs);\n\tisp = XS_ISP(xs);\n\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: adapter not ready\\n\", isp->isp_name);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check command CDB length, etc.. We really are limited to 16 bytes\n\t * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,\n\t * but probably only if we're running fairly new firmware (we'll\n\t * let the old f/w choke on an extended command queue entry).\n\t */\n\n\tif (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {\n\t\tPRINTF(\"%s: unsupported cdb length (%d, CDB[0]=0x%x)\\n\",\n\t\t    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check to see whether we have good firmware state still or\n\t * need to refresh our port database for this target.\n\t */\n\ttarget = XS_TGT(xs);\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = isp->isp_param;\n\t\tstruct lportdb *lp;\n#if\tdefined(ISP2100_FABRIC)\n\t\t/*\n\t\t * If we're not on a Fabric, we can't have a target\n\t\t * above FL_PORT_ID-1. If we're on a fabric and\n\t\t * connected as an F-port, we can't have a target\n\t\t * less than FC_SNS_ID+1.\n\t\t */\n\t\tif (fcp->isp_onfabric == 0) {\n\t\t\tif (target >= FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (target >= FL_PORT_ID && target <= FC_SNS_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t\tif (fcp->isp_topo == TOPO_F_PORT &&\n\t\t\t    target < FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n#endif\n\t\t/*\n\t\t * Check for f/w being in ready state. If the f/w\n\t\t * isn't in ready state, then we don't know our\n\t\t * loop ID and the f/w hasn't completed logging\n\t\t * into all targets on the loop. If this is the\n\t\t * case, then bounce the command. We pretend this is\n\t\t * a SELECTION TIMEOUT error if we've never gone to\n\t\t * FW_READY state at all- in this case we may not\n\t\t * be hooked to a loop at all and we shouldn't hang\n\t\t * the machine for this. Otherwise, defer this command\n\t\t * until later.\n\t\t */\n\t\tif (fcp->isp_fwstate != FW_READY) {\n\t\t\tif (isp_fclink_test(isp, FC_FW_READY_DELAY)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\t\treturn (CMD_RQLATER);\n\t\t\t\t} else {\n\t\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is such that we haven't yet received\n\t\t * a \"Port Database Changed\" notification (after a LIP or\n\t\t * a Loop Reset or firmware initialization), then defer\n\t\t * sending commands for a little while, but only if we've\n\t\t * seen a valid loop at one point (otherwise we can get\n\t\t * stuck at initialization time).\n\t\t */\n\t\tif (fcp->isp_loopstate < LOOP_PDB_RCVD) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\treturn (CMD_RQLATER);\n\t\t\t} else {\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is now such that we've just now\n\t\t * received a Port Database Change notification, then\n\t\t * we have to go off and (re)synchronize our port\n\t\t * database.\n\t\t */\n\t\tif (fcp->isp_loopstate == LOOP_PDB_RCVD) {\n\t\t\tif (isp_pdb_sync(isp, target)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now check whether we should even think about pursuing this.\n\t\t */\n\t\tlp = &fcp->portdb[target];\n\t\tif (lp->valid == 0) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tif ((lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT)) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: target %d is not a target\\n\",\n\t\t\t    isp->isp_name, target));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\t/*\n\t\t * Now turn target into what the actual loop ID is.\n\t\t */\n\t\ttarget = lp->loopid;\n\t}\n\n\t/*\n\t * Next check to see if any HBA or Device\n\t * parameters need to be updated.\n\t */\n\tif (isp->isp_update != 0) {\n\t\tisp_update(isp);\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, (void **) &reqp)) {\n\t\tIDPRINTF(1, (\"%s: Request Queue Overflow\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\n\t/*\n\t * Now see if we need to synchronize the ISP with respect to anything.\n\t * We do dual duty here (cough) for synchronizing for busses other\n\t * than which we got here to send a command to.\n\t */\n\tif (isp->isp_sendmarker) {\n\t\tu_int8_t n = (IS_DUALBUS(isp)? 2: 1);\n\t\t/*\n\t\t * Check ports to send markers for...\n\t\t */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((isp->isp_sendmarker & (1 << i)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMEMZERO((void *) reqp, sizeof (*reqp));\n\t\t\treqp->req_header.rqs_entry_count = 1;\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_MARKER;\n\t\t\treqp->req_modifier = SYNC_ALL;\n\t\t\treqp->req_target = i << 7;\t/* insert bus number */\n\t\t\tISP_SWIZZLE_REQUEST(isp, reqp);\n\t\t\tMemoryBarrier();\n\t\t\tISP_ADD_REQUEST(isp, iptr);\n\n\t\t\tif (isp_getrqentry(isp, &iptr, &optr, (void **)&reqp)) {\n\t\t\t\tIDPRINTF(1, (\"%s: Request Queue Overflow+\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\treturn (CMD_EAGAIN);\n\t\t\t}\n\t\t}\n\t}\n\n\tMEMZERO((void *) reqp, UZSIZE);\n\treqp->req_header.rqs_entry_count = 1;\n\tif (IS_FC(isp)) {\n\t\treqp->req_header.rqs_entry_type = RQSTYPE_T2RQS;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;\n\t\telse\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;\n\t}\n\treqp->req_header.rqs_flags = 0;\n\treqp->req_header.rqs_seqno = 0;\n\tif (IS_FC(isp)) {\n\t\t/*\n\t\t * See comment in isp_intr\n\t\t */\n\t\tXS_RESID(xs) = 0;\n\n\t\t/*\n\t\t * Fibre Channel always requires some kind of tag.\n\t\t * The Qlogic drivers seem be happy not to use a tag,\n\t\t * but this breaks for some devices (IBM drives).\n\t\t */\n\t\tif (XS_CANTAG(xs)) {\n\t\t\tt2reqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t} else {\n\t\t\tif (XS_CDBP(xs)[0] == 0x3)\t/* REQUEST SENSE */\n\t\t\t\tt2reqp->req_flags = REQFLAG_HTAG;\n\t\t\telse\n\t\t\t\tt2reqp->req_flags = REQFLAG_OTAG;\n\t\t}\n\t} else {\n\t\tsdparam *sdp = (sdparam *)isp->isp_param;\n\t\tif ((sdp->isp_devparam[target].cur_dflags & DPARM_TQING) &&\n\t\t    XS_CANTAG(xs)) {\n\t\t\treqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t}\n\t}\n\treqp->req_target = target | (XS_CHANNEL(xs) << 7);\n\tif (IS_SCSI(isp)) {\n\t\treqp->req_lun_trn = XS_LUN(xs);\n\t\treqp->req_cdblen = XS_CDBLEN(xs);\n\t} else {\n#ifdef\tISP2100_SCCLUN\n\t\tt2reqp->req_scclun = XS_LUN(xs);\n#else\n\t\tt2reqp->req_lun_trn = XS_LUN(xs);\n#endif\n\t}\n\tMEMCPY(reqp->req_cdb, XS_CDBP(xs), XS_CDBLEN(xs));\n\n\treqp->req_time = XS_TIME(xs) / 1000;\n\tif (reqp->req_time == 0 && XS_TIME(xs))\n\t\treqp->req_time = 1;\n\n\t/*\n\t * Always give a bit more leeway to commands after a bus reset.\n\t * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED\n\t */\n\tif (isp->isp_sendmarker && reqp->req_time < 5) {\n\t\treqp->req_time = 5;\n\t}\n\tif (isp_save_xs(isp, xs, &reqp->req_handle)) {\n\t\tIDPRINTF(2, (\"%s: out of xflist pointers\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\t/*\n\t * Set up DMA and/or do any bus swizzling of the request entry\n\t * so that the Qlogic F/W understands what is being asked of it.\n \t*/\n\ti = ISP_DMASETUP(isp, xs, reqp, &iptr, optr);\n\tif (i != CMD_QUEUED) {\n\t\tisp_destroy_handle(isp, reqp->req_handle);\n\t\t/*\n\t\t * dmasetup sets actual error in packet, and\n\t\t * return what we were given to return.\n\t\t */\n\t\treturn (i);\n\t}\n\tXS_SETERR(xs, HBA_NOERROR);\n\tIDPRINTF(5, (\"%s(%d.%d.%d): START cmd 0x%x datalen %d\\n\",\n\t    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),\n\t    reqp->req_cdb[0], XS_XFRLEN(xs)));\n\tMemoryBarrier();\n\tISP_ADD_REQUEST(isp, iptr);\n\tisp->isp_nactive++;\n\tif (isp->isp_sendmarker)\n\t\tisp->isp_sendmarker = 0;\n\treturn (CMD_QUEUED);\n#undef\treqp\n#undef\tt2reqp\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))",
      "#define\tt2reqp\t_u._t2reqp",
      "#define\treqp\t_u._reqp"
    ],
    "globals_used": [
      "static int isp_fclink_test",
      "static int isp_pdb_sync",
      "static void isp_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISP_ADD_REQUEST",
          "args": [
            "isp",
            "iptr"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryBarrier",
          "args": [],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "5",
            "(\"%s(%d.%d.%d): START cmd 0x%x datalen %d\\n\",\n\t    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),\n\t    reqp->req_cdb[0], XS_XFRLEN(xs))"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_XFRLEN",
          "args": [
            "xs"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_NOERROR"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_destroy_handle",
          "args": [
            "isp",
            "reqp->req_handle"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "isp_destroy_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "237-245",
          "snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE void\nisp_destroy_handle(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle > 0 && handle <= (u_int32_t) isp->isp_maxcmds) {\n\t\tisp->isp_xflist[handle - 1] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_DMASETUP",
          "args": [
            "isp",
            "xs",
            "reqp",
            "&iptr",
            "optr"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"%s: out of xflist pointers\\n\", isp->isp_name)"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_save_xs",
          "args": [
            "isp",
            "xs",
            "&reqp->req_handle"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "isp_save_xs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "182-207",
          "snippet": "static INLINE int\nisp_save_xs(isp, xs, handlep)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t *handlep;\n{\n\tint i, j;\n\n\tfor (j = isp->isp_lasthdls, i = 0; i < (int) isp->isp_maxcmds; i++) {\n\t\tif (isp->isp_xflist[j] == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tif (++j == isp->isp_maxcmds) {\n\t\t\tj = 0;\n\t\t}\n\t}\n\tif (i == isp->isp_maxcmds) {\n\t\treturn (-1);\n\t}\n\tisp->isp_xflist[j] = xs;\n\t*handlep = j+1;\n\tif (++j == isp->isp_maxcmds)\n\t\tj = 0;\n\tisp->isp_lasthdls = j;\n\treturn (0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE int\nisp_save_xs(isp, xs, handlep)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t *handlep;\n{\n\tint i, j;\n\n\tfor (j = isp->isp_lasthdls, i = 0; i < (int) isp->isp_maxcmds; i++) {\n\t\tif (isp->isp_xflist[j] == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tif (++j == isp->isp_maxcmds) {\n\t\t\tj = 0;\n\t\t}\n\t}\n\tif (i == isp->isp_maxcmds) {\n\t\treturn (-1);\n\t}\n\tisp->isp_xflist[j] = xs;\n\t*handlep = j+1;\n\tif (++j == isp->isp_maxcmds)\n\t\tj = 0;\n\tisp->isp_lasthdls = j;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_TIME",
          "args": [
            "xs"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TIME",
          "args": [
            "xs"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMCPY",
          "args": [
            "reqp->req_cdb",
            "XS_CDBP(xs)",
            "XS_CDBLEN(xs)"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBLEN",
          "args": [
            "xs"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBP",
          "args": [
            "xs"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBLEN",
          "args": [
            "xs"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_KINDOF_TAG",
          "args": [
            "xs"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CANTAG",
          "args": [
            "xs"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBP",
          "args": [
            "xs"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_KINDOF_TAG",
          "args": [
            "xs"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CANTAG",
          "args": [
            "xs"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_RESID",
          "args": [
            "xs"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBLEN",
          "args": [
            "xs"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "(void *) reqp",
            "UZSIZE"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: Request Queue Overflow+\\n\",\n\t\t\t\t    isp->isp_name)"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_getrqentry",
          "args": [
            "isp",
            "&iptr",
            "&optr",
            "(void **)&reqp"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "isp_getrqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "258-277",
          "snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_ADD_REQUEST",
          "args": [
            "isp",
            "iptr"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryBarrier",
          "args": [],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZZLE_REQUEST",
          "args": [
            "isp",
            "reqp"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "(void *) reqp",
            "sizeof (*reqp)"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: Request Queue Overflow\\n\", isp->isp_name)"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_update",
          "args": [
            "isp"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "isp_update_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3760-3854",
          "snippet": "static void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_mboxcmd",
            "static void isp_update_bus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mboxcmd;\nstatic void isp_update_bus;\n\nstatic void\nisp_update_bus(isp, bus)\n\tstruct ispsoftc *isp;\n\tint bus;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\treturn;\n\t}\n\n\tsdp = isp->isp_param;\n\tsdp += bus;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tu_int16_t flags, period, offset;\n\t\tint get;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d update\\n\",\n\t\t\t    isp->isp_name, tgt, bus));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the goal is to update the status of the device,\n\t\t * take what's in dev_flags and try and set the device\n\t\t * toward that. Otherwise, if we're just refreshing the\n\t\t * current device state, get the current parameters.\n\t\t */\n\t\tif (sdp->isp_devparam[tgt].dev_update) {\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[2] = sdp->isp_devparam[tgt].dev_flags;\n\t\t\t/*\n\t\t\t * Insist that PARITY must be enabled if SYNC\n\t\t\t * is enabled.\n\t\t\t */\n\t\t\tif (mbs.param[2] & DPARM_SYNC) {\n\t\t\t\tmbs.param[2] |= DPARM_PARITY;\n\t\t\t}\n\t\t\tmbs.param[3] =\n\t\t\t\t(sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t\t(sdp->isp_devparam[tgt].sync_period);\n\t\t\tsdp->isp_devparam[tgt].dev_update = 0;\n\t\t\t/*\n\t\t\t * A command completion later that has\n\t\t\t * RQSTF_NEGOTIATION set will cause\n\t\t\t * the dev_refresh/announce cycle.\n\t\t\t *\n\t\t\t * Note: It is really important to update our current\n\t\t\t * flags with at least the state of TAG capabilities-\n\t\t\t * otherwise we might try and send a tagged command\n\t\t\t * when we have it all turned off. So change it here\n\t\t\t * to say that current already matches goal.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\t\tsdp->isp_devparam[tgt].cur_dflags |=\n\t\t\t    (sdp->isp_devparam[tgt].dev_flags & DPARM_TQING);\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 1;\n\t\t\tIDPRINTF(3, (\"%s: bus %d set tgt %d flags 0x%x off 0x%x\"\n\t\t\t    \" period 0x%x\\n\", isp->isp_name, bus, tgt,\n\t\t\t    mbs.param[2], mbs.param[3] >> 8,\n\t\t\t    mbs.param[3] & 0xff));\n\t\t\tget = 0;\n\t\t} else if (sdp->isp_devparam[tgt].dev_refresh) {\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tsdp->isp_devparam[tgt].dev_refresh = 0;\n\t\t\tget = 1;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tmbs.param[1] = (bus << 15) | (tgt << 8) ;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: failed to %cet SCSI parameters for \"\n\t\t\t    \"target %d\\n\", isp->isp_name, (get)? 'g' : 's',\n\t\t\t    tgt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (get == 0) {\n\t\t\tisp->isp_sendmarker |= (1 << bus);\n\t\t\tcontinue;\n\t\t}\n\t\tflags = mbs.param[2];\n\t\tperiod = mbs.param[3] & 0xff;\n\t\toffset = mbs.param[3] >> 8;\n\t\tsdp->isp_devparam[tgt].cur_dflags = flags;\n\t\tsdp->isp_devparam[tgt].cur_period = period;\n\t\tsdp->isp_devparam[tgt].cur_offset = offset;\n\t\tget = (bus << 16) | tgt;\n\t\t(void) isp_async(isp, ISPASYNC_NEW_TGT_PARAMS, &get);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: target %d is not a target\\n\",\n\t\t\t    isp->isp_name, target)"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_pdb_sync",
          "args": [
            "isp",
            "target"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pdb_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1380-1795",
          "snippet": "static int\nisp_pdb_sync(isp, target)\n\tstruct ispsoftc *isp;\n\tint target;\n{\n\tstruct lportdb *lp, *tport;\n\tfcparam *fcp = isp->isp_param;\n\tisp_pdb_t pdb;\n\tint loopid, lim;\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * XXX: If we do this *after* building up our local port database,\n\t * XXX: the commands simply don't work.\n\t */\n\t/*\n\t * (Re)discover all fabric devices\n\t */\n\tif (fcp->isp_onfabric)\n\t\t(void) isp_scan_fabric(isp);\n#endif\n\n\n\t/*\n\t * Run through the local loop ports and get port database info\n\t * for each loop ID.\n\t *\n\t * There's a somewhat unexplained situation where the f/w passes back\n\t * the wrong database entity- if that happens, just restart (up to\n\t * FL_PORT_ID times).\n\t */\n\ttport = fcp->tport;\n\n\t/*\n\t * make sure the temp port database is clean...\n\t */\n\tMEMZERO((void *) tport, sizeof (tport));\n\tfor (lim = loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tlp = &tport[loopid];\n\t\tlp->node_wwn = isp_get_portname(isp, loopid, 1);\n\t\tif (lp->node_wwn == 0)\n\t\t\tcontinue;\n\t\tlp->port_wwn = isp_get_portname(isp, loopid, 0);\n\t\tif (lp->port_wwn == 0) {\n\t\t\tlp->node_wwn = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get an entry....\n\t\t */\n\t\tif (isp_getpdb(isp, loopid, &pdb) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the returned database element doesn't match what we\n\t\t * asked for, restart the process entirely (up to a point...).\n\t\t */\n\t\tif (pdb.pdb_loopid != loopid) {\n\t\t\tIDPRINTF(1, (\"%s: wankage (%d != %d)\\n\",\n\t\t\t    isp->isp_name, pdb.pdb_loopid, loopid));\n\t\t\tloopid = 0;\n\t\t\tif (lim++ < FL_PORT_ID) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPRINTF(\"%s: giving up on synchronizing the port \"\n\t\t\t    \"database\\n\", isp->isp_name);\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Save the pertinent info locally.\n\t\t */\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->loopid = pdb.pdb_loopid;\n\t\t/*\n\t\t * Do a quick check to see whether this matches the saved port\n\t\t * database for the same loopid. We do this here to save\n\t\t * searching later (if possible). Note that this fails over\n\t\t * time as things shuffle on the loop- we get the current\n\t\t * loop state (where loop id as an index matches loop id in\n\t\t * use) and then compare it to our saved database which\n\t\t * never shifts.\n\t\t */\n\t\tif (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {\n\t\t\tlp->valid = 1;\n\t\t}\n\t}\n\n\t/*\n\t * If we get this far, we've settled our differences with the f/w\n\t * and we can say that the loop state is ready.\n\t */\n\tfcp->isp_loopstate = LOOP_READY;\n\n\t/*\n\t * Mark all of the permanent local loop database entries as invalid.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tfcp->portdb[loopid].valid = 0;\n\t}\n\n\t/*\n\t * Now merge our local copy of the port database into our saved copy.\n\t * Notify the outer layers of new devices arriving.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tint i;\n\n\t\t/*\n\t\t * If we don't have a non-zero Port WWN, we're not here.\n\t\t */\n\t\tif (tport[loopid].port_wwn == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we've already marked our tmp copy as valid,\n\t\t * this means that we've decided that it's the\n\t\t * same as our saved data base. This didn't include\n\t\t * the 'valid' marking so we have set that here.\n\t\t */\n\t\tif (tport[loopid].valid) {\n\t\t\tfcp->portdb[loopid].valid = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For the purposes of deciding whether this is the\n\t\t * 'same' device or not, we only search for an identical\n\t\t * Port WWN. Node WWNs may or may not be the same as\n\t\t * the Port WWN, and there may be multiple different\n\t\t * Port WWNs with the same Node WWN. It would be chaos\n\t\t * to have multiple identical Port WWNs, so we don't\n\t\t * allow that.\n\t\t */\n\n\t\tfor (i = 0; i < FL_PORT_ID; i++) {\n\t\t\tint j;\n\t\t\tif (fcp->portdb[i].port_wwn == 0)\n\t\t\t\tcontinue;\n\t\t\tif (fcp->portdb[i].port_wwn != tport[loopid].port_wwn)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We found this WWN elsewhere- it's changed\n\t\t\t * loopids then. We don't change it's actual\n\t\t\t * position in our cached port database- we\n\t\t\t * just change the actual loop ID we'd use.\n\t\t\t */\n\t\t\tif (fcp->portdb[i].loopid != loopid) {\n\t\t\t\tPRINTF(\"%s: Target ID %d Loop 0x%x (Port 0x%x) \"\n\t\t\t\t    \"=> Loop 0x%x (Port 0x%x) \\n\",\n\t\t\t\t    isp->isp_name, i, fcp->portdb[i].loopid,\n\t\t\t\t    fcp->portdb[i].portid, loopid,\n\t\t\t\t    tport[loopid].portid);\n\t\t\t}\n\t\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\t\tfcp->portdb[i].loopid = loopid;\n\t\t\tfcp->portdb[i].valid = 1;\n\t\t\t/*\n\t\t\t * XXX: Should we also propagate roles in case they\n\t\t\t * XXX: changed?\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Now make sure this Port WWN doesn't exist elsewhere\n\t\t\t * in the port database.\n\t\t\t */\n\t\t\tfor (j = i+1; j < FL_PORT_ID; j++) {\n\t\t\t\tif (fcp->portdb[i].port_wwn !=\n\t\t\t\t    fcp->portdb[j].port_wwn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPRINTF(\"%s: Target ID %d Duplicates Target ID \"\n\t\t\t\t    \"%d- killing off both\\n\",\n\t\t\t\t    isp->isp_name, j, i);\n\t\t\t\t/*\n\t\t\t\t * Invalidate the 'old' *and* 'new' ones.\n\t\t\t\t * This is really harsh and not quite right,\n\t\t\t\t * but if this happens, we really don't know\n\t\t\t\t * who is what at this point.\n\t\t\t\t */\n\t\t\t\tfcp->portdb[i].valid = 0;\n\t\t\t\tfcp->portdb[j].valid = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't traverse the entire port database,\n\t\t * then we found (and remapped) an existing entry.\n\t\t * No need to notify anyone- go for the next one.\n\t\t */\n\t\tif (i < FL_PORT_ID) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We've not found this Port WWN anywhere. It's a new entry.\n\t\t * See if we can leave it where it is (with target == loopid).\n\t\t */\n\t\tif (fcp->portdb[loopid].port_wwn != 0) {\n\t\t\tfor (lim = 0; lim < FL_PORT_ID; lim++) {\n\t\t\t\tif (fcp->portdb[lim].port_wwn == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* \"Cannot Happen\" */\n\t\t\tif (lim == FL_PORT_ID) {\n\t\t\t\tPRINTF(\"%s: remap overflow?\\n\", isp->isp_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = lim;\n\t\t} else {\n\t\t\ti = loopid;\n\t\t}\n\n\t\t/*\n\t\t * NB:\tThe actual loopid we use here is loopid- we may\n\t\t *\tin fact be at a completely different index (target).\n\t\t */\n\t\tfcp->portdb[i].loopid = loopid;\n\t\tfcp->portdb[i].port_wwn = tport[loopid].port_wwn;\n\t\tfcp->portdb[i].node_wwn = tport[loopid].node_wwn;\n\t\tfcp->portdb[i].roles = tport[loopid].roles;\n\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\tfcp->portdb[i].valid = 1;\n\n\t\t/*\n\t\t * Tell the outside world we've arrived.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &i);\n\t}\n\n\t/*\n\t * Now find all previously used targets that are now invalid and\n\t * notify the outer layers that they're gone.\n\t */\n\tfor (lp = fcp->portdb; lp < &fcp->portdb[FL_PORT_ID]; lp++) {\n\t\tif (lp->valid || lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Tell the outside world we've gone away.\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\tMEMZERO((void *) lp, sizeof (*lp));\n\t}\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * Now log in any fabric devices\n\t */\n\tfor (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];\n\t     lp < &fcp->portdb[MAX_FC_TARG]; lp++) {\n\t\tu_int32_t portid;\n\t\tmbreg_t mbs;\n\n\t\t/*\n\t\t * Nothing here?\n\t\t */\n\t\tif (lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Don't try to log into yourself.\n\t\t */\n\t\tif ((portid = lp->portid) == fcp->isp_portid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Force a logout if we were logged in.\n\t\t */\n\t\tif (lp->valid) {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tlp->valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * And log in....\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\tlp->loopid = 0;\n\t\tlim = 0;\n\t\tdo {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGIN;\n\t\t\tmbs.param[1] = loopid << 8;\n\t\t\tif (IS_2200(isp)) {\n\t\t\t\t/* only issue a PLOGI if not logged in */\n\t\t\t\tmbs.param[1] |= 0x1;\n\t\t\t}\n\t\t\tmbs.param[2] = portid >> 16;\n\t\t\tmbs.param[3] = portid & 0xffff;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase MBOX_LOOP_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * Try the next available loop id.\n\t\t\t\t */\n\t\t\t\tloopid++;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_PORT_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * This port is already logged in.\n\t\t\t\t * Snaffle the loop id it's using.\n\t\t\t\t */\n\t\t\t\tif ((loopid = mbs.param[1]) == 0) {\n\t\t\t\t\tlim = -1;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_COMMAND_COMPLETE:\n\t\t\t\tlp->loopid = loopid;\n\t\t\t\tlim = 1;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_COMMAND_ERROR:\n\t\t\t\tPRINTF(\"%s: command error in PLOGI (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, mbs.param[1]);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_ALL_IDS_USED: /* We're outta IDs */\n\t\t\tdefault:\n\t\t\t\tlim = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (lim == 0 && loopid < MAX_FC_TARG);\n\t\tif (lim < 0)\n\t\t\tcontinue;\n\n\t\tlp->valid = 1;\n\t\tlp->fabdev = 1;\n\t\tif (isp_getpdb(isp, lp->loopid, &pdb) != 0) {\n\t\t\t/*\n\t\t\t * Be kind...\n\t\t\t */\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Faked PortID 0x%x into LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pdb.pdb_loopid != lp->loopid) {\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Wanked PortID 0x%x to LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\t/*\n\t\t * Check to make sure this all makes sense.\n\t\t */\n\t\tif (lp->node_wwn && lp->port_wwn) {\n\t\t\tloopid = lp - fcp->portdb;\n\t\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->fabdev = lp->valid = 0;\n\t\tPRINTF(\"%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\\n\",\n\t\t    isp->isp_name, loopid, lp->loopid, lp->portid);\n\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\tmbs.param[1] = lp->loopid << 8;\n\t\tmbs.param[2] = 0;\n\t\tmbs.param[3] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t}\n#endif\n\t/*\n\t * If we get here, we've for sure seen not only a valid loop\n\t * but know what is or isn't on it, so mark this for usage\n\t * in ispscsicmd.\n\t */\n\tfcp->loop_seen_once = 1;\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_getpdb",
            "static u_int64_t isp_get_portname",
            "static int isp_same_lportdb",
            "static int isp_pdb_sync",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic u_int64_t isp_get_portname;\nstatic int isp_same_lportdb;\nstatic int isp_pdb_sync;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_pdb_sync(isp, target)\n\tstruct ispsoftc *isp;\n\tint target;\n{\n\tstruct lportdb *lp, *tport;\n\tfcparam *fcp = isp->isp_param;\n\tisp_pdb_t pdb;\n\tint loopid, lim;\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * XXX: If we do this *after* building up our local port database,\n\t * XXX: the commands simply don't work.\n\t */\n\t/*\n\t * (Re)discover all fabric devices\n\t */\n\tif (fcp->isp_onfabric)\n\t\t(void) isp_scan_fabric(isp);\n#endif\n\n\n\t/*\n\t * Run through the local loop ports and get port database info\n\t * for each loop ID.\n\t *\n\t * There's a somewhat unexplained situation where the f/w passes back\n\t * the wrong database entity- if that happens, just restart (up to\n\t * FL_PORT_ID times).\n\t */\n\ttport = fcp->tport;\n\n\t/*\n\t * make sure the temp port database is clean...\n\t */\n\tMEMZERO((void *) tport, sizeof (tport));\n\tfor (lim = loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tlp = &tport[loopid];\n\t\tlp->node_wwn = isp_get_portname(isp, loopid, 1);\n\t\tif (lp->node_wwn == 0)\n\t\t\tcontinue;\n\t\tlp->port_wwn = isp_get_portname(isp, loopid, 0);\n\t\tif (lp->port_wwn == 0) {\n\t\t\tlp->node_wwn = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get an entry....\n\t\t */\n\t\tif (isp_getpdb(isp, loopid, &pdb) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the returned database element doesn't match what we\n\t\t * asked for, restart the process entirely (up to a point...).\n\t\t */\n\t\tif (pdb.pdb_loopid != loopid) {\n\t\t\tIDPRINTF(1, (\"%s: wankage (%d != %d)\\n\",\n\t\t\t    isp->isp_name, pdb.pdb_loopid, loopid));\n\t\t\tloopid = 0;\n\t\t\tif (lim++ < FL_PORT_ID) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPRINTF(\"%s: giving up on synchronizing the port \"\n\t\t\t    \"database\\n\", isp->isp_name);\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Save the pertinent info locally.\n\t\t */\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->loopid = pdb.pdb_loopid;\n\t\t/*\n\t\t * Do a quick check to see whether this matches the saved port\n\t\t * database for the same loopid. We do this here to save\n\t\t * searching later (if possible). Note that this fails over\n\t\t * time as things shuffle on the loop- we get the current\n\t\t * loop state (where loop id as an index matches loop id in\n\t\t * use) and then compare it to our saved database which\n\t\t * never shifts.\n\t\t */\n\t\tif (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {\n\t\t\tlp->valid = 1;\n\t\t}\n\t}\n\n\t/*\n\t * If we get this far, we've settled our differences with the f/w\n\t * and we can say that the loop state is ready.\n\t */\n\tfcp->isp_loopstate = LOOP_READY;\n\n\t/*\n\t * Mark all of the permanent local loop database entries as invalid.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tfcp->portdb[loopid].valid = 0;\n\t}\n\n\t/*\n\t * Now merge our local copy of the port database into our saved copy.\n\t * Notify the outer layers of new devices arriving.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tint i;\n\n\t\t/*\n\t\t * If we don't have a non-zero Port WWN, we're not here.\n\t\t */\n\t\tif (tport[loopid].port_wwn == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we've already marked our tmp copy as valid,\n\t\t * this means that we've decided that it's the\n\t\t * same as our saved data base. This didn't include\n\t\t * the 'valid' marking so we have set that here.\n\t\t */\n\t\tif (tport[loopid].valid) {\n\t\t\tfcp->portdb[loopid].valid = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For the purposes of deciding whether this is the\n\t\t * 'same' device or not, we only search for an identical\n\t\t * Port WWN. Node WWNs may or may not be the same as\n\t\t * the Port WWN, and there may be multiple different\n\t\t * Port WWNs with the same Node WWN. It would be chaos\n\t\t * to have multiple identical Port WWNs, so we don't\n\t\t * allow that.\n\t\t */\n\n\t\tfor (i = 0; i < FL_PORT_ID; i++) {\n\t\t\tint j;\n\t\t\tif (fcp->portdb[i].port_wwn == 0)\n\t\t\t\tcontinue;\n\t\t\tif (fcp->portdb[i].port_wwn != tport[loopid].port_wwn)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We found this WWN elsewhere- it's changed\n\t\t\t * loopids then. We don't change it's actual\n\t\t\t * position in our cached port database- we\n\t\t\t * just change the actual loop ID we'd use.\n\t\t\t */\n\t\t\tif (fcp->portdb[i].loopid != loopid) {\n\t\t\t\tPRINTF(\"%s: Target ID %d Loop 0x%x (Port 0x%x) \"\n\t\t\t\t    \"=> Loop 0x%x (Port 0x%x) \\n\",\n\t\t\t\t    isp->isp_name, i, fcp->portdb[i].loopid,\n\t\t\t\t    fcp->portdb[i].portid, loopid,\n\t\t\t\t    tport[loopid].portid);\n\t\t\t}\n\t\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\t\tfcp->portdb[i].loopid = loopid;\n\t\t\tfcp->portdb[i].valid = 1;\n\t\t\t/*\n\t\t\t * XXX: Should we also propagate roles in case they\n\t\t\t * XXX: changed?\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Now make sure this Port WWN doesn't exist elsewhere\n\t\t\t * in the port database.\n\t\t\t */\n\t\t\tfor (j = i+1; j < FL_PORT_ID; j++) {\n\t\t\t\tif (fcp->portdb[i].port_wwn !=\n\t\t\t\t    fcp->portdb[j].port_wwn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPRINTF(\"%s: Target ID %d Duplicates Target ID \"\n\t\t\t\t    \"%d- killing off both\\n\",\n\t\t\t\t    isp->isp_name, j, i);\n\t\t\t\t/*\n\t\t\t\t * Invalidate the 'old' *and* 'new' ones.\n\t\t\t\t * This is really harsh and not quite right,\n\t\t\t\t * but if this happens, we really don't know\n\t\t\t\t * who is what at this point.\n\t\t\t\t */\n\t\t\t\tfcp->portdb[i].valid = 0;\n\t\t\t\tfcp->portdb[j].valid = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't traverse the entire port database,\n\t\t * then we found (and remapped) an existing entry.\n\t\t * No need to notify anyone- go for the next one.\n\t\t */\n\t\tif (i < FL_PORT_ID) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We've not found this Port WWN anywhere. It's a new entry.\n\t\t * See if we can leave it where it is (with target == loopid).\n\t\t */\n\t\tif (fcp->portdb[loopid].port_wwn != 0) {\n\t\t\tfor (lim = 0; lim < FL_PORT_ID; lim++) {\n\t\t\t\tif (fcp->portdb[lim].port_wwn == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* \"Cannot Happen\" */\n\t\t\tif (lim == FL_PORT_ID) {\n\t\t\t\tPRINTF(\"%s: remap overflow?\\n\", isp->isp_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = lim;\n\t\t} else {\n\t\t\ti = loopid;\n\t\t}\n\n\t\t/*\n\t\t * NB:\tThe actual loopid we use here is loopid- we may\n\t\t *\tin fact be at a completely different index (target).\n\t\t */\n\t\tfcp->portdb[i].loopid = loopid;\n\t\tfcp->portdb[i].port_wwn = tport[loopid].port_wwn;\n\t\tfcp->portdb[i].node_wwn = tport[loopid].node_wwn;\n\t\tfcp->portdb[i].roles = tport[loopid].roles;\n\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\tfcp->portdb[i].valid = 1;\n\n\t\t/*\n\t\t * Tell the outside world we've arrived.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &i);\n\t}\n\n\t/*\n\t * Now find all previously used targets that are now invalid and\n\t * notify the outer layers that they're gone.\n\t */\n\tfor (lp = fcp->portdb; lp < &fcp->portdb[FL_PORT_ID]; lp++) {\n\t\tif (lp->valid || lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Tell the outside world we've gone away.\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\tMEMZERO((void *) lp, sizeof (*lp));\n\t}\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * Now log in any fabric devices\n\t */\n\tfor (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];\n\t     lp < &fcp->portdb[MAX_FC_TARG]; lp++) {\n\t\tu_int32_t portid;\n\t\tmbreg_t mbs;\n\n\t\t/*\n\t\t * Nothing here?\n\t\t */\n\t\tif (lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Don't try to log into yourself.\n\t\t */\n\t\tif ((portid = lp->portid) == fcp->isp_portid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Force a logout if we were logged in.\n\t\t */\n\t\tif (lp->valid) {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tlp->valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * And log in....\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\tlp->loopid = 0;\n\t\tlim = 0;\n\t\tdo {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGIN;\n\t\t\tmbs.param[1] = loopid << 8;\n\t\t\tif (IS_2200(isp)) {\n\t\t\t\t/* only issue a PLOGI if not logged in */\n\t\t\t\tmbs.param[1] |= 0x1;\n\t\t\t}\n\t\t\tmbs.param[2] = portid >> 16;\n\t\t\tmbs.param[3] = portid & 0xffff;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase MBOX_LOOP_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * Try the next available loop id.\n\t\t\t\t */\n\t\t\t\tloopid++;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_PORT_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * This port is already logged in.\n\t\t\t\t * Snaffle the loop id it's using.\n\t\t\t\t */\n\t\t\t\tif ((loopid = mbs.param[1]) == 0) {\n\t\t\t\t\tlim = -1;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_COMMAND_COMPLETE:\n\t\t\t\tlp->loopid = loopid;\n\t\t\t\tlim = 1;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_COMMAND_ERROR:\n\t\t\t\tPRINTF(\"%s: command error in PLOGI (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, mbs.param[1]);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_ALL_IDS_USED: /* We're outta IDs */\n\t\t\tdefault:\n\t\t\t\tlim = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (lim == 0 && loopid < MAX_FC_TARG);\n\t\tif (lim < 0)\n\t\t\tcontinue;\n\n\t\tlp->valid = 1;\n\t\tlp->fabdev = 1;\n\t\tif (isp_getpdb(isp, lp->loopid, &pdb) != 0) {\n\t\t\t/*\n\t\t\t * Be kind...\n\t\t\t */\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Faked PortID 0x%x into LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pdb.pdb_loopid != lp->loopid) {\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Wanked PortID 0x%x to LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\t/*\n\t\t * Check to make sure this all makes sense.\n\t\t */\n\t\tif (lp->node_wwn && lp->port_wwn) {\n\t\t\tloopid = lp - fcp->portdb;\n\t\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->fabdev = lp->valid = 0;\n\t\tPRINTF(\"%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\\n\",\n\t\t    isp->isp_name, loopid, lp->loopid, lp->portid);\n\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\tmbs.param[1] = lp->loopid << 8;\n\t\tmbs.param[2] = 0;\n\t\tmbs.param[3] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t}\n#endif\n\t/*\n\t * If we get here, we've for sure seen not only a valid loop\n\t * but know what is or isn't on it, so mark this for usage\n\t * in ispscsicmd.\n\t */\n\tfcp->loop_seen_once = 1;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_fclink_test",
          "args": [
            "isp",
            "FC_FW_READY_DELAY"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "isp_fclink_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1247-1352",
          "snippet": "static int\nisp_fclink_test(isp, waitdelay)\n\tstruct ispsoftc *isp;\n\tint waitdelay;\n{\n\tstatic char *toponames[] = {\n\t\t\"Private Loop\",\n\t\t\"FL Port\",\n\t\t\"N-Port to N-Port\",\n\t\t\"F Port\"\n\t};\n\tmbreg_t mbs;\n\tint count;\n\tu_int8_t lwfs;\n\tfcparam *fcp;\n#if\tdefined(ISP2100_FABRIC)\n\tisp_pdb_t pdb;\n#endif\n\tfcp = isp->isp_param;\n\n\t/*\n\t * Wait up to N microseconds for F/W to go to a ready state.\n\t */\n\tlwfs = FW_CONFIG_WAIT;\n\tfor (count = 0; count < waitdelay; count += 100) {\n\t\tisp_fw_state(isp);\n\t\tif (lwfs != fcp->isp_fwstate) {\n\t\t\tPRINTF(\"%s: Firmware State %s -> %s\\n\",\n\t\t\t    isp->isp_name, isp2100_fw_statename((int)lwfs),\n\t\t\t    isp2100_fw_statename((int)fcp->isp_fwstate));\n\t\t\tlwfs = fcp->isp_fwstate;\n\t\t}\n\t\tif (fcp->isp_fwstate == FW_READY) {\n\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\t/* wait 100 microseconds */\n\t}\n\n\t/*\n\t * If we haven't gone to 'ready' state, return.\n\t */\n\tif (fcp->isp_fwstate != FW_READY) {\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get our Loop ID (if possible). We really need to have it.\n\t */\n\tmbs.param[0] = MBOX_GET_LOOP_ID;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: GET LOOP ID failed\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tfcp->isp_loopid = mbs.param[1];\n\tif (IS_2200(isp)) {\n\t\tcount = (int) mbs.param[6];\n\t\tif (count < TOPO_NL_PORT || count > TOPO_PTP_STUB)\n\t\t\tcount = TOPO_PTP_STUB;\n\t\tfcp->isp_topo = count;\n\t} else {\n\t\tfcp->isp_topo = TOPO_NL_PORT;\n\t}\n\n\t/*\n\t * If we're not on a fabric, the low 8 bits will be our AL_PA.\n\t * If we're on a fabric, the low 8 bits will still be our AL_PA.\n\t */\n\tfcp->isp_alpa = mbs.param[2];\n#if\tdefined(ISP2100_FABRIC)\n\tfcp->isp_onfabric = 0;\n\tif (isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {\n\n\t\tif (IS_2100(isp))\n\t\t\tfcp->isp_topo = TOPO_FL_PORT;\n\n\t\tfcp->isp_portid = mbs.param[2] | (((int)mbs.param[3]) << 16);\n\t\tfcp->isp_onfabric = 1;\n\t\tCFGPRINTF(\"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State \"\n\t\t    \"0x%x topology '%s'\\n\", isp->isp_name, fcp->isp_loopid,\n\t\t    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,\n\t\t    toponames[fcp->isp_topo]);\n\n\t\t/*\n\t\t * Make sure we're logged out of all fabric devices.\n\t\t */\n\t\tfor (count = FC_SNS_ID+1; count < MAX_FC_TARG; count++) {\n\t\t\tstruct lportdb *lp = &fcp->portdb[count];\n\t\t\tif (lp->valid == 0 || lp->fabdev == 0)\n\t\t\t\tcontinue;\n\t\t\tPRINTF(\"%s: logging out target %d at Loop ID %d \"\n\t\t\t    \"(port id 0x%x)\\n\", isp->isp_name, count,\n\t\t\t    lp->loopid, lp->portid);\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t}\n\t} else\n#endif\n\tCFGPRINTF(\"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\\n\",\n\t    isp->isp_name, fcp->isp_loopid, fcp->isp_alpa, fcp->isp_loopstate,\n\t    toponames[fcp->isp_topo]);\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_getpdb",
            "static int isp_fclink_test",
            "static void isp_fw_state",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic int isp_fclink_test;\nstatic void isp_fw_state;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_fclink_test(isp, waitdelay)\n\tstruct ispsoftc *isp;\n\tint waitdelay;\n{\n\tstatic char *toponames[] = {\n\t\t\"Private Loop\",\n\t\t\"FL Port\",\n\t\t\"N-Port to N-Port\",\n\t\t\"F Port\"\n\t};\n\tmbreg_t mbs;\n\tint count;\n\tu_int8_t lwfs;\n\tfcparam *fcp;\n#if\tdefined(ISP2100_FABRIC)\n\tisp_pdb_t pdb;\n#endif\n\tfcp = isp->isp_param;\n\n\t/*\n\t * Wait up to N microseconds for F/W to go to a ready state.\n\t */\n\tlwfs = FW_CONFIG_WAIT;\n\tfor (count = 0; count < waitdelay; count += 100) {\n\t\tisp_fw_state(isp);\n\t\tif (lwfs != fcp->isp_fwstate) {\n\t\t\tPRINTF(\"%s: Firmware State %s -> %s\\n\",\n\t\t\t    isp->isp_name, isp2100_fw_statename((int)lwfs),\n\t\t\t    isp2100_fw_statename((int)fcp->isp_fwstate));\n\t\t\tlwfs = fcp->isp_fwstate;\n\t\t}\n\t\tif (fcp->isp_fwstate == FW_READY) {\n\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\t/* wait 100 microseconds */\n\t}\n\n\t/*\n\t * If we haven't gone to 'ready' state, return.\n\t */\n\tif (fcp->isp_fwstate != FW_READY) {\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get our Loop ID (if possible). We really need to have it.\n\t */\n\tmbs.param[0] = MBOX_GET_LOOP_ID;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: GET LOOP ID failed\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tfcp->isp_loopid = mbs.param[1];\n\tif (IS_2200(isp)) {\n\t\tcount = (int) mbs.param[6];\n\t\tif (count < TOPO_NL_PORT || count > TOPO_PTP_STUB)\n\t\t\tcount = TOPO_PTP_STUB;\n\t\tfcp->isp_topo = count;\n\t} else {\n\t\tfcp->isp_topo = TOPO_NL_PORT;\n\t}\n\n\t/*\n\t * If we're not on a fabric, the low 8 bits will be our AL_PA.\n\t * If we're on a fabric, the low 8 bits will still be our AL_PA.\n\t */\n\tfcp->isp_alpa = mbs.param[2];\n#if\tdefined(ISP2100_FABRIC)\n\tfcp->isp_onfabric = 0;\n\tif (isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {\n\n\t\tif (IS_2100(isp))\n\t\t\tfcp->isp_topo = TOPO_FL_PORT;\n\n\t\tfcp->isp_portid = mbs.param[2] | (((int)mbs.param[3]) << 16);\n\t\tfcp->isp_onfabric = 1;\n\t\tCFGPRINTF(\"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State \"\n\t\t    \"0x%x topology '%s'\\n\", isp->isp_name, fcp->isp_loopid,\n\t\t    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,\n\t\t    toponames[fcp->isp_topo]);\n\n\t\t/*\n\t\t * Make sure we're logged out of all fabric devices.\n\t\t */\n\t\tfor (count = FC_SNS_ID+1; count < MAX_FC_TARG; count++) {\n\t\t\tstruct lportdb *lp = &fcp->portdb[count];\n\t\t\tif (lp->valid == 0 || lp->fabdev == 0)\n\t\t\t\tcontinue;\n\t\t\tPRINTF(\"%s: logging out target %d at Loop ID %d \"\n\t\t\t    \"(port id 0x%x)\\n\", isp->isp_name, count,\n\t\t\t    lp->loopid, lp->portid);\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t}\n\t} else\n#endif\n\tCFGPRINTF(\"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\\n\",\n\t    isp->isp_name, fcp->isp_loopid, fcp->isp_alpa, fcp->isp_loopstate,\n\t    toponames[fcp->isp_topo]);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_SELTIMEOUT"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: unsupported cdb length (%d, CDB[0]=0x%x)\\n\"",
            "isp->isp_name",
            "XS_CDBLEN(xs)",
            "XS_CDBP(xs)[0] & 0xff"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBP",
          "args": [
            "xs"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBLEN",
          "args": [
            "xs"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBLEN",
          "args": [
            "xs"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBLEN",
          "args": [
            "xs"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: adapter not ready\\n\"",
            "isp->isp_name"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_ISP",
          "args": [
            "xs"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_INITERR",
          "args": [
            "xs"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n#define\tt2reqp\t_u._t2reqp\n#define\treqp\t_u._reqp\n\nstatic int isp_fclink_test;\nstatic int isp_pdb_sync;\nstatic void isp_update;\n\nint32_t\nispscsicmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tu_int16_t iptr, optr;\n\tunion {\n\t\tispreq_t *_reqp;\n\t\tispreqt2_t *_t2reqp;\n\t} _u;\n#define\treqp\t_u._reqp\n#define\tt2reqp\t_u._t2reqp\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n\tint target, i;\n\n\tXS_INITERR(xs);\n\tisp = XS_ISP(xs);\n\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: adapter not ready\\n\", isp->isp_name);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check command CDB length, etc.. We really are limited to 16 bytes\n\t * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,\n\t * but probably only if we're running fairly new firmware (we'll\n\t * let the old f/w choke on an extended command queue entry).\n\t */\n\n\tif (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {\n\t\tPRINTF(\"%s: unsupported cdb length (%d, CDB[0]=0x%x)\\n\",\n\t\t    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check to see whether we have good firmware state still or\n\t * need to refresh our port database for this target.\n\t */\n\ttarget = XS_TGT(xs);\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = isp->isp_param;\n\t\tstruct lportdb *lp;\n#if\tdefined(ISP2100_FABRIC)\n\t\t/*\n\t\t * If we're not on a Fabric, we can't have a target\n\t\t * above FL_PORT_ID-1. If we're on a fabric and\n\t\t * connected as an F-port, we can't have a target\n\t\t * less than FC_SNS_ID+1.\n\t\t */\n\t\tif (fcp->isp_onfabric == 0) {\n\t\t\tif (target >= FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (target >= FL_PORT_ID && target <= FC_SNS_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t\tif (fcp->isp_topo == TOPO_F_PORT &&\n\t\t\t    target < FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n#endif\n\t\t/*\n\t\t * Check for f/w being in ready state. If the f/w\n\t\t * isn't in ready state, then we don't know our\n\t\t * loop ID and the f/w hasn't completed logging\n\t\t * into all targets on the loop. If this is the\n\t\t * case, then bounce the command. We pretend this is\n\t\t * a SELECTION TIMEOUT error if we've never gone to\n\t\t * FW_READY state at all- in this case we may not\n\t\t * be hooked to a loop at all and we shouldn't hang\n\t\t * the machine for this. Otherwise, defer this command\n\t\t * until later.\n\t\t */\n\t\tif (fcp->isp_fwstate != FW_READY) {\n\t\t\tif (isp_fclink_test(isp, FC_FW_READY_DELAY)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\t\treturn (CMD_RQLATER);\n\t\t\t\t} else {\n\t\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is such that we haven't yet received\n\t\t * a \"Port Database Changed\" notification (after a LIP or\n\t\t * a Loop Reset or firmware initialization), then defer\n\t\t * sending commands for a little while, but only if we've\n\t\t * seen a valid loop at one point (otherwise we can get\n\t\t * stuck at initialization time).\n\t\t */\n\t\tif (fcp->isp_loopstate < LOOP_PDB_RCVD) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\treturn (CMD_RQLATER);\n\t\t\t} else {\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is now such that we've just now\n\t\t * received a Port Database Change notification, then\n\t\t * we have to go off and (re)synchronize our port\n\t\t * database.\n\t\t */\n\t\tif (fcp->isp_loopstate == LOOP_PDB_RCVD) {\n\t\t\tif (isp_pdb_sync(isp, target)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now check whether we should even think about pursuing this.\n\t\t */\n\t\tlp = &fcp->portdb[target];\n\t\tif (lp->valid == 0) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tif ((lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT)) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: target %d is not a target\\n\",\n\t\t\t    isp->isp_name, target));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\t/*\n\t\t * Now turn target into what the actual loop ID is.\n\t\t */\n\t\ttarget = lp->loopid;\n\t}\n\n\t/*\n\t * Next check to see if any HBA or Device\n\t * parameters need to be updated.\n\t */\n\tif (isp->isp_update != 0) {\n\t\tisp_update(isp);\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, (void **) &reqp)) {\n\t\tIDPRINTF(1, (\"%s: Request Queue Overflow\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\n\t/*\n\t * Now see if we need to synchronize the ISP with respect to anything.\n\t * We do dual duty here (cough) for synchronizing for busses other\n\t * than which we got here to send a command to.\n\t */\n\tif (isp->isp_sendmarker) {\n\t\tu_int8_t n = (IS_DUALBUS(isp)? 2: 1);\n\t\t/*\n\t\t * Check ports to send markers for...\n\t\t */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((isp->isp_sendmarker & (1 << i)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMEMZERO((void *) reqp, sizeof (*reqp));\n\t\t\treqp->req_header.rqs_entry_count = 1;\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_MARKER;\n\t\t\treqp->req_modifier = SYNC_ALL;\n\t\t\treqp->req_target = i << 7;\t/* insert bus number */\n\t\t\tISP_SWIZZLE_REQUEST(isp, reqp);\n\t\t\tMemoryBarrier();\n\t\t\tISP_ADD_REQUEST(isp, iptr);\n\n\t\t\tif (isp_getrqentry(isp, &iptr, &optr, (void **)&reqp)) {\n\t\t\t\tIDPRINTF(1, (\"%s: Request Queue Overflow+\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\treturn (CMD_EAGAIN);\n\t\t\t}\n\t\t}\n\t}\n\n\tMEMZERO((void *) reqp, UZSIZE);\n\treqp->req_header.rqs_entry_count = 1;\n\tif (IS_FC(isp)) {\n\t\treqp->req_header.rqs_entry_type = RQSTYPE_T2RQS;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;\n\t\telse\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;\n\t}\n\treqp->req_header.rqs_flags = 0;\n\treqp->req_header.rqs_seqno = 0;\n\tif (IS_FC(isp)) {\n\t\t/*\n\t\t * See comment in isp_intr\n\t\t */\n\t\tXS_RESID(xs) = 0;\n\n\t\t/*\n\t\t * Fibre Channel always requires some kind of tag.\n\t\t * The Qlogic drivers seem be happy not to use a tag,\n\t\t * but this breaks for some devices (IBM drives).\n\t\t */\n\t\tif (XS_CANTAG(xs)) {\n\t\t\tt2reqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t} else {\n\t\t\tif (XS_CDBP(xs)[0] == 0x3)\t/* REQUEST SENSE */\n\t\t\t\tt2reqp->req_flags = REQFLAG_HTAG;\n\t\t\telse\n\t\t\t\tt2reqp->req_flags = REQFLAG_OTAG;\n\t\t}\n\t} else {\n\t\tsdparam *sdp = (sdparam *)isp->isp_param;\n\t\tif ((sdp->isp_devparam[target].cur_dflags & DPARM_TQING) &&\n\t\t    XS_CANTAG(xs)) {\n\t\t\treqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t}\n\t}\n\treqp->req_target = target | (XS_CHANNEL(xs) << 7);\n\tif (IS_SCSI(isp)) {\n\t\treqp->req_lun_trn = XS_LUN(xs);\n\t\treqp->req_cdblen = XS_CDBLEN(xs);\n\t} else {\n#ifdef\tISP2100_SCCLUN\n\t\tt2reqp->req_scclun = XS_LUN(xs);\n#else\n\t\tt2reqp->req_lun_trn = XS_LUN(xs);\n#endif\n\t}\n\tMEMCPY(reqp->req_cdb, XS_CDBP(xs), XS_CDBLEN(xs));\n\n\treqp->req_time = XS_TIME(xs) / 1000;\n\tif (reqp->req_time == 0 && XS_TIME(xs))\n\t\treqp->req_time = 1;\n\n\t/*\n\t * Always give a bit more leeway to commands after a bus reset.\n\t * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED\n\t */\n\tif (isp->isp_sendmarker && reqp->req_time < 5) {\n\t\treqp->req_time = 5;\n\t}\n\tif (isp_save_xs(isp, xs, &reqp->req_handle)) {\n\t\tIDPRINTF(2, (\"%s: out of xflist pointers\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\t/*\n\t * Set up DMA and/or do any bus swizzling of the request entry\n\t * so that the Qlogic F/W understands what is being asked of it.\n \t*/\n\ti = ISP_DMASETUP(isp, xs, reqp, &iptr, optr);\n\tif (i != CMD_QUEUED) {\n\t\tisp_destroy_handle(isp, reqp->req_handle);\n\t\t/*\n\t\t * dmasetup sets actual error in packet, and\n\t\t * return what we were given to return.\n\t\t */\n\t\treturn (i);\n\t}\n\tXS_SETERR(xs, HBA_NOERROR);\n\tIDPRINTF(5, (\"%s(%d.%d.%d): START cmd 0x%x datalen %d\\n\",\n\t    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),\n\t    reqp->req_cdb[0], XS_XFRLEN(xs)));\n\tMemoryBarrier();\n\tISP_ADD_REQUEST(isp, iptr);\n\tisp->isp_nactive++;\n\tif (isp->isp_sendmarker)\n\t\tisp->isp_sendmarker = 0;\n\treturn (CMD_QUEUED);\n#undef\treqp\n#undef\tt2reqp\n}"
  },
  {
    "function_name": "isp_scan_fabric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1798-1856",
    "snippet": "static int\nisp_scan_fabric(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = isp->isp_param;\n\tu_int32_t portid, first_nz_portid;\n\tsns_screq_t *reqp;\n\tsns_scrsp_t *resp;\n\tmbreg_t mbs;\n\tint hicap;\n\n\treqp = (sns_screq_t *) fcp->isp_scratch;\n\tresp = (sns_scrsp_t *) (&((char *)fcp->isp_scratch)[0x100]);\n\tfirst_nz_portid = portid = fcp->isp_portid;\n\n\tfor (hicap = 0; hicap < 1024; hicap++) {\n\t\tMEMZERO((void *) reqp, SNS_GAN_REQ_SIZE);\n\t\treqp->snscb_rblen = SNS_GAN_RESP_SIZE >> 1;\n\t\treqp->snscb_addr[RQRSP_ADDR0015] =\n\t\t\tDMA_LSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_addr[RQRSP_ADDR1631] =\n\t\t\tDMA_MSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_sblen = 6;\n\t\treqp->snscb_data[0] = SNS_GAN;\n\t\treqp->snscb_data[4] = portid & 0xffff;\n\t\treqp->snscb_data[5] = (portid >> 16) & 0xff;\n\t\tISP_SWIZZLE_SNS_REQ(isp, reqp);\n\t\tmbs.param[0] = MBOX_SEND_SNS;\n\t\tmbs.param[1] = SNS_GAN_REQ_SIZE >> 1;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tMemoryBarrier();\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: SNS failed (0x%x)\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\treturn (-1);\n\t\t}\n\t\tISP_UNSWIZZLE_SNS_RSP(isp, resp, SNS_GAN_RESP_SIZE >> 1);\n\t\tportid = (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\t\tif (isp_async(isp, ISPASYNC_FABRIC_DEV, resp)) {\n\t\t\treturn (-1);\n\t\t}\n\t\tif (first_nz_portid == 0 && portid) {\n\t\t\tfirst_nz_portid = portid;\n\t\t}\n\t\tif (first_nz_portid == portid) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/*\n\t * We either have a broken name server or a huge fabric if we get here.\n\t */\n\treturn (0);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\treqp\t_u._reqp"
    ],
    "globals_used": [
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_FABRIC_DEV",
            "resp"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_UNSWIZZLE_SNS_RSP",
          "args": [
            "isp",
            "resp",
            "SNS_GAN_RESP_SIZE >> 1"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: SNS failed (0x%x)\\n\", isp->isp_name,\n\t\t\t    mbs.param[0])"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryBarrier",
          "args": [],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "fcp->isp_scdma"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "fcp->isp_scdma"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZZLE_SNS_REQ",
          "args": [
            "isp",
            "reqp"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "fcp->isp_scdma + 0x100"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "fcp->isp_scdma + 0x100"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "(void *) reqp",
            "SNS_GAN_REQ_SIZE"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\treqp\t_u._reqp\n\nstatic void isp_mboxcmd;\n\nstatic int\nisp_scan_fabric(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = isp->isp_param;\n\tu_int32_t portid, first_nz_portid;\n\tsns_screq_t *reqp;\n\tsns_scrsp_t *resp;\n\tmbreg_t mbs;\n\tint hicap;\n\n\treqp = (sns_screq_t *) fcp->isp_scratch;\n\tresp = (sns_scrsp_t *) (&((char *)fcp->isp_scratch)[0x100]);\n\tfirst_nz_portid = portid = fcp->isp_portid;\n\n\tfor (hicap = 0; hicap < 1024; hicap++) {\n\t\tMEMZERO((void *) reqp, SNS_GAN_REQ_SIZE);\n\t\treqp->snscb_rblen = SNS_GAN_RESP_SIZE >> 1;\n\t\treqp->snscb_addr[RQRSP_ADDR0015] =\n\t\t\tDMA_LSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_addr[RQRSP_ADDR1631] =\n\t\t\tDMA_MSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_sblen = 6;\n\t\treqp->snscb_data[0] = SNS_GAN;\n\t\treqp->snscb_data[4] = portid & 0xffff;\n\t\treqp->snscb_data[5] = (portid >> 16) & 0xff;\n\t\tISP_SWIZZLE_SNS_REQ(isp, reqp);\n\t\tmbs.param[0] = MBOX_SEND_SNS;\n\t\tmbs.param[1] = SNS_GAN_REQ_SIZE >> 1;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tMemoryBarrier();\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: SNS failed (0x%x)\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\treturn (-1);\n\t\t}\n\t\tISP_UNSWIZZLE_SNS_RSP(isp, resp, SNS_GAN_RESP_SIZE >> 1);\n\t\tportid = (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\t\tif (isp_async(isp, ISPASYNC_FABRIC_DEV, resp)) {\n\t\t\treturn (-1);\n\t\t}\n\t\tif (first_nz_portid == 0 && portid) {\n\t\t\tfirst_nz_portid = portid;\n\t\t}\n\t\tif (first_nz_portid == portid) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/*\n\t * We either have a broken name server or a huge fabric if we get here.\n\t */\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_pdb_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1380-1795",
    "snippet": "static int\nisp_pdb_sync(isp, target)\n\tstruct ispsoftc *isp;\n\tint target;\n{\n\tstruct lportdb *lp, *tport;\n\tfcparam *fcp = isp->isp_param;\n\tisp_pdb_t pdb;\n\tint loopid, lim;\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * XXX: If we do this *after* building up our local port database,\n\t * XXX: the commands simply don't work.\n\t */\n\t/*\n\t * (Re)discover all fabric devices\n\t */\n\tif (fcp->isp_onfabric)\n\t\t(void) isp_scan_fabric(isp);\n#endif\n\n\n\t/*\n\t * Run through the local loop ports and get port database info\n\t * for each loop ID.\n\t *\n\t * There's a somewhat unexplained situation where the f/w passes back\n\t * the wrong database entity- if that happens, just restart (up to\n\t * FL_PORT_ID times).\n\t */\n\ttport = fcp->tport;\n\n\t/*\n\t * make sure the temp port database is clean...\n\t */\n\tMEMZERO((void *) tport, sizeof (tport));\n\tfor (lim = loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tlp = &tport[loopid];\n\t\tlp->node_wwn = isp_get_portname(isp, loopid, 1);\n\t\tif (lp->node_wwn == 0)\n\t\t\tcontinue;\n\t\tlp->port_wwn = isp_get_portname(isp, loopid, 0);\n\t\tif (lp->port_wwn == 0) {\n\t\t\tlp->node_wwn = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get an entry....\n\t\t */\n\t\tif (isp_getpdb(isp, loopid, &pdb) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the returned database element doesn't match what we\n\t\t * asked for, restart the process entirely (up to a point...).\n\t\t */\n\t\tif (pdb.pdb_loopid != loopid) {\n\t\t\tIDPRINTF(1, (\"%s: wankage (%d != %d)\\n\",\n\t\t\t    isp->isp_name, pdb.pdb_loopid, loopid));\n\t\t\tloopid = 0;\n\t\t\tif (lim++ < FL_PORT_ID) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPRINTF(\"%s: giving up on synchronizing the port \"\n\t\t\t    \"database\\n\", isp->isp_name);\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Save the pertinent info locally.\n\t\t */\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->loopid = pdb.pdb_loopid;\n\t\t/*\n\t\t * Do a quick check to see whether this matches the saved port\n\t\t * database for the same loopid. We do this here to save\n\t\t * searching later (if possible). Note that this fails over\n\t\t * time as things shuffle on the loop- we get the current\n\t\t * loop state (where loop id as an index matches loop id in\n\t\t * use) and then compare it to our saved database which\n\t\t * never shifts.\n\t\t */\n\t\tif (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {\n\t\t\tlp->valid = 1;\n\t\t}\n\t}\n\n\t/*\n\t * If we get this far, we've settled our differences with the f/w\n\t * and we can say that the loop state is ready.\n\t */\n\tfcp->isp_loopstate = LOOP_READY;\n\n\t/*\n\t * Mark all of the permanent local loop database entries as invalid.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tfcp->portdb[loopid].valid = 0;\n\t}\n\n\t/*\n\t * Now merge our local copy of the port database into our saved copy.\n\t * Notify the outer layers of new devices arriving.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tint i;\n\n\t\t/*\n\t\t * If we don't have a non-zero Port WWN, we're not here.\n\t\t */\n\t\tif (tport[loopid].port_wwn == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we've already marked our tmp copy as valid,\n\t\t * this means that we've decided that it's the\n\t\t * same as our saved data base. This didn't include\n\t\t * the 'valid' marking so we have set that here.\n\t\t */\n\t\tif (tport[loopid].valid) {\n\t\t\tfcp->portdb[loopid].valid = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For the purposes of deciding whether this is the\n\t\t * 'same' device or not, we only search for an identical\n\t\t * Port WWN. Node WWNs may or may not be the same as\n\t\t * the Port WWN, and there may be multiple different\n\t\t * Port WWNs with the same Node WWN. It would be chaos\n\t\t * to have multiple identical Port WWNs, so we don't\n\t\t * allow that.\n\t\t */\n\n\t\tfor (i = 0; i < FL_PORT_ID; i++) {\n\t\t\tint j;\n\t\t\tif (fcp->portdb[i].port_wwn == 0)\n\t\t\t\tcontinue;\n\t\t\tif (fcp->portdb[i].port_wwn != tport[loopid].port_wwn)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We found this WWN elsewhere- it's changed\n\t\t\t * loopids then. We don't change it's actual\n\t\t\t * position in our cached port database- we\n\t\t\t * just change the actual loop ID we'd use.\n\t\t\t */\n\t\t\tif (fcp->portdb[i].loopid != loopid) {\n\t\t\t\tPRINTF(\"%s: Target ID %d Loop 0x%x (Port 0x%x) \"\n\t\t\t\t    \"=> Loop 0x%x (Port 0x%x) \\n\",\n\t\t\t\t    isp->isp_name, i, fcp->portdb[i].loopid,\n\t\t\t\t    fcp->portdb[i].portid, loopid,\n\t\t\t\t    tport[loopid].portid);\n\t\t\t}\n\t\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\t\tfcp->portdb[i].loopid = loopid;\n\t\t\tfcp->portdb[i].valid = 1;\n\t\t\t/*\n\t\t\t * XXX: Should we also propagate roles in case they\n\t\t\t * XXX: changed?\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Now make sure this Port WWN doesn't exist elsewhere\n\t\t\t * in the port database.\n\t\t\t */\n\t\t\tfor (j = i+1; j < FL_PORT_ID; j++) {\n\t\t\t\tif (fcp->portdb[i].port_wwn !=\n\t\t\t\t    fcp->portdb[j].port_wwn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPRINTF(\"%s: Target ID %d Duplicates Target ID \"\n\t\t\t\t    \"%d- killing off both\\n\",\n\t\t\t\t    isp->isp_name, j, i);\n\t\t\t\t/*\n\t\t\t\t * Invalidate the 'old' *and* 'new' ones.\n\t\t\t\t * This is really harsh and not quite right,\n\t\t\t\t * but if this happens, we really don't know\n\t\t\t\t * who is what at this point.\n\t\t\t\t */\n\t\t\t\tfcp->portdb[i].valid = 0;\n\t\t\t\tfcp->portdb[j].valid = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't traverse the entire port database,\n\t\t * then we found (and remapped) an existing entry.\n\t\t * No need to notify anyone- go for the next one.\n\t\t */\n\t\tif (i < FL_PORT_ID) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We've not found this Port WWN anywhere. It's a new entry.\n\t\t * See if we can leave it where it is (with target == loopid).\n\t\t */\n\t\tif (fcp->portdb[loopid].port_wwn != 0) {\n\t\t\tfor (lim = 0; lim < FL_PORT_ID; lim++) {\n\t\t\t\tif (fcp->portdb[lim].port_wwn == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* \"Cannot Happen\" */\n\t\t\tif (lim == FL_PORT_ID) {\n\t\t\t\tPRINTF(\"%s: remap overflow?\\n\", isp->isp_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = lim;\n\t\t} else {\n\t\t\ti = loopid;\n\t\t}\n\n\t\t/*\n\t\t * NB:\tThe actual loopid we use here is loopid- we may\n\t\t *\tin fact be at a completely different index (target).\n\t\t */\n\t\tfcp->portdb[i].loopid = loopid;\n\t\tfcp->portdb[i].port_wwn = tport[loopid].port_wwn;\n\t\tfcp->portdb[i].node_wwn = tport[loopid].node_wwn;\n\t\tfcp->portdb[i].roles = tport[loopid].roles;\n\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\tfcp->portdb[i].valid = 1;\n\n\t\t/*\n\t\t * Tell the outside world we've arrived.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &i);\n\t}\n\n\t/*\n\t * Now find all previously used targets that are now invalid and\n\t * notify the outer layers that they're gone.\n\t */\n\tfor (lp = fcp->portdb; lp < &fcp->portdb[FL_PORT_ID]; lp++) {\n\t\tif (lp->valid || lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Tell the outside world we've gone away.\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\tMEMZERO((void *) lp, sizeof (*lp));\n\t}\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * Now log in any fabric devices\n\t */\n\tfor (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];\n\t     lp < &fcp->portdb[MAX_FC_TARG]; lp++) {\n\t\tu_int32_t portid;\n\t\tmbreg_t mbs;\n\n\t\t/*\n\t\t * Nothing here?\n\t\t */\n\t\tif (lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Don't try to log into yourself.\n\t\t */\n\t\tif ((portid = lp->portid) == fcp->isp_portid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Force a logout if we were logged in.\n\t\t */\n\t\tif (lp->valid) {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tlp->valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * And log in....\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\tlp->loopid = 0;\n\t\tlim = 0;\n\t\tdo {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGIN;\n\t\t\tmbs.param[1] = loopid << 8;\n\t\t\tif (IS_2200(isp)) {\n\t\t\t\t/* only issue a PLOGI if not logged in */\n\t\t\t\tmbs.param[1] |= 0x1;\n\t\t\t}\n\t\t\tmbs.param[2] = portid >> 16;\n\t\t\tmbs.param[3] = portid & 0xffff;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase MBOX_LOOP_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * Try the next available loop id.\n\t\t\t\t */\n\t\t\t\tloopid++;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_PORT_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * This port is already logged in.\n\t\t\t\t * Snaffle the loop id it's using.\n\t\t\t\t */\n\t\t\t\tif ((loopid = mbs.param[1]) == 0) {\n\t\t\t\t\tlim = -1;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_COMMAND_COMPLETE:\n\t\t\t\tlp->loopid = loopid;\n\t\t\t\tlim = 1;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_COMMAND_ERROR:\n\t\t\t\tPRINTF(\"%s: command error in PLOGI (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, mbs.param[1]);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_ALL_IDS_USED: /* We're outta IDs */\n\t\t\tdefault:\n\t\t\t\tlim = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (lim == 0 && loopid < MAX_FC_TARG);\n\t\tif (lim < 0)\n\t\t\tcontinue;\n\n\t\tlp->valid = 1;\n\t\tlp->fabdev = 1;\n\t\tif (isp_getpdb(isp, lp->loopid, &pdb) != 0) {\n\t\t\t/*\n\t\t\t * Be kind...\n\t\t\t */\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Faked PortID 0x%x into LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pdb.pdb_loopid != lp->loopid) {\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Wanked PortID 0x%x to LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\t/*\n\t\t * Check to make sure this all makes sense.\n\t\t */\n\t\tif (lp->node_wwn && lp->port_wwn) {\n\t\t\tloopid = lp - fcp->portdb;\n\t\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->fabdev = lp->valid = 0;\n\t\tPRINTF(\"%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\\n\",\n\t\t    isp->isp_name, loopid, lp->loopid, lp->portid);\n\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\tmbs.param[1] = lp->loopid << 8;\n\t\tmbs.param[2] = 0;\n\t\tmbs.param[3] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t}\n#endif\n\t/*\n\t * If we get here, we've for sure seen not only a valid loop\n\t * but know what is or isn't on it, so mark this for usage\n\t * in ispscsicmd.\n\t */\n\tfcp->loop_seen_once = 1;\n\treturn (0);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_getpdb",
      "static u_int64_t isp_get_portname",
      "static int isp_same_lportdb",
      "static int isp_pdb_sync",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\\n\"",
            "isp->isp_name",
            "loopid",
            "lp->loopid",
            "lp->portid"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_PDB_CHANGED",
            "&loopid"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS2WORD",
          "args": [
            "pdb.pdb_portid_bits"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Wanked PortID 0x%x to LoopID %d\\n\"",
            "isp->isp_name",
            "lp->portid",
            "lp->loopid"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Faked PortID 0x%x into LoopID %d\\n\"",
            "isp->isp_name",
            "lp->portid",
            "lp->loopid"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_getpdb",
          "args": [
            "isp",
            "lp->loopid",
            "&pdb"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "isp_getpdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1171-1213",
          "snippet": "static int\nisp_getpdb(isp, id, pdbp)\n\tstruct ispsoftc *isp;\n\tint id;\n\tisp_pdb_t *pdbp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_DB;\n\tmbs.param[1] = id << 8;\n\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t/*\n\t * Unneeded. For the 2100, except for initializing f/w, registers\n\t * 4/5 have to not be written to.\n\t *\tmbs.param[4] = 0;\n\t *\tmbs.param[5] = 0;\n\t *\n\t */\n\tmbs.param[6] = 0;\n\tmbs.param[7] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tswitch (mbs.param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tMemoryBarrier();\n\t\tISP_UNSWIZZLE_AND_COPY_PDBP(isp, pdbp, fcp->isp_scratch);\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: DMA error getting port database\\n\", isp->isp_name);\n\t\treturn (-1);\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\t/* Not Logged In */\n\t\tIDPRINTF(3, (\"%s: Param Error on Get Port Database for id %d\\n\",\n\t\t    isp->isp_name, id));\n\t\treturn (-1);\n\tdefault:\n\t\tPRINTF(\"%s: error 0x%x getting port database for ID %d\\n\",\n\t\t    isp->isp_name, mbs.param[0], id);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_getpdb",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_getpdb(isp, id, pdbp)\n\tstruct ispsoftc *isp;\n\tint id;\n\tisp_pdb_t *pdbp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_DB;\n\tmbs.param[1] = id << 8;\n\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t/*\n\t * Unneeded. For the 2100, except for initializing f/w, registers\n\t * 4/5 have to not be written to.\n\t *\tmbs.param[4] = 0;\n\t *\tmbs.param[5] = 0;\n\t *\n\t */\n\tmbs.param[6] = 0;\n\tmbs.param[7] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tswitch (mbs.param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tMemoryBarrier();\n\t\tISP_UNSWIZZLE_AND_COPY_PDBP(isp, pdbp, fcp->isp_scratch);\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: DMA error getting port database\\n\", isp->isp_name);\n\t\treturn (-1);\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\t/* Not Logged In */\n\t\tIDPRINTF(3, (\"%s: Param Error on Get Port Database for id %d\\n\",\n\t\t    isp->isp_name, id));\n\t\treturn (-1);\n\tdefault:\n\t\tPRINTF(\"%s: error 0x%x getting port database for ID %d\\n\",\n\t\t    isp->isp_name, mbs.param[0], id);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: command error in PLOGI (0x%x)\\n\"",
            "isp->isp_name",
            "mbs.param[1]"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_2200",
          "args": [
            "isp"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "(void *) lp",
            "sizeof (*lp)"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: remap overflow?\\n\"",
            "isp->isp_name"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Target ID %d Duplicates Target ID \"\n\t\t\t\t    \"%d- killing off both\\n\"",
            "isp->isp_name",
            "j",
            "i"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Target ID %d Loop 0x%x (Port 0x%x) \"\n\t\t\t\t    \"=> Loop 0x%x (Port 0x%x) \\n\"",
            "isp->isp_name",
            "i",
            "fcp->portdb[i].loopid",
            "fcp->portdb[i].portid",
            "loopid",
            "tport[loopid].portid"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_same_lportdb",
          "args": [
            "lp",
            "&fcp->portdb[target]"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "isp_same_lportdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1358-1373",
          "snippet": "static int\nisp_same_lportdb(a, b)\n\tstruct lportdb *a, *b;\n{\n\t/*\n\t * We decide two lports are the same if they have non-zero and\n\t * identical port WWNs and identical loop IDs.\n\t */\n\n\tif (a->port_wwn == 0 || a->port_wwn != b->port_wwn ||\n\t    a->loopid != b->loopid) {\n\t\treturn (0);\n\t} else {\n\t\treturn (1);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_same_lportdb"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_same_lportdb;\n\nstatic int\nisp_same_lportdb(a, b)\n\tstruct lportdb *a, *b;\n{\n\t/*\n\t * We decide two lports are the same if they have non-zero and\n\t * identical port WWNs and identical loop IDs.\n\t */\n\n\tif (a->port_wwn == 0 || a->port_wwn != b->port_wwn ||\n\t    a->loopid != b->loopid) {\n\t\treturn (0);\n\t} else {\n\t\treturn (1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS2WORD",
          "args": [
            "pdb.pdb_portid_bits"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: giving up on synchronizing the port \"\n\t\t\t    \"database\\n\"",
            "isp->isp_name"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: wankage (%d != %d)\\n\",\n\t\t\t    isp->isp_name, pdb.pdb_loopid, loopid)"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_get_portname",
          "args": [
            "isp",
            "loopid",
            "0"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "isp_get_portname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1215-1241",
          "snippet": "static u_int64_t\nisp_get_portname(isp, loopid, nodename)\n\tstruct ispsoftc *isp;\n\tint loopid;\n\tint nodename;\n{\n\tu_int64_t wwn = 0;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_NAME;\n\tmbs.param[1] = loopid << 8;\n\tif (nodename)\n\t\tmbs.param[1] |= 1;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\twwn =\n\t\t    (((u_int64_t)(mbs.param[2] & 0xff)) << 56) |\n\t\t    (((u_int64_t)(mbs.param[2] >> 8))\t<< 48) |\n\t\t    (((u_int64_t)(mbs.param[3] & 0xff))\t<< 40) |\n\t\t    (((u_int64_t)(mbs.param[3] >> 8))\t<< 32) |\n\t\t    (((u_int64_t)(mbs.param[6] & 0xff))\t<< 24) |\n\t\t    (((u_int64_t)(mbs.param[6] >> 8))\t<< 16) |\n\t\t    (((u_int64_t)(mbs.param[7] & 0xff))\t<<  8) |\n\t\t    (((u_int64_t)(mbs.param[7] >> 8)));\n\t}\n\treturn (wwn);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int64_t isp_get_portname",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic u_int64_t isp_get_portname;\nstatic void isp_mboxcmd;\n\nstatic u_int64_t\nisp_get_portname(isp, loopid, nodename)\n\tstruct ispsoftc *isp;\n\tint loopid;\n\tint nodename;\n{\n\tu_int64_t wwn = 0;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_NAME;\n\tmbs.param[1] = loopid << 8;\n\tif (nodename)\n\t\tmbs.param[1] |= 1;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\twwn =\n\t\t    (((u_int64_t)(mbs.param[2] & 0xff)) << 56) |\n\t\t    (((u_int64_t)(mbs.param[2] >> 8))\t<< 48) |\n\t\t    (((u_int64_t)(mbs.param[3] & 0xff))\t<< 40) |\n\t\t    (((u_int64_t)(mbs.param[3] >> 8))\t<< 32) |\n\t\t    (((u_int64_t)(mbs.param[6] & 0xff))\t<< 24) |\n\t\t    (((u_int64_t)(mbs.param[6] >> 8))\t<< 16) |\n\t\t    (((u_int64_t)(mbs.param[7] & 0xff))\t<<  8) |\n\t\t    (((u_int64_t)(mbs.param[7] >> 8)));\n\t}\n\treturn (wwn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "(void *) tport",
            "sizeof (tport)"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_scan_fabric",
          "args": [
            "isp"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "isp_scan_fabric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1798-1856",
          "snippet": "static int\nisp_scan_fabric(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = isp->isp_param;\n\tu_int32_t portid, first_nz_portid;\n\tsns_screq_t *reqp;\n\tsns_scrsp_t *resp;\n\tmbreg_t mbs;\n\tint hicap;\n\n\treqp = (sns_screq_t *) fcp->isp_scratch;\n\tresp = (sns_scrsp_t *) (&((char *)fcp->isp_scratch)[0x100]);\n\tfirst_nz_portid = portid = fcp->isp_portid;\n\n\tfor (hicap = 0; hicap < 1024; hicap++) {\n\t\tMEMZERO((void *) reqp, SNS_GAN_REQ_SIZE);\n\t\treqp->snscb_rblen = SNS_GAN_RESP_SIZE >> 1;\n\t\treqp->snscb_addr[RQRSP_ADDR0015] =\n\t\t\tDMA_LSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_addr[RQRSP_ADDR1631] =\n\t\t\tDMA_MSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_sblen = 6;\n\t\treqp->snscb_data[0] = SNS_GAN;\n\t\treqp->snscb_data[4] = portid & 0xffff;\n\t\treqp->snscb_data[5] = (portid >> 16) & 0xff;\n\t\tISP_SWIZZLE_SNS_REQ(isp, reqp);\n\t\tmbs.param[0] = MBOX_SEND_SNS;\n\t\tmbs.param[1] = SNS_GAN_REQ_SIZE >> 1;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tMemoryBarrier();\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: SNS failed (0x%x)\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\treturn (-1);\n\t\t}\n\t\tISP_UNSWIZZLE_SNS_RSP(isp, resp, SNS_GAN_RESP_SIZE >> 1);\n\t\tportid = (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\t\tif (isp_async(isp, ISPASYNC_FABRIC_DEV, resp)) {\n\t\t\treturn (-1);\n\t\t}\n\t\tif (first_nz_portid == 0 && portid) {\n\t\t\tfirst_nz_portid = portid;\n\t\t}\n\t\tif (first_nz_portid == portid) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/*\n\t * We either have a broken name server or a huge fabric if we get here.\n\t */\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\treqp\t_u._reqp"
          ],
          "globals_used": [
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\treqp\t_u._reqp\n\nstatic void isp_mboxcmd;\n\nstatic int\nisp_scan_fabric(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = isp->isp_param;\n\tu_int32_t portid, first_nz_portid;\n\tsns_screq_t *reqp;\n\tsns_scrsp_t *resp;\n\tmbreg_t mbs;\n\tint hicap;\n\n\treqp = (sns_screq_t *) fcp->isp_scratch;\n\tresp = (sns_scrsp_t *) (&((char *)fcp->isp_scratch)[0x100]);\n\tfirst_nz_portid = portid = fcp->isp_portid;\n\n\tfor (hicap = 0; hicap < 1024; hicap++) {\n\t\tMEMZERO((void *) reqp, SNS_GAN_REQ_SIZE);\n\t\treqp->snscb_rblen = SNS_GAN_RESP_SIZE >> 1;\n\t\treqp->snscb_addr[RQRSP_ADDR0015] =\n\t\t\tDMA_LSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_addr[RQRSP_ADDR1631] =\n\t\t\tDMA_MSW(fcp->isp_scdma + 0x100);\n\t\treqp->snscb_sblen = 6;\n\t\treqp->snscb_data[0] = SNS_GAN;\n\t\treqp->snscb_data[4] = portid & 0xffff;\n\t\treqp->snscb_data[5] = (portid >> 16) & 0xff;\n\t\tISP_SWIZZLE_SNS_REQ(isp, reqp);\n\t\tmbs.param[0] = MBOX_SEND_SNS;\n\t\tmbs.param[1] = SNS_GAN_REQ_SIZE >> 1;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tMemoryBarrier();\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: SNS failed (0x%x)\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\treturn (-1);\n\t\t}\n\t\tISP_UNSWIZZLE_SNS_RSP(isp, resp, SNS_GAN_RESP_SIZE >> 1);\n\t\tportid = (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\t\tif (isp_async(isp, ISPASYNC_FABRIC_DEV, resp)) {\n\t\t\treturn (-1);\n\t\t}\n\t\tif (first_nz_portid == 0 && portid) {\n\t\t\tfirst_nz_portid = portid;\n\t\t}\n\t\tif (first_nz_portid == portid) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/*\n\t * We either have a broken name server or a huge fabric if we get here.\n\t */\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic u_int64_t isp_get_portname;\nstatic int isp_same_lportdb;\nstatic int isp_pdb_sync;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_pdb_sync(isp, target)\n\tstruct ispsoftc *isp;\n\tint target;\n{\n\tstruct lportdb *lp, *tport;\n\tfcparam *fcp = isp->isp_param;\n\tisp_pdb_t pdb;\n\tint loopid, lim;\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * XXX: If we do this *after* building up our local port database,\n\t * XXX: the commands simply don't work.\n\t */\n\t/*\n\t * (Re)discover all fabric devices\n\t */\n\tif (fcp->isp_onfabric)\n\t\t(void) isp_scan_fabric(isp);\n#endif\n\n\n\t/*\n\t * Run through the local loop ports and get port database info\n\t * for each loop ID.\n\t *\n\t * There's a somewhat unexplained situation where the f/w passes back\n\t * the wrong database entity- if that happens, just restart (up to\n\t * FL_PORT_ID times).\n\t */\n\ttport = fcp->tport;\n\n\t/*\n\t * make sure the temp port database is clean...\n\t */\n\tMEMZERO((void *) tport, sizeof (tport));\n\tfor (lim = loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tlp = &tport[loopid];\n\t\tlp->node_wwn = isp_get_portname(isp, loopid, 1);\n\t\tif (lp->node_wwn == 0)\n\t\t\tcontinue;\n\t\tlp->port_wwn = isp_get_portname(isp, loopid, 0);\n\t\tif (lp->port_wwn == 0) {\n\t\t\tlp->node_wwn = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get an entry....\n\t\t */\n\t\tif (isp_getpdb(isp, loopid, &pdb) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the returned database element doesn't match what we\n\t\t * asked for, restart the process entirely (up to a point...).\n\t\t */\n\t\tif (pdb.pdb_loopid != loopid) {\n\t\t\tIDPRINTF(1, (\"%s: wankage (%d != %d)\\n\",\n\t\t\t    isp->isp_name, pdb.pdb_loopid, loopid));\n\t\t\tloopid = 0;\n\t\t\tif (lim++ < FL_PORT_ID) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPRINTF(\"%s: giving up on synchronizing the port \"\n\t\t\t    \"database\\n\", isp->isp_name);\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Save the pertinent info locally.\n\t\t */\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->loopid = pdb.pdb_loopid;\n\t\t/*\n\t\t * Do a quick check to see whether this matches the saved port\n\t\t * database for the same loopid. We do this here to save\n\t\t * searching later (if possible). Note that this fails over\n\t\t * time as things shuffle on the loop- we get the current\n\t\t * loop state (where loop id as an index matches loop id in\n\t\t * use) and then compare it to our saved database which\n\t\t * never shifts.\n\t\t */\n\t\tif (target >= 0 && isp_same_lportdb(lp, &fcp->portdb[target])) {\n\t\t\tlp->valid = 1;\n\t\t}\n\t}\n\n\t/*\n\t * If we get this far, we've settled our differences with the f/w\n\t * and we can say that the loop state is ready.\n\t */\n\tfcp->isp_loopstate = LOOP_READY;\n\n\t/*\n\t * Mark all of the permanent local loop database entries as invalid.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tfcp->portdb[loopid].valid = 0;\n\t}\n\n\t/*\n\t * Now merge our local copy of the port database into our saved copy.\n\t * Notify the outer layers of new devices arriving.\n\t */\n\tfor (loopid = 0; loopid < FL_PORT_ID; loopid++) {\n\t\tint i;\n\n\t\t/*\n\t\t * If we don't have a non-zero Port WWN, we're not here.\n\t\t */\n\t\tif (tport[loopid].port_wwn == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we've already marked our tmp copy as valid,\n\t\t * this means that we've decided that it's the\n\t\t * same as our saved data base. This didn't include\n\t\t * the 'valid' marking so we have set that here.\n\t\t */\n\t\tif (tport[loopid].valid) {\n\t\t\tfcp->portdb[loopid].valid = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For the purposes of deciding whether this is the\n\t\t * 'same' device or not, we only search for an identical\n\t\t * Port WWN. Node WWNs may or may not be the same as\n\t\t * the Port WWN, and there may be multiple different\n\t\t * Port WWNs with the same Node WWN. It would be chaos\n\t\t * to have multiple identical Port WWNs, so we don't\n\t\t * allow that.\n\t\t */\n\n\t\tfor (i = 0; i < FL_PORT_ID; i++) {\n\t\t\tint j;\n\t\t\tif (fcp->portdb[i].port_wwn == 0)\n\t\t\t\tcontinue;\n\t\t\tif (fcp->portdb[i].port_wwn != tport[loopid].port_wwn)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We found this WWN elsewhere- it's changed\n\t\t\t * loopids then. We don't change it's actual\n\t\t\t * position in our cached port database- we\n\t\t\t * just change the actual loop ID we'd use.\n\t\t\t */\n\t\t\tif (fcp->portdb[i].loopid != loopid) {\n\t\t\t\tPRINTF(\"%s: Target ID %d Loop 0x%x (Port 0x%x) \"\n\t\t\t\t    \"=> Loop 0x%x (Port 0x%x) \\n\",\n\t\t\t\t    isp->isp_name, i, fcp->portdb[i].loopid,\n\t\t\t\t    fcp->portdb[i].portid, loopid,\n\t\t\t\t    tport[loopid].portid);\n\t\t\t}\n\t\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\t\tfcp->portdb[i].loopid = loopid;\n\t\t\tfcp->portdb[i].valid = 1;\n\t\t\t/*\n\t\t\t * XXX: Should we also propagate roles in case they\n\t\t\t * XXX: changed?\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Now make sure this Port WWN doesn't exist elsewhere\n\t\t\t * in the port database.\n\t\t\t */\n\t\t\tfor (j = i+1; j < FL_PORT_ID; j++) {\n\t\t\t\tif (fcp->portdb[i].port_wwn !=\n\t\t\t\t    fcp->portdb[j].port_wwn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPRINTF(\"%s: Target ID %d Duplicates Target ID \"\n\t\t\t\t    \"%d- killing off both\\n\",\n\t\t\t\t    isp->isp_name, j, i);\n\t\t\t\t/*\n\t\t\t\t * Invalidate the 'old' *and* 'new' ones.\n\t\t\t\t * This is really harsh and not quite right,\n\t\t\t\t * but if this happens, we really don't know\n\t\t\t\t * who is what at this point.\n\t\t\t\t */\n\t\t\t\tfcp->portdb[i].valid = 0;\n\t\t\t\tfcp->portdb[j].valid = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't traverse the entire port database,\n\t\t * then we found (and remapped) an existing entry.\n\t\t * No need to notify anyone- go for the next one.\n\t\t */\n\t\tif (i < FL_PORT_ID) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We've not found this Port WWN anywhere. It's a new entry.\n\t\t * See if we can leave it where it is (with target == loopid).\n\t\t */\n\t\tif (fcp->portdb[loopid].port_wwn != 0) {\n\t\t\tfor (lim = 0; lim < FL_PORT_ID; lim++) {\n\t\t\t\tif (fcp->portdb[lim].port_wwn == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* \"Cannot Happen\" */\n\t\t\tif (lim == FL_PORT_ID) {\n\t\t\t\tPRINTF(\"%s: remap overflow?\\n\", isp->isp_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = lim;\n\t\t} else {\n\t\t\ti = loopid;\n\t\t}\n\n\t\t/*\n\t\t * NB:\tThe actual loopid we use here is loopid- we may\n\t\t *\tin fact be at a completely different index (target).\n\t\t */\n\t\tfcp->portdb[i].loopid = loopid;\n\t\tfcp->portdb[i].port_wwn = tport[loopid].port_wwn;\n\t\tfcp->portdb[i].node_wwn = tport[loopid].node_wwn;\n\t\tfcp->portdb[i].roles = tport[loopid].roles;\n\t\tfcp->portdb[i].portid = tport[loopid].portid;\n\t\tfcp->portdb[i].valid = 1;\n\n\t\t/*\n\t\t * Tell the outside world we've arrived.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &i);\n\t}\n\n\t/*\n\t * Now find all previously used targets that are now invalid and\n\t * notify the outer layers that they're gone.\n\t */\n\tfor (lp = fcp->portdb; lp < &fcp->portdb[FL_PORT_ID]; lp++) {\n\t\tif (lp->valid || lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Tell the outside world we've gone away.\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\tMEMZERO((void *) lp, sizeof (*lp));\n\t}\n\n#ifdef\tISP2100_FABRIC\n\t/*\n\t * Now log in any fabric devices\n\t */\n\tfor (lim = FC_SNS_ID+1, lp = &fcp->portdb[FC_SNS_ID+1];\n\t     lp < &fcp->portdb[MAX_FC_TARG]; lp++) {\n\t\tu_int32_t portid;\n\t\tmbreg_t mbs;\n\n\t\t/*\n\t\t * Nothing here?\n\t\t */\n\t\tif (lp->port_wwn == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Don't try to log into yourself.\n\t\t */\n\t\tif ((portid = lp->portid) == fcp->isp_portid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Force a logout if we were logged in.\n\t\t */\n\t\tif (lp->valid) {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tlp->valid = 0;\n\t\t}\n\n\t\t/*\n\t\t * And log in....\n\t\t */\n\t\tloopid = lp - fcp->portdb;\n\t\tlp->loopid = 0;\n\t\tlim = 0;\n\t\tdo {\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGIN;\n\t\t\tmbs.param[1] = loopid << 8;\n\t\t\tif (IS_2200(isp)) {\n\t\t\t\t/* only issue a PLOGI if not logged in */\n\t\t\t\tmbs.param[1] |= 0x1;\n\t\t\t}\n\t\t\tmbs.param[2] = portid >> 16;\n\t\t\tmbs.param[3] = portid & 0xffff;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase MBOX_LOOP_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * Try the next available loop id.\n\t\t\t\t */\n\t\t\t\tloopid++;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_PORT_ID_USED:\n\t\t\t\t/*\n\t\t\t\t * This port is already logged in.\n\t\t\t\t * Snaffle the loop id it's using.\n\t\t\t\t */\n\t\t\t\tif ((loopid = mbs.param[1]) == 0) {\n\t\t\t\t\tlim = -1;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_COMMAND_COMPLETE:\n\t\t\t\tlp->loopid = loopid;\n\t\t\t\tlim = 1;\n\t\t\t\tbreak;\n\t\t\tcase MBOX_COMMAND_ERROR:\n\t\t\t\tPRINTF(\"%s: command error in PLOGI (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, mbs.param[1]);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase MBOX_ALL_IDS_USED: /* We're outta IDs */\n\t\t\tdefault:\n\t\t\t\tlim = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (lim == 0 && loopid < MAX_FC_TARG);\n\t\tif (lim < 0)\n\t\t\tcontinue;\n\n\t\tlp->valid = 1;\n\t\tlp->fabdev = 1;\n\t\tif (isp_getpdb(isp, lp->loopid, &pdb) != 0) {\n\t\t\t/*\n\t\t\t * Be kind...\n\t\t\t */\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Faked PortID 0x%x into LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pdb.pdb_loopid != lp->loopid) {\n\t\t\tlp->roles = (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT);\n\t\t\tPRINTF(\"%s: Wanked PortID 0x%x to LoopID %d\\n\",\n\t\t\t    isp->isp_name, lp->portid, lp->loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->roles =\n\t\t    (pdb.pdb_prli_svc3 & SVC3_ROLE_MASK) >> SVC3_ROLE_SHIFT;\n\t\tlp->portid = BITS2WORD(pdb.pdb_portid_bits);\n\t\tlp->node_wwn =\n\t\t    (((u_int64_t)pdb.pdb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_nodename[7]));\n\t\tlp->port_wwn =\n\t\t    (((u_int64_t)pdb.pdb_portname[0]) << 56) |\n\t\t    (((u_int64_t)pdb.pdb_portname[1]) << 48) |\n\t\t    (((u_int64_t)pdb.pdb_portname[2]) << 40) |\n\t\t    (((u_int64_t)pdb.pdb_portname[3]) << 32) |\n\t\t    (((u_int64_t)pdb.pdb_portname[4]) << 24) |\n\t\t    (((u_int64_t)pdb.pdb_portname[5]) << 16) |\n\t\t    (((u_int64_t)pdb.pdb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)pdb.pdb_portname[7]));\n\t\t/*\n\t\t * Check to make sure this all makes sense.\n\t\t */\n\t\tif (lp->node_wwn && lp->port_wwn) {\n\t\t\tloopid = lp - fcp->portdb;\n\t\t\t(void) isp_async(isp, ISPASYNC_PDB_CHANGED, &loopid);\n\t\t\tcontinue;\n\t\t}\n\t\tlp->fabdev = lp->valid = 0;\n\t\tPRINTF(\"%s: Target %d (Loop 0x%x) Port ID 0x%x lost its WWN\\n\",\n\t\t    isp->isp_name, loopid, lp->loopid, lp->portid);\n\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\tmbs.param[1] = lp->loopid << 8;\n\t\tmbs.param[2] = 0;\n\t\tmbs.param[3] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t}\n#endif\n\t/*\n\t * If we get here, we've for sure seen not only a valid loop\n\t * but know what is or isn't on it, so mark this for usage\n\t * in ispscsicmd.\n\t */\n\tfcp->loop_seen_once = 1;\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_same_lportdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1358-1373",
    "snippet": "static int\nisp_same_lportdb(a, b)\n\tstruct lportdb *a, *b;\n{\n\t/*\n\t * We decide two lports are the same if they have non-zero and\n\t * identical port WWNs and identical loop IDs.\n\t */\n\n\tif (a->port_wwn == 0 || a->port_wwn != b->port_wwn ||\n\t    a->loopid != b->loopid) {\n\t\treturn (0);\n\t} else {\n\t\treturn (1);\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_same_lportdb"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_same_lportdb;\n\nstatic int\nisp_same_lportdb(a, b)\n\tstruct lportdb *a, *b;\n{\n\t/*\n\t * We decide two lports are the same if they have non-zero and\n\t * identical port WWNs and identical loop IDs.\n\t */\n\n\tif (a->port_wwn == 0 || a->port_wwn != b->port_wwn ||\n\t    a->loopid != b->loopid) {\n\t\treturn (0);\n\t} else {\n\t\treturn (1);\n\t}\n}"
  },
  {
    "function_name": "isp_fclink_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1247-1352",
    "snippet": "static int\nisp_fclink_test(isp, waitdelay)\n\tstruct ispsoftc *isp;\n\tint waitdelay;\n{\n\tstatic char *toponames[] = {\n\t\t\"Private Loop\",\n\t\t\"FL Port\",\n\t\t\"N-Port to N-Port\",\n\t\t\"F Port\"\n\t};\n\tmbreg_t mbs;\n\tint count;\n\tu_int8_t lwfs;\n\tfcparam *fcp;\n#if\tdefined(ISP2100_FABRIC)\n\tisp_pdb_t pdb;\n#endif\n\tfcp = isp->isp_param;\n\n\t/*\n\t * Wait up to N microseconds for F/W to go to a ready state.\n\t */\n\tlwfs = FW_CONFIG_WAIT;\n\tfor (count = 0; count < waitdelay; count += 100) {\n\t\tisp_fw_state(isp);\n\t\tif (lwfs != fcp->isp_fwstate) {\n\t\t\tPRINTF(\"%s: Firmware State %s -> %s\\n\",\n\t\t\t    isp->isp_name, isp2100_fw_statename((int)lwfs),\n\t\t\t    isp2100_fw_statename((int)fcp->isp_fwstate));\n\t\t\tlwfs = fcp->isp_fwstate;\n\t\t}\n\t\tif (fcp->isp_fwstate == FW_READY) {\n\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\t/* wait 100 microseconds */\n\t}\n\n\t/*\n\t * If we haven't gone to 'ready' state, return.\n\t */\n\tif (fcp->isp_fwstate != FW_READY) {\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get our Loop ID (if possible). We really need to have it.\n\t */\n\tmbs.param[0] = MBOX_GET_LOOP_ID;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: GET LOOP ID failed\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tfcp->isp_loopid = mbs.param[1];\n\tif (IS_2200(isp)) {\n\t\tcount = (int) mbs.param[6];\n\t\tif (count < TOPO_NL_PORT || count > TOPO_PTP_STUB)\n\t\t\tcount = TOPO_PTP_STUB;\n\t\tfcp->isp_topo = count;\n\t} else {\n\t\tfcp->isp_topo = TOPO_NL_PORT;\n\t}\n\n\t/*\n\t * If we're not on a fabric, the low 8 bits will be our AL_PA.\n\t * If we're on a fabric, the low 8 bits will still be our AL_PA.\n\t */\n\tfcp->isp_alpa = mbs.param[2];\n#if\tdefined(ISP2100_FABRIC)\n\tfcp->isp_onfabric = 0;\n\tif (isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {\n\n\t\tif (IS_2100(isp))\n\t\t\tfcp->isp_topo = TOPO_FL_PORT;\n\n\t\tfcp->isp_portid = mbs.param[2] | (((int)mbs.param[3]) << 16);\n\t\tfcp->isp_onfabric = 1;\n\t\tCFGPRINTF(\"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State \"\n\t\t    \"0x%x topology '%s'\\n\", isp->isp_name, fcp->isp_loopid,\n\t\t    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,\n\t\t    toponames[fcp->isp_topo]);\n\n\t\t/*\n\t\t * Make sure we're logged out of all fabric devices.\n\t\t */\n\t\tfor (count = FC_SNS_ID+1; count < MAX_FC_TARG; count++) {\n\t\t\tstruct lportdb *lp = &fcp->portdb[count];\n\t\t\tif (lp->valid == 0 || lp->fabdev == 0)\n\t\t\t\tcontinue;\n\t\t\tPRINTF(\"%s: logging out target %d at Loop ID %d \"\n\t\t\t    \"(port id 0x%x)\\n\", isp->isp_name, count,\n\t\t\t    lp->loopid, lp->portid);\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t}\n\t} else\n#endif\n\tCFGPRINTF(\"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\\n\",\n\t    isp->isp_name, fcp->isp_loopid, fcp->isp_alpa, fcp->isp_loopstate,\n\t    toponames[fcp->isp_topo]);\n\treturn (0);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_getpdb",
      "static int isp_fclink_test",
      "static void isp_fw_state",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\\n\"",
            "isp->isp_name",
            "fcp->isp_loopid",
            "fcp->isp_alpa",
            "fcp->isp_loopstate",
            "toponames[fcp->isp_topo]"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: logging out target %d at Loop ID %d \"\n\t\t\t    \"(port id 0x%x)\\n\"",
            "isp->isp_name",
            "count",
            "lp->loopid",
            "lp->portid"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State \"\n\t\t    \"0x%x topology '%s'\\n\"",
            "isp->isp_name",
            "fcp->isp_loopid",
            "fcp->isp_alpa",
            "fcp->isp_portid",
            "fcp->isp_loopstate",
            "toponames[fcp->isp_topo]"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_2100",
          "args": [
            "isp"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_getpdb",
          "args": [
            "isp",
            "FL_PORT_ID",
            "&pdb"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "isp_getpdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1171-1213",
          "snippet": "static int\nisp_getpdb(isp, id, pdbp)\n\tstruct ispsoftc *isp;\n\tint id;\n\tisp_pdb_t *pdbp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_DB;\n\tmbs.param[1] = id << 8;\n\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t/*\n\t * Unneeded. For the 2100, except for initializing f/w, registers\n\t * 4/5 have to not be written to.\n\t *\tmbs.param[4] = 0;\n\t *\tmbs.param[5] = 0;\n\t *\n\t */\n\tmbs.param[6] = 0;\n\tmbs.param[7] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tswitch (mbs.param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tMemoryBarrier();\n\t\tISP_UNSWIZZLE_AND_COPY_PDBP(isp, pdbp, fcp->isp_scratch);\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: DMA error getting port database\\n\", isp->isp_name);\n\t\treturn (-1);\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\t/* Not Logged In */\n\t\tIDPRINTF(3, (\"%s: Param Error on Get Port Database for id %d\\n\",\n\t\t    isp->isp_name, id));\n\t\treturn (-1);\n\tdefault:\n\t\tPRINTF(\"%s: error 0x%x getting port database for ID %d\\n\",\n\t\t    isp->isp_name, mbs.param[0], id);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_getpdb",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_getpdb(isp, id, pdbp)\n\tstruct ispsoftc *isp;\n\tint id;\n\tisp_pdb_t *pdbp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_DB;\n\tmbs.param[1] = id << 8;\n\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t/*\n\t * Unneeded. For the 2100, except for initializing f/w, registers\n\t * 4/5 have to not be written to.\n\t *\tmbs.param[4] = 0;\n\t *\tmbs.param[5] = 0;\n\t *\n\t */\n\tmbs.param[6] = 0;\n\tmbs.param[7] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tswitch (mbs.param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tMemoryBarrier();\n\t\tISP_UNSWIZZLE_AND_COPY_PDBP(isp, pdbp, fcp->isp_scratch);\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: DMA error getting port database\\n\", isp->isp_name);\n\t\treturn (-1);\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\t/* Not Logged In */\n\t\tIDPRINTF(3, (\"%s: Param Error on Get Port Database for id %d\\n\",\n\t\t    isp->isp_name, id));\n\t\treturn (-1);\n\tdefault:\n\t\tPRINTF(\"%s: error 0x%x getting port database for ID %d\\n\",\n\t\t    isp->isp_name, mbs.param[0], id);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_2200",
          "args": [
            "isp"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: GET LOOP ID failed\\n\"",
            "isp->isp_name"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Firmware State %s -> %s\\n\"",
            "isp->isp_name",
            "isp2100_fw_statename((int)lwfs)",
            "isp2100_fw_statename((int)fcp->isp_fwstate)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp2100_fw_statename",
          "args": [
            "(int)fcp->isp_fwstate"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp2100_fw_statename",
          "args": [
            "(int)lwfs"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_fw_state",
          "args": [
            "isp"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "isp_fw_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3695-3744",
          "snippet": "static void\nisp_fw_state(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tif (IS_FC(isp)) {\n\t\tint once = 0;\n\t\tfcparam *fcp = isp->isp_param;\nagain:\n\t\tmbs.param[0] = MBOX_GET_FW_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: isp_fw_state 0x%x\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase ASYNC_PDB_CHANGED:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_PDB_RCVD;\n\t\t\t\tgoto again;\n\t\t\tcase ASYNC_LIP_OCCURRED:\n\t\t\t\tfcp->isp_lipseq = mbs.param[1];\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_LOOP_UP:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_LIP_RCVD;\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ASYNC_LOOP_RESET:\n\t\t\tcase ASYNC_LOOP_DOWN:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_NIL;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_CHANGE_NOTIFY:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPRINTF(\"%s: GET FIRMWARE STATE failed (0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_fwstate = mbs.param[1];\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_fw_state",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fw_state;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_fw_state(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tif (IS_FC(isp)) {\n\t\tint once = 0;\n\t\tfcparam *fcp = isp->isp_param;\nagain:\n\t\tmbs.param[0] = MBOX_GET_FW_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: isp_fw_state 0x%x\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase ASYNC_PDB_CHANGED:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_PDB_RCVD;\n\t\t\t\tgoto again;\n\t\t\tcase ASYNC_LIP_OCCURRED:\n\t\t\t\tfcp->isp_lipseq = mbs.param[1];\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_LOOP_UP:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_LIP_RCVD;\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ASYNC_LOOP_RESET:\n\t\t\tcase ASYNC_LOOP_DOWN:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_NIL;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_CHANGE_NOTIFY:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPRINTF(\"%s: GET FIRMWARE STATE failed (0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_fwstate = mbs.param[1];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic int isp_fclink_test;\nstatic void isp_fw_state;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_fclink_test(isp, waitdelay)\n\tstruct ispsoftc *isp;\n\tint waitdelay;\n{\n\tstatic char *toponames[] = {\n\t\t\"Private Loop\",\n\t\t\"FL Port\",\n\t\t\"N-Port to N-Port\",\n\t\t\"F Port\"\n\t};\n\tmbreg_t mbs;\n\tint count;\n\tu_int8_t lwfs;\n\tfcparam *fcp;\n#if\tdefined(ISP2100_FABRIC)\n\tisp_pdb_t pdb;\n#endif\n\tfcp = isp->isp_param;\n\n\t/*\n\t * Wait up to N microseconds for F/W to go to a ready state.\n\t */\n\tlwfs = FW_CONFIG_WAIT;\n\tfor (count = 0; count < waitdelay; count += 100) {\n\t\tisp_fw_state(isp);\n\t\tif (lwfs != fcp->isp_fwstate) {\n\t\t\tPRINTF(\"%s: Firmware State %s -> %s\\n\",\n\t\t\t    isp->isp_name, isp2100_fw_statename((int)lwfs),\n\t\t\t    isp2100_fw_statename((int)fcp->isp_fwstate));\n\t\t\tlwfs = fcp->isp_fwstate;\n\t\t}\n\t\tif (fcp->isp_fwstate == FW_READY) {\n\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\t/* wait 100 microseconds */\n\t}\n\n\t/*\n\t * If we haven't gone to 'ready' state, return.\n\t */\n\tif (fcp->isp_fwstate != FW_READY) {\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get our Loop ID (if possible). We really need to have it.\n\t */\n\tmbs.param[0] = MBOX_GET_LOOP_ID;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: GET LOOP ID failed\\n\", isp->isp_name);\n\t\treturn (-1);\n\t}\n\tfcp->isp_loopid = mbs.param[1];\n\tif (IS_2200(isp)) {\n\t\tcount = (int) mbs.param[6];\n\t\tif (count < TOPO_NL_PORT || count > TOPO_PTP_STUB)\n\t\t\tcount = TOPO_PTP_STUB;\n\t\tfcp->isp_topo = count;\n\t} else {\n\t\tfcp->isp_topo = TOPO_NL_PORT;\n\t}\n\n\t/*\n\t * If we're not on a fabric, the low 8 bits will be our AL_PA.\n\t * If we're on a fabric, the low 8 bits will still be our AL_PA.\n\t */\n\tfcp->isp_alpa = mbs.param[2];\n#if\tdefined(ISP2100_FABRIC)\n\tfcp->isp_onfabric = 0;\n\tif (isp_getpdb(isp, FL_PORT_ID, &pdb) == 0) {\n\n\t\tif (IS_2100(isp))\n\t\t\tfcp->isp_topo = TOPO_FL_PORT;\n\n\t\tfcp->isp_portid = mbs.param[2] | (((int)mbs.param[3]) << 16);\n\t\tfcp->isp_onfabric = 1;\n\t\tCFGPRINTF(\"%s: Loop ID %d, AL_PA 0x%x, Port ID 0x%x Loop State \"\n\t\t    \"0x%x topology '%s'\\n\", isp->isp_name, fcp->isp_loopid,\n\t\t    fcp->isp_alpa, fcp->isp_portid, fcp->isp_loopstate,\n\t\t    toponames[fcp->isp_topo]);\n\n\t\t/*\n\t\t * Make sure we're logged out of all fabric devices.\n\t\t */\n\t\tfor (count = FC_SNS_ID+1; count < MAX_FC_TARG; count++) {\n\t\t\tstruct lportdb *lp = &fcp->portdb[count];\n\t\t\tif (lp->valid == 0 || lp->fabdev == 0)\n\t\t\t\tcontinue;\n\t\t\tPRINTF(\"%s: logging out target %d at Loop ID %d \"\n\t\t\t    \"(port id 0x%x)\\n\", isp->isp_name, count,\n\t\t\t    lp->loopid, lp->portid);\n\t\t\tmbs.param[0] = MBOX_FABRIC_LOGOUT;\n\t\t\tmbs.param[1] = lp->loopid << 8;\n\t\t\tmbs.param[2] = 0;\n\t\t\tmbs.param[3] = 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t}\n\t} else\n#endif\n\tCFGPRINTF(\"%s: Loop ID %d, ALPA 0x%x Loop State 0x%x topology '%s'\\n\",\n\t    isp->isp_name, fcp->isp_loopid, fcp->isp_alpa, fcp->isp_loopstate,\n\t    toponames[fcp->isp_topo]);\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_get_portname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1215-1241",
    "snippet": "static u_int64_t\nisp_get_portname(isp, loopid, nodename)\n\tstruct ispsoftc *isp;\n\tint loopid;\n\tint nodename;\n{\n\tu_int64_t wwn = 0;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_NAME;\n\tmbs.param[1] = loopid << 8;\n\tif (nodename)\n\t\tmbs.param[1] |= 1;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\twwn =\n\t\t    (((u_int64_t)(mbs.param[2] & 0xff)) << 56) |\n\t\t    (((u_int64_t)(mbs.param[2] >> 8))\t<< 48) |\n\t\t    (((u_int64_t)(mbs.param[3] & 0xff))\t<< 40) |\n\t\t    (((u_int64_t)(mbs.param[3] >> 8))\t<< 32) |\n\t\t    (((u_int64_t)(mbs.param[6] & 0xff))\t<< 24) |\n\t\t    (((u_int64_t)(mbs.param[6] >> 8))\t<< 16) |\n\t\t    (((u_int64_t)(mbs.param[7] & 0xff))\t<<  8) |\n\t\t    (((u_int64_t)(mbs.param[7] >> 8)));\n\t}\n\treturn (wwn);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int64_t isp_get_portname",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[7] >> 8"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[7] & 0xff"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[6] >> 8"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[6] & 0xff"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[3] >> 8"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[3] & 0xff"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[2] >> 8"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "mbs.param[2] & 0xff"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic u_int64_t isp_get_portname;\nstatic void isp_mboxcmd;\n\nstatic u_int64_t\nisp_get_portname(isp, loopid, nodename)\n\tstruct ispsoftc *isp;\n\tint loopid;\n\tint nodename;\n{\n\tu_int64_t wwn = 0;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_NAME;\n\tmbs.param[1] = loopid << 8;\n\tif (nodename)\n\t\tmbs.param[1] |= 1;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\twwn =\n\t\t    (((u_int64_t)(mbs.param[2] & 0xff)) << 56) |\n\t\t    (((u_int64_t)(mbs.param[2] >> 8))\t<< 48) |\n\t\t    (((u_int64_t)(mbs.param[3] & 0xff))\t<< 40) |\n\t\t    (((u_int64_t)(mbs.param[3] >> 8))\t<< 32) |\n\t\t    (((u_int64_t)(mbs.param[6] & 0xff))\t<< 24) |\n\t\t    (((u_int64_t)(mbs.param[6] >> 8))\t<< 16) |\n\t\t    (((u_int64_t)(mbs.param[7] & 0xff))\t<<  8) |\n\t\t    (((u_int64_t)(mbs.param[7] >> 8)));\n\t}\n\treturn (wwn);\n}"
  },
  {
    "function_name": "isp_getpdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1171-1213",
    "snippet": "static int\nisp_getpdb(isp, id, pdbp)\n\tstruct ispsoftc *isp;\n\tint id;\n\tisp_pdb_t *pdbp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_DB;\n\tmbs.param[1] = id << 8;\n\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t/*\n\t * Unneeded. For the 2100, except for initializing f/w, registers\n\t * 4/5 have to not be written to.\n\t *\tmbs.param[4] = 0;\n\t *\tmbs.param[5] = 0;\n\t *\n\t */\n\tmbs.param[6] = 0;\n\tmbs.param[7] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tswitch (mbs.param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tMemoryBarrier();\n\t\tISP_UNSWIZZLE_AND_COPY_PDBP(isp, pdbp, fcp->isp_scratch);\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: DMA error getting port database\\n\", isp->isp_name);\n\t\treturn (-1);\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\t/* Not Logged In */\n\t\tIDPRINTF(3, (\"%s: Param Error on Get Port Database for id %d\\n\",\n\t\t    isp->isp_name, id));\n\t\treturn (-1);\n\tdefault:\n\t\tPRINTF(\"%s: error 0x%x getting port database for ID %d\\n\",\n\t\t    isp->isp_name, mbs.param[0], id);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_getpdb",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: error 0x%x getting port database for ID %d\\n\"",
            "isp->isp_name",
            "mbs.param[0]",
            "id"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: Param Error on Get Port Database for id %d\\n\",\n\t\t    isp->isp_name, id)"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: DMA error getting port database\\n\"",
            "isp->isp_name"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_UNSWIZZLE_AND_COPY_PDBP",
          "args": [
            "isp",
            "pdbp",
            "fcp->isp_scratch"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryBarrier",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "fcp->isp_scdma"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "fcp->isp_scdma"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_getpdb;\nstatic void isp_mboxcmd;\n\nstatic int\nisp_getpdb(isp, id, pdbp)\n\tstruct ispsoftc *isp;\n\tint id;\n\tisp_pdb_t *pdbp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tmbreg_t mbs;\n\n\tmbs.param[0] = MBOX_GET_PORT_DB;\n\tmbs.param[1] = id << 8;\n\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t/*\n\t * Unneeded. For the 2100, except for initializing f/w, registers\n\t * 4/5 have to not be written to.\n\t *\tmbs.param[4] = 0;\n\t *\tmbs.param[5] = 0;\n\t *\n\t */\n\tmbs.param[6] = 0;\n\tmbs.param[7] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tswitch (mbs.param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tMemoryBarrier();\n\t\tISP_UNSWIZZLE_AND_COPY_PDBP(isp, pdbp, fcp->isp_scratch);\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: DMA error getting port database\\n\", isp->isp_name);\n\t\treturn (-1);\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\t/* Not Logged In */\n\t\tIDPRINTF(3, (\"%s: Param Error on Get Port Database for id %d\\n\",\n\t\t    isp->isp_name, id));\n\t\treturn (-1);\n\tdefault:\n\t\tPRINTF(\"%s: error 0x%x getting port database for ID %d\\n\",\n\t\t    isp->isp_name, mbs.param[0], id);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_mark_getpdb_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "1160-1169",
    "snippet": "static void\nisp_mark_getpdb_all(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tint i;\n\tfor (i = 0; i < MAX_FC_TARG; i++) {\n\t\tfcp->portdb[i].valid = 0;\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_mark_getpdb_all"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mark_getpdb_all;\n\nstatic void\nisp_mark_getpdb_all(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tint i;\n\tfor (i = 0; i < MAX_FC_TARG; i++) {\n\t\tfcp->portdb[i].valid = 0;\n\t}\n}"
  },
  {
    "function_name": "isp_fibre_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "982-1151",
    "snippet": "static void\nisp_fibre_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp;\n\tisp_icb_t *icbp;\n\tmbreg_t mbs;\n\tint loopid;\n\n\tfcp = isp->isp_param;\n\n\t/*\n\t * For systems that don't have BIOS methods for which\n\t * we can easily change the NVRAM based loopid, we'll\n\t * override that here. Note that when we initialize\n\t * the firmware we may get back a different loopid than\n\t * we asked for anyway. XXX This is probably not the\n\t * best way to figure this out XXX\n\t */\n#ifndef\t__i386__\n\tloopid = DEFAULT_LOOPID(isp);\n#else\n\tloopid = fcp->isp_loopid;\n#endif\n\n\ticbp = (isp_icb_t *) fcp->isp_scratch;\n\tMEMZERO(icbp, sizeof (*icbp));\n\n\ticbp->icb_version = ICB_VERSION1;\n#ifdef\tISP_TARGET_MODE\n\tfcp->isp_fwoptions = ICBOPT_TGT_ENABLE;\n#else\n\tfcp->isp_fwoptions = 0;\n#endif\n\tfcp->isp_fwoptions |= ICBOPT_FAIRNESS;\n\t/*\n\t * If this is a 2100 < revision 5, we have to turn off FAIRNESS.\n\t */\n\tif ((isp->isp_type == ISP_HA_FC_2100) && isp->isp_revision < 5) {\n\t\tfcp->isp_fwoptions &= ~ICBOPT_FAIRNESS;\n\t}\n\tfcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;\n\tfcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;\n\t/*\n\t * We have to use FULL LOGIN even though it resets the loop too much\n\t * because otherwise port database entries don't get updated after\n\t * a LIP- this is a known f/w bug.\n\t */\n\tif (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(1, 17, 0)) {\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_LOGIN;\n\t}\n#ifndef\tISP_NO_FASTPOST_FC\n\tfcp->isp_fwoptions |= ICBOPT_FAST_POST;\n#endif\n\tif (isp->isp_confopts & ISP_CFG_FULL_DUPLEX)\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;\n\n\t/*\n\t * We don't set ICBOPT_PORTNAME because we want our\n\t * Node Name && Port Names to be distinct.\n\t */\n\n\ticbp->icb_fwoptions = fcp->isp_fwoptions;\n\ticbp->icb_maxfrmlen = fcp->isp_maxfrmlen;\n\tif (icbp->icb_maxfrmlen < ICB_MIN_FRMLEN ||\n\t    icbp->icb_maxfrmlen > ICB_MAX_FRMLEN) {\n\t\tPRINTF(\"%s: bad frame length (%d) from NVRAM- using %d\\n\",\n\t\t    isp->isp_name, fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);\n\t\ticbp->icb_maxfrmlen = ICB_DFLT_FRMLEN;\n\t}\n\ticbp->icb_maxalloc = fcp->isp_maxalloc;\n\tif (icbp->icb_maxalloc < 1) {\n\t\tPRINTF(\"%s: bad maximum allocation (%d)- using 16\\n\",\n\t\t     isp->isp_name, fcp->isp_maxalloc);\n\t\ticbp->icb_maxalloc = 16;\n\t}\n\ticbp->icb_execthrottle = fcp->isp_execthrottle;\n\tif (icbp->icb_execthrottle < 1) {\n\t\tPRINTF(\"%s: bad execution throttle of %d- using 16\\n\",\n\t\t    isp->isp_name, fcp->isp_execthrottle);\n\t\ticbp->icb_execthrottle = ICB_DFLT_THROTTLE;\n\t}\n\ticbp->icb_retry_delay = fcp->isp_retry_delay;\n\ticbp->icb_retry_count = fcp->isp_retry_count;\n\ticbp->icb_hardaddr = loopid;\n#ifdef\tPRET_A_PORTE\n\tif (IS_2200(isp)) {\n\t\ticbp->icb_fwoptions |= ICBOPT_EXTENDED;\n\t\t/*\n\t\t * Prefer or force Point-To-Point instead Loop?\n\t\t */\n\t\tif (isp->isp_confopts & ISP_CFG_NPORT)\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_PTP_2_LOOP;\n\t\telse\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_LOOP_2_PTP;\n\t}\n#endif\n\ticbp->icb_logintime = 60;\t/* 60 second login timeout */\n\n\tif (fcp->isp_nodewwn) {\n\t\tu_int64_t pn;\n\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, fcp->isp_nodewwn);\n\t\tif (fcp->isp_portwwn) {\n\t\t\tpn = fcp->isp_portwwn;\n\t\t} else {\n\t\t\tpn = fcp->isp_nodewwn |\n\t\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t\t}\n\t\t/*\n\t\t * If the top nibble is 2, we can construct a port name\n\t\t * from the node name by setting a nonzero instance in\n\t\t * bits 56..59. Otherwise, we need to make it identical\n\t\t * to Node name...\n\t\t */\n\t\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pn);\n\t\t} else {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname,\n\t\t\t    fcp->isp_nodewwn);\n\t\t}\n\t} else {\n\t\tfcp->isp_fwoptions &= ~(ICBOPT_USE_PORTNAME|ICBOPT_FULL_LOGIN);\n\t}\n\ticbp->icb_rqstqlen = RQUEST_QUEUE_LEN;\n\ticbp->icb_rsltqlen = RESULT_QUEUE_LEN;\n\ticbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_rquest_dma);\n\ticbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_rquest_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_result_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_result_dma);\n\tISP_SWIZZLE_ICB(isp, icbp);\n\n\t/*\n\t * Do this *before* initializing the firmware.\n\t */\n\tisp_mark_getpdb_all(isp);\n\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\tfcp->isp_loopstate = LOOP_NIL;\n\n\tMemoryBarrier();\n\tfor (;;) {\n\t\tmbs.param[0] = MBOX_INIT_FIRMWARE;\n\t\tmbs.param[1] = 0;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[4] = 0;\n\t\tmbs.param[5] = 0;\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: INIT FIRMWARE failed (code 0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tif (mbs.param[0] & 0x8000) {\n\t\t\t\tSYS_DELAY(1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\tisp->isp_residx = 0;\n\tisp->isp_sendmarker = 1;\n\n\t/*\n\t * Whatever happens, we're now committed to being here.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_fibre_init",
      "static void isp_mark_getpdb_all",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "1000"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: INIT FIRMWARE failed (code 0x%x)\\n\"",
            "isp->isp_name",
            "mbs.param[0]"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "fcp->isp_scdma"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "fcp->isp_scdma"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryBarrier",
          "args": [],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mark_getpdb_all",
          "args": [
            "isp"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mark_getpdb_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1160-1169",
          "snippet": "static void\nisp_mark_getpdb_all(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tint i;\n\tfor (i = 0; i < MAX_FC_TARG; i++) {\n\t\tfcp->portdb[i].valid = 0;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_mark_getpdb_all"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mark_getpdb_all;\n\nstatic void\nisp_mark_getpdb_all(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp = (fcparam *) isp->isp_param;\n\tint i;\n\tfor (i = 0; i < MAX_FC_TARG; i++) {\n\t\tfcp->portdb[i].valid = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_SWIZZLE_ICB",
          "args": [
            "isp",
            "icbp"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "isp->isp_result_dma"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "isp->isp_result_dma"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "isp->isp_rquest_dma"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "isp->isp_rquest_dma"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE_NODE_NAME_FROM_WWN",
          "args": [
            "icbp->icb_portname",
            "fcp->isp_nodewwn"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE_NODE_NAME_FROM_WWN",
          "args": [
            "icbp->icb_portname",
            "pn"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "isp->isp_unit+1"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE_NODE_NAME_FROM_WWN",
          "args": [
            "icbp->icb_nodename",
            "fcp->isp_nodewwn"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_2200",
          "args": [
            "isp"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad execution throttle of %d- using 16\\n\"",
            "isp->isp_name",
            "fcp->isp_execthrottle"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad maximum allocation (%d)- using 16\\n\"",
            "isp->isp_name",
            "fcp->isp_maxalloc"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad frame length (%d) from NVRAM- using %d\\n\"",
            "isp->isp_name",
            "fcp->isp_maxfrmlen",
            "ICB_DFLT_FRMLEN"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REV",
          "args": [
            "1",
            "17",
            "0"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REVX",
          "args": [
            "isp->isp_fwrev"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "icbp",
            "sizeof (*icbp)"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_LOOPID",
          "args": [
            "isp"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fibre_init;\nstatic void isp_mark_getpdb_all;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_fibre_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp;\n\tisp_icb_t *icbp;\n\tmbreg_t mbs;\n\tint loopid;\n\n\tfcp = isp->isp_param;\n\n\t/*\n\t * For systems that don't have BIOS methods for which\n\t * we can easily change the NVRAM based loopid, we'll\n\t * override that here. Note that when we initialize\n\t * the firmware we may get back a different loopid than\n\t * we asked for anyway. XXX This is probably not the\n\t * best way to figure this out XXX\n\t */\n#ifndef\t__i386__\n\tloopid = DEFAULT_LOOPID(isp);\n#else\n\tloopid = fcp->isp_loopid;\n#endif\n\n\ticbp = (isp_icb_t *) fcp->isp_scratch;\n\tMEMZERO(icbp, sizeof (*icbp));\n\n\ticbp->icb_version = ICB_VERSION1;\n#ifdef\tISP_TARGET_MODE\n\tfcp->isp_fwoptions = ICBOPT_TGT_ENABLE;\n#else\n\tfcp->isp_fwoptions = 0;\n#endif\n\tfcp->isp_fwoptions |= ICBOPT_FAIRNESS;\n\t/*\n\t * If this is a 2100 < revision 5, we have to turn off FAIRNESS.\n\t */\n\tif ((isp->isp_type == ISP_HA_FC_2100) && isp->isp_revision < 5) {\n\t\tfcp->isp_fwoptions &= ~ICBOPT_FAIRNESS;\n\t}\n\tfcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;\n\tfcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;\n\t/*\n\t * We have to use FULL LOGIN even though it resets the loop too much\n\t * because otherwise port database entries don't get updated after\n\t * a LIP- this is a known f/w bug.\n\t */\n\tif (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(1, 17, 0)) {\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_LOGIN;\n\t}\n#ifndef\tISP_NO_FASTPOST_FC\n\tfcp->isp_fwoptions |= ICBOPT_FAST_POST;\n#endif\n\tif (isp->isp_confopts & ISP_CFG_FULL_DUPLEX)\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;\n\n\t/*\n\t * We don't set ICBOPT_PORTNAME because we want our\n\t * Node Name && Port Names to be distinct.\n\t */\n\n\ticbp->icb_fwoptions = fcp->isp_fwoptions;\n\ticbp->icb_maxfrmlen = fcp->isp_maxfrmlen;\n\tif (icbp->icb_maxfrmlen < ICB_MIN_FRMLEN ||\n\t    icbp->icb_maxfrmlen > ICB_MAX_FRMLEN) {\n\t\tPRINTF(\"%s: bad frame length (%d) from NVRAM- using %d\\n\",\n\t\t    isp->isp_name, fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);\n\t\ticbp->icb_maxfrmlen = ICB_DFLT_FRMLEN;\n\t}\n\ticbp->icb_maxalloc = fcp->isp_maxalloc;\n\tif (icbp->icb_maxalloc < 1) {\n\t\tPRINTF(\"%s: bad maximum allocation (%d)- using 16\\n\",\n\t\t     isp->isp_name, fcp->isp_maxalloc);\n\t\ticbp->icb_maxalloc = 16;\n\t}\n\ticbp->icb_execthrottle = fcp->isp_execthrottle;\n\tif (icbp->icb_execthrottle < 1) {\n\t\tPRINTF(\"%s: bad execution throttle of %d- using 16\\n\",\n\t\t    isp->isp_name, fcp->isp_execthrottle);\n\t\ticbp->icb_execthrottle = ICB_DFLT_THROTTLE;\n\t}\n\ticbp->icb_retry_delay = fcp->isp_retry_delay;\n\ticbp->icb_retry_count = fcp->isp_retry_count;\n\ticbp->icb_hardaddr = loopid;\n#ifdef\tPRET_A_PORTE\n\tif (IS_2200(isp)) {\n\t\ticbp->icb_fwoptions |= ICBOPT_EXTENDED;\n\t\t/*\n\t\t * Prefer or force Point-To-Point instead Loop?\n\t\t */\n\t\tif (isp->isp_confopts & ISP_CFG_NPORT)\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_PTP_2_LOOP;\n\t\telse\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_LOOP_2_PTP;\n\t}\n#endif\n\ticbp->icb_logintime = 60;\t/* 60 second login timeout */\n\n\tif (fcp->isp_nodewwn) {\n\t\tu_int64_t pn;\n\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, fcp->isp_nodewwn);\n\t\tif (fcp->isp_portwwn) {\n\t\t\tpn = fcp->isp_portwwn;\n\t\t} else {\n\t\t\tpn = fcp->isp_nodewwn |\n\t\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t\t}\n\t\t/*\n\t\t * If the top nibble is 2, we can construct a port name\n\t\t * from the node name by setting a nonzero instance in\n\t\t * bits 56..59. Otherwise, we need to make it identical\n\t\t * to Node name...\n\t\t */\n\t\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pn);\n\t\t} else {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname,\n\t\t\t    fcp->isp_nodewwn);\n\t\t}\n\t} else {\n\t\tfcp->isp_fwoptions &= ~(ICBOPT_USE_PORTNAME|ICBOPT_FULL_LOGIN);\n\t}\n\ticbp->icb_rqstqlen = RQUEST_QUEUE_LEN;\n\ticbp->icb_rsltqlen = RESULT_QUEUE_LEN;\n\ticbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_rquest_dma);\n\ticbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_rquest_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_result_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_result_dma);\n\tISP_SWIZZLE_ICB(isp, icbp);\n\n\t/*\n\t * Do this *before* initializing the firmware.\n\t */\n\tisp_mark_getpdb_all(isp);\n\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\tfcp->isp_loopstate = LOOP_NIL;\n\n\tMemoryBarrier();\n\tfor (;;) {\n\t\tmbs.param[0] = MBOX_INIT_FIRMWARE;\n\t\tmbs.param[1] = 0;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[4] = 0;\n\t\tmbs.param[5] = 0;\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: INIT FIRMWARE failed (code 0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tif (mbs.param[0] & 0x8000) {\n\t\t\t\tSYS_DELAY(1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\tisp->isp_residx = 0;\n\tisp->isp_sendmarker = 1;\n\n\t/*\n\t * Whatever happens, we're now committed to being here.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}"
  },
  {
    "function_name": "isp_scsi_channel_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "836-975",
    "snippet": "static void\nisp_scsi_channel_init(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tsdparam *sdp;\n\tmbreg_t mbs;\n\tint tgt;\n\n\tsdp = isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Set (possibly new) Initiator ID.\n\t */\n\tmbs.param[0] = MBOX_SET_INIT_SCSI_ID;\n\tmbs.param[1] = (channel << 7) | sdp->isp_initiator_id;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: cannot set initiator id on bus %d to %d\\n\",\n\t\t    isp->isp_name, channel, sdp->isp_initiator_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set current per-target parameters to a safe minimum.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tint maxlun, lun;\n\t\tu_int16_t sdf;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d settings\\n\",\n\t\t\t    isp->isp_name, tgt, channel));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we're in LVD mode, then we pretty much should\n\t\t * only disable tagged queuing.\n\t\t */\n\t\tif (IS_ULTRA2(isp) && sdp->isp_lvdmode) {\n\t\t\tsdf = DPARM_DEFAULT & ~DPARM_TQING;\n\t\t} else {\n\t\t\tint rvf = ISP_FW_REVX(isp->isp_fwrev);\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\t\n\t\t\t/*\n\t\t\t * It is not quite clear when this changed over so that\n\t\t\t * we could force narrow and async, so assume >= 7.55\n\t\t\t * for i/t F/W and = 4.55 for initiator f/w.\n\t\t\t */\n\t\t\tif ((ISP_FW_REV(4, 55, 0) <= rvf &&\n\t\t\t    (ISP_FW_REV(5, 0, 0) > rvf)) ||\n\t\t\t    (ISP_FW_REV(7, 55, 0) <= rvf)) {\n\t\t\t\tsdf |= DPARM_NARROW | DPARM_ASYNC;\n\t\t\t}\n\t\t}\n\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tmbs.param[2] = sdf;\n\t\tmbs.param[3] =\n\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\t\tmbs.param[2] = sdf;\n\t\t\tmbs.param[3] =\n\t\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed even to set defaults for \"\n\t\t\t\t    \"target %d\\n\", isp->isp_name, tgt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n#if\t0\n\t\t/*\n\t\t * We don't update dev_flags with what we've set\n\t\t * because that's not the ultimate goal setting.\n\t\t * If we succeed with the command, we *do* update\n\t\t * cur_dflags by getting target parameters.\n\t\t */\n\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t/*\n\t\t\t * Urrr.... We'll set cur_dflags to DPARM_SAFE_DFLT so\n\t\t\t * we don't try and do tags if tags aren't enabled.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = DPARM_SAFE_DFLT;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t}\n\t\tIDPRINTF(3, (\"%s: set flags 0x%x got 0x%x back for target %d\\n\",\n\t\t    isp->isp_name, sdf, mbs.param[2], tgt));\n\n#else\n\t\t/*\n\t\t * We don't update any information because we need to run\n\t\t * at least one command per target to cause a new state\n\t\t * to be latched.\n\t\t */\n#endif\n\t\t/*\n\t\t * Ensure that we don't believe tagged queuing is enabled yet.\n\t\t * It turns out that sometimes the ISP just ignores our\n\t\t * attempts to set parameters for devices that it hasn't\n\t\t * seen yet.\n\t\t */\n\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\tif ((ISP_FW_REV(4, 55, 0) <= ISP_FW_REVX(isp->isp_fwrev) &&\n\t\t    (ISP_FW_REV(5, 0, 0) > ISP_FW_REVX(isp->isp_fwrev))) ||\n\t\t    (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0)))\n\t\t\tmaxlun = 32;\n\t\telse\n\t\t\tmaxlun = 8;\n\t\tfor (lun = 0; lun < maxlun; lun++) {\n\t\t\tmbs.param[0] = MBOX_SET_DEV_QUEUE_PARAMS;\n\t\t\tmbs.param[1] = (channel << 15) | (tgt << 8) | lun;\n\t\t\tmbs.param[2] = sdp->isp_max_queue_depth;\n\t\t\tmbs.param[3] = sdp->isp_devparam[tgt].exc_throttle;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed to set device queue \"\n\t\t\t\t    \"parameters for target %d, lun %d\\n\",\n\t\t\t\t    isp->isp_name, tgt, lun);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_scsi_channel_init",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed to set device queue \"\n\t\t\t\t    \"parameters for target %d, lun %d\\n\"",
            "isp->isp_name",
            "tgt",
            "lun"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_FW_REV",
          "args": [
            "7",
            "55",
            "0"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REVX",
          "args": [
            "isp->isp_fwrev"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REVX",
          "args": [
            "isp->isp_fwrev"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REV",
          "args": [
            "5",
            "0",
            "0"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REVX",
          "args": [
            "isp->isp_fwrev"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REV",
          "args": [
            "4",
            "55",
            "0"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: set flags 0x%x got 0x%x back for target %d\\n\",\n\t\t    isp->isp_name, sdf, mbs.param[2], tgt)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed even to set defaults for \"\n\t\t\t\t    \"target %d\\n\"",
            "isp->isp_name",
            "tgt"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REV",
          "args": [
            "7",
            "55",
            "0"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REV",
          "args": [
            "5",
            "0",
            "0"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REV",
          "args": [
            "4",
            "55",
            "0"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_FW_REVX",
          "args": [
            "isp->isp_fwrev"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ULTRA2",
          "args": [
            "isp"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "1",
            "(\"%s: skipping target %d bus %d settings\\n\",\n\t\t\t    isp->isp_name, tgt, channel)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: cannot set initiator id on bus %d to %d\\n\"",
            "isp->isp_name",
            "channel",
            "sdp->isp_initiator_id"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_channel_init;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_scsi_channel_init(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tsdparam *sdp;\n\tmbreg_t mbs;\n\tint tgt;\n\n\tsdp = isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Set (possibly new) Initiator ID.\n\t */\n\tmbs.param[0] = MBOX_SET_INIT_SCSI_ID;\n\tmbs.param[1] = (channel << 7) | sdp->isp_initiator_id;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: cannot set initiator id on bus %d to %d\\n\",\n\t\t    isp->isp_name, channel, sdp->isp_initiator_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set current per-target parameters to a safe minimum.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tint maxlun, lun;\n\t\tu_int16_t sdf;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d settings\\n\",\n\t\t\t    isp->isp_name, tgt, channel));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we're in LVD mode, then we pretty much should\n\t\t * only disable tagged queuing.\n\t\t */\n\t\tif (IS_ULTRA2(isp) && sdp->isp_lvdmode) {\n\t\t\tsdf = DPARM_DEFAULT & ~DPARM_TQING;\n\t\t} else {\n\t\t\tint rvf = ISP_FW_REVX(isp->isp_fwrev);\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\t\n\t\t\t/*\n\t\t\t * It is not quite clear when this changed over so that\n\t\t\t * we could force narrow and async, so assume >= 7.55\n\t\t\t * for i/t F/W and = 4.55 for initiator f/w.\n\t\t\t */\n\t\t\tif ((ISP_FW_REV(4, 55, 0) <= rvf &&\n\t\t\t    (ISP_FW_REV(5, 0, 0) > rvf)) ||\n\t\t\t    (ISP_FW_REV(7, 55, 0) <= rvf)) {\n\t\t\t\tsdf |= DPARM_NARROW | DPARM_ASYNC;\n\t\t\t}\n\t\t}\n\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tmbs.param[2] = sdf;\n\t\tmbs.param[3] =\n\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\t\tmbs.param[2] = sdf;\n\t\t\tmbs.param[3] =\n\t\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed even to set defaults for \"\n\t\t\t\t    \"target %d\\n\", isp->isp_name, tgt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n#if\t0\n\t\t/*\n\t\t * We don't update dev_flags with what we've set\n\t\t * because that's not the ultimate goal setting.\n\t\t * If we succeed with the command, we *do* update\n\t\t * cur_dflags by getting target parameters.\n\t\t */\n\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t/*\n\t\t\t * Urrr.... We'll set cur_dflags to DPARM_SAFE_DFLT so\n\t\t\t * we don't try and do tags if tags aren't enabled.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = DPARM_SAFE_DFLT;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t}\n\t\tIDPRINTF(3, (\"%s: set flags 0x%x got 0x%x back for target %d\\n\",\n\t\t    isp->isp_name, sdf, mbs.param[2], tgt));\n\n#else\n\t\t/*\n\t\t * We don't update any information because we need to run\n\t\t * at least one command per target to cause a new state\n\t\t * to be latched.\n\t\t */\n#endif\n\t\t/*\n\t\t * Ensure that we don't believe tagged queuing is enabled yet.\n\t\t * It turns out that sometimes the ISP just ignores our\n\t\t * attempts to set parameters for devices that it hasn't\n\t\t * seen yet.\n\t\t */\n\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\tif ((ISP_FW_REV(4, 55, 0) <= ISP_FW_REVX(isp->isp_fwrev) &&\n\t\t    (ISP_FW_REV(5, 0, 0) > ISP_FW_REVX(isp->isp_fwrev))) ||\n\t\t    (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0)))\n\t\t\tmaxlun = 32;\n\t\telse\n\t\t\tmaxlun = 8;\n\t\tfor (lun = 0; lun < maxlun; lun++) {\n\t\t\tmbs.param[0] = MBOX_SET_DEV_QUEUE_PARAMS;\n\t\t\tmbs.param[1] = (channel << 15) | (tgt << 8) | lun;\n\t\t\tmbs.param[2] = sdp->isp_max_queue_depth;\n\t\t\tmbs.param[3] = sdp->isp_devparam[tgt].exc_throttle;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed to set device queue \"\n\t\t\t\t    \"parameters for target %d, lun %d\\n\",\n\t\t\t\t    isp->isp_name, tgt, lun);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "isp_scsi_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "666-834",
    "snippet": "static void\nisp_scsi_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tsdparam *sdp_chan0, *sdp_chan1;\n\tmbreg_t mbs;\n\n\tsdp_chan0 = isp->isp_param;\n\tsdp_chan1 = sdp_chan0;\n\tif (IS_DUALBUS(isp)) {\n\t\tsdp_chan1++;\n\t}\n\n\t/* First do overall per-card settings. */\n\n\t/*\n\t * If we have fast memory timing enabled, turn it on.\n\t */\n\tif (isp->isp_fast_mttr) {\n\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t}\n\n\t/*\n\t * Set Retry Delay and Count.\n\t * You set both channels at the same time.\n\t */\n\tmbs.param[0] = MBOX_SET_RETRY_COUNT;\n\tmbs.param[1] = sdp_chan0->isp_retry_count;\n\tmbs.param[2] = sdp_chan0->isp_retry_delay;\n\tmbs.param[6] = sdp_chan1->isp_retry_count;\n\tmbs.param[7] = sdp_chan1->isp_retry_delay;\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set retry count and retry delay\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ASYNC DATA SETUP time. This is very important.\n\t */\n\tmbs.param[0] = MBOX_SET_ASYNC_DATA_SETUP_TIME;\n\tmbs.param[1] = sdp_chan0->isp_async_data_setup;\n\tmbs.param[2] = sdp_chan1->isp_async_data_setup;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set asynchronous data setup time\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ACTIVE Negation State.\n\t */\n\tmbs.param[0] = MBOX_SET_ACT_NEG_STATE;\n\tmbs.param[1] =\n\t    (sdp_chan0->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan0->isp_data_line_active_neg << 5);\n\tmbs.param[2] =\n\t    (sdp_chan1->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan1->isp_data_line_active_neg << 5);\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set active negation state \"\n\t\t    \"(%d,%d),(%d,%d)\\n\", isp->isp_name,\n\t\t    sdp_chan0->isp_req_ack_active_neg,\n\t\t    sdp_chan0->isp_data_line_active_neg,\n\t\t    sdp_chan1->isp_req_ack_active_neg,\n\t\t    sdp_chan1->isp_data_line_active_neg);\n\t\t/*\n\t\t * But don't return.\n\t\t */\n\t}\n\n\t/*\n\t * Set the Tag Aging limit\n\t */\n\tmbs.param[0] = MBOX_SET_TAG_AGE_LIMIT;\n\tmbs.param[1] = sdp_chan0->isp_tag_aging;\n\tmbs.param[2] = sdp_chan1->isp_tag_aging;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set tag age limit (%d,%d)\\n\",\n\t\t    isp->isp_name, sdp_chan0->isp_tag_aging,\n\t\t    sdp_chan1->isp_tag_aging);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set selection timeout.\n\t */\n\tmbs.param[0] = MBOX_SET_SELECT_TIMEOUT;\n\tmbs.param[1] = sdp_chan0->isp_selection_timeout;\n\tmbs.param[2] = sdp_chan1->isp_selection_timeout;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set selection timeout\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\n\t/* now do per-channel settings */\n\tisp_scsi_channel_init(isp, 0);\n\tif (IS_DUALBUS(isp))\n\t\tisp_scsi_channel_init(isp, 1);\n\n\t/*\n\t * Now enable request/response queues\n\t */\n\n\tmbs.param[0] = MBOX_INIT_RES_QUEUE;\n\tmbs.param[1] = RESULT_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_result_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_result_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of response queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_residx = 0;\n\n\tmbs.param[0] = MBOX_INIT_REQ_QUEUE;\n\tmbs.param[1] = RQUEST_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_rquest_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_rquest_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of request queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\n\t/*\n\t * Turn on Fast Posting, LVD transitions\n\t *\n\t * Ultra2 F/W always has had fast posting (and LVD transitions)\n\t *\n\t * Ultra and older (i.e., SBus) cards may not. It's just safer\n\t * to assume not for them.\n\t */\n\n\tmbs.param[0] = MBOX_SET_FW_FEATURES;\n\tmbs.param[1] = 0;\n\tif (IS_ULTRA2(isp))\n\t\tmbs.param[1] |= FW_FEATURE_LVD_NOTIFY;\n\tif (IS_ULTRA2(isp) || IS_1240(isp))\n\t\tmbs.param[1] |= FW_FEATURE_FAST_POST;\n\tif (mbs.param[1] != 0) {\n\t\tu_int16_t sfeat = mbs.param[1];\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: cannot enable FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: enabled FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t}\n\t}\n\n\t/*\n\t * Let the outer layers decide whether to issue a SCSI bus reset.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_scsi_init",
      "static void isp_scsi_channel_init",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: enabled FW features (0x%x)\\n\"",
            "isp->isp_name",
            "sfeat"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: cannot enable FW features (0x%x)\\n\"",
            "isp->isp_name",
            "sfeat"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_1240",
          "args": [
            "isp"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ULTRA2",
          "args": [
            "isp"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ULTRA2",
          "args": [
            "isp"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: set of request queue failed\\n\"",
            "isp->isp_name"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "isp->isp_rquest_dma"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "isp->isp_rquest_dma"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: set of response queue failed\\n\"",
            "isp->isp_name"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_LSW",
          "args": [
            "isp->isp_result_dma"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_MSW",
          "args": [
            "isp->isp_result_dma"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_scsi_channel_init",
          "args": [
            "isp",
            "1"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "isp_scsi_channel_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "836-975",
          "snippet": "static void\nisp_scsi_channel_init(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tsdparam *sdp;\n\tmbreg_t mbs;\n\tint tgt;\n\n\tsdp = isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Set (possibly new) Initiator ID.\n\t */\n\tmbs.param[0] = MBOX_SET_INIT_SCSI_ID;\n\tmbs.param[1] = (channel << 7) | sdp->isp_initiator_id;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: cannot set initiator id on bus %d to %d\\n\",\n\t\t    isp->isp_name, channel, sdp->isp_initiator_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set current per-target parameters to a safe minimum.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tint maxlun, lun;\n\t\tu_int16_t sdf;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d settings\\n\",\n\t\t\t    isp->isp_name, tgt, channel));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we're in LVD mode, then we pretty much should\n\t\t * only disable tagged queuing.\n\t\t */\n\t\tif (IS_ULTRA2(isp) && sdp->isp_lvdmode) {\n\t\t\tsdf = DPARM_DEFAULT & ~DPARM_TQING;\n\t\t} else {\n\t\t\tint rvf = ISP_FW_REVX(isp->isp_fwrev);\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\t\n\t\t\t/*\n\t\t\t * It is not quite clear when this changed over so that\n\t\t\t * we could force narrow and async, so assume >= 7.55\n\t\t\t * for i/t F/W and = 4.55 for initiator f/w.\n\t\t\t */\n\t\t\tif ((ISP_FW_REV(4, 55, 0) <= rvf &&\n\t\t\t    (ISP_FW_REV(5, 0, 0) > rvf)) ||\n\t\t\t    (ISP_FW_REV(7, 55, 0) <= rvf)) {\n\t\t\t\tsdf |= DPARM_NARROW | DPARM_ASYNC;\n\t\t\t}\n\t\t}\n\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tmbs.param[2] = sdf;\n\t\tmbs.param[3] =\n\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\t\tmbs.param[2] = sdf;\n\t\t\tmbs.param[3] =\n\t\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed even to set defaults for \"\n\t\t\t\t    \"target %d\\n\", isp->isp_name, tgt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n#if\t0\n\t\t/*\n\t\t * We don't update dev_flags with what we've set\n\t\t * because that's not the ultimate goal setting.\n\t\t * If we succeed with the command, we *do* update\n\t\t * cur_dflags by getting target parameters.\n\t\t */\n\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t/*\n\t\t\t * Urrr.... We'll set cur_dflags to DPARM_SAFE_DFLT so\n\t\t\t * we don't try and do tags if tags aren't enabled.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = DPARM_SAFE_DFLT;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t}\n\t\tIDPRINTF(3, (\"%s: set flags 0x%x got 0x%x back for target %d\\n\",\n\t\t    isp->isp_name, sdf, mbs.param[2], tgt));\n\n#else\n\t\t/*\n\t\t * We don't update any information because we need to run\n\t\t * at least one command per target to cause a new state\n\t\t * to be latched.\n\t\t */\n#endif\n\t\t/*\n\t\t * Ensure that we don't believe tagged queuing is enabled yet.\n\t\t * It turns out that sometimes the ISP just ignores our\n\t\t * attempts to set parameters for devices that it hasn't\n\t\t * seen yet.\n\t\t */\n\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\tif ((ISP_FW_REV(4, 55, 0) <= ISP_FW_REVX(isp->isp_fwrev) &&\n\t\t    (ISP_FW_REV(5, 0, 0) > ISP_FW_REVX(isp->isp_fwrev))) ||\n\t\t    (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0)))\n\t\t\tmaxlun = 32;\n\t\telse\n\t\t\tmaxlun = 8;\n\t\tfor (lun = 0; lun < maxlun; lun++) {\n\t\t\tmbs.param[0] = MBOX_SET_DEV_QUEUE_PARAMS;\n\t\t\tmbs.param[1] = (channel << 15) | (tgt << 8) | lun;\n\t\t\tmbs.param[2] = sdp->isp_max_queue_depth;\n\t\t\tmbs.param[3] = sdp->isp_devparam[tgt].exc_throttle;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed to set device queue \"\n\t\t\t\t    \"parameters for target %d, lun %d\\n\",\n\t\t\t\t    isp->isp_name, tgt, lun);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_scsi_channel_init",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_channel_init;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_scsi_channel_init(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tsdparam *sdp;\n\tmbreg_t mbs;\n\tint tgt;\n\n\tsdp = isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Set (possibly new) Initiator ID.\n\t */\n\tmbs.param[0] = MBOX_SET_INIT_SCSI_ID;\n\tmbs.param[1] = (channel << 7) | sdp->isp_initiator_id;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: cannot set initiator id on bus %d to %d\\n\",\n\t\t    isp->isp_name, channel, sdp->isp_initiator_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set current per-target parameters to a safe minimum.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tint maxlun, lun;\n\t\tu_int16_t sdf;\n\n\t\tif (sdp->isp_devparam[tgt].dev_enable == 0) {\n\t\t\tIDPRINTF(1, (\"%s: skipping target %d bus %d settings\\n\",\n\t\t\t    isp->isp_name, tgt, channel));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If we're in LVD mode, then we pretty much should\n\t\t * only disable tagged queuing.\n\t\t */\n\t\tif (IS_ULTRA2(isp) && sdp->isp_lvdmode) {\n\t\t\tsdf = DPARM_DEFAULT & ~DPARM_TQING;\n\t\t} else {\n\t\t\tint rvf = ISP_FW_REVX(isp->isp_fwrev);\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\t\n\t\t\t/*\n\t\t\t * It is not quite clear when this changed over so that\n\t\t\t * we could force narrow and async, so assume >= 7.55\n\t\t\t * for i/t F/W and = 4.55 for initiator f/w.\n\t\t\t */\n\t\t\tif ((ISP_FW_REV(4, 55, 0) <= rvf &&\n\t\t\t    (ISP_FW_REV(5, 0, 0) > rvf)) ||\n\t\t\t    (ISP_FW_REV(7, 55, 0) <= rvf)) {\n\t\t\t\tsdf |= DPARM_NARROW | DPARM_ASYNC;\n\t\t\t}\n\t\t}\n\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tmbs.param[2] = sdf;\n\t\tmbs.param[3] =\n\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tsdf = DPARM_SAFE_DFLT;\n\t\t\tmbs.param[0] = MBOX_SET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\t\tmbs.param[2] = sdf;\n\t\t\tmbs.param[3] =\n\t\t\t    (sdp->isp_devparam[tgt].sync_offset << 8) |\n\t\t\t    (sdp->isp_devparam[tgt].sync_period);\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed even to set defaults for \"\n\t\t\t\t    \"target %d\\n\", isp->isp_name, tgt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n#if\t0\n\t\t/*\n\t\t * We don't update dev_flags with what we've set\n\t\t * because that's not the ultimate goal setting.\n\t\t * If we succeed with the command, we *do* update\n\t\t * cur_dflags by getting target parameters.\n\t\t */\n\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\tmbs.param[1] = (tgt << 8) | (channel << 15);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t/*\n\t\t\t * Urrr.... We'll set cur_dflags to DPARM_SAFE_DFLT so\n\t\t\t * we don't try and do tags if tags aren't enabled.\n\t\t\t */\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = DPARM_SAFE_DFLT;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t}\n\t\tIDPRINTF(3, (\"%s: set flags 0x%x got 0x%x back for target %d\\n\",\n\t\t    isp->isp_name, sdf, mbs.param[2], tgt));\n\n#else\n\t\t/*\n\t\t * We don't update any information because we need to run\n\t\t * at least one command per target to cause a new state\n\t\t * to be latched.\n\t\t */\n#endif\n\t\t/*\n\t\t * Ensure that we don't believe tagged queuing is enabled yet.\n\t\t * It turns out that sometimes the ISP just ignores our\n\t\t * attempts to set parameters for devices that it hasn't\n\t\t * seen yet.\n\t\t */\n\t\tsdp->isp_devparam[tgt].cur_dflags &= ~DPARM_TQING;\n\t\tif ((ISP_FW_REV(4, 55, 0) <= ISP_FW_REVX(isp->isp_fwrev) &&\n\t\t    (ISP_FW_REV(5, 0, 0) > ISP_FW_REVX(isp->isp_fwrev))) ||\n\t\t    (ISP_FW_REVX(isp->isp_fwrev) >= ISP_FW_REV(7, 55, 0)))\n\t\t\tmaxlun = 32;\n\t\telse\n\t\t\tmaxlun = 8;\n\t\tfor (lun = 0; lun < maxlun; lun++) {\n\t\t\tmbs.param[0] = MBOX_SET_DEV_QUEUE_PARAMS;\n\t\t\tmbs.param[1] = (channel << 15) | (tgt << 8) | lun;\n\t\t\tmbs.param[2] = sdp->isp_max_queue_depth;\n\t\t\tmbs.param[3] = sdp->isp_devparam[tgt].exc_throttle;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: failed to set device queue \"\n\t\t\t\t    \"parameters for target %d, lun %d\\n\",\n\t\t\t\t    isp->isp_name, tgt, lun);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed to set selection timeout\\n\"",
            "isp->isp_name"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed to set tag age limit (%d,%d)\\n\"",
            "isp->isp_name",
            "sdp_chan0->isp_tag_aging",
            "sdp_chan1->isp_tag_aging"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed to set active negation state \"\n\t\t    \"(%d,%d),(%d,%d)\\n\"",
            "isp->isp_name",
            "sdp_chan0->isp_req_ack_active_neg",
            "sdp_chan0->isp_data_line_active_neg",
            "sdp_chan1->isp_req_ack_active_neg",
            "sdp_chan1->isp_data_line_active_neg"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed to set asynchronous data setup time\\n\"",
            "isp->isp_name"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: failed to set retry count and retry delay\\n\"",
            "isp->isp_name"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "RISC_MTR",
            "0x1313"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_init;\nstatic void isp_scsi_channel_init;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_scsi_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tsdparam *sdp_chan0, *sdp_chan1;\n\tmbreg_t mbs;\n\n\tsdp_chan0 = isp->isp_param;\n\tsdp_chan1 = sdp_chan0;\n\tif (IS_DUALBUS(isp)) {\n\t\tsdp_chan1++;\n\t}\n\n\t/* First do overall per-card settings. */\n\n\t/*\n\t * If we have fast memory timing enabled, turn it on.\n\t */\n\tif (isp->isp_fast_mttr) {\n\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t}\n\n\t/*\n\t * Set Retry Delay and Count.\n\t * You set both channels at the same time.\n\t */\n\tmbs.param[0] = MBOX_SET_RETRY_COUNT;\n\tmbs.param[1] = sdp_chan0->isp_retry_count;\n\tmbs.param[2] = sdp_chan0->isp_retry_delay;\n\tmbs.param[6] = sdp_chan1->isp_retry_count;\n\tmbs.param[7] = sdp_chan1->isp_retry_delay;\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set retry count and retry delay\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ASYNC DATA SETUP time. This is very important.\n\t */\n\tmbs.param[0] = MBOX_SET_ASYNC_DATA_SETUP_TIME;\n\tmbs.param[1] = sdp_chan0->isp_async_data_setup;\n\tmbs.param[2] = sdp_chan1->isp_async_data_setup;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set asynchronous data setup time\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ACTIVE Negation State.\n\t */\n\tmbs.param[0] = MBOX_SET_ACT_NEG_STATE;\n\tmbs.param[1] =\n\t    (sdp_chan0->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan0->isp_data_line_active_neg << 5);\n\tmbs.param[2] =\n\t    (sdp_chan1->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan1->isp_data_line_active_neg << 5);\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set active negation state \"\n\t\t    \"(%d,%d),(%d,%d)\\n\", isp->isp_name,\n\t\t    sdp_chan0->isp_req_ack_active_neg,\n\t\t    sdp_chan0->isp_data_line_active_neg,\n\t\t    sdp_chan1->isp_req_ack_active_neg,\n\t\t    sdp_chan1->isp_data_line_active_neg);\n\t\t/*\n\t\t * But don't return.\n\t\t */\n\t}\n\n\t/*\n\t * Set the Tag Aging limit\n\t */\n\tmbs.param[0] = MBOX_SET_TAG_AGE_LIMIT;\n\tmbs.param[1] = sdp_chan0->isp_tag_aging;\n\tmbs.param[2] = sdp_chan1->isp_tag_aging;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set tag age limit (%d,%d)\\n\",\n\t\t    isp->isp_name, sdp_chan0->isp_tag_aging,\n\t\t    sdp_chan1->isp_tag_aging);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set selection timeout.\n\t */\n\tmbs.param[0] = MBOX_SET_SELECT_TIMEOUT;\n\tmbs.param[1] = sdp_chan0->isp_selection_timeout;\n\tmbs.param[2] = sdp_chan1->isp_selection_timeout;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set selection timeout\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\n\t/* now do per-channel settings */\n\tisp_scsi_channel_init(isp, 0);\n\tif (IS_DUALBUS(isp))\n\t\tisp_scsi_channel_init(isp, 1);\n\n\t/*\n\t * Now enable request/response queues\n\t */\n\n\tmbs.param[0] = MBOX_INIT_RES_QUEUE;\n\tmbs.param[1] = RESULT_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_result_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_result_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of response queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_residx = 0;\n\n\tmbs.param[0] = MBOX_INIT_REQ_QUEUE;\n\tmbs.param[1] = RQUEST_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_rquest_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_rquest_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of request queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\n\t/*\n\t * Turn on Fast Posting, LVD transitions\n\t *\n\t * Ultra2 F/W always has had fast posting (and LVD transitions)\n\t *\n\t * Ultra and older (i.e., SBus) cards may not. It's just safer\n\t * to assume not for them.\n\t */\n\n\tmbs.param[0] = MBOX_SET_FW_FEATURES;\n\tmbs.param[1] = 0;\n\tif (IS_ULTRA2(isp))\n\t\tmbs.param[1] |= FW_FEATURE_LVD_NOTIFY;\n\tif (IS_ULTRA2(isp) || IS_1240(isp))\n\t\tmbs.param[1] |= FW_FEATURE_FAST_POST;\n\tif (mbs.param[1] != 0) {\n\t\tu_int16_t sfeat = mbs.param[1];\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: cannot enable FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: enabled FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t}\n\t}\n\n\t/*\n\t * Let the outer layers decide whether to issue a SCSI bus reset.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}"
  },
  {
    "function_name": "isp_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "647-664",
    "snippet": "void\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_scsi_init",
      "static void isp_fibre_init",
      "static void isp_setdfltparm"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_scsi_init",
          "args": [
            "isp"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "isp_scsi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "666-834",
          "snippet": "static void\nisp_scsi_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tsdparam *sdp_chan0, *sdp_chan1;\n\tmbreg_t mbs;\n\n\tsdp_chan0 = isp->isp_param;\n\tsdp_chan1 = sdp_chan0;\n\tif (IS_DUALBUS(isp)) {\n\t\tsdp_chan1++;\n\t}\n\n\t/* First do overall per-card settings. */\n\n\t/*\n\t * If we have fast memory timing enabled, turn it on.\n\t */\n\tif (isp->isp_fast_mttr) {\n\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t}\n\n\t/*\n\t * Set Retry Delay and Count.\n\t * You set both channels at the same time.\n\t */\n\tmbs.param[0] = MBOX_SET_RETRY_COUNT;\n\tmbs.param[1] = sdp_chan0->isp_retry_count;\n\tmbs.param[2] = sdp_chan0->isp_retry_delay;\n\tmbs.param[6] = sdp_chan1->isp_retry_count;\n\tmbs.param[7] = sdp_chan1->isp_retry_delay;\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set retry count and retry delay\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ASYNC DATA SETUP time. This is very important.\n\t */\n\tmbs.param[0] = MBOX_SET_ASYNC_DATA_SETUP_TIME;\n\tmbs.param[1] = sdp_chan0->isp_async_data_setup;\n\tmbs.param[2] = sdp_chan1->isp_async_data_setup;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set asynchronous data setup time\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ACTIVE Negation State.\n\t */\n\tmbs.param[0] = MBOX_SET_ACT_NEG_STATE;\n\tmbs.param[1] =\n\t    (sdp_chan0->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan0->isp_data_line_active_neg << 5);\n\tmbs.param[2] =\n\t    (sdp_chan1->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan1->isp_data_line_active_neg << 5);\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set active negation state \"\n\t\t    \"(%d,%d),(%d,%d)\\n\", isp->isp_name,\n\t\t    sdp_chan0->isp_req_ack_active_neg,\n\t\t    sdp_chan0->isp_data_line_active_neg,\n\t\t    sdp_chan1->isp_req_ack_active_neg,\n\t\t    sdp_chan1->isp_data_line_active_neg);\n\t\t/*\n\t\t * But don't return.\n\t\t */\n\t}\n\n\t/*\n\t * Set the Tag Aging limit\n\t */\n\tmbs.param[0] = MBOX_SET_TAG_AGE_LIMIT;\n\tmbs.param[1] = sdp_chan0->isp_tag_aging;\n\tmbs.param[2] = sdp_chan1->isp_tag_aging;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set tag age limit (%d,%d)\\n\",\n\t\t    isp->isp_name, sdp_chan0->isp_tag_aging,\n\t\t    sdp_chan1->isp_tag_aging);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set selection timeout.\n\t */\n\tmbs.param[0] = MBOX_SET_SELECT_TIMEOUT;\n\tmbs.param[1] = sdp_chan0->isp_selection_timeout;\n\tmbs.param[2] = sdp_chan1->isp_selection_timeout;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set selection timeout\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\n\t/* now do per-channel settings */\n\tisp_scsi_channel_init(isp, 0);\n\tif (IS_DUALBUS(isp))\n\t\tisp_scsi_channel_init(isp, 1);\n\n\t/*\n\t * Now enable request/response queues\n\t */\n\n\tmbs.param[0] = MBOX_INIT_RES_QUEUE;\n\tmbs.param[1] = RESULT_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_result_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_result_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of response queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_residx = 0;\n\n\tmbs.param[0] = MBOX_INIT_REQ_QUEUE;\n\tmbs.param[1] = RQUEST_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_rquest_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_rquest_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of request queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\n\t/*\n\t * Turn on Fast Posting, LVD transitions\n\t *\n\t * Ultra2 F/W always has had fast posting (and LVD transitions)\n\t *\n\t * Ultra and older (i.e., SBus) cards may not. It's just safer\n\t * to assume not for them.\n\t */\n\n\tmbs.param[0] = MBOX_SET_FW_FEATURES;\n\tmbs.param[1] = 0;\n\tif (IS_ULTRA2(isp))\n\t\tmbs.param[1] |= FW_FEATURE_LVD_NOTIFY;\n\tif (IS_ULTRA2(isp) || IS_1240(isp))\n\t\tmbs.param[1] |= FW_FEATURE_FAST_POST;\n\tif (mbs.param[1] != 0) {\n\t\tu_int16_t sfeat = mbs.param[1];\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: cannot enable FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: enabled FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t}\n\t}\n\n\t/*\n\t * Let the outer layers decide whether to issue a SCSI bus reset.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_scsi_init",
            "static void isp_scsi_channel_init",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_init;\nstatic void isp_scsi_channel_init;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_scsi_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tsdparam *sdp_chan0, *sdp_chan1;\n\tmbreg_t mbs;\n\n\tsdp_chan0 = isp->isp_param;\n\tsdp_chan1 = sdp_chan0;\n\tif (IS_DUALBUS(isp)) {\n\t\tsdp_chan1++;\n\t}\n\n\t/* First do overall per-card settings. */\n\n\t/*\n\t * If we have fast memory timing enabled, turn it on.\n\t */\n\tif (isp->isp_fast_mttr) {\n\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t}\n\n\t/*\n\t * Set Retry Delay and Count.\n\t * You set both channels at the same time.\n\t */\n\tmbs.param[0] = MBOX_SET_RETRY_COUNT;\n\tmbs.param[1] = sdp_chan0->isp_retry_count;\n\tmbs.param[2] = sdp_chan0->isp_retry_delay;\n\tmbs.param[6] = sdp_chan1->isp_retry_count;\n\tmbs.param[7] = sdp_chan1->isp_retry_delay;\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set retry count and retry delay\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ASYNC DATA SETUP time. This is very important.\n\t */\n\tmbs.param[0] = MBOX_SET_ASYNC_DATA_SETUP_TIME;\n\tmbs.param[1] = sdp_chan0->isp_async_data_setup;\n\tmbs.param[2] = sdp_chan1->isp_async_data_setup;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set asynchronous data setup time\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set ACTIVE Negation State.\n\t */\n\tmbs.param[0] = MBOX_SET_ACT_NEG_STATE;\n\tmbs.param[1] =\n\t    (sdp_chan0->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan0->isp_data_line_active_neg << 5);\n\tmbs.param[2] =\n\t    (sdp_chan1->isp_req_ack_active_neg << 4) |\n\t    (sdp_chan1->isp_data_line_active_neg << 5);\n\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set active negation state \"\n\t\t    \"(%d,%d),(%d,%d)\\n\", isp->isp_name,\n\t\t    sdp_chan0->isp_req_ack_active_neg,\n\t\t    sdp_chan0->isp_data_line_active_neg,\n\t\t    sdp_chan1->isp_req_ack_active_neg,\n\t\t    sdp_chan1->isp_data_line_active_neg);\n\t\t/*\n\t\t * But don't return.\n\t\t */\n\t}\n\n\t/*\n\t * Set the Tag Aging limit\n\t */\n\tmbs.param[0] = MBOX_SET_TAG_AGE_LIMIT;\n\tmbs.param[1] = sdp_chan0->isp_tag_aging;\n\tmbs.param[2] = sdp_chan1->isp_tag_aging;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set tag age limit (%d,%d)\\n\",\n\t\t    isp->isp_name, sdp_chan0->isp_tag_aging,\n\t\t    sdp_chan1->isp_tag_aging);\n\t\treturn;\n\t}\n\n\t/*\n\t * Set selection timeout.\n\t */\n\tmbs.param[0] = MBOX_SET_SELECT_TIMEOUT;\n\tmbs.param[1] = sdp_chan0->isp_selection_timeout;\n\tmbs.param[2] = sdp_chan1->isp_selection_timeout;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: failed to set selection timeout\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\n\t/* now do per-channel settings */\n\tisp_scsi_channel_init(isp, 0);\n\tif (IS_DUALBUS(isp))\n\t\tisp_scsi_channel_init(isp, 1);\n\n\t/*\n\t * Now enable request/response queues\n\t */\n\n\tmbs.param[0] = MBOX_INIT_RES_QUEUE;\n\tmbs.param[1] = RESULT_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_result_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_result_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of response queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_residx = 0;\n\n\tmbs.param[0] = MBOX_INIT_REQ_QUEUE;\n\tmbs.param[1] = RQUEST_QUEUE_LEN;\n\tmbs.param[2] = DMA_MSW(isp->isp_rquest_dma);\n\tmbs.param[3] = DMA_LSW(isp->isp_rquest_dma);\n\tmbs.param[4] = 0;\n\tmbs.param[5] = 0;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: set of request queue failed\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\n\t/*\n\t * Turn on Fast Posting, LVD transitions\n\t *\n\t * Ultra2 F/W always has had fast posting (and LVD transitions)\n\t *\n\t * Ultra and older (i.e., SBus) cards may not. It's just safer\n\t * to assume not for them.\n\t */\n\n\tmbs.param[0] = MBOX_SET_FW_FEATURES;\n\tmbs.param[1] = 0;\n\tif (IS_ULTRA2(isp))\n\t\tmbs.param[1] |= FW_FEATURE_LVD_NOTIFY;\n\tif (IS_ULTRA2(isp) || IS_1240(isp))\n\t\tmbs.param[1] |= FW_FEATURE_FAST_POST;\n\tif (mbs.param[1] != 0) {\n\t\tu_int16_t sfeat = mbs.param[1];\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: cannot enable FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: enabled FW features (0x%x)\\n\",\n\t\t\t    isp->isp_name, sfeat);\n\t\t}\n\t}\n\n\t/*\n\t * Let the outer layers decide whether to issue a SCSI bus reset.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_fibre_init",
          "args": [
            "isp"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "isp_fibre_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "982-1151",
          "snippet": "static void\nisp_fibre_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp;\n\tisp_icb_t *icbp;\n\tmbreg_t mbs;\n\tint loopid;\n\n\tfcp = isp->isp_param;\n\n\t/*\n\t * For systems that don't have BIOS methods for which\n\t * we can easily change the NVRAM based loopid, we'll\n\t * override that here. Note that when we initialize\n\t * the firmware we may get back a different loopid than\n\t * we asked for anyway. XXX This is probably not the\n\t * best way to figure this out XXX\n\t */\n#ifndef\t__i386__\n\tloopid = DEFAULT_LOOPID(isp);\n#else\n\tloopid = fcp->isp_loopid;\n#endif\n\n\ticbp = (isp_icb_t *) fcp->isp_scratch;\n\tMEMZERO(icbp, sizeof (*icbp));\n\n\ticbp->icb_version = ICB_VERSION1;\n#ifdef\tISP_TARGET_MODE\n\tfcp->isp_fwoptions = ICBOPT_TGT_ENABLE;\n#else\n\tfcp->isp_fwoptions = 0;\n#endif\n\tfcp->isp_fwoptions |= ICBOPT_FAIRNESS;\n\t/*\n\t * If this is a 2100 < revision 5, we have to turn off FAIRNESS.\n\t */\n\tif ((isp->isp_type == ISP_HA_FC_2100) && isp->isp_revision < 5) {\n\t\tfcp->isp_fwoptions &= ~ICBOPT_FAIRNESS;\n\t}\n\tfcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;\n\tfcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;\n\t/*\n\t * We have to use FULL LOGIN even though it resets the loop too much\n\t * because otherwise port database entries don't get updated after\n\t * a LIP- this is a known f/w bug.\n\t */\n\tif (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(1, 17, 0)) {\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_LOGIN;\n\t}\n#ifndef\tISP_NO_FASTPOST_FC\n\tfcp->isp_fwoptions |= ICBOPT_FAST_POST;\n#endif\n\tif (isp->isp_confopts & ISP_CFG_FULL_DUPLEX)\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;\n\n\t/*\n\t * We don't set ICBOPT_PORTNAME because we want our\n\t * Node Name && Port Names to be distinct.\n\t */\n\n\ticbp->icb_fwoptions = fcp->isp_fwoptions;\n\ticbp->icb_maxfrmlen = fcp->isp_maxfrmlen;\n\tif (icbp->icb_maxfrmlen < ICB_MIN_FRMLEN ||\n\t    icbp->icb_maxfrmlen > ICB_MAX_FRMLEN) {\n\t\tPRINTF(\"%s: bad frame length (%d) from NVRAM- using %d\\n\",\n\t\t    isp->isp_name, fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);\n\t\ticbp->icb_maxfrmlen = ICB_DFLT_FRMLEN;\n\t}\n\ticbp->icb_maxalloc = fcp->isp_maxalloc;\n\tif (icbp->icb_maxalloc < 1) {\n\t\tPRINTF(\"%s: bad maximum allocation (%d)- using 16\\n\",\n\t\t     isp->isp_name, fcp->isp_maxalloc);\n\t\ticbp->icb_maxalloc = 16;\n\t}\n\ticbp->icb_execthrottle = fcp->isp_execthrottle;\n\tif (icbp->icb_execthrottle < 1) {\n\t\tPRINTF(\"%s: bad execution throttle of %d- using 16\\n\",\n\t\t    isp->isp_name, fcp->isp_execthrottle);\n\t\ticbp->icb_execthrottle = ICB_DFLT_THROTTLE;\n\t}\n\ticbp->icb_retry_delay = fcp->isp_retry_delay;\n\ticbp->icb_retry_count = fcp->isp_retry_count;\n\ticbp->icb_hardaddr = loopid;\n#ifdef\tPRET_A_PORTE\n\tif (IS_2200(isp)) {\n\t\ticbp->icb_fwoptions |= ICBOPT_EXTENDED;\n\t\t/*\n\t\t * Prefer or force Point-To-Point instead Loop?\n\t\t */\n\t\tif (isp->isp_confopts & ISP_CFG_NPORT)\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_PTP_2_LOOP;\n\t\telse\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_LOOP_2_PTP;\n\t}\n#endif\n\ticbp->icb_logintime = 60;\t/* 60 second login timeout */\n\n\tif (fcp->isp_nodewwn) {\n\t\tu_int64_t pn;\n\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, fcp->isp_nodewwn);\n\t\tif (fcp->isp_portwwn) {\n\t\t\tpn = fcp->isp_portwwn;\n\t\t} else {\n\t\t\tpn = fcp->isp_nodewwn |\n\t\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t\t}\n\t\t/*\n\t\t * If the top nibble is 2, we can construct a port name\n\t\t * from the node name by setting a nonzero instance in\n\t\t * bits 56..59. Otherwise, we need to make it identical\n\t\t * to Node name...\n\t\t */\n\t\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pn);\n\t\t} else {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname,\n\t\t\t    fcp->isp_nodewwn);\n\t\t}\n\t} else {\n\t\tfcp->isp_fwoptions &= ~(ICBOPT_USE_PORTNAME|ICBOPT_FULL_LOGIN);\n\t}\n\ticbp->icb_rqstqlen = RQUEST_QUEUE_LEN;\n\ticbp->icb_rsltqlen = RESULT_QUEUE_LEN;\n\ticbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_rquest_dma);\n\ticbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_rquest_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_result_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_result_dma);\n\tISP_SWIZZLE_ICB(isp, icbp);\n\n\t/*\n\t * Do this *before* initializing the firmware.\n\t */\n\tisp_mark_getpdb_all(isp);\n\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\tfcp->isp_loopstate = LOOP_NIL;\n\n\tMemoryBarrier();\n\tfor (;;) {\n\t\tmbs.param[0] = MBOX_INIT_FIRMWARE;\n\t\tmbs.param[1] = 0;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[4] = 0;\n\t\tmbs.param[5] = 0;\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: INIT FIRMWARE failed (code 0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tif (mbs.param[0] & 0x8000) {\n\t\t\t\tSYS_DELAY(1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\tisp->isp_residx = 0;\n\tisp->isp_sendmarker = 1;\n\n\t/*\n\t * Whatever happens, we're now committed to being here.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_fibre_init",
            "static void isp_mark_getpdb_all",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fibre_init;\nstatic void isp_mark_getpdb_all;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_fibre_init(isp)\n\tstruct ispsoftc *isp;\n{\n\tfcparam *fcp;\n\tisp_icb_t *icbp;\n\tmbreg_t mbs;\n\tint loopid;\n\n\tfcp = isp->isp_param;\n\n\t/*\n\t * For systems that don't have BIOS methods for which\n\t * we can easily change the NVRAM based loopid, we'll\n\t * override that here. Note that when we initialize\n\t * the firmware we may get back a different loopid than\n\t * we asked for anyway. XXX This is probably not the\n\t * best way to figure this out XXX\n\t */\n#ifndef\t__i386__\n\tloopid = DEFAULT_LOOPID(isp);\n#else\n\tloopid = fcp->isp_loopid;\n#endif\n\n\ticbp = (isp_icb_t *) fcp->isp_scratch;\n\tMEMZERO(icbp, sizeof (*icbp));\n\n\ticbp->icb_version = ICB_VERSION1;\n#ifdef\tISP_TARGET_MODE\n\tfcp->isp_fwoptions = ICBOPT_TGT_ENABLE;\n#else\n\tfcp->isp_fwoptions = 0;\n#endif\n\tfcp->isp_fwoptions |= ICBOPT_FAIRNESS;\n\t/*\n\t * If this is a 2100 < revision 5, we have to turn off FAIRNESS.\n\t */\n\tif ((isp->isp_type == ISP_HA_FC_2100) && isp->isp_revision < 5) {\n\t\tfcp->isp_fwoptions &= ~ICBOPT_FAIRNESS;\n\t}\n\tfcp->isp_fwoptions |= ICBOPT_PDBCHANGE_AE;\n\tfcp->isp_fwoptions |= ICBOPT_HARD_ADDRESS;\n\t/*\n\t * We have to use FULL LOGIN even though it resets the loop too much\n\t * because otherwise port database entries don't get updated after\n\t * a LIP- this is a known f/w bug.\n\t */\n\tif (ISP_FW_REVX(isp->isp_fwrev) < ISP_FW_REV(1, 17, 0)) {\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_LOGIN;\n\t}\n#ifndef\tISP_NO_FASTPOST_FC\n\tfcp->isp_fwoptions |= ICBOPT_FAST_POST;\n#endif\n\tif (isp->isp_confopts & ISP_CFG_FULL_DUPLEX)\n\t\tfcp->isp_fwoptions |= ICBOPT_FULL_DUPLEX;\n\n\t/*\n\t * We don't set ICBOPT_PORTNAME because we want our\n\t * Node Name && Port Names to be distinct.\n\t */\n\n\ticbp->icb_fwoptions = fcp->isp_fwoptions;\n\ticbp->icb_maxfrmlen = fcp->isp_maxfrmlen;\n\tif (icbp->icb_maxfrmlen < ICB_MIN_FRMLEN ||\n\t    icbp->icb_maxfrmlen > ICB_MAX_FRMLEN) {\n\t\tPRINTF(\"%s: bad frame length (%d) from NVRAM- using %d\\n\",\n\t\t    isp->isp_name, fcp->isp_maxfrmlen, ICB_DFLT_FRMLEN);\n\t\ticbp->icb_maxfrmlen = ICB_DFLT_FRMLEN;\n\t}\n\ticbp->icb_maxalloc = fcp->isp_maxalloc;\n\tif (icbp->icb_maxalloc < 1) {\n\t\tPRINTF(\"%s: bad maximum allocation (%d)- using 16\\n\",\n\t\t     isp->isp_name, fcp->isp_maxalloc);\n\t\ticbp->icb_maxalloc = 16;\n\t}\n\ticbp->icb_execthrottle = fcp->isp_execthrottle;\n\tif (icbp->icb_execthrottle < 1) {\n\t\tPRINTF(\"%s: bad execution throttle of %d- using 16\\n\",\n\t\t    isp->isp_name, fcp->isp_execthrottle);\n\t\ticbp->icb_execthrottle = ICB_DFLT_THROTTLE;\n\t}\n\ticbp->icb_retry_delay = fcp->isp_retry_delay;\n\ticbp->icb_retry_count = fcp->isp_retry_count;\n\ticbp->icb_hardaddr = loopid;\n#ifdef\tPRET_A_PORTE\n\tif (IS_2200(isp)) {\n\t\ticbp->icb_fwoptions |= ICBOPT_EXTENDED;\n\t\t/*\n\t\t * Prefer or force Point-To-Point instead Loop?\n\t\t */\n\t\tif (isp->isp_confopts & ISP_CFG_NPORT)\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_PTP_2_LOOP;\n\t\telse\n\t\t\ticbp->icb_xfwoptions = ICBXOPT_LOOP_2_PTP;\n\t}\n#endif\n\ticbp->icb_logintime = 60;\t/* 60 second login timeout */\n\n\tif (fcp->isp_nodewwn) {\n\t\tu_int64_t pn;\n\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_nodename, fcp->isp_nodewwn);\n\t\tif (fcp->isp_portwwn) {\n\t\t\tpn = fcp->isp_portwwn;\n\t\t} else {\n\t\t\tpn = fcp->isp_nodewwn |\n\t\t\t    (((u_int64_t)(isp->isp_unit+1)) << 56);\n\t\t}\n\t\t/*\n\t\t * If the top nibble is 2, we can construct a port name\n\t\t * from the node name by setting a nonzero instance in\n\t\t * bits 56..59. Otherwise, we need to make it identical\n\t\t * to Node name...\n\t\t */\n\t\tif ((fcp->isp_nodewwn >> 60) == 2) {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname, pn);\n\t\t} else {\n\t\t\tMAKE_NODE_NAME_FROM_WWN(icbp->icb_portname,\n\t\t\t    fcp->isp_nodewwn);\n\t\t}\n\t} else {\n\t\tfcp->isp_fwoptions &= ~(ICBOPT_USE_PORTNAME|ICBOPT_FULL_LOGIN);\n\t}\n\ticbp->icb_rqstqlen = RQUEST_QUEUE_LEN;\n\ticbp->icb_rsltqlen = RESULT_QUEUE_LEN;\n\ticbp->icb_rqstaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_rquest_dma);\n\ticbp->icb_rqstaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_rquest_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR0015] = DMA_LSW(isp->isp_result_dma);\n\ticbp->icb_respaddr[RQRSP_ADDR1631] = DMA_MSW(isp->isp_result_dma);\n\tISP_SWIZZLE_ICB(isp, icbp);\n\n\t/*\n\t * Do this *before* initializing the firmware.\n\t */\n\tisp_mark_getpdb_all(isp);\n\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\tfcp->isp_loopstate = LOOP_NIL;\n\n\tMemoryBarrier();\n\tfor (;;) {\n\t\tmbs.param[0] = MBOX_INIT_FIRMWARE;\n\t\tmbs.param[1] = 0;\n\t\tmbs.param[2] = DMA_MSW(fcp->isp_scdma);\n\t\tmbs.param[3] = DMA_LSW(fcp->isp_scdma);\n\t\tmbs.param[4] = 0;\n\t\tmbs.param[5] = 0;\n\t\tmbs.param[6] = 0;\n\t\tmbs.param[7] = 0;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: INIT FIRMWARE failed (code 0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tif (mbs.param[0] & 0x8000) {\n\t\t\t\tSYS_DELAY(1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tisp->isp_reqidx = isp->isp_reqodx = 0;\n\tisp->isp_residx = 0;\n\tisp->isp_sendmarker = 1;\n\n\t/*\n\t * Whatever happens, we're now committed to being here.\n\t */\n\tisp->isp_state = ISP_INITSTATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_setdfltparm",
          "args": [
            "isp",
            "1"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "isp_setdfltparm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3856-4053",
          "snippet": "static void\nisp_setdfltparm(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = (fcparam *) isp->isp_param;\n\t\tfcp += channel;\n\t\tif (fcp->isp_gotdparms) {\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_gotdparms = 1;\n\t\tfcp->isp_maxfrmlen = ICB_DFLT_FRMLEN;\n\t\tfcp->isp_maxalloc = ICB_DFLT_ALLOC;\n\t\tfcp->isp_execthrottle = ICB_DFLT_THROTTLE;\n\t\tfcp->isp_retry_delay = ICB_DFLT_RDELAY;\n\t\tfcp->isp_retry_count = ICB_DFLT_RCOUNT;\n\t\t/* Platform specific.... */\n\t\tfcp->isp_loopid = DEFAULT_LOOPID(isp);\n\t\tfcp->isp_nodewwn = DEFAULT_WWN(isp);\n\t\tfcp->isp_portwwn = 0;\n\t\t/*\n\t\t * Now try and read NVRAM\n\t\t */\n\t\tif ((isp->isp_confopts & (ISP_CFG_NONVRAM|ISP_CFG_OWNWWN)) ||\n\t\t    (isp_read_nvram(isp))) {\n\t\t\tPRINTF(\"%s: using Node WWN 0x%08x%08x\\n\",\n\t\t\t    isp->isp_name, (u_int32_t)(fcp->isp_nodewwn >> 32),\n\t\t\t    (u_int32_t)(fcp->isp_nodewwn & 0xffffffff));\n\t\t}\n\t\treturn;\n\t}\n\n\tsdp = (sdparam *) isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Been there, done that, got the T-shirt...\n\t */\n\tif (sdp->isp_gotdparms) {\n\t\treturn;\n\t}\n\tsdp->isp_gotdparms = 1;\n\n\t/*\n\t * If we've not been told to avoid reading NVRAM, try and read it.\n\t * If we're successful reading it, we can return since NVRAM will\n\t * tell us the right thing to do. Otherwise, establish some reasonable\n\t * defaults.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tif (isp_read_nvram(isp) == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Now try and see whether we have specific values for them.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tmbs.param[0] = MBOX_GET_ACT_NEG_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(2, (\"could not GET ACT NEG STATE\\n\"));\n\t\t\tsdp->isp_req_ack_active_neg = 1;\n\t\t\tsdp->isp_data_line_active_neg = 1;\n\t\t} else {\n\t\t\tsdp->isp_req_ack_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 4) & 0x1;\n\t\t\tsdp->isp_data_line_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 5) & 0x1;\n\t\t}\n\t} else {\n\t\tsdp->isp_req_ack_active_neg = 1;\n\t\tsdp->isp_data_line_active_neg = 1;\n\t}\n\n\tIDPRINTF(3, (\"%s: defaulting bus %d REQ/ACK Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_req_ack_active_neg));\n\tIDPRINTF(3, (\"%s: defaulting bus %d DATA Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_data_line_active_neg));\n\n\t/*\n\t * The trick here is to establish a default for the default (honk!)\n\t * state (dev_flags). Then try and get the current status from\n\t * the card to fill in the current state. We don't, in fact, set\n\t * the default to the SAFE default state- that's not the goal state.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].cur_offset = 0;\n\t\tsdp->isp_devparam[tgt].cur_period = 0;\n\t\tsdp->isp_devparam[tgt].dev_flags = DPARM_DEFAULT;\n\t\tsdp->isp_devparam[tgt].cur_dflags = 0;\n\t\t/*\n\t\t * We default to Wide/Fast for versions less than a 1040\n\t\t * (unless it's SBus).\n\t\t */\n\t\tif ((isp->isp_bustype == ISP_BT_SBUS &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1020A) ||\n\t\t    (isp->isp_bustype == ISP_BT_PCI &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1040) ||\n\t\t    (isp->isp_clock && isp->isp_clock < 60)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t} else if (IS_ULTRA2(isp)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_40M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_40M_SYNCPARMS & 0xff;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_20M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_20M_SYNCPARMS & 0xff;\n\t\t}\n\n\t\t/*\n\t\t * Don't get current target parameters if we've been\n\t\t * told not to use NVRAM- it's really the same thing.\n\t\t */\n\t\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = tgt << 8;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].dev_flags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\n\t\t\t/*\n\t\t\t * The maximum period we can really see\n\t\t\t * here is 100 (decimal), or 400 ns.\n\t\t\t * For some unknown reason we sometimes\n\t\t\t * get back wildass numbers from the\n\t\t\t * boot device's parameters (alpha only).\n\t\t\t */\n\t\t\tif ((mbs.param[3] & 0xff) <= 0x64) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    mbs.param[3] & 0xff;\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    mbs.param[3] >> 8;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * It is not safe to run Ultra Mode with a clock < 60.\n\t\t\t */\n\t\t\tif (((isp->isp_clock && isp->isp_clock < 60) ||\n\t\t\t    (isp->isp_type < ISP_HA_SCSI_1020A)) &&\n\t\t\t    (sdp->isp_devparam[tgt].sync_period <=\n\t\t\t    (ISP_20M_SYNCPARMS & 0xff))) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t\t}\n\t\t}\n\t\tIDPRINTF(3, (\"%s: bus %d tgt %d flags %x offset %x period %x\\n\",\n\t\t    isp->isp_name, channel, tgt,\n\t\t    sdp->isp_devparam[tgt].dev_flags,\n\t\t    sdp->isp_devparam[tgt].sync_offset,\n\t\t    sdp->isp_devparam[tgt].sync_period));\n\t}\n\n\t/*\n\t * Establish default some more default parameters.\n\t */\n\tsdp->isp_cmd_dma_burst_enable = 1;\n\tsdp->isp_data_dma_burst_enabl = 1;\n\tsdp->isp_fifo_threshold = 0;\n\tsdp->isp_initiator_id = 7;\n\t/* XXXX This is probably based upon clock XXXX */\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tsdp->isp_async_data_setup = 9;\n\t} else {\n\t\tsdp->isp_async_data_setup = 6;\n\t}\n\tsdp->isp_selection_timeout = 250;\n\tsdp->isp_max_queue_depth = MAXISPREQUEST;\n\tsdp->isp_tag_aging = 8;\n\tsdp->isp_bus_reset_delay = 3;\n\tsdp->isp_retry_count = 2;\n\tsdp->isp_retry_delay = 2;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].exc_throttle = 16;\n\t\tsdp->isp_devparam[tgt].dev_enable = 1;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_mboxcmd",
            "static void isp_setdfltparm",
            "static int isp_read_nvram"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_mboxcmd;\nstatic void isp_setdfltparm;\nstatic int isp_read_nvram;\n\nstatic void\nisp_setdfltparm(isp, channel)\n\tstruct ispsoftc *isp;\n\tint channel;\n{\n\tint tgt;\n\tmbreg_t mbs;\n\tsdparam *sdp;\n\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = (fcparam *) isp->isp_param;\n\t\tfcp += channel;\n\t\tif (fcp->isp_gotdparms) {\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_gotdparms = 1;\n\t\tfcp->isp_maxfrmlen = ICB_DFLT_FRMLEN;\n\t\tfcp->isp_maxalloc = ICB_DFLT_ALLOC;\n\t\tfcp->isp_execthrottle = ICB_DFLT_THROTTLE;\n\t\tfcp->isp_retry_delay = ICB_DFLT_RDELAY;\n\t\tfcp->isp_retry_count = ICB_DFLT_RCOUNT;\n\t\t/* Platform specific.... */\n\t\tfcp->isp_loopid = DEFAULT_LOOPID(isp);\n\t\tfcp->isp_nodewwn = DEFAULT_WWN(isp);\n\t\tfcp->isp_portwwn = 0;\n\t\t/*\n\t\t * Now try and read NVRAM\n\t\t */\n\t\tif ((isp->isp_confopts & (ISP_CFG_NONVRAM|ISP_CFG_OWNWWN)) ||\n\t\t    (isp_read_nvram(isp))) {\n\t\t\tPRINTF(\"%s: using Node WWN 0x%08x%08x\\n\",\n\t\t\t    isp->isp_name, (u_int32_t)(fcp->isp_nodewwn >> 32),\n\t\t\t    (u_int32_t)(fcp->isp_nodewwn & 0xffffffff));\n\t\t}\n\t\treturn;\n\t}\n\n\tsdp = (sdparam *) isp->isp_param;\n\tsdp += channel;\n\n\t/*\n\t * Been there, done that, got the T-shirt...\n\t */\n\tif (sdp->isp_gotdparms) {\n\t\treturn;\n\t}\n\tsdp->isp_gotdparms = 1;\n\n\t/*\n\t * If we've not been told to avoid reading NVRAM, try and read it.\n\t * If we're successful reading it, we can return since NVRAM will\n\t * tell us the right thing to do. Otherwise, establish some reasonable\n\t * defaults.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tif (isp_read_nvram(isp) == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Now try and see whether we have specific values for them.\n\t */\n\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\t\tmbs.param[0] = MBOX_GET_ACT_NEG_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(2, (\"could not GET ACT NEG STATE\\n\"));\n\t\t\tsdp->isp_req_ack_active_neg = 1;\n\t\t\tsdp->isp_data_line_active_neg = 1;\n\t\t} else {\n\t\t\tsdp->isp_req_ack_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 4) & 0x1;\n\t\t\tsdp->isp_data_line_active_neg =\n\t\t\t    (mbs.param[1+channel] >> 5) & 0x1;\n\t\t}\n\t} else {\n\t\tsdp->isp_req_ack_active_neg = 1;\n\t\tsdp->isp_data_line_active_neg = 1;\n\t}\n\n\tIDPRINTF(3, (\"%s: defaulting bus %d REQ/ACK Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_req_ack_active_neg));\n\tIDPRINTF(3, (\"%s: defaulting bus %d DATA Active Negation is %d\\n\",\n\t    isp->isp_name, channel, sdp->isp_data_line_active_neg));\n\n\t/*\n\t * The trick here is to establish a default for the default (honk!)\n\t * state (dev_flags). Then try and get the current status from\n\t * the card to fill in the current state. We don't, in fact, set\n\t * the default to the SAFE default state- that's not the goal state.\n\t */\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].cur_offset = 0;\n\t\tsdp->isp_devparam[tgt].cur_period = 0;\n\t\tsdp->isp_devparam[tgt].dev_flags = DPARM_DEFAULT;\n\t\tsdp->isp_devparam[tgt].cur_dflags = 0;\n\t\t/*\n\t\t * We default to Wide/Fast for versions less than a 1040\n\t\t * (unless it's SBus).\n\t\t */\n\t\tif ((isp->isp_bustype == ISP_BT_SBUS &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1020A) ||\n\t\t    (isp->isp_bustype == ISP_BT_PCI &&\n\t\t    isp->isp_type < ISP_HA_SCSI_1040) ||\n\t\t    (isp->isp_clock && isp->isp_clock < 60)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t} else if (IS_ULTRA2(isp)) {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_40M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_40M_SYNCPARMS & 0xff;\n\t\t} else {\n\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t    ISP_20M_SYNCPARMS >> 8;\n\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t    ISP_20M_SYNCPARMS & 0xff;\n\t\t}\n\n\t\t/*\n\t\t * Don't get current target parameters if we've been\n\t\t * told not to use NVRAM- it's really the same thing.\n\t\t */\n\t\tif ((isp->isp_confopts & ISP_CFG_NONVRAM) == 0) {\n\n\t\t\tmbs.param[0] = MBOX_GET_TARGET_PARAMS;\n\t\t\tmbs.param[1] = tgt << 8;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsdp->isp_devparam[tgt].cur_dflags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].dev_flags = mbs.param[2];\n\t\t\tsdp->isp_devparam[tgt].cur_period = mbs.param[3] & 0xff;\n\t\t\tsdp->isp_devparam[tgt].cur_offset = mbs.param[3] >> 8;\n\n\t\t\t/*\n\t\t\t * The maximum period we can really see\n\t\t\t * here is 100 (decimal), or 400 ns.\n\t\t\t * For some unknown reason we sometimes\n\t\t\t * get back wildass numbers from the\n\t\t\t * boot device's parameters (alpha only).\n\t\t\t */\n\t\t\tif ((mbs.param[3] & 0xff) <= 0x64) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    mbs.param[3] & 0xff;\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    mbs.param[3] >> 8;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * It is not safe to run Ultra Mode with a clock < 60.\n\t\t\t */\n\t\t\tif (((isp->isp_clock && isp->isp_clock < 60) ||\n\t\t\t    (isp->isp_type < ISP_HA_SCSI_1020A)) &&\n\t\t\t    (sdp->isp_devparam[tgt].sync_period <=\n\t\t\t    (ISP_20M_SYNCPARMS & 0xff))) {\n\t\t\t\tsdp->isp_devparam[tgt].sync_offset =\n\t\t\t\t    ISP_10M_SYNCPARMS >> 8;\n\t\t\t\tsdp->isp_devparam[tgt].sync_period =\n\t\t\t\t    ISP_10M_SYNCPARMS & 0xff;\n\t\t\t}\n\t\t}\n\t\tIDPRINTF(3, (\"%s: bus %d tgt %d flags %x offset %x period %x\\n\",\n\t\t    isp->isp_name, channel, tgt,\n\t\t    sdp->isp_devparam[tgt].dev_flags,\n\t\t    sdp->isp_devparam[tgt].sync_offset,\n\t\t    sdp->isp_devparam[tgt].sync_period));\n\t}\n\n\t/*\n\t * Establish default some more default parameters.\n\t */\n\tsdp->isp_cmd_dma_burst_enable = 1;\n\tsdp->isp_data_dma_burst_enabl = 1;\n\tsdp->isp_fifo_threshold = 0;\n\tsdp->isp_initiator_id = 7;\n\t/* XXXX This is probably based upon clock XXXX */\n\tif (isp->isp_type >= ISP_HA_SCSI_1040) {\n\t\tsdp->isp_async_data_setup = 9;\n\t} else {\n\t\tsdp->isp_async_data_setup = 6;\n\t}\n\tsdp->isp_selection_timeout = 250;\n\tsdp->isp_max_queue_depth = MAXISPREQUEST;\n\tsdp->isp_tag_aging = 8;\n\tsdp->isp_bus_reset_delay = 3;\n\tsdp->isp_retry_count = 2;\n\tsdp->isp_retry_delay = 2;\n\n\tfor (tgt = 0; tgt < MAX_TARGETS; tgt++) {\n\t\tsdp->isp_devparam[tgt].exc_throttle = 16;\n\t\tsdp->isp_devparam[tgt].dev_enable = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_init;\nstatic void isp_fibre_init;\nstatic void isp_setdfltparm;\n\nvoid\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}"
  },
  {
    "function_name": "isp_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
    "lines": "111-639",
    "snippet": "void\nisp_reset(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tint loops, i, dodnld = 1;\n\tchar *revname;\n\n\tisp->isp_state = ISP_NILSTATE;\n\n\t/*\n\t * Basic types (SCSI, FibreChannel and PCI or SBus)\n\t * have been set in the MD code. We figure out more\n\t * here.\n\t */\n\tisp->isp_dblev = DFLT_DBLEVEL;\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\t/*\n\t * Get the current running firmware revision out of the\n\t * chip before we hit it over the head (if this is our\n\t * first time through). Note that we store this as the\n\t * 'ROM' firmware revision- which it may not be. In any\n\t * case, we don't really use this yet, but we may in\n\t * the future.\n\t */\n\tif (isp->isp_touched == 0) {\n\t\t/*\n\t\t * Just in case it was paused...\n\t\t */\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\t/*\n\t\t * If this fails, it probably means we're running\n\t\t * an old prom, if anything at all...\n\t\t */\n\t\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\t\tisp->isp_romfw_rev[0] = mbs.param[1];\n\t\t\tisp->isp_romfw_rev[1] = mbs.param[2];\n\t\t\tisp->isp_romfw_rev[2] = mbs.param[3];\n\t\t}\n\t\tisp->isp_touched = 1;\n\t}\n\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Put the board into PAUSE mode (so we can read the SXP registers).\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\n\tif (IS_FC(isp)) {\n\t\trevname = \"2X00\";\n\t\tswitch (isp->isp_type) {\n\t\tcase ISP_HA_FC_2100:\n\t\t\trevname[1] = '1';\n\t\t\tbreak;\n\t\tcase ISP_HA_FC_2200:\n\t\t\trevname[1] = '2';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_1240(isp)) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\trevname = \"1240\";\n\t\tisp->isp_clock = 60;\n\t\tsdp->isp_ultramode = 1;\n\t\tsdp++;\n\t\tsdp->isp_ultramode = 1;\n\t\t/*\n\t\t * XXX: Should probably do some bus sensing.\n\t\t */\n\t} else if (IS_ULTRA2(isp)) {\n\t\tstatic char *m = \"%s: bus %d is in %s Mode\\n\";\n\t\tu_int16_t l;\n\t\tsdparam *sdp = isp->isp_param;\n\n\t\tisp->isp_clock = 100;\n\n\t\tif (IS_1280(isp))\n\t\t\trevname = \"1280\";\n\t\telse if (IS_1080(isp))\n\t\t\trevname = \"1080\";\n\t\telse if (IS_12160(isp))\n\t\t\trevname = \"12160\";\n\t\telse\n\t\t\trevname = \"<UNKLVD>\";\n\n\t\tl = ISP_READ(isp, SXP_PINS_DIFF) & ISP1080_MODE_MASK;\n\t\tswitch (l) {\n\t\tcase ISP1080_LVD_MODE:\n\t\t\tsdp->isp_lvdmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"LVD\");\n\t\t\tbreak;\n\t\tcase ISP1080_HVD_MODE:\n\t\t\tsdp->isp_diffmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Differential\");\n\t\t\tbreak;\n\t\tcase ISP1080_SE_MODE:\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Single-Ended\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t    isp->isp_name, 0, l);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tsdp++;\n\t\t\tl = ISP_READ(isp, SXP_PINS_DIFF|SXP_BANK1_SELECT);\n\t\t\tl &= ISP1080_MODE_MASK;\n\t\t\tswitch(l) {\n\t\t\tcase ISP1080_LVD_MODE:\n\t\t\t\tsdp->isp_lvdmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"LVD\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_HVD_MODE:\n\t\t\t\tsdp->isp_diffmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Differential\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_SE_MODE:\n\t\t\t\tsdp->isp_ultramode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Single-Ended\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, 1, l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\ti = ISP_READ(isp, BIU_CONF0) & BIU_CONF0_HW_MASK;\n\t\tswitch (i) {\n\t\tdefault:\n\t\t\tPRINTF(\"%s: unknown chip rev. 0x%x- assuming a 1020\\n\",\n\t\t\t    isp->isp_name, i);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\trevname = \"1020\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/*\n\t\t\t * Some 1020A chips are Ultra Capable, but don't\n\t\t\t * run the clock rate up for that unless told to\n\t\t\t * do so by the Ultra Capable bits being set.\n\t\t\t */\n\t\t\trevname = \"1020A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020A;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trevname = \"1040\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trevname = \"1040A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040A;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevname = \"1040B\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040B;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 6: \n\t\t\trevname = \"1040C\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040C;\n\t\t\tisp->isp_clock = 60;\n                        break; \n\t\t}\n\t\t/*\n\t\t * Now, while we're at it, gather info about ultra\n\t\t * and/or differential mode.\n\t\t */\n\t\tif (ISP_READ(isp, SXP_PINS_DIFF) & SXP_PINS_DIFF_MODE) {\n\t\t\tCFGPRINTF(\"%s: Differential Mode\\n\", isp->isp_name);\n\t\t\tsdp->isp_diffmode = 1;\n\t\t} else {\n\t\t\tsdp->isp_diffmode = 0;\n\t\t}\n\t\ti = ISP_READ(isp, RISC_PSR);\n\t\tif (isp->isp_bustype == ISP_BT_SBUS) {\n\t\t\ti &= RISC_PSR_SBUS_ULTRA;\n\t\t} else {\n\t\t\ti &= RISC_PSR_PCI_ULTRA;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tCFGPRINTF(\"%s: Ultra Mode Capable\\n\", isp->isp_name);\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\t/*\n\t\t\t * If we're in Ultra Mode, we have to be 60Mhz clock-\n\t\t\t * even for the SBus version.\n\t\t\t */\n\t\t\tisp->isp_clock = 60;\n\t\t} else {\n\t\t\tsdp->isp_ultramode = 0;\n\t\t\t/*\n\t\t\t * Clock is known. Gronk.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Machine dependent clock (if set) overrides\n\t\t * our generic determinations.\n\t\t */\n\t\tif (isp->isp_mdvec->dv_clock) {\n\t\t\tif (isp->isp_mdvec->dv_clock < isp->isp_clock) {\n\t\t\t\tisp->isp_clock = isp->isp_mdvec->dv_clock;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * Do MD specific pre initialization\n\t */\n\tISP_RESET0(isp);\n\nagain:\n\n\t/*\n\t * Hit the chip over the head with hammer,\n\t * and give the ISP a chance to recover.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n#if\t0\n\t\tPRINTF(\"%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t    isp->isp_name, ISP_READ(isp, OUTMAILBOX0),\n\t\t    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2),\n\t\t    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4),\n\t\t    ISP_READ(isp, OUTMAILBOX5));\n#endif\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\t\tISP_WRITE(isp, DDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\n\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, TDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, RDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t}\n\n\t/*\n\t * Wait for ISP to be ready to go...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!(ISP_READ(isp, BIU2100_CSR) & BIU2100_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tisp_dumpregs(isp, \"chip reset timed out\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_CONF1, 0);\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, 0);\n\t}\n\n\t/*\n\t * Reset RISC Processor\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RESET);\n\tSYS_DELAY(100);\n\n\t/*\n\t * Establish some initial burst rate stuff.\n\t * (only for the 1XX0 boards). This really should\n\t * be done later after fetching from NVRAM.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tu_int16_t tmp = isp->isp_mdvec->dv_conf1;\n\t\t/*\n\t\t * Busted FIFO. Turn off all but burst enables.\n\t\t */\n\t\tif (isp->isp_type == ISP_HA_SCSI_1040A) {\n\t\t\ttmp &= BIU_BURST_ENABLE;\n\t\t}\n\t\tISP_SETBITS(isp, BIU_CONF1, tmp);\n\t\tif (tmp & BIU_BURST_ENABLE) {\n\t\t\tISP_SETBITS(isp, CDMA_CONF, DMA_ENABLE_BURST);\n\t\t\tISP_SETBITS(isp, DDMA_CONF, DMA_ENABLE_BURST);\n\t\t}\n#ifdef\tPTI_CARDS\n\t\tif (((sdparam *) isp->isp_param)->isp_ultramode) {\n\t\t\twhile (ISP_READ(isp, RISC_MTR) != 0x1313) {\n\t\t\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_STEP);\n\t\t\t}\n\t\t} else {\n\t\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n\t\t}\n\t\t/*\n\t\t * PTI specific register\n\t\t */\n\t\tISP_WRITE(isp, RISC_EMB, DUAL_BANK)\n#else\n\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n#endif\n\t} else {\n\t\tISP_WRITE(isp, RISC_MTR2100, 0x1212);\n\t}\n\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE); /* release paused processor */\n\n\t/*\n\t * Do MD specific post initialization\n\t */\n\tISP_RESET1(isp);\n\n\t/*\n\t * Wait for everything to finish firing up...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\twhile (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: MBOX_BUSY never cleared on reset\\n\",\n\t\t\t    isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Up until this point we've done everything by just reading or\n\t * setting registers. From this point on we rely on at least *some*\n\t * kind of firmware running in the card.\n\t */\n\n\t/*\n\t * Do some sanity checking.\n\t */\n\tmbs.param[0] = MBOX_NO_OP;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"NOP test failed\");\n\t\treturn;\n\t}\n\n\tif (IS_SCSI(isp)) {\n\t\tmbs.param[0] = MBOX_MAILBOX_REG_TEST;\n\t\tmbs.param[1] = 0xdead;\n\t\tmbs.param[2] = 0xbeef;\n\t\tmbs.param[3] = 0xffff;\n\t\tmbs.param[4] = 0x1111;\n\t\tmbs.param[5] = 0xa5a5;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp,\n\t\t\t\t\"Mailbox Register test didn't complete\");\n\t\t\treturn;\n\t\t}\n\t\tif (mbs.param[1] != 0xdead || mbs.param[2] != 0xbeef ||\n\t\t    mbs.param[3] != 0xffff || mbs.param[4] != 0x1111 ||\n\t\t    mbs.param[5] != 0xa5a5) {\n\t\t\tisp_dumpregs(isp, \"Register Test Failed\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\t/*\n\t * Download new Firmware, unless requested not to do so.\n\t * This is made slightly trickier in some cases where the\n\t * firmware of the ROM revision is newer than the revision\n\t * compiled into the driver. So, where we used to compare\n\t * versions of our f/w and the ROM f/w, now we just see\n\t * whether we have f/w at all and whether a config flag\n\t * has disabled our download.\n\t */\n\tif ((isp->isp_mdvec->dv_ispfw == NULL) ||\n\t    (isp->isp_confopts & ISP_CFG_NORELOAD)) {\n\t\tdodnld = 0;\n\t}\n\n\tif (dodnld) {\n\t\tu_int16_t fwlen  = isp->isp_mdvec->dv_fwlen;\n\t\tif (fwlen == 0)\n\t\t\tfwlen = isp->isp_mdvec->dv_ispfw[3]; /* usually here */\n\t\tfor (i = 0; i < fwlen; i++) {\n\t\t\tmbs.param[0] = MBOX_WRITE_RAM_WORD;\n\t\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg + i;\n\t\t\tmbs.param[2] = isp->isp_mdvec->dv_ispfw[i];\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: F/W download failed at word %d\\n\",\n\t\t\t\t    isp->isp_name, i);\n\t\t\t\tdodnld = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Verify that it downloaded correctly.\n\t\t */\n\t\tmbs.param[0] = MBOX_VERIFY_CHECKSUM;\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"ram checksum failure\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tIDPRINTF(3, (\"%s: skipping f/w download\\n\", isp->isp_name));\n\t}\n\n\t/*\n\t * Now start it rolling.\n\t *\n\t * If we didn't actually download f/w,\n\t * we still need to (re)start it.\n\t */\n\n\tmbs.param[0] = MBOX_EXEC_FIRMWARE;\n\tif (isp->isp_mdvec->dv_codeorg)\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\telse\n\t\tmbs.param[1] = 0x1000;\n\tisp_mboxcmd(isp, &mbs);\n\n\tif (IS_SCSI(isp)) {\n\t\t/*\n\t\t * Set CLOCK RATE, but only if asked to.\n\t\t */\n\t\tif (isp->isp_clock) {\n\t\t\tmbs.param[0] = MBOX_SET_CLOCK_RATE;\n\t\t\tmbs.param[1] = isp->isp_clock;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"failed to set clockrate (0x%x)\\n\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\t/* but continue */\n\t\t\t}\n\t\t}\n\t}\n\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"could not get f/w started (0x%x)\\n\", mbs.param[0]);\n\t\treturn;\n\t}\n\tCFGPRINTF(\"%s: Board Revision %s, %s F/W Revision %d.%d.%d\\n\",\n\t    isp->isp_name, revname, dodnld? \"loaded\" : \"resident\",\n\t    mbs.param[1], mbs.param[2], mbs.param[3]);\n\tif (IS_FC(isp)) {\n\t\tif (ISP_READ(isp, BIU2100_CSR) & BIU2100_PCI64) {\n\t\t\tCFGPRINTF(\"%s: in 64-Bit PCI slot\\n\", isp->isp_name);\n\t\t}\n\t}\n\n\tisp->isp_fwrev[0] = mbs.param[1];\n\tisp->isp_fwrev[1] = mbs.param[2];\n\tisp->isp_fwrev[2] = mbs.param[3];\n\tif (isp->isp_romfw_rev[0] || isp->isp_romfw_rev[1] ||\n\t    isp->isp_romfw_rev[2]) {\n\t\tCFGPRINTF(\"%s: Last F/W revision was %d.%d.%d\\n\", isp->isp_name,\n\t\t    isp->isp_romfw_rev[0], isp->isp_romfw_rev[1],\n\t\t    isp->isp_romfw_rev[2]);\n\t}\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: could not GET FIRMWARE STATUS\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_maxcmds = mbs.param[2];\n\tCFGPRINTF(\"%s: %d max I/O commands supported\\n\",\n\t    isp->isp_name, mbs.param[2]);\n\tisp_fw_state(isp);\n\n\t/*\n\t * Set up DMA for the request and result mailboxes.\n\t */\n\tif (ISP_MBOXDMASETUP(isp) != 0) {\n\t\tPRINTF(\"%s: can't setup dma mailboxes\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_state = ISP_RESETSTATE;\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
    ],
    "globals_used": [
      "static void isp_fw_state",
      "static void isp_dumpregs",
      "static void isp_mboxcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: can't setup dma mailboxes\\n\"",
            "isp->isp_name"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_MBOXDMASETUP",
          "args": [
            "isp"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_fw_state",
          "args": [
            "isp"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "isp_fw_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3695-3744",
          "snippet": "static void\nisp_fw_state(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tif (IS_FC(isp)) {\n\t\tint once = 0;\n\t\tfcparam *fcp = isp->isp_param;\nagain:\n\t\tmbs.param[0] = MBOX_GET_FW_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: isp_fw_state 0x%x\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase ASYNC_PDB_CHANGED:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_PDB_RCVD;\n\t\t\t\tgoto again;\n\t\t\tcase ASYNC_LIP_OCCURRED:\n\t\t\t\tfcp->isp_lipseq = mbs.param[1];\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_LOOP_UP:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_LIP_RCVD;\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ASYNC_LOOP_RESET:\n\t\t\tcase ASYNC_LOOP_DOWN:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_NIL;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_CHANGE_NOTIFY:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPRINTF(\"%s: GET FIRMWARE STATE failed (0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_fwstate = mbs.param[1];\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_fw_state",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_fw_state;\nstatic void isp_mboxcmd;\n\nstatic void\nisp_fw_state(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tif (IS_FC(isp)) {\n\t\tint once = 0;\n\t\tfcparam *fcp = isp->isp_param;\nagain:\n\t\tmbs.param[0] = MBOX_GET_FW_STATE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tIDPRINTF(1, (\"%s: isp_fw_state 0x%x\\n\", isp->isp_name,\n\t\t\t    mbs.param[0]));\n\t\t\tswitch (mbs.param[0]) {\n\t\t\tcase ASYNC_PDB_CHANGED:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_PDB_RCVD;\n\t\t\t\tgoto again;\n\t\t\tcase ASYNC_LIP_OCCURRED:\n\t\t\t\tfcp->isp_lipseq = mbs.param[1];\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_LOOP_UP:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_LIP_RCVD;\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ASYNC_LOOP_RESET:\n\t\t\tcase ASYNC_LOOP_DOWN:\n\t\t\t\tfcp->isp_fwstate = FW_CONFIG_WAIT;\n\t\t\t\tfcp->isp_loopstate = LOOP_NIL;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase ASYNC_CHANGE_NOTIFY:\n\t\t\t\tif (once++ < 10) {\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tPRINTF(\"%s: GET FIRMWARE STATE failed (0x%x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\treturn;\n\t\t}\n\t\tfcp->isp_fwstate = mbs.param[1];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: %d max I/O commands supported\\n\"",
            "isp->isp_name",
            "mbs.param[2]"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: could not GET FIRMWARE STATUS\\n\"",
            "isp->isp_name"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_mboxcmd",
          "args": [
            "isp",
            "&mbs"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "isp_mboxcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3242-3620",
          "snippet": "static void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))",
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static void isp_fastpost_complete",
            "static void isp_mboxcmd",
            "static u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tNMBCOM\t(sizeof (mbpcnt) / sizeof (mbpcnt[0]))\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic int isp_parse_async;\nstatic void isp_fastpost_complete;\nstatic void isp_mboxcmd;\nstatic u_int8_t mbpcnt[] = {\n\tMAKNIB(1, 1),\t/* 0x00: MBOX_NO_OP */\n\tMAKNIB(5, 5),\t/* 0x01: MBOX_LOAD_RAM */\n\tMAKNIB(2, 0),\t/* 0x02: MBOX_EXEC_FIRMWARE */\n\tMAKNIB(5, 5),\t/* 0x03: MBOX_DUMP_RAM */\n\tMAKNIB(3, 3),\t/* 0x04: MBOX_WRITE_RAM_WORD */\n\tMAKNIB(2, 3),\t/* 0x05: MBOX_READ_RAM_WORD */\n\tMAKNIB(6, 6),\t/* 0x06: MBOX_MAILBOX_REG_TEST */\n\tMAKNIB(2, 3),\t/* 0x07: MBOX_VERIFY_CHECKSUM\t*/\n\tMAKNIB(1, 4),\t/* 0x08: MBOX_ABOUT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x09: */\n\tMAKNIB(0, 0),\t/* 0x0a: */\n\tMAKNIB(0, 0),\t/* 0x0b: */\n\tMAKNIB(0, 0),\t/* 0x0c: */\n\tMAKNIB(0, 0),\t/* 0x0d: */\n\tMAKNIB(1, 2),\t/* 0x0e: MBOX_CHECK_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x0f: */\n\tMAKNIB(5, 5),\t/* 0x10: MBOX_INIT_REQ_QUEUE */\n\tMAKNIB(6, 6),\t/* 0x11: MBOX_INIT_RES_QUEUE */\n\tMAKNIB(4, 4),\t/* 0x12: MBOX_EXECUTE_IOCB */\n\tMAKNIB(2, 2),\t/* 0x13: MBOX_WAKE_UP\t*/\n\tMAKNIB(1, 6),\t/* 0x14: MBOX_STOP_FIRMWARE */\n\tMAKNIB(4, 4),\t/* 0x15: MBOX_ABORT */\n\tMAKNIB(2, 2),\t/* 0x16: MBOX_ABORT_DEVICE */\n\tMAKNIB(3, 3),\t/* 0x17: MBOX_ABORT_TARGET */\n\tMAKNIB(3, 1),\t/* 0x18: MBOX_BUS_RESET */\n\tMAKNIB(2, 3),\t/* 0x19: MBOX_STOP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1a: MBOX_START_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1b: MBOX_SINGLE_STEP_QUEUE */\n\tMAKNIB(2, 3),\t/* 0x1c: MBOX_ABORT_QUEUE */\n\tMAKNIB(2, 4),\t/* 0x1d: MBOX_GET_DEV_QUEUE_STATUS */\n\tMAKNIB(0, 0),\t/* 0x1e: */\n\tMAKNIB(1, 3),\t/* 0x1f: MBOX_GET_FIRMWARE_STATUS */\n\tMAKNIB(1, 4),\t/* 0x20: MBOX_GET_INIT_SCSI_ID, MBOX_GET_LOOP_ID */\n\tMAKNIB(1, 3),\t/* 0x21: MBOX_GET_SELECT_TIMEOUT */\n\tMAKNIB(1, 3),\t/* 0x22: MBOX_GET_RETRY_COUNT\t*/\n\tMAKNIB(1, 2),\t/* 0x23: MBOX_GET_TAG_AGE_LIMIT */\n\tMAKNIB(1, 2),\t/* 0x24: MBOX_GET_CLOCK_RATE */\n\tMAKNIB(1, 2),\t/* 0x25: MBOX_GET_ACT_NEG_STATE */\n\tMAKNIB(1, 2),\t/* 0x26: MBOX_GET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(1, 3),\t/* 0x27: MBOX_GET_PCI_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x28: MBOX_GET_TARGET_PARAMS */\n\tMAKNIB(2, 4),\t/* 0x29: MBOX_GET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x2a: MBOX_GET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x2b: */\n\tMAKNIB(0, 0),\t/* 0x2c: */\n\tMAKNIB(0, 0),\t/* 0x2d: */\n\tMAKNIB(0, 0),\t/* 0x2e: */\n\tMAKNIB(0, 0),\t/* 0x2f: */\n\tMAKNIB(2, 2),\t/* 0x30: MBOX_SET_INIT_SCSI_ID */\n\tMAKNIB(2, 3),\t/* 0x31: MBOX_SET_SELECT_TIMEOUT */\n\tMAKNIB(3, 3),\t/* 0x32: MBOX_SET_RETRY_COUNT\t*/\n\tMAKNIB(2, 2),\t/* 0x33: MBOX_SET_TAG_AGE_LIMIT */\n\tMAKNIB(2, 2),\t/* 0x34: MBOX_SET_CLOCK_RATE */\n\tMAKNIB(2, 2),\t/* 0x35: MBOX_SET_ACT_NEG_STATE */\n\tMAKNIB(2, 2),\t/* 0x36: MBOX_SET_ASYNC_DATA_SETUP_TIME */\n\tMAKNIB(3, 3),\t/* 0x37: MBOX_SET_PCI_CONTROL_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x38: MBOX_SET_TARGET_PARAMS */\n\tMAKNIB(4, 4),\t/* 0x39: MBOX_SET_DEV_QUEUE_PARAMS */\n\tMAKNIB(1, 2),\t/* 0x3a: MBOX_SET_RESET_DELAY_PARAMS */\n\tMAKNIB(0, 0),\t/* 0x3b: */\n\tMAKNIB(0, 0),\t/* 0x3c: */\n\tMAKNIB(0, 0),\t/* 0x3d: */\n\tMAKNIB(0, 0),\t/* 0x3e: */\n\tMAKNIB(0, 0),\t/* 0x3f: */\n\tMAKNIB(1, 2),\t/* 0x40: MBOX_RETURN_BIOS_BLOCK_ADDR */\n\tMAKNIB(6, 1),\t/* 0x41: MBOX_WRITE_FOUR_RAM_WORDS */\n\tMAKNIB(2, 3),\t/* 0x42: MBOX_EXEC_BIOS_IOCB */\n\tMAKNIB(0, 0),\t/* 0x43: */\n\tMAKNIB(0, 0),\t/* 0x44: */\n\tMAKNIB(0, 0),\t/* 0x45: */\n\tMAKNIB(0, 0),\t/* 0x46: */\n\tMAKNIB(0, 0),\t/* 0x47: */\n\tMAKNIB(0, 0),\t/* 0x48: */\n\tMAKNIB(0, 0),\t/* 0x49: */\n\tMAKNIB(2, 1),\t/* 0x4a: MBOX_SET_FIRMWARE_FEATURES */\n\tMAKNIB(1, 2),\t/* 0x4b: MBOX_GET_FIRMWARE_FEATURES */\n\tMAKNIB(0, 0),\t/* 0x4c: */\n\tMAKNIB(0, 0),\t/* 0x4d: */\n\tMAKNIB(0, 0),\t/* 0x4e: */\n\tMAKNIB(0, 0),\t/* 0x4f: */\n\tMAKNIB(0, 0),\t/* 0x50: */\n\tMAKNIB(0, 0),\t/* 0x51: */\n\tMAKNIB(0, 0),\t/* 0x52: */\n\tMAKNIB(0, 0),\t/* 0x53: */\n\tMAKNIB(8, 0),\t/* 0x54: MBOX_EXEC_COMMAND_IOCB_A64 */\n\tMAKNIB(2, 1),\t/* 0x55: MBOX_ENABLE_TARGET_MODE */\n\tMAKNIB(0, 0),\t/* 0x56: */\n\tMAKNIB(0, 0),\t/* 0x57: */\n\tMAKNIB(0, 0),\t/* 0x58: */\n\tMAKNIB(0, 0),\t/* 0x59: */\n\tMAKNIB(0, 0),\t/* 0x5a: */\n\tMAKNIB(0, 0),\t/* 0x5b: */\n\tMAKNIB(0, 0),\t/* 0x5c: */\n\tMAKNIB(0, 0),\t/* 0x5d: */\n\tMAKNIB(0, 0),\t/* 0x5e: */\n\tMAKNIB(0, 0),\t/* 0x5f: */\n\tMAKNIB(8, 6),\t/* 0x60: MBOX_INIT_FIRMWARE */\n\tMAKNIB(0, 0),\t/* 0x61: */\n\tMAKNIB(2, 1),\t/* 0x62: MBOX_INIT_LIP */\n\tMAKNIB(8, 1),\t/* 0x63: MBOX_GET_FC_AL_POSITION_MAP */\n\tMAKNIB(8, 1),\t/* 0x64: MBOX_GET_PORT_DB */\n\tMAKNIB(3, 1),\t/* 0x65: MBOX_CLEAR_ACA */\n\tMAKNIB(3, 1),\t/* 0x66: MBOX_TARGET_RESET */\n\tMAKNIB(3, 1),\t/* 0x67: MBOX_CLEAR_TASK_SET */\n\tMAKNIB(3, 1),\t/* 0x68: MBOX_ABORT_TASK_SET */\n\tMAKNIB(1, 2),\t/* 0x69: MBOX_GET_FW_STATE */\n\tMAKNIB(2, 8),\t/* 0x6a: MBOX_GET_PORT_NAME */\n\tMAKNIB(8, 1),\t/* 0x6b: MBOX_GET_LINK_STATUS */\n\tMAKNIB(4, 4),\t/* 0x6c: MBOX_INIT_LIP_RESET */\n\tMAKNIB(0, 0),\t/* 0x6d: */\n\tMAKNIB(8, 2),\t/* 0x6e: MBOX_SEND_SNS */\n\tMAKNIB(4, 3),\t/* 0x6f: MBOX_FABRIC_LOGIN */\n\tMAKNIB(2, 1),\t/* 0x70: MBOX_SEND_CHANGE_REQUEST */\n\tMAKNIB(2, 1),\t/* 0x71: MBOX_FABRIC_LOGOUT */\n\tMAKNIB(4, 1)\t/* 0x72: MBOX_INIT_LIP_LOGIN */\n};\n\nstatic void\nisp_mboxcmd(isp, mbp)\n\tstruct ispsoftc *isp;\n\tmbreg_t *mbp;\n{\n\tint outparam, inparam;\n\tint loops, dld = 0;\n\tu_int8_t opcode;\n\n\tif (mbp->param[0] == ISP2100_SET_PCI_PARAM) {\n\t\topcode = mbp->param[0] = MBOX_SET_PCI_PARAMETERS;\n\t\tinparam = 4;\n\t\toutparam = 4;\n\t\tgoto command_known;\n\t} else if (mbp->param[0] > NMBCOM) {\n\t\tPRINTF(\"%s: bad command %x\\n\", isp->isp_name, mbp->param[0]);\n\t\treturn;\n\t}\n\n\topcode = mbp->param[0];\n\tinparam = HINIB(mbpcnt[mbp->param[0]]);\n\toutparam =  LONIB(mbpcnt[mbp->param[0]]);\n\n\tif (inparam == 0 && outparam == 0) {\n\t\tPRINTF(\"%s: no parameters for %x\\n\", isp->isp_name,\n\t\t\tmbp->param[0]);\n\t\treturn;\n\t}\n\n\n\t/*\n\t * Check for variants\n\t */\n#ifdef\tISP2100_SCCLUN\n\tif (IS_FC(isp)) {\n\t\tswitch (mbp->param[0]) {\n\t\tcase MBOX_ABORT:\n\t\t\tinparam = 7;\n\t\t\tbreak;\n\t\tcase MBOX_ABORT_DEVICE:\n\t\tcase MBOX_START_QUEUE:\n\t\tcase MBOX_STOP_QUEUE:\n\t\tcase MBOX_SINGLE_STEP_QUEUE:\n\t\tcase MBOX_ABORT_QUEUE:\n\t\tcase MBOX_GET_DEV_QUEUE_STATUS:\n\t\t\tinparam = 3;\n\t\t\tbreak;\n\t\tcase MBOX_BUS_RESET:\n\t\t\tinparam = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\ncommand_known:\n\n\t/*\n\t * Set semaphore on mailbox registers to win any races to acquire them.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 1);\n\n\t/*\n\t * Qlogic Errata for the ISP2100 says that there is a necessary\n\t * debounce between between writing the semaphore register\n\t * and reading a mailbox register. I believe we're okay here.\n\t */\n\n\t/*\n\t * Make sure we can send some words.\n\t * Check to see if there's an async mbox event pending.\n\t */\n\n\tloops = MBOX_DELAY_COUNT;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_HOST_INT) != 0) {\n\t\tif (ISP_READ(isp, BIU_SEMA) & 1) {\n\t\t\tint fph;\n\t\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\t\t/*\n\t\t\t * We have a pending MBOX async event.\n\t\t\t */\n\t\t\tif (mbox & 0x8000) {\n\t\t\t\tfph = isp_parse_async(isp, (int) mbox);\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, fph %d\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, fph));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tif (fph < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (fph > 0) {\n\t\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t\t}\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have a pending MBOX completion? Might be\n\t\t\t * from a previous command. We can't (sometimes)\n\t\t\t * just clear HOST INTERRUPT, so we'll just silently\n\t\t\t * eat this here.\n\t\t\t */\n\t\t\tif (mbox & 0x4000) {\n\t\t\t\tIDPRINTF(5, (\"%s: line %d, mbox 0x%x\\n\",\n\t\t\t\t    isp->isp_name, __LINE__, mbox));\n\t\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\t\tSYS_DELAY(100);\n\t\t\t\tgoto command_known;\n\t\t\t}\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tif (dld++ > 10) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd could not get command \"\n\t\t\t\t    \"started\\n\", isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tgoto command_known;\n\t\t}\n\t}\n\n\t/*\n\t * Write input parameters.\n\t *\n\t * Special case some of the setups for the dual port SCSI cards.\n\t * XXX Eventually will be fixed by converting register write/read\n\t * XXX counts to bitmasks.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tISP_WRITE(isp, INMAILBOX7, mbp->param[7]);\n\t\t\tmbp->param[7] = 0;\n\t\t\tISP_WRITE(isp, INMAILBOX6, mbp->param[6]);\n\t\t\tmbp->param[6] = 0;\n\t\t\tbreak;\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_SELECT_TIMEOUT:\n\t\t\tISP_WRITE(isp, INMAILBOX2, mbp->param[2]);\n\t\t\tmbp->param[2] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (inparam) {\n\tcase 8: ISP_WRITE(isp, INMAILBOX7, mbp->param[7]); mbp->param[7] = 0;\n\tcase 7: ISP_WRITE(isp, INMAILBOX6, mbp->param[6]); mbp->param[6] = 0;\n\tcase 6:\n\t\t/*\n\t\t * The Qlogic 2100 cannot have registers 4 and 5 written to\n\t\t * after initialization or BAD THINGS HAPPEN (tm).\n\t\t */\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX5, mbp->param[5]);\n\t\tmbp->param[5] = 0;\n\tcase 5:\n\t\tif (IS_SCSI(isp) || mbp->param[0] == MBOX_INIT_FIRMWARE)\n\t\t\tISP_WRITE(isp, INMAILBOX4, mbp->param[4]);\n\t\tmbp->param[4] = 0;\n\tcase 4: ISP_WRITE(isp, INMAILBOX3, mbp->param[3]); mbp->param[3] = 0;\n\tcase 3: ISP_WRITE(isp, INMAILBOX2, mbp->param[2]); mbp->param[2] = 0;\n\tcase 2: ISP_WRITE(isp, INMAILBOX1, mbp->param[1]); mbp->param[1] = 0;\n\tcase 1: ISP_WRITE(isp, INMAILBOX0, mbp->param[0]); mbp->param[0] = 0;\n\t}\n\n\t/*\n\t * Clear RISC int condition.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Clear semaphore on mailbox registers so that the Qlogic\n\t * may update outgoing registers.\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Set Host Interrupt condition so that RISC will pick up mailbox regs.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_SET_HOST_INT);\n\n\t/*\n\t * Wait until HOST INT has gone away (meaning that the Qlogic\n\t * has picked up the mailbox command. Wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, HCCR) & HCCR_CMD_CLEAR_RISC_INT) != 0) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #2\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * While the Semaphore registers isn't set, wait for the Qlogic\n\t * to process the mailbox command. Again- wait a long time.\n\t */\n\tloops = MBOX_DELAY_COUNT * 5;\n\twhile ((ISP_READ(isp, BIU_SEMA) & 1) == 0) {\n\t\tSYS_DELAY(100);\n\t\t/*\n\t\t * Wierd- I've seen the case where the semaphore register\n\t\t * isn't getting set- sort of a violation of the protocol..\n\t\t */\n\t\tif (ISP_READ(isp, OUTMAILBOX0) & 0x4000)\n\t\t\tbreak;\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #3\\n\", isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that the MBOX_BUSY has gone away\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox == MBOX_BUSY) {\n\t\t\tif (--loops < 0) {\n\t\t\t\tPRINTF(\"%s: isp_mboxcmd timeout #4\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * We have a pending MBOX async event.\n\t\t */\n\t\tif (mbox & 0x8000) {\n\t\t\tint fph = isp_parse_async(isp, (int) mbox);\n\t\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\t\tif (fph < 0) {\n\t\t\t\treturn;\n\t\t\t} else if (fph > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fph);\n\t\t\t}\n\t\t\tSYS_DELAY(100);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Pick up output parameters. Special case some of the readbacks\n\t * for the dual port SCSI cards.\n\t */\n\tif (IS_DUALBUS(isp)) {\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_RETRY_COUNT:\n\t\tcase MBOX_SET_RETRY_COUNT:\n\t\t\tmbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t\tbreak;\n\t\tcase MBOX_GET_TAG_AGE_LIMIT:\n\t\tcase MBOX_SET_TAG_AGE_LIMIT:\n\t\tcase MBOX_GET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ACT_NEG_STATE:\n\t\tcase MBOX_SET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_ASYNC_DATA_SETUP_TIME:\n\t\tcase MBOX_GET_RESET_DELAY_PARAMS:\n\t\tcase MBOX_SET_RESET_DELAY_PARAMS:\n\t\t\tmbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (IS_2200(isp)) {\n\t\tif (opcode == MBOX_GET_LOOP_ID) {\n\t\t\tmbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\t\t}\n\t}\n\n\tswitch (outparam) {\n\tcase 8: mbp->param[7] = ISP_READ(isp, OUTMAILBOX7);\n\tcase 7: mbp->param[6] = ISP_READ(isp, OUTMAILBOX6);\n\tcase 6: mbp->param[5] = ISP_READ(isp, OUTMAILBOX5);\n\tcase 5: mbp->param[4] = ISP_READ(isp, OUTMAILBOX4);\n\tcase 4: mbp->param[3] = ISP_READ(isp, OUTMAILBOX3);\n\tcase 3: mbp->param[2] = ISP_READ(isp, OUTMAILBOX2);\n\tcase 2: mbp->param[1] = ISP_READ(isp, OUTMAILBOX1);\n\tcase 1: mbp->param[0] = ISP_READ(isp, OUTMAILBOX0);\n\t}\n\n\t/*\n\t * Clear RISC int.\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\n\t/*\n\t * Release semaphore on mailbox registers\n\t */\n\tISP_WRITE(isp, BIU_SEMA, 0);\n\n\t/*\n\t * Just to be chatty here...\n\t */\n\tswitch (mbp->param[0]) {\n\tcase MBOX_COMMAND_COMPLETE:\n\t\tbreak;\n\tcase MBOX_INVALID_COMMAND:\n\t\tIDPRINTF(2, (\"%s: mbox cmd %x failed with INVALID_COMMAND\\n\",\n\t\t    isp->isp_name, opcode));\n\t\tbreak;\n\tcase MBOX_HOST_INTERFACE_ERROR:\n\t\tPRINTF(\"%s: mbox cmd %x failed with HOST_INTERFACE_ERROR\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_TEST_FAILED:\n\t\tPRINTF(\"%s: mbox cmd %x failed with TEST_FAILED\\n\",\n\t\t    isp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_ERROR:\n\t\tif (opcode != MBOX_ABOUT_FIRMWARE)\n\t\t    PRINTF(\"%s: mbox cmd %x failed with COMMAND_ERROR\\n\",\n\t\t\tisp->isp_name, opcode);\n\t\tbreak;\n\tcase MBOX_COMMAND_PARAM_ERROR:\n\t\tswitch (opcode) {\n\t\tcase MBOX_GET_PORT_DB:\n\t\tcase MBOX_GET_PORT_NAME:\n\t\tcase MBOX_GET_DEV_QUEUE_PARAMS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with \"\n\t\t\t    \"COMMAND_PARAM_ERROR\\n\", isp->isp_name, opcode);\n\t\t}\n\t\tbreak;\n\n\tcase MBOX_LOOP_ID_USED:\n\tcase MBOX_PORT_ID_USED:\n\tcase MBOX_ALL_IDS_USED:\n\t\tbreak;\n\n\n\t/*\n\t * Be silent about these...\n\t */\n\tcase ASYNC_PDB_CHANGED:\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_PDB_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LIP_OCCURRED:\n\t\t((fcparam *) isp->isp_param)->isp_lipseq = mbp->param[1];\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_LOOP_UP:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_LIP_RCVD;\n\t\tbreak;\n\n\tcase ASYNC_LOOP_DOWN:\n\tcase ASYNC_LOOP_RESET:\n\t\t((fcparam *) isp->isp_param)->isp_fwstate = FW_CONFIG_WAIT;\n\t\t((fcparam *) isp->isp_param)->isp_loopstate = LOOP_NIL;\n\t\t/* FALLTHROUGH */\n\tcase ASYNC_CHANGE_NOTIFY:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * The expected return of EXEC_FIRMWARE is zero.\n\t\t */\n\t\tif ((opcode == MBOX_EXEC_FIRMWARE && mbp->param[0] != 0) ||\n\t\t    (opcode != MBOX_EXEC_FIRMWARE)) {\n\t\t\tPRINTF(\"%s: mbox cmd %x failed with error %x\\n\",\n\t\t\t\tisp->isp_name, opcode, mbp->param[0]);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Last F/W revision was %d.%d.%d\\n\"",
            "isp->isp_name",
            "isp->isp_romfw_rev[0]",
            "isp->isp_romfw_rev[1]",
            "isp->isp_romfw_rev[2]"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: in 64-Bit PCI slot\\n\"",
            "isp->isp_name"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU2100_CSR"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Board Revision %s, %s F/W Revision %d.%d.%d\\n\"",
            "isp->isp_name",
            "revname",
            "dodnld? \"loaded\" : \"resident\"",
            "mbs.param[1]",
            "mbs.param[2]",
            "mbs.param[3]"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"could not get f/w started (0x%x)\\n\"",
            "mbs.param[0]"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"failed to set clockrate (0x%x)\\n\"",
            "mbs.param[0]"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "3",
            "(\"%s: skipping f/w download\\n\", isp->isp_name)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_dumpregs",
          "args": [
            "isp",
            "\"ram checksum failure\""
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "isp_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "3659-3693",
          "snippet": "static void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_dumpregs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_dumpregs;\n\nstatic void\nisp_dumpregs(isp, msg)\n\tstruct ispsoftc *isp;\n\tconst char *msg;\n{\n\tPRINTF(\"%s: %s\\n\", isp->isp_name, msg);\n\tif (IS_SCSI(isp))\n\t\tPRINTF(\"    biu_conf1=%x\", ISP_READ(isp, BIU_CONF1));\n\telse\n\t\tPRINTF(\"    biu_csr=%x\", ISP_READ(isp, BIU2100_CSR));\n\tPRINTF(\" biu_icr=%x biu_isr=%x biu_sema=%x \", ISP_READ(isp, BIU_ICR),\n\t    ISP_READ(isp, BIU_ISR), ISP_READ(isp, BIU_SEMA));\n\tPRINTF(\"risc_hccr=%x\\n\", ISP_READ(isp, HCCR));\n\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\t\tPRINTF(\"    cdma_conf=%x cdma_sts=%x cdma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, CDMA_CONF), ISP_READ(isp, CDMA_STATUS),\n\t\t\tISP_READ(isp, CDMA_FIFO_STS));\n\t\tPRINTF(\"    ddma_conf=%x ddma_sts=%x ddma_fifostat=%x\\n\",\n\t\t\tISP_READ(isp, DDMA_CONF), ISP_READ(isp, DDMA_STATUS),\n\t\t\tISP_READ(isp, DDMA_FIFO_STS));\n\t\tPRINTF(\"    sxp_int=%x sxp_gross=%x sxp(scsi_ctrl)=%x\\n\",\n\t\t\tISP_READ(isp, SXP_INTERRUPT),\n\t\t\tISP_READ(isp, SXP_GROSS_ERR),\n\t\t\tISP_READ(isp, SXP_PINS_CTRL));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t}\n\tPRINTF(\"    mbox regs: %x %x %x %x %x\\n\",\n\t    ISP_READ(isp, OUTMAILBOX0), ISP_READ(isp, OUTMAILBOX1),\n\t    ISP_READ(isp, OUTMAILBOX2), ISP_READ(isp, OUTMAILBOX3),\n\t    ISP_READ(isp, OUTMAILBOX4));\n\tISP_DUMPREGS(isp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: F/W download failed at word %d\\n\"",
            "isp->isp_name",
            "i"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: MBOX_BUSY never cleared on reset\\n\"",
            "isp->isp_name"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_RESET1",
          "args": [
            "isp"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_RELEASE"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "RISC_MTR2100",
            "0x1212"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "RISC_MTR",
            "0x1212"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "RISC_EMB",
            "DUAL_BANK"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "RISC_MTR",
            "0x1212"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_STEP"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "RISC_MTR",
            "0x1313"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "RISC_MTR"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SETBITS",
          "args": [
            "isp",
            "DDMA_CONF",
            "DMA_ENABLE_BURST"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SETBITS",
          "args": [
            "isp",
            "CDMA_CONF",
            "DMA_ENABLE_BURST"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SETBITS",
          "args": [
            "isp",
            "BIU_CONF1",
            "tmp"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_RESET"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU2100_CSR",
            "0"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_CONF1",
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU2100_CSR"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_ICR"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "RDMA2100_CONTROL",
            "DMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "TDMA2100_CONTROL",
            "DMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "CDMA2100_CONTROL",
            "DMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU2100_CSR",
            "BIU2100_SOFT_RESET"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "DDMA_CONTROL",
            "DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "CDMA_CONTROL",
            "DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\"",
            "isp->isp_name",
            "ISP_READ(isp, OUTMAILBOX0)",
            "ISP_READ(isp, OUTMAILBOX1)",
            "ISP_READ(isp, OUTMAILBOX2)",
            "ISP_READ(isp, OUTMAILBOX3)",
            "ISP_READ(isp, OUTMAILBOX4)",
            "ISP_READ(isp, OUTMAILBOX5)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX5"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX4"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX3"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX2"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX1"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "OUTMAILBOX0"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYS_DELAY",
          "args": [
            "100"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "BIU_ICR",
            "BIU_ICR_SOFT_RESET"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_RESET0",
          "args": [
            "isp"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Ultra Mode Capable\\n\"",
            "isp->isp_name"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "RISC_PSR"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Differential Mode\\n\"",
            "isp->isp_name"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "SXP_PINS_DIFF"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: unknown chip rev. 0x%x- assuming a 1020\\n\"",
            "isp->isp_name",
            "i"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "BIU_CONF0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: unknown mode on bus %d (0x%x)\\n\"",
            "isp->isp_name",
            "1",
            "l"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "m",
            "isp->isp_name",
            "1",
            "\"Single-Ended\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "m",
            "isp->isp_name",
            "1",
            "\"Differential\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "m",
            "isp->isp_name",
            "1",
            "\"LVD\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "SXP_PINS_DIFF|SXP_BANK1_SELECT"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: unknown mode on bus %d (0x%x)\\n\"",
            "isp->isp_name",
            "0",
            "l"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "m",
            "isp->isp_name",
            "0",
            "\"Single-Ended\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "m",
            "isp->isp_name",
            "0",
            "\"Differential\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "m",
            "isp->isp_name",
            "0",
            "\"LVD\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_READ",
          "args": [
            "isp",
            "SXP_PINS_DIFF"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_12160",
          "args": [
            "isp"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_1080",
          "args": [
            "isp"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_1280",
          "args": [
            "isp"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ULTRA2",
          "args": [
            "isp"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_1240",
          "args": [
            "isp"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_PAUSE"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_WRITE",
          "args": [
            "isp",
            "HCCR",
            "HCCR_CMD_RELEASE"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic void isp_fw_state;\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\n\nvoid\nisp_reset(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tint loops, i, dodnld = 1;\n\tchar *revname;\n\n\tisp->isp_state = ISP_NILSTATE;\n\n\t/*\n\t * Basic types (SCSI, FibreChannel and PCI or SBus)\n\t * have been set in the MD code. We figure out more\n\t * here.\n\t */\n\tisp->isp_dblev = DFLT_DBLEVEL;\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\t/*\n\t * Get the current running firmware revision out of the\n\t * chip before we hit it over the head (if this is our\n\t * first time through). Note that we store this as the\n\t * 'ROM' firmware revision- which it may not be. In any\n\t * case, we don't really use this yet, but we may in\n\t * the future.\n\t */\n\tif (isp->isp_touched == 0) {\n\t\t/*\n\t\t * Just in case it was paused...\n\t\t */\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\t/*\n\t\t * If this fails, it probably means we're running\n\t\t * an old prom, if anything at all...\n\t\t */\n\t\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\t\tisp->isp_romfw_rev[0] = mbs.param[1];\n\t\t\tisp->isp_romfw_rev[1] = mbs.param[2];\n\t\t\tisp->isp_romfw_rev[2] = mbs.param[3];\n\t\t}\n\t\tisp->isp_touched = 1;\n\t}\n\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Put the board into PAUSE mode (so we can read the SXP registers).\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\n\tif (IS_FC(isp)) {\n\t\trevname = \"2X00\";\n\t\tswitch (isp->isp_type) {\n\t\tcase ISP_HA_FC_2100:\n\t\t\trevname[1] = '1';\n\t\t\tbreak;\n\t\tcase ISP_HA_FC_2200:\n\t\t\trevname[1] = '2';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_1240(isp)) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\trevname = \"1240\";\n\t\tisp->isp_clock = 60;\n\t\tsdp->isp_ultramode = 1;\n\t\tsdp++;\n\t\tsdp->isp_ultramode = 1;\n\t\t/*\n\t\t * XXX: Should probably do some bus sensing.\n\t\t */\n\t} else if (IS_ULTRA2(isp)) {\n\t\tstatic char *m = \"%s: bus %d is in %s Mode\\n\";\n\t\tu_int16_t l;\n\t\tsdparam *sdp = isp->isp_param;\n\n\t\tisp->isp_clock = 100;\n\n\t\tif (IS_1280(isp))\n\t\t\trevname = \"1280\";\n\t\telse if (IS_1080(isp))\n\t\t\trevname = \"1080\";\n\t\telse if (IS_12160(isp))\n\t\t\trevname = \"12160\";\n\t\telse\n\t\t\trevname = \"<UNKLVD>\";\n\n\t\tl = ISP_READ(isp, SXP_PINS_DIFF) & ISP1080_MODE_MASK;\n\t\tswitch (l) {\n\t\tcase ISP1080_LVD_MODE:\n\t\t\tsdp->isp_lvdmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"LVD\");\n\t\t\tbreak;\n\t\tcase ISP1080_HVD_MODE:\n\t\t\tsdp->isp_diffmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Differential\");\n\t\t\tbreak;\n\t\tcase ISP1080_SE_MODE:\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Single-Ended\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t    isp->isp_name, 0, l);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tsdp++;\n\t\t\tl = ISP_READ(isp, SXP_PINS_DIFF|SXP_BANK1_SELECT);\n\t\t\tl &= ISP1080_MODE_MASK;\n\t\t\tswitch(l) {\n\t\t\tcase ISP1080_LVD_MODE:\n\t\t\t\tsdp->isp_lvdmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"LVD\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_HVD_MODE:\n\t\t\t\tsdp->isp_diffmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Differential\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_SE_MODE:\n\t\t\t\tsdp->isp_ultramode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Single-Ended\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, 1, l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\ti = ISP_READ(isp, BIU_CONF0) & BIU_CONF0_HW_MASK;\n\t\tswitch (i) {\n\t\tdefault:\n\t\t\tPRINTF(\"%s: unknown chip rev. 0x%x- assuming a 1020\\n\",\n\t\t\t    isp->isp_name, i);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\trevname = \"1020\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/*\n\t\t\t * Some 1020A chips are Ultra Capable, but don't\n\t\t\t * run the clock rate up for that unless told to\n\t\t\t * do so by the Ultra Capable bits being set.\n\t\t\t */\n\t\t\trevname = \"1020A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020A;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trevname = \"1040\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trevname = \"1040A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040A;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevname = \"1040B\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040B;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 6: \n\t\t\trevname = \"1040C\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040C;\n\t\t\tisp->isp_clock = 60;\n                        break; \n\t\t}\n\t\t/*\n\t\t * Now, while we're at it, gather info about ultra\n\t\t * and/or differential mode.\n\t\t */\n\t\tif (ISP_READ(isp, SXP_PINS_DIFF) & SXP_PINS_DIFF_MODE) {\n\t\t\tCFGPRINTF(\"%s: Differential Mode\\n\", isp->isp_name);\n\t\t\tsdp->isp_diffmode = 1;\n\t\t} else {\n\t\t\tsdp->isp_diffmode = 0;\n\t\t}\n\t\ti = ISP_READ(isp, RISC_PSR);\n\t\tif (isp->isp_bustype == ISP_BT_SBUS) {\n\t\t\ti &= RISC_PSR_SBUS_ULTRA;\n\t\t} else {\n\t\t\ti &= RISC_PSR_PCI_ULTRA;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tCFGPRINTF(\"%s: Ultra Mode Capable\\n\", isp->isp_name);\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\t/*\n\t\t\t * If we're in Ultra Mode, we have to be 60Mhz clock-\n\t\t\t * even for the SBus version.\n\t\t\t */\n\t\t\tisp->isp_clock = 60;\n\t\t} else {\n\t\t\tsdp->isp_ultramode = 0;\n\t\t\t/*\n\t\t\t * Clock is known. Gronk.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Machine dependent clock (if set) overrides\n\t\t * our generic determinations.\n\t\t */\n\t\tif (isp->isp_mdvec->dv_clock) {\n\t\t\tif (isp->isp_mdvec->dv_clock < isp->isp_clock) {\n\t\t\t\tisp->isp_clock = isp->isp_mdvec->dv_clock;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * Do MD specific pre initialization\n\t */\n\tISP_RESET0(isp);\n\nagain:\n\n\t/*\n\t * Hit the chip over the head with hammer,\n\t * and give the ISP a chance to recover.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n#if\t0\n\t\tPRINTF(\"%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t    isp->isp_name, ISP_READ(isp, OUTMAILBOX0),\n\t\t    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2),\n\t\t    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4),\n\t\t    ISP_READ(isp, OUTMAILBOX5));\n#endif\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\t\tISP_WRITE(isp, DDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\n\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, TDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, RDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t}\n\n\t/*\n\t * Wait for ISP to be ready to go...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!(ISP_READ(isp, BIU2100_CSR) & BIU2100_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tisp_dumpregs(isp, \"chip reset timed out\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_CONF1, 0);\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, 0);\n\t}\n\n\t/*\n\t * Reset RISC Processor\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RESET);\n\tSYS_DELAY(100);\n\n\t/*\n\t * Establish some initial burst rate stuff.\n\t * (only for the 1XX0 boards). This really should\n\t * be done later after fetching from NVRAM.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tu_int16_t tmp = isp->isp_mdvec->dv_conf1;\n\t\t/*\n\t\t * Busted FIFO. Turn off all but burst enables.\n\t\t */\n\t\tif (isp->isp_type == ISP_HA_SCSI_1040A) {\n\t\t\ttmp &= BIU_BURST_ENABLE;\n\t\t}\n\t\tISP_SETBITS(isp, BIU_CONF1, tmp);\n\t\tif (tmp & BIU_BURST_ENABLE) {\n\t\t\tISP_SETBITS(isp, CDMA_CONF, DMA_ENABLE_BURST);\n\t\t\tISP_SETBITS(isp, DDMA_CONF, DMA_ENABLE_BURST);\n\t\t}\n#ifdef\tPTI_CARDS\n\t\tif (((sdparam *) isp->isp_param)->isp_ultramode) {\n\t\t\twhile (ISP_READ(isp, RISC_MTR) != 0x1313) {\n\t\t\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_STEP);\n\t\t\t}\n\t\t} else {\n\t\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n\t\t}\n\t\t/*\n\t\t * PTI specific register\n\t\t */\n\t\tISP_WRITE(isp, RISC_EMB, DUAL_BANK)\n#else\n\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n#endif\n\t} else {\n\t\tISP_WRITE(isp, RISC_MTR2100, 0x1212);\n\t}\n\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE); /* release paused processor */\n\n\t/*\n\t * Do MD specific post initialization\n\t */\n\tISP_RESET1(isp);\n\n\t/*\n\t * Wait for everything to finish firing up...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\twhile (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: MBOX_BUSY never cleared on reset\\n\",\n\t\t\t    isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Up until this point we've done everything by just reading or\n\t * setting registers. From this point on we rely on at least *some*\n\t * kind of firmware running in the card.\n\t */\n\n\t/*\n\t * Do some sanity checking.\n\t */\n\tmbs.param[0] = MBOX_NO_OP;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"NOP test failed\");\n\t\treturn;\n\t}\n\n\tif (IS_SCSI(isp)) {\n\t\tmbs.param[0] = MBOX_MAILBOX_REG_TEST;\n\t\tmbs.param[1] = 0xdead;\n\t\tmbs.param[2] = 0xbeef;\n\t\tmbs.param[3] = 0xffff;\n\t\tmbs.param[4] = 0x1111;\n\t\tmbs.param[5] = 0xa5a5;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp,\n\t\t\t\t\"Mailbox Register test didn't complete\");\n\t\t\treturn;\n\t\t}\n\t\tif (mbs.param[1] != 0xdead || mbs.param[2] != 0xbeef ||\n\t\t    mbs.param[3] != 0xffff || mbs.param[4] != 0x1111 ||\n\t\t    mbs.param[5] != 0xa5a5) {\n\t\t\tisp_dumpregs(isp, \"Register Test Failed\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\t/*\n\t * Download new Firmware, unless requested not to do so.\n\t * This is made slightly trickier in some cases where the\n\t * firmware of the ROM revision is newer than the revision\n\t * compiled into the driver. So, where we used to compare\n\t * versions of our f/w and the ROM f/w, now we just see\n\t * whether we have f/w at all and whether a config flag\n\t * has disabled our download.\n\t */\n\tif ((isp->isp_mdvec->dv_ispfw == NULL) ||\n\t    (isp->isp_confopts & ISP_CFG_NORELOAD)) {\n\t\tdodnld = 0;\n\t}\n\n\tif (dodnld) {\n\t\tu_int16_t fwlen  = isp->isp_mdvec->dv_fwlen;\n\t\tif (fwlen == 0)\n\t\t\tfwlen = isp->isp_mdvec->dv_ispfw[3]; /* usually here */\n\t\tfor (i = 0; i < fwlen; i++) {\n\t\t\tmbs.param[0] = MBOX_WRITE_RAM_WORD;\n\t\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg + i;\n\t\t\tmbs.param[2] = isp->isp_mdvec->dv_ispfw[i];\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: F/W download failed at word %d\\n\",\n\t\t\t\t    isp->isp_name, i);\n\t\t\t\tdodnld = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Verify that it downloaded correctly.\n\t\t */\n\t\tmbs.param[0] = MBOX_VERIFY_CHECKSUM;\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"ram checksum failure\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tIDPRINTF(3, (\"%s: skipping f/w download\\n\", isp->isp_name));\n\t}\n\n\t/*\n\t * Now start it rolling.\n\t *\n\t * If we didn't actually download f/w,\n\t * we still need to (re)start it.\n\t */\n\n\tmbs.param[0] = MBOX_EXEC_FIRMWARE;\n\tif (isp->isp_mdvec->dv_codeorg)\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\telse\n\t\tmbs.param[1] = 0x1000;\n\tisp_mboxcmd(isp, &mbs);\n\n\tif (IS_SCSI(isp)) {\n\t\t/*\n\t\t * Set CLOCK RATE, but only if asked to.\n\t\t */\n\t\tif (isp->isp_clock) {\n\t\t\tmbs.param[0] = MBOX_SET_CLOCK_RATE;\n\t\t\tmbs.param[1] = isp->isp_clock;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"failed to set clockrate (0x%x)\\n\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\t/* but continue */\n\t\t\t}\n\t\t}\n\t}\n\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"could not get f/w started (0x%x)\\n\", mbs.param[0]);\n\t\treturn;\n\t}\n\tCFGPRINTF(\"%s: Board Revision %s, %s F/W Revision %d.%d.%d\\n\",\n\t    isp->isp_name, revname, dodnld? \"loaded\" : \"resident\",\n\t    mbs.param[1], mbs.param[2], mbs.param[3]);\n\tif (IS_FC(isp)) {\n\t\tif (ISP_READ(isp, BIU2100_CSR) & BIU2100_PCI64) {\n\t\t\tCFGPRINTF(\"%s: in 64-Bit PCI slot\\n\", isp->isp_name);\n\t\t}\n\t}\n\n\tisp->isp_fwrev[0] = mbs.param[1];\n\tisp->isp_fwrev[1] = mbs.param[2];\n\tisp->isp_fwrev[2] = mbs.param[3];\n\tif (isp->isp_romfw_rev[0] || isp->isp_romfw_rev[1] ||\n\t    isp->isp_romfw_rev[2]) {\n\t\tCFGPRINTF(\"%s: Last F/W revision was %d.%d.%d\\n\", isp->isp_name,\n\t\t    isp->isp_romfw_rev[0], isp->isp_romfw_rev[1],\n\t\t    isp->isp_romfw_rev[2]);\n\t}\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: could not GET FIRMWARE STATUS\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_maxcmds = mbs.param[2];\n\tCFGPRINTF(\"%s: %d max I/O commands supported\\n\",\n\t    isp->isp_name, mbs.param[2]);\n\tisp_fw_state(isp);\n\n\t/*\n\t * Set up DMA for the request and result mailboxes.\n\t */\n\tif (ISP_MBOXDMASETUP(isp) != 0) {\n\t\tPRINTF(\"%s: can't setup dma mailboxes\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_state = ISP_RESETSTATE;\n}"
  }
]