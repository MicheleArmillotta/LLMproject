[
  {
    "function_name": "rf_CopybackComplete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
    "lines": "416-447",
    "snippet": "static void \nrf_CopybackComplete(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tstruct timeval t, diff;\n\n\tif (!status) {\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\tRF_ASSERT(raidPtr->Layout.map->parityConfig == 'D');\n\t\t\trf_FreeSpareTable(raidPtr);\n\t\t} else {\n\t\t\traidPtr->Disks[desc->spRow][desc->spCol].status = rf_ds_spare;\n\t\t}\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(t);\n\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\tprintf(\"Copyback time was %d.%06d seconds\\n\",\n\t\t    (int) diff.tv_sec, (int) diff.tv_usec);\n\t} else\n\t\tprintf(\"COPYBACK: Failure.\\n\");\n\n\tRF_Free(desc->databuf, rf_RaidAddressToByte(raidPtr, desc->sectPerSU));\n\trf_FreeMCPair(desc->mcpair);\n\tRF_Free(desc, sizeof(*desc));\n\n\trf_copyback_in_progress = 0;\n\trf_ResumeNewRequests(raidPtr);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int     rf_copyback_in_progress;",
      "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ResumeNewRequests",
          "args": [
            "raidPtr"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ResumeNewRequests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "810-834",
          "snippet": "void \nrf_ResumeNewRequests(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_CallbackDesc_t *t, *cb;\n\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Resuming new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended--;\n\tif (raidPtr->accesses_suspended == 0)\n\t\tcb = raidPtr->quiesce_wait_list;\n\telse\n\t\tcb = NULL;\n\traidPtr->quiesce_wait_list = NULL;\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\n\twhile (cb) {\n\t\tt = cb;\n\t\tcb = cb->next;\n\t\t(t->callbackFunc) (t->callbackArg);\n\t\trf_FreeCallbackDesc(t);\n\t}\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_ResumeNewRequests(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_CallbackDesc_t *t, *cb;\n\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Resuming new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended--;\n\tif (raidPtr->accesses_suspended == 0)\n\t\tcb = raidPtr->quiesce_wait_list;\n\telse\n\t\tcb = NULL;\n\traidPtr->quiesce_wait_list = NULL;\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\n\twhile (cb) {\n\t\tt = cb;\n\t\tcb = cb->next;\n\t\t(t->callbackFunc) (t->callbackArg);\n\t\trf_FreeCallbackDesc(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "desc",
            "sizeof(*desc)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeMCPair",
          "args": [
            "desc->mcpair"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeMCPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_mcpair.c",
          "lines": "125-130",
          "snippet": "void \nrf_FreeMCPair(t)\n\tRF_MCPair_t *t;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_mcpair_freelist, t, next, clean_mcpair);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_mcpair_freelist;",
            "static int init_mcpair(RF_MCPair_t *);",
            "static void clean_mcpair(RF_MCPair_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_mcpair_freelist;\nstatic int init_mcpair(RF_MCPair_t *);\nstatic void clean_mcpair(RF_MCPair_t *);\n\nvoid \nrf_FreeMCPair(t)\n\tRF_MCPair_t *t;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_mcpair_freelist, t, next, clean_mcpair);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "desc->databuf",
            "rf_RaidAddressToByte(raidPtr, desc->sectPerSU)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "desc->sectPerSU"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"COPYBACK: Failure.\\n\""
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_TIMEVAL_DIFF",
          "args": [
            "&desc->starttime",
            "&t",
            "&diff"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "t"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeSpareTable",
          "args": [
            "raidPtr"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeSpareTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "730-744",
          "snippet": "void \nrf_FreeSpareTable(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tlong    i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_SpareTableEntry_t **table = info->SpareTable;\n\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Free(table[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t}\n\tRF_Free(table, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\tinfo->SpareTable = (RF_SpareTableEntry_t **) NULL;\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeSpareTable(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tlong    i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_SpareTableEntry_t **table = info->SpareTable;\n\n\tfor (i = 0; i < info->TablesPerSpareRegion; i++) {\n\t\tRF_Free(table[i], info->BlocksPerTable * sizeof(RF_SpareTableEntry_t));\n\t}\n\tRF_Free(table, info->TablesPerSpareRegion * sizeof(RF_SpareTableEntry_t *));\n\tinfo->SpareTable = (RF_SpareTableEntry_t **) NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->Layout.map->parityConfig == 'D'"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint     rf_copyback_in_progress;\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nstatic void \nrf_CopybackComplete(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tstruct timeval t, diff;\n\n\tif (!status) {\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\tRF_ASSERT(raidPtr->Layout.map->parityConfig == 'D');\n\t\t\trf_FreeSpareTable(raidPtr);\n\t\t} else {\n\t\t\traidPtr->Disks[desc->spRow][desc->spCol].status = rf_ds_spare;\n\t\t}\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(t);\n\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\tprintf(\"Copyback time was %d.%06d seconds\\n\",\n\t\t    (int) diff.tv_sec, (int) diff.tv_usec);\n\t} else\n\t\tprintf(\"COPYBACK: Failure.\\n\");\n\n\tRF_Free(desc->databuf, rf_RaidAddressToByte(raidPtr, desc->sectPerSU));\n\trf_FreeMCPair(desc->mcpair);\n\tRF_Free(desc, sizeof(*desc));\n\n\trf_copyback_in_progress = 0;\n\trf_ResumeNewRequests(raidPtr);\n}"
  },
  {
    "function_name": "rf_CopybackWriteDoneProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
    "lines": "403-414",
    "snippet": "static int \nrf_CopybackWriteDoneProc(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tif (status && status != -100) {\n\t\tprintf(\"COPYBACK: copyback write failed.  Aborting.\\n\");\n\t}\n\tdesc->status = status;\n\trf_MCPairWakeupFunc(desc->mcpair);\n\treturn (0);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_MCPairWakeupFunc",
          "args": [
            "desc->mcpair"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "rf_MCPairWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_mcpair.c",
          "lines": "132-148",
          "snippet": "void \nrf_MCPairWakeupFunc(mcpair)\n\tRF_MCPair_t *mcpair;\n{\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 1;\n#if 0\n\tprintf(\"MCPairWakeupFunc called!\\n\");\n#endif\n\twakeup(&(mcpair->flag));/* XXX Does this do anything useful!! GO */\n\t/* XXX Looks like the following is needed to truly get the\n\t * functionality they were looking for here... This could be a\n\t * side-effect of my using a tsleep in the Net- and OpenBSD port\n\t * though... XXX */\n\twakeup(&(mcpair->cond));/* XXX XXX XXX GO */\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_mcpair(RF_MCPair_t *);",
            "static void clean_mcpair(RF_MCPair_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_mcpair(RF_MCPair_t *);\nstatic void clean_mcpair(RF_MCPair_t *);\n\nvoid \nrf_MCPairWakeupFunc(mcpair)\n\tRF_MCPair_t *mcpair;\n{\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 1;\n#if 0\n\tprintf(\"MCPairWakeupFunc called!\\n\");\n#endif\n\twakeup(&(mcpair->flag));/* XXX Does this do anything useful!! GO */\n\t/* XXX Looks like the following is needed to truly get the\n\t * functionality they were looking for here... This could be a\n\t * side-effect of my using a tsleep in the Net- and OpenBSD port\n\t * though... XXX */\n\twakeup(&(mcpair->cond));/* XXX XXX XXX GO */\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"COPYBACK: copyback write failed.  Aborting.\\n\""
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nstatic int \nrf_CopybackWriteDoneProc(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tif (status && status != -100) {\n\t\tprintf(\"COPYBACK: copyback write failed.  Aborting.\\n\");\n\t}\n\tdesc->status = status;\n\trf_MCPairWakeupFunc(desc->mcpair);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_CopybackReadDoneProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
    "lines": "385-397",
    "snippet": "static int \nrf_CopybackReadDoneProc(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tif (status) {\t\t/* invoke the callback with bad status */\n\t\tprintf(\"COPYBACK: copyback read failed.  Aborting.\\n\");\n\t\t(desc->writereq->CompleteFunc) (desc, -100);\n\t} else {\n\t\trf_DiskIOEnqueue(&(desc->raidPtr->Queues[desc->frow][desc->fcol]), desc->writereq, RF_IO_NORMAL_PRIORITY);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&(desc->raidPtr->Queues[desc->frow][desc->fcol])",
            "desc->writereq",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "desc",
            "-100"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"COPYBACK: copyback read failed.  Aborting.\\n\""
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nstatic int \nrf_CopybackReadDoneProc(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tif (status) {\t\t/* invoke the callback with bad status */\n\t\tprintf(\"COPYBACK: copyback read failed.  Aborting.\\n\");\n\t\t(desc->writereq->CompleteFunc) (desc, -100);\n\t} else {\n\t\trf_DiskIOEnqueue(&(desc->raidPtr->Queues[desc->frow][desc->fcol]), desc->writereq, RF_IO_NORMAL_PRIORITY);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_CopybackOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
    "lines": "327-381",
    "snippet": "static void \nrf_CopybackOne(desc, typ, addr, testRow, testCol, testOffs)\n\tRF_CopybackDesc_t *desc;\n\tint     typ;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow;\n\tRF_RowCol_t testCol;\n\tRF_SectorNum_t testOffs;\n{\n\tRF_SectorCount_t sectPerSU = desc->sectPerSU;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RowCol_t spRow = desc->spRow;\n\tRF_RowCol_t spCol = desc->spCol;\n\tRF_SectorNum_t spOffs;\n\n\t/* find the spare spare location for this SU */\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (typ == RF_COPYBACK_DATA)\n\t\t\traidPtr->Layout.map->MapSector(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t\telse\n\t\t\traidPtr->Layout.map->MapParity(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t} else {\n\t\tspOffs = testOffs;\n\t}\n\n\t/* create reqs to read the old location & write the new */\n\tdesc->readreq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, spOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackReadDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->writereq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, testOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackWriteDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->frow = testRow;\n\tdesc->fcol = testCol;\n\n\t/* enqueue the read.  the write will go out as part of the callback on\n\t * the read. at user-level & in the kernel, wait for the read-write\n\t * pair to complete. in the simulator, just return, since everything\n\t * will happen as callbacks */\n\n\tRF_LOCK_MUTEX(desc->mcpair->mutex);\n\tdesc->mcpair->flag = 0;\n\n\trf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq, RF_IO_NORMAL_PRIORITY);\n\n\twhile (!desc->mcpair->flag) {\n\t\tRF_WAIT_MCPAIR(desc->mcpair);\n\t}\n\tRF_UNLOCK_MUTEX(desc->mcpair->mutex);\n\trf_FreeDiskQueueData(desc->readreq);\n\trf_FreeDiskQueueData(desc->writereq);\n\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define RF_COPYBACK_DATA   0"
    ],
    "globals_used": [
      "static void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeDiskQueueData",
          "args": [
            "desc->writereq"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "596-601",
          "snippet": "void \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nvoid \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "desc->mcpair->mutex"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_MCPAIR",
          "args": [
            "desc->mcpair"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&raidPtr->Queues[spRow][spCol]",
            "desc->readreq",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "desc->mcpair->mutex"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "RF_IO_TYPE_WRITE",
            "testOffs",
            "sectPerSU",
            "desc->databuf",
            "0L",
            "0",
            "(int (*) (void *, int)) rf_CopybackWriteDoneProc",
            "desc",
            "NULL",
            "NULL",
            "(void *) raidPtr",
            "RF_DISKQUEUE_DATA_FLAGS_NONE",
            "NULL"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidPtr->Layout.map->MapParity",
          "args": [
            "raidPtr",
            "addr",
            "&spRow",
            "&spCol",
            "&spOffs",
            "RF_REMAP"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidPtr->Layout.map->MapSector",
          "args": [
            "raidPtr",
            "addr",
            "&spRow",
            "&spCol",
            "&spOffs",
            "RF_REMAP"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\n#define RF_COPYBACK_DATA   0\n\nstatic void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);\n\nstatic void \nrf_CopybackOne(desc, typ, addr, testRow, testCol, testOffs)\n\tRF_CopybackDesc_t *desc;\n\tint     typ;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow;\n\tRF_RowCol_t testCol;\n\tRF_SectorNum_t testOffs;\n{\n\tRF_SectorCount_t sectPerSU = desc->sectPerSU;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RowCol_t spRow = desc->spRow;\n\tRF_RowCol_t spCol = desc->spCol;\n\tRF_SectorNum_t spOffs;\n\n\t/* find the spare spare location for this SU */\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (typ == RF_COPYBACK_DATA)\n\t\t\traidPtr->Layout.map->MapSector(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t\telse\n\t\t\traidPtr->Layout.map->MapParity(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t} else {\n\t\tspOffs = testOffs;\n\t}\n\n\t/* create reqs to read the old location & write the new */\n\tdesc->readreq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, spOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackReadDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->writereq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, testOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackWriteDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->frow = testRow;\n\tdesc->fcol = testCol;\n\n\t/* enqueue the read.  the write will go out as part of the callback on\n\t * the read. at user-level & in the kernel, wait for the read-write\n\t * pair to complete. in the simulator, just return, since everything\n\t * will happen as callbacks */\n\n\tRF_LOCK_MUTEX(desc->mcpair->mutex);\n\tdesc->mcpair->flag = 0;\n\n\trf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq, RF_IO_NORMAL_PRIORITY);\n\n\twhile (!desc->mcpair->flag) {\n\t\tRF_WAIT_MCPAIR(desc->mcpair);\n\t}\n\tRF_UNLOCK_MUTEX(desc->mcpair->mutex);\n\trf_FreeDiskQueueData(desc->readreq);\n\trf_FreeDiskQueueData(desc->writereq);\n\n}"
  },
  {
    "function_name": "rf_ContinueCopyback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
    "lines": "258-323",
    "snippet": "void \nrf_ContinueCopyback(desc)\n\tRF_CopybackDesc_t *desc;\n{\n\tRF_SectorNum_t testOffs, stripeAddr;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow, testCol;\n\tint     old_pctg, new_pctg, done;\n\tstruct timeval t, diff;\n\n\told_pctg = (-1);\n\twhile (1) {\n\t\tstripeAddr = desc->stripeAddr;\n\t\tdesc->raidPtr->copyback_stripes_done = stripeAddr\n\t\t\t/ desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\told_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t}\n\t\tdesc->stripeAddr += desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\tnew_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t\tif (new_pctg != old_pctg) {\n\t\t\t\tRF_GETTIME(t);\n\t\t\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\t\t\tprintf(\"%d %d.%06d\\n\", new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);\n\t\t\t}\n\t\t}\n\t\tif (stripeAddr >= raidPtr->totalSectors) {\n\t\t\trf_CopybackComplete(desc, 0);\n\t\t\treturn;\n\t\t}\n\t\t/* walk through the current stripe, su-by-su */\n\t\tfor (done = 0, addr = stripeAddr; addr < stripeAddr + desc->sectPerStripe; addr += desc->sectPerSU) {\n\n\t\t\t/* map the SU, disallowing remap to spare space */\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, addr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_DATA, addr, testRow, testCol, testOffs);\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!done) {\n\t\t\t/* we didn't find the failed disk in the data part.\n\t\t\t * check parity. */\n\n\t\t\t/* map the parity for this stripe, disallowing remap\n\t\t\t * to spare space */\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_PARITY, stripeAddr, testRow, testCol, testOffs);\n\t\t\t}\n\t\t}\n\t\t/* check to see if the last read/write pair failed */\n\t\tif (desc->status) {\n\t\t\trf_CopybackComplete(desc, 1);\n\t\t\treturn;\n\t\t}\n\t\t/* we didn't find any units to copy back in this stripe.\n\t\t * Continue with the next one */\n\t}\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define RF_COPYBACK_PARITY 1",
      "#define RF_COPYBACK_DATA   0"
    ],
    "globals_used": [
      "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);",
      "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CopybackComplete",
          "args": [
            "desc",
            "1"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CopybackComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
          "lines": "416-447",
          "snippet": "static void \nrf_CopybackComplete(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tstruct timeval t, diff;\n\n\tif (!status) {\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\tRF_ASSERT(raidPtr->Layout.map->parityConfig == 'D');\n\t\t\trf_FreeSpareTable(raidPtr);\n\t\t} else {\n\t\t\traidPtr->Disks[desc->spRow][desc->spCol].status = rf_ds_spare;\n\t\t}\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(t);\n\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\tprintf(\"Copyback time was %d.%06d seconds\\n\",\n\t\t    (int) diff.tv_sec, (int) diff.tv_usec);\n\t} else\n\t\tprintf(\"COPYBACK: Failure.\\n\");\n\n\tRF_Free(desc->databuf, rf_RaidAddressToByte(raidPtr, desc->sectPerSU));\n\trf_FreeMCPair(desc->mcpair);\n\tRF_Free(desc, sizeof(*desc));\n\n\trf_copyback_in_progress = 0;\n\trf_ResumeNewRequests(raidPtr);\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int     rf_copyback_in_progress;",
            "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
            "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
            "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint     rf_copyback_in_progress;\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nstatic void \nrf_CopybackComplete(desc, status)\n\tRF_CopybackDesc_t *desc;\n\tint     status;\n{\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tstruct timeval t, diff;\n\n\tif (!status) {\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\tRF_ASSERT(raidPtr->Layout.map->parityConfig == 'D');\n\t\t\trf_FreeSpareTable(raidPtr);\n\t\t} else {\n\t\t\traidPtr->Disks[desc->spRow][desc->spCol].status = rf_ds_spare;\n\t\t}\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(t);\n\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\tprintf(\"Copyback time was %d.%06d seconds\\n\",\n\t\t    (int) diff.tv_sec, (int) diff.tv_usec);\n\t} else\n\t\tprintf(\"COPYBACK: Failure.\\n\");\n\n\tRF_Free(desc->databuf, rf_RaidAddressToByte(raidPtr, desc->sectPerSU));\n\trf_FreeMCPair(desc->mcpair);\n\tRF_Free(desc, sizeof(*desc));\n\n\trf_copyback_in_progress = 0;\n\trf_ResumeNewRequests(raidPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CopybackOne",
          "args": [
            "desc",
            "RF_COPYBACK_PARITY",
            "stripeAddr",
            "testRow",
            "testCol",
            "testOffs"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CopybackOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
          "lines": "327-381",
          "snippet": "static void \nrf_CopybackOne(desc, typ, addr, testRow, testCol, testOffs)\n\tRF_CopybackDesc_t *desc;\n\tint     typ;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow;\n\tRF_RowCol_t testCol;\n\tRF_SectorNum_t testOffs;\n{\n\tRF_SectorCount_t sectPerSU = desc->sectPerSU;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RowCol_t spRow = desc->spRow;\n\tRF_RowCol_t spCol = desc->spCol;\n\tRF_SectorNum_t spOffs;\n\n\t/* find the spare spare location for this SU */\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (typ == RF_COPYBACK_DATA)\n\t\t\traidPtr->Layout.map->MapSector(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t\telse\n\t\t\traidPtr->Layout.map->MapParity(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t} else {\n\t\tspOffs = testOffs;\n\t}\n\n\t/* create reqs to read the old location & write the new */\n\tdesc->readreq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, spOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackReadDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->writereq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, testOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackWriteDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->frow = testRow;\n\tdesc->fcol = testCol;\n\n\t/* enqueue the read.  the write will go out as part of the callback on\n\t * the read. at user-level & in the kernel, wait for the read-write\n\t * pair to complete. in the simulator, just return, since everything\n\t * will happen as callbacks */\n\n\tRF_LOCK_MUTEX(desc->mcpair->mutex);\n\tdesc->mcpair->flag = 0;\n\n\trf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq, RF_IO_NORMAL_PRIORITY);\n\n\twhile (!desc->mcpair->flag) {\n\t\tRF_WAIT_MCPAIR(desc->mcpair);\n\t}\n\tRF_UNLOCK_MUTEX(desc->mcpair->mutex);\n\trf_FreeDiskQueueData(desc->readreq);\n\trf_FreeDiskQueueData(desc->writereq);\n\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define RF_COPYBACK_DATA   0"
          ],
          "globals_used": [
            "static void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\n#define RF_COPYBACK_DATA   0\n\nstatic void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);\n\nstatic void \nrf_CopybackOne(desc, typ, addr, testRow, testCol, testOffs)\n\tRF_CopybackDesc_t *desc;\n\tint     typ;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow;\n\tRF_RowCol_t testCol;\n\tRF_SectorNum_t testOffs;\n{\n\tRF_SectorCount_t sectPerSU = desc->sectPerSU;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RowCol_t spRow = desc->spRow;\n\tRF_RowCol_t spCol = desc->spCol;\n\tRF_SectorNum_t spOffs;\n\n\t/* find the spare spare location for this SU */\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (typ == RF_COPYBACK_DATA)\n\t\t\traidPtr->Layout.map->MapSector(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t\telse\n\t\t\traidPtr->Layout.map->MapParity(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);\n\t} else {\n\t\tspOffs = testOffs;\n\t}\n\n\t/* create reqs to read the old location & write the new */\n\tdesc->readreq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, spOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackReadDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->writereq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, testOffs,\n\t    sectPerSU, desc->databuf, 0L, 0,\n\t    (int (*) (void *, int)) rf_CopybackWriteDoneProc, desc,\n\t    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);\n\tdesc->frow = testRow;\n\tdesc->fcol = testCol;\n\n\t/* enqueue the read.  the write will go out as part of the callback on\n\t * the read. at user-level & in the kernel, wait for the read-write\n\t * pair to complete. in the simulator, just return, since everything\n\t * will happen as callbacks */\n\n\tRF_LOCK_MUTEX(desc->mcpair->mutex);\n\tdesc->mcpair->flag = 0;\n\n\trf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq, RF_IO_NORMAL_PRIORITY);\n\n\twhile (!desc->mcpair->flag) {\n\t\tRF_WAIT_MCPAIR(desc->mcpair);\n\t}\n\tRF_UNLOCK_MUTEX(desc->mcpair->mutex);\n\trf_FreeDiskQueueData(desc->readreq);\n\trf_FreeDiskQueueData(desc->writereq);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "stripeAddr",
            "&testRow",
            "&testCol",
            "&testOffs",
            "RF_DONT_REMAP"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "addr",
            "&testRow",
            "&testCol",
            "&testOffs",
            "RF_DONT_REMAP"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d %d.%06d\\n\"",
            "new_pctg",
            "(int) diff.tv_sec",
            "(int) diff.tv_usec"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_TIMEVAL_DIFF",
          "args": [
            "&desc->starttime",
            "&t",
            "&diff"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "t"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\n#define RF_COPYBACK_PARITY 1\n#define RF_COPYBACK_DATA   0\n\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nvoid \nrf_ContinueCopyback(desc)\n\tRF_CopybackDesc_t *desc;\n{\n\tRF_SectorNum_t testOffs, stripeAddr;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow, testCol;\n\tint     old_pctg, new_pctg, done;\n\tstruct timeval t, diff;\n\n\told_pctg = (-1);\n\twhile (1) {\n\t\tstripeAddr = desc->stripeAddr;\n\t\tdesc->raidPtr->copyback_stripes_done = stripeAddr\n\t\t\t/ desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\told_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t}\n\t\tdesc->stripeAddr += desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\tnew_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t\tif (new_pctg != old_pctg) {\n\t\t\t\tRF_GETTIME(t);\n\t\t\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\t\t\tprintf(\"%d %d.%06d\\n\", new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);\n\t\t\t}\n\t\t}\n\t\tif (stripeAddr >= raidPtr->totalSectors) {\n\t\t\trf_CopybackComplete(desc, 0);\n\t\t\treturn;\n\t\t}\n\t\t/* walk through the current stripe, su-by-su */\n\t\tfor (done = 0, addr = stripeAddr; addr < stripeAddr + desc->sectPerStripe; addr += desc->sectPerSU) {\n\n\t\t\t/* map the SU, disallowing remap to spare space */\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, addr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_DATA, addr, testRow, testCol, testOffs);\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!done) {\n\t\t\t/* we didn't find the failed disk in the data part.\n\t\t\t * check parity. */\n\n\t\t\t/* map the parity for this stripe, disallowing remap\n\t\t\t * to spare space */\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_PARITY, stripeAddr, testRow, testCol, testOffs);\n\t\t\t}\n\t\t}\n\t\t/* check to see if the last read/write pair failed */\n\t\tif (desc->status) {\n\t\t\trf_CopybackComplete(desc, 1);\n\t\t\treturn;\n\t\t}\n\t\t/* we didn't find any units to copy back in this stripe.\n\t\t * Continue with the next one */\n\t}\n}"
  },
  {
    "function_name": "rf_CopybackReconstructedData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
    "lines": "88-251",
    "snippet": "void \nrf_CopybackReconstructedData(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint     done, retcode;\n\tRF_CopybackDesc_t *desc;\n\tRF_RowCol_t frow, fcol;\n\tRF_RaidDisk_t *badDisk;\n\tchar   *databuf;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\n\tdone = 0;\n\tfcol = 0;\n\tfor (frow = 0; frow < raidPtr->numRow; frow++) {\n\t\tfor (fcol = 0; fcol < raidPtr->numCol; fcol++) {\n\t\t\tif (raidPtr->Disks[frow][fcol].status == rf_ds_dist_spared\n\t\t\t    || raidPtr->Disks[frow][fcol].status == rf_ds_spared) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (done)\n\t\t\tbreak;\n\t}\n\n\tif (frow == raidPtr->numRow) {\n\t\tprintf(\"COPYBACK:  no disks need copyback\\n\");\n\t\treturn;\n\t}\n\tbadDisk = &raidPtr->Disks[frow][fcol];\n\n\tproc = raidPtr->engine_thread;\n\n\t/* This device may have been opened successfully the first time. Close\n\t * it before trying to open it again.. */\n\n\tif (raidPtr->raid_cinfo[frow][fcol].ci_vp != NULL) {\n\t\tprintf(\"Closed the open device: %s\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname);\n\t\tVOP_UNLOCK(raidPtr->raid_cinfo[frow][fcol].ci_vp, 0, proc);\n\t\t(void) vn_close(raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t    FREAD | FWRITE, proc->p_ucred, proc);\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = NULL;\n\t}\n\tprintf(\"About to (re-)open the device: %s\\n\",\n\t    raidPtr->Disks[frow][fcol].devname);\n\n\tretcode = raidlookup(raidPtr->Disks[frow][fcol].devname, proc, &vp);\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: raidlookup on device: %s failed: %d!\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname, retcode);\n\n\t\t/* XXX the component isn't responding properly... must be\n\t\t * still dead :-( */\n\t\treturn;\n\n\t} else {\n\n\t\t/* Ok, so we can at least do a lookup... How about actually\n\t\t * getting a vp for it? */\n\n\t\tif ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tretcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (retcode) {\n\t\t\treturn;\n\t\t}\n\t\traidPtr->Disks[frow][fcol].blockSize = dpart.disklab->d_secsize;\n\n\t\traidPtr->Disks[frow][fcol].numBlocks = dpart.part->p_size -\n\t\t    rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = vp;\n\t\traidPtr->raid_cinfo[frow][fcol].ci_dev = va.va_rdev;\n\n\t\traidPtr->Disks[frow][fcol].dev = va.va_rdev;\t/* XXX or the above? */\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\traidPtr->Disks[frow][fcol].numBlocks =\n\t\t    raidPtr->Disks[frow][fcol].numBlocks *\n\t\t    rf_sizePercentage / 100;\n\t}\n#if 0\n\t/* This is the way it was done before the CAM stuff was removed */\n\n\tif (rf_extract_ids(badDisk->devname, &bus, &targ, &lun)) {\n\t\tprintf(\"COPYBACK: unable to extract bus, target, lun from devname %s\\n\",\n\t\t    badDisk->devname);\n\t\treturn;\n\t}\n\t/* TUR the disk that's marked as bad to be sure that it's actually\n\t * alive */\n\trf_SCSI_AllocTUR(&tur_op);\n\tretcode = rf_SCSI_DoTUR(tur_op, bus, targ, lun, badDisk->dev);\n\trf_SCSI_FreeDiskOp(tur_op, 0);\n#endif\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: target disk failed TUR\\n\");\n\t\treturn;\n\t}\n\t/* get a buffer to hold one SU  */\n\tRF_Malloc(databuf, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (char *));\n\n\t/* create a descriptor */\n\tRF_Malloc(desc, sizeof(*desc), (RF_CopybackDesc_t *));\n\tdesc->raidPtr = raidPtr;\n\tdesc->status = 0;\n\tdesc->frow = frow;\n\tdesc->fcol = fcol;\n\tdesc->spRow = badDisk->spareRow;\n\tdesc->spCol = badDisk->spareCol;\n\tdesc->stripeAddr = 0;\n\tdesc->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tdesc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.numDataCol;\n\tdesc->databuf = databuf;\n\tdesc->mcpair = rf_AllocMCPair();\n\n\tprintf(\"COPYBACK: Quiescing the array\\n\");\n\t/* quiesce the array, since we don't want to code support for user\n\t * accs here */\n\trf_SuspendNewRequestsAndWait(raidPtr);\n\n\t/* adjust state of the array and of the disks */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->Disks[desc->frow][desc->fcol].status = rf_ds_optimal;\n\traidPtr->status[desc->frow] = rf_rs_optimal;\n\trf_copyback_in_progress = 1;\t/* debug only */\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\tprintf(\"COPYBACK: Beginning\\n\");\n\tRF_GETTIME(desc->starttime);\n\trf_ContinueCopyback(desc);\n\n\t/* Data has been restored.  Fix up the component label. */\n\t/* Don't actually need the read here.. */\n\traidread_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t  raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t  &c_label);\n\t\t\n\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\tc_label.mod_counter = raidPtr->mod_counter;\n\tc_label.serial_number = raidPtr->serial_number;\n\tc_label.row = frow;\n\tc_label.column = fcol;\n\tc_label.num_rows = raidPtr->numRow;\n\tc_label.num_columns = raidPtr->numCol;\n\tc_label.clean = RF_RAID_DIRTY;\n\tc_label.status = rf_ds_optimal;\n\t\n\traidwrite_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t   raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t   &c_label);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int     rf_copyback_in_progress;",
      "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
      "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "raidPtr->raid_cinfo[frow][fcol].ci_dev",
            "raidPtr->raid_cinfo[frow][fcol].ci_vp",
            "&c_label"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1985-2017",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nstatic void KernelWakeupFunc(struct buf * bp);\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "raidPtr->raid_cinfo[frow][fcol].ci_dev",
            "raidPtr->raid_cinfo[frow][fcol].ci_vp",
            "&c_label"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1935-1983",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nstatic void KernelWakeupFunc(struct buf * bp);\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ContinueCopyback",
          "args": [
            "desc"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ContinueCopyback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
          "lines": "258-323",
          "snippet": "void \nrf_ContinueCopyback(desc)\n\tRF_CopybackDesc_t *desc;\n{\n\tRF_SectorNum_t testOffs, stripeAddr;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow, testCol;\n\tint     old_pctg, new_pctg, done;\n\tstruct timeval t, diff;\n\n\told_pctg = (-1);\n\twhile (1) {\n\t\tstripeAddr = desc->stripeAddr;\n\t\tdesc->raidPtr->copyback_stripes_done = stripeAddr\n\t\t\t/ desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\told_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t}\n\t\tdesc->stripeAddr += desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\tnew_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t\tif (new_pctg != old_pctg) {\n\t\t\t\tRF_GETTIME(t);\n\t\t\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\t\t\tprintf(\"%d %d.%06d\\n\", new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);\n\t\t\t}\n\t\t}\n\t\tif (stripeAddr >= raidPtr->totalSectors) {\n\t\t\trf_CopybackComplete(desc, 0);\n\t\t\treturn;\n\t\t}\n\t\t/* walk through the current stripe, su-by-su */\n\t\tfor (done = 0, addr = stripeAddr; addr < stripeAddr + desc->sectPerStripe; addr += desc->sectPerSU) {\n\n\t\t\t/* map the SU, disallowing remap to spare space */\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, addr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_DATA, addr, testRow, testCol, testOffs);\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!done) {\n\t\t\t/* we didn't find the failed disk in the data part.\n\t\t\t * check parity. */\n\n\t\t\t/* map the parity for this stripe, disallowing remap\n\t\t\t * to spare space */\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_PARITY, stripeAddr, testRow, testCol, testOffs);\n\t\t\t}\n\t\t}\n\t\t/* check to see if the last read/write pair failed */\n\t\tif (desc->status) {\n\t\t\trf_CopybackComplete(desc, 1);\n\t\t\treturn;\n\t\t}\n\t\t/* we didn't find any units to copy back in this stripe.\n\t\t * Continue with the next one */\n\t}\n}",
          "includes": [
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define RF_COPYBACK_PARITY 1",
            "#define RF_COPYBACK_DATA   0"
          ],
          "globals_used": [
            "static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);",
            "static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);",
            "static void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);",
            "static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\n#define RF_COPYBACK_PARITY 1\n#define RF_COPYBACK_DATA   0\n\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,\n\t\t\t   RF_RaidAddr_t addr, RF_RowCol_t testRow, \n\t\t\t   RF_RowCol_t testCol,\n    RF_SectorNum_t testOffs);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nvoid \nrf_ContinueCopyback(desc)\n\tRF_CopybackDesc_t *desc;\n{\n\tRF_SectorNum_t testOffs, stripeAddr;\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\tRF_RaidAddr_t addr;\n\tRF_RowCol_t testRow, testCol;\n\tint     old_pctg, new_pctg, done;\n\tstruct timeval t, diff;\n\n\told_pctg = (-1);\n\twhile (1) {\n\t\tstripeAddr = desc->stripeAddr;\n\t\tdesc->raidPtr->copyback_stripes_done = stripeAddr\n\t\t\t/ desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\told_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t}\n\t\tdesc->stripeAddr += desc->sectPerStripe;\n\t\tif (rf_prReconSched) {\n\t\t\tnew_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;\n\t\t\tif (new_pctg != old_pctg) {\n\t\t\t\tRF_GETTIME(t);\n\t\t\t\tRF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);\n\t\t\t\tprintf(\"%d %d.%06d\\n\", new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);\n\t\t\t}\n\t\t}\n\t\tif (stripeAddr >= raidPtr->totalSectors) {\n\t\t\trf_CopybackComplete(desc, 0);\n\t\t\treturn;\n\t\t}\n\t\t/* walk through the current stripe, su-by-su */\n\t\tfor (done = 0, addr = stripeAddr; addr < stripeAddr + desc->sectPerStripe; addr += desc->sectPerSU) {\n\n\t\t\t/* map the SU, disallowing remap to spare space */\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, addr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_DATA, addr, testRow, testCol, testOffs);\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!done) {\n\t\t\t/* we didn't find the failed disk in the data part.\n\t\t\t * check parity. */\n\n\t\t\t/* map the parity for this stripe, disallowing remap\n\t\t\t * to spare space */\n\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);\n\n\t\t\tif (testRow == desc->frow && testCol == desc->fcol) {\n\t\t\t\trf_CopybackOne(desc, RF_COPYBACK_PARITY, stripeAddr, testRow, testCol, testOffs);\n\t\t\t}\n\t\t}\n\t\t/* check to see if the last read/write pair failed */\n\t\tif (desc->status) {\n\t\t\trf_CopybackComplete(desc, 1);\n\t\t\treturn;\n\t\t}\n\t\t/* we didn't find any units to copy back in this stripe.\n\t\t * Continue with the next one */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "desc->starttime"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"COPYBACK: Beginning\\n\""
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_SuspendNewRequestsAndWait",
          "args": [
            "raidPtr"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SuspendNewRequestsAndWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "785-808",
          "snippet": "int \nrf_SuspendNewRequestsAndWait(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Suspending new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended++;\n\traidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\traidPtr->access_suspend_release = 0;\n\t\twhile (!raidPtr->access_suspend_release) {\n\t\t\tprintf(\"Suspending: Waiting for Quiesence\\n\");\n\t\t\tWAIT_FOR_QUIESCENCE(raidPtr);\n\t\t\traidPtr->waiting_for_quiescence = 0;\n\t\t}\n\t}\n\tprintf(\"Quiesence reached..\\n\");\n\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\treturn (raidPtr->waiting_for_quiescence);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_SuspendNewRequestsAndWait(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Suspending new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended++;\n\traidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\traidPtr->access_suspend_release = 0;\n\t\twhile (!raidPtr->access_suspend_release) {\n\t\t\tprintf(\"Suspending: Waiting for Quiesence\\n\");\n\t\t\tWAIT_FOR_QUIESCENCE(raidPtr);\n\t\t\traidPtr->waiting_for_quiescence = 0;\n\t\t}\n\t}\n\tprintf(\"Quiesence reached..\\n\");\n\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\treturn (raidPtr->waiting_for_quiescence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_AllocMCPair",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocMCPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_mcpair.c",
          "lines": "112-123",
          "snippet": "RF_MCPair_t *\nrf_AllocMCPair()\n{\n\tRF_MCPair_t *t;\n\n\tRF_FREELIST_GET_INIT(rf_mcpair_freelist, t, next, (RF_MCPair_t *), init_mcpair);\n\tif (t) {\n\t\tt->flag = 0;\n\t\tt->next = NULL;\n\t}\n\treturn (t);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_mcpair_freelist;",
            "static int init_mcpair(RF_MCPair_t *);",
            "static void clean_mcpair(RF_MCPair_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_mcpair_freelist;\nstatic int init_mcpair(RF_MCPair_t *);\nstatic void clean_mcpair(RF_MCPair_t *);\n\nRF_MCPair_t *\nrf_AllocMCPair()\n{\n\tRF_MCPair_t *t;\n\n\tRF_FREELIST_GET_INIT(rf_mcpair_freelist, t, next, (RF_MCPair_t *), init_mcpair);\n\tif (t) {\n\t\tt->flag = 0;\n\t\tt->next = NULL;\n\t}\n\treturn (t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "desc",
            "sizeof(*desc)",
            "(RF_CopybackDesc_t *)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "databuf",
            "rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit)",
            "(char *)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "raidPtr->Layout.sectorsPerStripeUnit"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_SCSI_FreeDiskOp",
          "args": [
            "tur_op",
            "0"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_SCSI_DoTUR",
          "args": [
            "tur_op",
            "bus",
            "targ",
            "lun",
            "badDisk->dev"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_SCSI_AllocTUR",
          "args": [
            "&tur_op"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_extract_ids",
          "args": [
            "badDisk->devname",
            "&bus",
            "&targ",
            "&lun"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_IOCTL",
          "args": [
            "vp",
            "DIOCGPART",
            "(caddr_t) & dpart",
            "FREAD",
            "proc->p_ucred",
            "proc"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_GETATTR",
          "args": [
            "vp",
            "&va",
            "proc->p_ucred",
            "proc"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidlookup",
          "args": [
            "raidPtr->Disks[frow][fcol].devname",
            "proc",
            "&vp"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "raidlookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1831-1869",
          "snippet": "int\nraidlookup(path, p, vpp)\n\tchar   *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint     error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD | FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0);\n\t*vpp = vp;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint\nraidlookup(path, p, vpp)\n\tchar   *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint     error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD | FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0);\n\t*vpp = vp;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "raidPtr->raid_cinfo[frow][fcol].ci_vp",
            "FREAD | FWRITE",
            "proc->p_ucred",
            "proc"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "raidPtr->raid_cinfo[frow][fcol].ci_vp",
            "0",
            "proc"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint     rf_copyback_in_progress;\nstatic int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);\nstatic void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);\n\nvoid \nrf_CopybackReconstructedData(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint     done, retcode;\n\tRF_CopybackDesc_t *desc;\n\tRF_RowCol_t frow, fcol;\n\tRF_RaidDisk_t *badDisk;\n\tchar   *databuf;\n\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\n\tdone = 0;\n\tfcol = 0;\n\tfor (frow = 0; frow < raidPtr->numRow; frow++) {\n\t\tfor (fcol = 0; fcol < raidPtr->numCol; fcol++) {\n\t\t\tif (raidPtr->Disks[frow][fcol].status == rf_ds_dist_spared\n\t\t\t    || raidPtr->Disks[frow][fcol].status == rf_ds_spared) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (done)\n\t\t\tbreak;\n\t}\n\n\tif (frow == raidPtr->numRow) {\n\t\tprintf(\"COPYBACK:  no disks need copyback\\n\");\n\t\treturn;\n\t}\n\tbadDisk = &raidPtr->Disks[frow][fcol];\n\n\tproc = raidPtr->engine_thread;\n\n\t/* This device may have been opened successfully the first time. Close\n\t * it before trying to open it again.. */\n\n\tif (raidPtr->raid_cinfo[frow][fcol].ci_vp != NULL) {\n\t\tprintf(\"Closed the open device: %s\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname);\n\t\tVOP_UNLOCK(raidPtr->raid_cinfo[frow][fcol].ci_vp, 0, proc);\n\t\t(void) vn_close(raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t    FREAD | FWRITE, proc->p_ucred, proc);\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = NULL;\n\t}\n\tprintf(\"About to (re-)open the device: %s\\n\",\n\t    raidPtr->Disks[frow][fcol].devname);\n\n\tretcode = raidlookup(raidPtr->Disks[frow][fcol].devname, proc, &vp);\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: raidlookup on device: %s failed: %d!\\n\",\n\t\t    raidPtr->Disks[frow][fcol].devname, retcode);\n\n\t\t/* XXX the component isn't responding properly... must be\n\t\t * still dead :-( */\n\t\treturn;\n\n\t} else {\n\n\t\t/* Ok, so we can at least do a lookup... How about actually\n\t\t * getting a vp for it? */\n\n\t\tif ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tretcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t    FREAD, proc->p_ucred, proc);\n\t\tif (retcode) {\n\t\t\treturn;\n\t\t}\n\t\traidPtr->Disks[frow][fcol].blockSize = dpart.disklab->d_secsize;\n\n\t\traidPtr->Disks[frow][fcol].numBlocks = dpart.part->p_size -\n\t\t    rf_protectedSectors;\n\n\t\traidPtr->raid_cinfo[frow][fcol].ci_vp = vp;\n\t\traidPtr->raid_cinfo[frow][fcol].ci_dev = va.va_rdev;\n\n\t\traidPtr->Disks[frow][fcol].dev = va.va_rdev;\t/* XXX or the above? */\n\n\t\t/* we allow the user to specify that only a fraction of the\n\t\t * disks should be used this is just for debug:  it speeds up\n\t\t * the parity scan */\n\t\traidPtr->Disks[frow][fcol].numBlocks =\n\t\t    raidPtr->Disks[frow][fcol].numBlocks *\n\t\t    rf_sizePercentage / 100;\n\t}\n#if 0\n\t/* This is the way it was done before the CAM stuff was removed */\n\n\tif (rf_extract_ids(badDisk->devname, &bus, &targ, &lun)) {\n\t\tprintf(\"COPYBACK: unable to extract bus, target, lun from devname %s\\n\",\n\t\t    badDisk->devname);\n\t\treturn;\n\t}\n\t/* TUR the disk that's marked as bad to be sure that it's actually\n\t * alive */\n\trf_SCSI_AllocTUR(&tur_op);\n\tretcode = rf_SCSI_DoTUR(tur_op, bus, targ, lun, badDisk->dev);\n\trf_SCSI_FreeDiskOp(tur_op, 0);\n#endif\n\n\tif (retcode) {\n\t\tprintf(\"COPYBACK: target disk failed TUR\\n\");\n\t\treturn;\n\t}\n\t/* get a buffer to hold one SU  */\n\tRF_Malloc(databuf, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (char *));\n\n\t/* create a descriptor */\n\tRF_Malloc(desc, sizeof(*desc), (RF_CopybackDesc_t *));\n\tdesc->raidPtr = raidPtr;\n\tdesc->status = 0;\n\tdesc->frow = frow;\n\tdesc->fcol = fcol;\n\tdesc->spRow = badDisk->spareRow;\n\tdesc->spCol = badDisk->spareCol;\n\tdesc->stripeAddr = 0;\n\tdesc->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tdesc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.numDataCol;\n\tdesc->databuf = databuf;\n\tdesc->mcpair = rf_AllocMCPair();\n\n\tprintf(\"COPYBACK: Quiescing the array\\n\");\n\t/* quiesce the array, since we don't want to code support for user\n\t * accs here */\n\trf_SuspendNewRequestsAndWait(raidPtr);\n\n\t/* adjust state of the array and of the disks */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->Disks[desc->frow][desc->fcol].status = rf_ds_optimal;\n\traidPtr->status[desc->frow] = rf_rs_optimal;\n\trf_copyback_in_progress = 1;\t/* debug only */\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\tprintf(\"COPYBACK: Beginning\\n\");\n\tRF_GETTIME(desc->starttime);\n\trf_ContinueCopyback(desc);\n\n\t/* Data has been restored.  Fix up the component label. */\n\t/* Don't actually need the read here.. */\n\traidread_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t  raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t  &c_label);\n\t\t\n\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\tc_label.mod_counter = raidPtr->mod_counter;\n\tc_label.serial_number = raidPtr->serial_number;\n\tc_label.row = frow;\n\tc_label.column = fcol;\n\tc_label.num_rows = raidPtr->numRow;\n\tc_label.num_columns = raidPtr->numCol;\n\tc_label.clean = RF_RAID_DIRTY;\n\tc_label.status = rf_ds_optimal;\n\t\n\traidwrite_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,\n\t\t\t\t   raidPtr->raid_cinfo[frow][fcol].ci_vp,\n\t\t\t\t   &c_label);\n}"
  },
  {
    "function_name": "rf_ConfigureCopyback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_copyback.c",
    "lines": "70-76",
    "snippet": "int \nrf_ConfigureCopyback(listp)\n\tRF_ShutdownList_t **listp;\n{\n\trf_copyback_in_progress = 0;\n\treturn (0);\n}",
    "includes": [
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int     rf_copyback_in_progress;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_decluster.h\"\n#include \"rf_copyback.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_raid.h\"\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint     rf_copyback_in_progress;\n\nint \nrf_ConfigureCopyback(listp)\n\tRF_ShutdownList_t **listp;\n{\n\trf_copyback_in_progress = 0;\n\treturn (0);\n}"
  }
]