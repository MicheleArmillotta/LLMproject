[
  {
    "function_name": "rf_VerifyDegrModeWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
    "lines": "367-373",
    "snippet": "int \nrf_VerifyDegrModeWrite(raidPtr, asmh)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMapHeader_t *asmh;\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\n\nint \nrf_VerifyDegrModeWrite(raidPtr, asmh)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMapHeader_t *asmh;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_TryToRedirectPDA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
    "lines": "315-348",
    "snippet": "int \nrf_TryToRedirectPDA(raidPtr, pda, parity)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tint     parity;\n{\n\tif (raidPtr->Disks[pda->row][pda->col].status == rf_ds_reconstructing) {\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[pda->row]->reconMap, pda->startSector)) {\n\t\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\t\tRF_RowCol_t or = pda->row, oc = pda->col;\n\t\t\t\tRF_SectorNum_t os = pda->startSector;\n\t\t\t\tif (parity) {\n\t\t\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir P r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t} else {\n\t\t\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRF_RowCol_t spRow = raidPtr->Disks[pda->row][pda->col].spareRow;\n\t\t\t\tRF_RowCol_t spCol = raidPtr->Disks[pda->row][pda->col].spareCol;\n\t\t\t\tpda->row = spRow;\n\t\t\t\tpda->col = spCol;\n\t\t\t}\n\t\t}\n\t}\n\tif (RF_DEAD_DISK(raidPtr->Disks[pda->row][pda->col].status))\n\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;",
      "RF_RaidAccessFlags_t flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[pda->row][pda->col].status"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\\n\"",
            "or",
            "oc",
            "(long) os",
            "pda->row",
            "pda->col",
            "(long) pda->startSector"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "pda->raidAddress",
            "&pda->row",
            "&pda->col",
            "&pda->startSector",
            "RF_REMAP"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "pda->raidAddress",
            "&pda->row",
            "&pda->col",
            "&pda->startSector",
            "RF_REMAP"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckRUReconstructed",
          "args": [
            "raidPtr->reconControl[pda->row]->reconMap",
            "pda->startSector"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckRUReconstructed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "308-319",
          "snippet": "int \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\n\nint \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\nRF_RaidAccessFlags_t flags;\n\nint \nrf_TryToRedirectPDA(raidPtr, pda, parity)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tint     parity;\n{\n\tif (raidPtr->Disks[pda->row][pda->col].status == rf_ds_reconstructing) {\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[pda->row]->reconMap, pda->startSector)) {\n\t\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\t\tRF_RowCol_t or = pda->row, oc = pda->col;\n\t\t\t\tRF_SectorNum_t os = pda->startSector;\n\t\t\t\tif (parity) {\n\t\t\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir P r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t} else {\n\t\t\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRF_RowCol_t spRow = raidPtr->Disks[pda->row][pda->col].spareRow;\n\t\t\t\tRF_RowCol_t spCol = raidPtr->Disks[pda->row][pda->col].spareCol;\n\t\t\t\tpda->row = spRow;\n\t\t\t\tpda->col = spCol;\n\t\t\t}\n\t\t}\n\t}\n\tif (RF_DEAD_DISK(raidPtr->Disks[pda->row][pda->col].status))\n\t\treturn (1);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_VerifyParityBasic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
    "lines": "173-313",
    "snippet": "int \nrf_VerifyParityBasic(raidPtr, raidAddr, parityPDA, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_PhysDiskAddr_t *parityPDA;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,\n\t\t\t\t\t\t\t\t     raidAddr);\n\tRF_SectorCount_t numsector = parityPDA->numSector;\n\tint     numbytes = rf_RaidAddressToByte(raidPtr, numsector);\n\tint     bytesPerStripe = numbytes * layoutPtr->numDataCol;\n\tRF_DagHeader_t *rd_dag_h, *wr_dag_h;\t/* read, write dag */\n\tRF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_AllocListElem_t *alloclist;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *pbuf, *buf, *end_p, *p;\n\tint     i, retcode;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr,\n\t\t\t\t\t\t\t     raidAddr,\n\t\t\t\t\t\t\t     &which_ru);\n\tint     stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\tRF_AccTraceEntry_t tracerec;\n\tRF_MCPair_t *mcpair;\n\n\tretcode = RF_PARITY_OKAY;\n\n\tmcpair = rf_AllocMCPair();\n\trf_MakeAllocList(alloclist);\n\tRF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);\n\tRF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\tend_p = buf + bytesPerStripe;\n\n\trd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,\n\t    \"Rod\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\tblockNode = rd_dag_h->succedents[0];\n\tunblockNode = blockNode->succedents[0]->succedents[0];\n\n\t/* map the stripe and fill in the PDAs in the dag */\n\tasm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);\n\tasmap = asm_h->stripeMap;\n\n\tfor (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol; i++, pda = pda->next) {\n\t\tRF_ASSERT(pda);\n\t\trf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);\n\t\tRF_ASSERT(pda->numSector != 0);\n\t\tif (rf_TryToRedirectPDA(raidPtr, pda, 0))\n\t\t\tgoto out;\t/* no way to verify parity if disk is\n\t\t\t\t\t * dead.  return w/ good status */\n\t\tblockNode->succedents[i]->params[0].p = pda;\n\t\tblockNode->succedents[i]->params[2].v = psID;\n\t\tblockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t}\n\n\tRF_ASSERT(!asmap->parityInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);\n\tRF_ASSERT(asmap->parityInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))\n\t\tgoto out;\n\tblockNode->succedents[layoutPtr->numDataCol]->params[0].p = asmap->parityInfo;\n\n\t/* fire off the DAG */\n\tbzero((char *) &tracerec, sizeof(tracerec));\n\trd_dag_h->tracerec = &tracerec;\n\n\tif (rf_verifyParityDebug) {\n\t\tprintf(\"Parity verify read dag:\\n\");\n\t\trf_PrintDAGList(rd_dag_h);\n\t}\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 0;\n\trf_DispatchDAG(rd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t    (void *) mcpair);\n\twhile (!mcpair->flag)\n\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\tif (rd_dag_h->status != rf_enable) {\n\t\tRF_ERRORMSG(\"Unable to verify parity:  can't read the stripe\\n\");\n\t\tretcode = RF_PARITY_COULD_NOT_VERIFY;\n\t\tgoto out;\n\t}\n\tfor (p = buf; p < end_p; p += numbytes) {\n\t\trf_bxor(p, pbuf, numbytes, NULL);\n\t}\n\tfor (i = 0; i < numbytes; i++) {\n#if 0\n\t\tif (pbuf[i] != 0 || buf[bytesPerStripe + i] != 0) {\n\t\t\tprintf(\"Bytes: %d %d %d\\n\", i, pbuf[i], buf[bytesPerStripe + i]);\n\t\t}\n#endif\n\t\tif (pbuf[i] != buf[bytesPerStripe + i]) {\n\t\t\tif (!correct_it)\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + i], (u_char) pbuf[i]);\n\t\t\tretcode = RF_PARITY_BAD;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retcode && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnp\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->parityInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Parity verify write dag:\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\");\n\t\t\tretcode = RF_PARITY_COULD_NOT_CORRECT;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t\tif (retcode == RF_PARITY_BAD)\n\t\t\tretcode = RF_PARITY_CORRECTED;\n\t}\nout:\n\trf_FreeAccessStripeMap(asm_h);\n\trf_FreeAllocList(alloclist);\n\trf_FreeDAG(rd_dag_h);\n\trf_FreeMCPair(mcpair);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;",
      "RF_AllocListElem_t *alloclist;",
      "RF_RaidAccessFlags_t flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeMCPair",
          "args": [
            "mcpair"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeMCPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_mcpair.c",
          "lines": "125-130",
          "snippet": "void \nrf_FreeMCPair(t)\n\tRF_MCPair_t *t;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_mcpair_freelist, t, next, clean_mcpair);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_mcpair_freelist;",
            "static int init_mcpair(RF_MCPair_t *);",
            "static void clean_mcpair(RF_MCPair_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_mcpair_freelist;\nstatic int init_mcpair(RF_MCPair_t *);\nstatic void clean_mcpair(RF_MCPair_t *);\n\nvoid \nrf_FreeMCPair(t)\n\tRF_MCPair_t *t;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_mcpair_freelist, t, next, clean_mcpair);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeDAG",
          "args": [
            "rd_dag_h"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeDAGHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "257-261",
          "snippet": "void \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
            "static RF_FreeList_t *rf_dagh_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\n\nvoid \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeAllocList",
          "args": [
            "alloclist"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAllocList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_alloclist.c",
          "lines": "139-164",
          "snippet": "void \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define RF_AL_FREELIST_MAX 256"
          ],
          "globals_used": [
            "static RF_AllocListElem_t *al_free_list = NULL;",
            "static int al_free_list_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define RF_AL_FREELIST_MAX 256\n\nstatic RF_AllocListElem_t *al_free_list = NULL;\nstatic int al_free_list_count;\n\nvoid \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeAccessStripeMap",
          "args": [
            "asm_h"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAccessStripeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "537-598",
          "snippet": "void \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
            "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
            "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;",
            "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
            "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nvoid \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "mcpair->cond",
            "mcpair->mutex"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DispatchDAG",
          "args": [
            "wr_dag_h",
            "(void (*) (void *)) rf_MCPairWakeupFunc",
            "(void *) mcpair"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DispatchDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "668-695",
          "snippet": "int \nrf_DispatchDAG(\n    RF_DagHeader_t * dag,\n    void (*cbFunc) (void *),\n    void *cbArg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = dag->raidPtr;\n\tif (dag->tracerec) {\n\t\tRF_ETIMER_START(dag->tracerec->timer);\n\t}\n\tif (rf_engineDebug || rf_validateDAGDebug) {\n\t\tif (rf_ValidateDAG(dag))\n\t\t\tRF_PANIC();\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Entering DispatchDAG\\n\", raidPtr->raidid);\n\t}\n\traidPtr->dags_in_flight++;\t/* debug only:  blow off proper\n\t\t\t\t\t * locking */\n\tdag->cbFunc = cbFunc;\n\tdag->cbArg = cbArg;\n\tdag->numNodesCompleted = 0;\n\tdag->status = rf_enable;\n\tFireNodeArray(dag->numSuccedents, dag->succedents);\n\treturn (1);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_DispatchDAG(\n    RF_DagHeader_t * dag,\n    void (*cbFunc) (void *),\n    void *cbArg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = dag->raidPtr;\n\tif (dag->tracerec) {\n\t\tRF_ETIMER_START(dag->tracerec->timer);\n\t}\n\tif (rf_engineDebug || rf_validateDAGDebug) {\n\t\tif (rf_ValidateDAG(dag))\n\t\t\tRF_PANIC();\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Entering DispatchDAG\\n\", raidPtr->raidid);\n\t}\n\traidPtr->dags_in_flight++;\t/* debug only:  blow off proper\n\t\t\t\t\t * locking */\n\tdag->cbFunc = cbFunc;\n\tdag->cbArg = cbArg;\n\tdag->numNodesCompleted = 0;\n\tdag->status = rf_enable;\n\tFireNodeArray(dag->numSuccedents, dag->succedents);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PrintDAGList",
          "args": [
            "wr_dag_h"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintDAGList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "509-519",
          "snippet": "void \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Parity verify write dag:\\n\""
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) &tracerec",
            "sizeof(tracerec)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_PARAM3",
          "args": [
            "RF_IO_NORMAL_PRIORITY",
            "0",
            "0",
            "which_ru"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeSimpleDAG",
          "args": [
            "raidPtr",
            "1",
            "numbytes",
            "pbuf",
            "rf_DiskWriteFunc",
            "rf_DiskWriteUndoFunc",
            "\"Wnp\"",
            "alloclist",
            "flags",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\"",
            "i",
            "(u_char) buf[bytesPerStripe + i]",
            "(u_char) pbuf[i]"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "p",
            "pbuf",
            "numbytes",
            "NULL"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Unable to verify parity:  can't read the stripe\\n\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "mcpair->cond",
            "mcpair->mutex"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) &tracerec",
            "sizeof(tracerec)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_TryToRedirectPDA",
          "args": [
            "raidPtr",
            "asmap->parityInfo",
            "1"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "rf_TryToRedirectPDA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
          "lines": "315-348",
          "snippet": "int \nrf_TryToRedirectPDA(raidPtr, pda, parity)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tint     parity;\n{\n\tif (raidPtr->Disks[pda->row][pda->col].status == rf_ds_reconstructing) {\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[pda->row]->reconMap, pda->startSector)) {\n\t\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\t\tRF_RowCol_t or = pda->row, oc = pda->col;\n\t\t\t\tRF_SectorNum_t os = pda->startSector;\n\t\t\t\tif (parity) {\n\t\t\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir P r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t} else {\n\t\t\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRF_RowCol_t spRow = raidPtr->Disks[pda->row][pda->col].spareRow;\n\t\t\t\tRF_RowCol_t spCol = raidPtr->Disks[pda->row][pda->col].spareCol;\n\t\t\t\tpda->row = spRow;\n\t\t\t\tpda->col = spCol;\n\t\t\t}\n\t\t}\n\t}\n\tif (RF_DEAD_DISK(raidPtr->Disks[pda->row][pda->col].status))\n\t\treturn (1);\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_map.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAccessFlags_t flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\nRF_RaidAccessFlags_t flags;\n\nint \nrf_TryToRedirectPDA(raidPtr, pda, parity)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tint     parity;\n{\n\tif (raidPtr->Disks[pda->row][pda->col].status == rf_ds_reconstructing) {\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[pda->row]->reconMap, pda->startSector)) {\n\t\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\t\tRF_RowCol_t or = pda->row, oc = pda->col;\n\t\t\t\tRF_SectorNum_t os = pda->startSector;\n\t\t\t\tif (parity) {\n\t\t\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir P r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t} else {\n\t\t\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRF_RowCol_t spRow = raidPtr->Disks[pda->row][pda->col].spareRow;\n\t\t\t\tRF_RowCol_t spCol = raidPtr->Disks[pda->row][pda->col].spareCol;\n\t\t\t\tpda->row = spRow;\n\t\t\t\tpda->col = spCol;\n\t\t\t}\n\t\t}\n\t}\n\tif (RF_DEAD_DISK(raidPtr->Disks[pda->row][pda->col].status))\n\t\treturn (1);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->parityInfo->numSector != 0"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RangeRestrictPDA",
          "args": [
            "raidPtr",
            "parityPDA",
            "asmap->parityInfo",
            "0",
            "1"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RangeRestrictPDA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "1050-1075",
          "snippet": "void \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!asmap->parityInfo->next"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_PARAM3",
          "args": [
            "RF_IO_NORMAL_PRIORITY",
            "0",
            "0",
            "which_ru"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pda->numSector != 0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pda"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "startAddr",
            "layoutPtr->dataSectorsPerStripe",
            "buf",
            "RF_DONT_REMAP"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeSimpleDAG",
          "args": [
            "raidPtr",
            "stripeWidth",
            "numbytes",
            "buf",
            "rf_DiskReadFunc",
            "rf_DiskReadUndoFunc",
            "\"Rod\"",
            "alloclist",
            "flags",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "pbuf",
            "1",
            "numbytes",
            "(char *), alloclist"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "buf",
            "numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol)",
            "(char *), alloclist"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeAllocList",
          "args": [
            "alloclist"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocMCPair",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocMCPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_mcpair.c",
          "lines": "112-123",
          "snippet": "RF_MCPair_t *\nrf_AllocMCPair()\n{\n\tRF_MCPair_t *t;\n\n\tRF_FREELIST_GET_INIT(rf_mcpair_freelist, t, next, (RF_MCPair_t *), init_mcpair);\n\tif (t) {\n\t\tt->flag = 0;\n\t\tt->next = NULL;\n\t}\n\treturn (t);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_mcpair_freelist;",
            "static int init_mcpair(RF_MCPair_t *);",
            "static void clean_mcpair(RF_MCPair_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_mcpair_freelist;\nstatic int init_mcpair(RF_MCPair_t *);\nstatic void clean_mcpair(RF_MCPair_t *);\n\nRF_MCPair_t *\nrf_AllocMCPair()\n{\n\tRF_MCPair_t *t;\n\n\tRF_FREELIST_GET_INIT(rf_mcpair_freelist, t, next, (RF_MCPair_t *), init_mcpair);\n\tif (t) {\n\t\tt->flag = 0;\n\t\tt->next = NULL;\n\t}\n\treturn (t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToParityStripeID",
          "args": [
            "layoutPtr",
            "raidAddr",
            "&which_ru"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "numsector"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "raidAddr"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\nRF_AllocListElem_t *alloclist;\nRF_RaidAccessFlags_t flags;\n\nint \nrf_VerifyParityBasic(raidPtr, raidAddr, parityPDA, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_PhysDiskAddr_t *parityPDA;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,\n\t\t\t\t\t\t\t\t     raidAddr);\n\tRF_SectorCount_t numsector = parityPDA->numSector;\n\tint     numbytes = rf_RaidAddressToByte(raidPtr, numsector);\n\tint     bytesPerStripe = numbytes * layoutPtr->numDataCol;\n\tRF_DagHeader_t *rd_dag_h, *wr_dag_h;\t/* read, write dag */\n\tRF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_AllocListElem_t *alloclist;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *pbuf, *buf, *end_p, *p;\n\tint     i, retcode;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr,\n\t\t\t\t\t\t\t     raidAddr,\n\t\t\t\t\t\t\t     &which_ru);\n\tint     stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\tRF_AccTraceEntry_t tracerec;\n\tRF_MCPair_t *mcpair;\n\n\tretcode = RF_PARITY_OKAY;\n\n\tmcpair = rf_AllocMCPair();\n\trf_MakeAllocList(alloclist);\n\tRF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);\n\tRF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\tend_p = buf + bytesPerStripe;\n\n\trd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,\n\t    \"Rod\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\tblockNode = rd_dag_h->succedents[0];\n\tunblockNode = blockNode->succedents[0]->succedents[0];\n\n\t/* map the stripe and fill in the PDAs in the dag */\n\tasm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);\n\tasmap = asm_h->stripeMap;\n\n\tfor (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol; i++, pda = pda->next) {\n\t\tRF_ASSERT(pda);\n\t\trf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);\n\t\tRF_ASSERT(pda->numSector != 0);\n\t\tif (rf_TryToRedirectPDA(raidPtr, pda, 0))\n\t\t\tgoto out;\t/* no way to verify parity if disk is\n\t\t\t\t\t * dead.  return w/ good status */\n\t\tblockNode->succedents[i]->params[0].p = pda;\n\t\tblockNode->succedents[i]->params[2].v = psID;\n\t\tblockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t}\n\n\tRF_ASSERT(!asmap->parityInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);\n\tRF_ASSERT(asmap->parityInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))\n\t\tgoto out;\n\tblockNode->succedents[layoutPtr->numDataCol]->params[0].p = asmap->parityInfo;\n\n\t/* fire off the DAG */\n\tbzero((char *) &tracerec, sizeof(tracerec));\n\trd_dag_h->tracerec = &tracerec;\n\n\tif (rf_verifyParityDebug) {\n\t\tprintf(\"Parity verify read dag:\\n\");\n\t\trf_PrintDAGList(rd_dag_h);\n\t}\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 0;\n\trf_DispatchDAG(rd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t    (void *) mcpair);\n\twhile (!mcpair->flag)\n\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\tif (rd_dag_h->status != rf_enable) {\n\t\tRF_ERRORMSG(\"Unable to verify parity:  can't read the stripe\\n\");\n\t\tretcode = RF_PARITY_COULD_NOT_VERIFY;\n\t\tgoto out;\n\t}\n\tfor (p = buf; p < end_p; p += numbytes) {\n\t\trf_bxor(p, pbuf, numbytes, NULL);\n\t}\n\tfor (i = 0; i < numbytes; i++) {\n#if 0\n\t\tif (pbuf[i] != 0 || buf[bytesPerStripe + i] != 0) {\n\t\t\tprintf(\"Bytes: %d %d %d\\n\", i, pbuf[i], buf[bytesPerStripe + i]);\n\t\t}\n#endif\n\t\tif (pbuf[i] != buf[bytesPerStripe + i]) {\n\t\t\tif (!correct_it)\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + i], (u_char) pbuf[i]);\n\t\t\tretcode = RF_PARITY_BAD;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retcode && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnp\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->parityInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Parity verify write dag:\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\");\n\t\t\tretcode = RF_PARITY_COULD_NOT_CORRECT;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t\tif (retcode == RF_PARITY_BAD)\n\t\t\tretcode = RF_PARITY_CORRECTED;\n\t}\nout:\n\trf_FreeAccessStripeMap(asm_h);\n\trf_FreeAllocList(alloclist);\n\trf_FreeDAG(rd_dag_h);\n\trf_FreeMCPair(mcpair);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_VerifyParity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
    "lines": "132-171",
    "snippet": "int \nrf_VerifyParity(raidPtr, aasm, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *aasm;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_PhysDiskAddr_t *parityPDA;\n\tRF_AccessStripeMap_t *doasm;\n\tRF_LayoutSW_t *lp;\n\tint     lrc, rc;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->faultsTolerated == 0) {\n\t\t/*\n\t         * There isn't any parity. Call it \"okay.\"\n\t         */\n\t\treturn (RF_PARITY_OKAY);\n\t}\n\trc = RF_PARITY_OKAY;\n\tif (lp->VerifyParity) {\n\t\tfor (doasm = aasm; doasm; doasm = doasm->next) {\n\t\t\tfor (parityPDA = doasm->parityInfo; parityPDA; \n\t\t\t     parityPDA = parityPDA->next) {\n\t\t\t\tlrc = lp->VerifyParity(raidPtr, \n\t\t\t\t\t\t       doasm->raidAddress, \n\t\t\t\t\t\t       parityPDA,\n\t\t\t\t\t\t       correct_it, flags);\n\t\t\t\tif (lrc > rc) {\n\t\t\t\t\t/* see rf_parityscan.h for why this\n\t\t\t\t\t * works */\n\t\t\t\t\trc = lrc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = RF_PARITY_COULD_NOT_VERIFY;\n\t}\n\treturn (rc);\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;",
      "RF_RaidAccessFlags_t flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lp->VerifyParity",
          "args": [
            "raidPtr",
            "doasm->raidAddress",
            "parityPDA",
            "correct_it",
            "flags"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\nRF_RaidAccessFlags_t flags;\n\nint \nrf_VerifyParity(raidPtr, aasm, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *aasm;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_PhysDiskAddr_t *parityPDA;\n\tRF_AccessStripeMap_t *doasm;\n\tRF_LayoutSW_t *lp;\n\tint     lrc, rc;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->faultsTolerated == 0) {\n\t\t/*\n\t         * There isn't any parity. Call it \"okay.\"\n\t         */\n\t\treturn (RF_PARITY_OKAY);\n\t}\n\trc = RF_PARITY_OKAY;\n\tif (lp->VerifyParity) {\n\t\tfor (doasm = aasm; doasm; doasm = doasm->next) {\n\t\t\tfor (parityPDA = doasm->parityInfo; parityPDA; \n\t\t\t     parityPDA = parityPDA->next) {\n\t\t\t\tlrc = lp->VerifyParity(raidPtr, \n\t\t\t\t\t\t       doasm->raidAddress, \n\t\t\t\t\t\t       parityPDA,\n\t\t\t\t\t\t       correct_it, flags);\n\t\t\t\tif (lrc > rc) {\n\t\t\t\t\t/* see rf_parityscan.h for why this\n\t\t\t\t\t * works */\n\t\t\t\t\trc = lrc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = RF_PARITY_COULD_NOT_VERIFY;\n\t}\n\treturn (rc);\n}"
  },
  {
    "function_name": "rf_RewriteParity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
    "lines": "60-122",
    "snippet": "int \nrf_RewriteParity(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint ret_val;\n\tint rc;\n\tRF_PhysDiskAddr_t pda;\n\tRF_SectorNum_t i;\n\n\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t/* There isn't any parity. Call it \"okay.\" */\n\t\treturn (RF_PARITY_OKAY);\n\t}\n\tif (raidPtr->status[0] != rf_rs_optimal) {\n\t\t/*\n\t\t * We're in degraded mode.  Don't try to verify parity now! \n\t\t * XXX: this should be a \"we don't want to\", not a \n\t\t * \"we can't\" error. \n\t\t */\n\t\treturn (RF_PARITY_COULD_NOT_VERIFY);\n\t}\n\n\tret_val = 0;\n\n\tpda.startSector = 0;\n\tpda.numSector = raidPtr->Layout.sectorsPerStripeUnit;\n\trc = RF_PARITY_OKAY;\n\n\tfor (i = 0; i < raidPtr->totalSectors && \n\t\t     rc <= RF_PARITY_CORRECTED; \n\t     i += layoutPtr->dataSectorsPerStripe) {\n\t\tasm_h = rf_MapAccess(raidPtr, i, \n\t\t\t\t     layoutPtr->dataSectorsPerStripe, \n\t\t\t\t     NULL, RF_DONT_REMAP);\n\t\traidPtr->parity_rewrite_stripes_done = \n\t\t\ti / layoutPtr->dataSectorsPerStripe ;\n\t\trc = rf_VerifyParity(raidPtr, asm_h->stripeMap, 1, 0);\n\t\tswitch (rc) {\n\t\tcase RF_PARITY_OKAY:\n\t\tcase RF_PARITY_CORRECTED:\n\t\t\tbreak;\n\t\tcase RF_PARITY_BAD:\n\t\t\tprintf(\"Parity bad during correction\\n\");\n\t\t\tret_val = 1;\n\t\t\tbreak;\n\t\tcase RF_PARITY_COULD_NOT_CORRECT:\n\t\t\tprintf(\"Could not correct bad parity\\n\");\n\t\t\tret_val = 1;\n\t\t\tbreak;\n\t\tcase RF_PARITY_COULD_NOT_VERIFY:\n\t\t\tprintf(\"Could not verify parity\\n\");\n\t\t\tret_val = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Bad rc=%d from VerifyParity in RewriteParity\\n\", rc);\n\t\t\tret_val = 1;\n\t\t}\n\t\trf_FreeAccessStripeMap(asm_h);\n\t}\n\treturn (ret_val);\n}",
    "includes": [
      "#include \"rf_map.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeAccessStripeMap",
          "args": [
            "asm_h"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAccessStripeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "537-598",
          "snippet": "void \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
            "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
            "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;",
            "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
            "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nvoid \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Bad rc=%d from VerifyParity in RewriteParity\\n\"",
            "rc"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_VerifyParity",
          "args": [
            "raidPtr",
            "asm_h->stripeMap",
            "1",
            "0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "rf_VerifyParityBasic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
          "lines": "173-313",
          "snippet": "int \nrf_VerifyParityBasic(raidPtr, raidAddr, parityPDA, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_PhysDiskAddr_t *parityPDA;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,\n\t\t\t\t\t\t\t\t     raidAddr);\n\tRF_SectorCount_t numsector = parityPDA->numSector;\n\tint     numbytes = rf_RaidAddressToByte(raidPtr, numsector);\n\tint     bytesPerStripe = numbytes * layoutPtr->numDataCol;\n\tRF_DagHeader_t *rd_dag_h, *wr_dag_h;\t/* read, write dag */\n\tRF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_AllocListElem_t *alloclist;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *pbuf, *buf, *end_p, *p;\n\tint     i, retcode;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr,\n\t\t\t\t\t\t\t     raidAddr,\n\t\t\t\t\t\t\t     &which_ru);\n\tint     stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\tRF_AccTraceEntry_t tracerec;\n\tRF_MCPair_t *mcpair;\n\n\tretcode = RF_PARITY_OKAY;\n\n\tmcpair = rf_AllocMCPair();\n\trf_MakeAllocList(alloclist);\n\tRF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);\n\tRF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\tend_p = buf + bytesPerStripe;\n\n\trd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,\n\t    \"Rod\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\tblockNode = rd_dag_h->succedents[0];\n\tunblockNode = blockNode->succedents[0]->succedents[0];\n\n\t/* map the stripe and fill in the PDAs in the dag */\n\tasm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);\n\tasmap = asm_h->stripeMap;\n\n\tfor (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol; i++, pda = pda->next) {\n\t\tRF_ASSERT(pda);\n\t\trf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);\n\t\tRF_ASSERT(pda->numSector != 0);\n\t\tif (rf_TryToRedirectPDA(raidPtr, pda, 0))\n\t\t\tgoto out;\t/* no way to verify parity if disk is\n\t\t\t\t\t * dead.  return w/ good status */\n\t\tblockNode->succedents[i]->params[0].p = pda;\n\t\tblockNode->succedents[i]->params[2].v = psID;\n\t\tblockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t}\n\n\tRF_ASSERT(!asmap->parityInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);\n\tRF_ASSERT(asmap->parityInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))\n\t\tgoto out;\n\tblockNode->succedents[layoutPtr->numDataCol]->params[0].p = asmap->parityInfo;\n\n\t/* fire off the DAG */\n\tbzero((char *) &tracerec, sizeof(tracerec));\n\trd_dag_h->tracerec = &tracerec;\n\n\tif (rf_verifyParityDebug) {\n\t\tprintf(\"Parity verify read dag:\\n\");\n\t\trf_PrintDAGList(rd_dag_h);\n\t}\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 0;\n\trf_DispatchDAG(rd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t    (void *) mcpair);\n\twhile (!mcpair->flag)\n\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\tif (rd_dag_h->status != rf_enable) {\n\t\tRF_ERRORMSG(\"Unable to verify parity:  can't read the stripe\\n\");\n\t\tretcode = RF_PARITY_COULD_NOT_VERIFY;\n\t\tgoto out;\n\t}\n\tfor (p = buf; p < end_p; p += numbytes) {\n\t\trf_bxor(p, pbuf, numbytes, NULL);\n\t}\n\tfor (i = 0; i < numbytes; i++) {\n#if 0\n\t\tif (pbuf[i] != 0 || buf[bytesPerStripe + i] != 0) {\n\t\t\tprintf(\"Bytes: %d %d %d\\n\", i, pbuf[i], buf[bytesPerStripe + i]);\n\t\t}\n#endif\n\t\tif (pbuf[i] != buf[bytesPerStripe + i]) {\n\t\t\tif (!correct_it)\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + i], (u_char) pbuf[i]);\n\t\t\tretcode = RF_PARITY_BAD;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retcode && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnp\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->parityInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Parity verify write dag:\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\");\n\t\t\tretcode = RF_PARITY_COULD_NOT_CORRECT;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t\tif (retcode == RF_PARITY_BAD)\n\t\t\tretcode = RF_PARITY_CORRECTED;\n\t}\nout:\n\trf_FreeAccessStripeMap(asm_h);\n\trf_FreeAllocList(alloclist);\n\trf_FreeDAG(rd_dag_h);\n\trf_FreeMCPair(mcpair);\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_map.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;",
            "RF_AllocListElem_t *alloclist;",
            "RF_RaidAccessFlags_t flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\nRF_AllocListElem_t *alloclist;\nRF_RaidAccessFlags_t flags;\n\nint \nrf_VerifyParityBasic(raidPtr, raidAddr, parityPDA, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_PhysDiskAddr_t *parityPDA;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,\n\t\t\t\t\t\t\t\t     raidAddr);\n\tRF_SectorCount_t numsector = parityPDA->numSector;\n\tint     numbytes = rf_RaidAddressToByte(raidPtr, numsector);\n\tint     bytesPerStripe = numbytes * layoutPtr->numDataCol;\n\tRF_DagHeader_t *rd_dag_h, *wr_dag_h;\t/* read, write dag */\n\tRF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_AllocListElem_t *alloclist;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *pbuf, *buf, *end_p, *p;\n\tint     i, retcode;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr,\n\t\t\t\t\t\t\t     raidAddr,\n\t\t\t\t\t\t\t     &which_ru);\n\tint     stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\tRF_AccTraceEntry_t tracerec;\n\tRF_MCPair_t *mcpair;\n\n\tretcode = RF_PARITY_OKAY;\n\n\tmcpair = rf_AllocMCPair();\n\trf_MakeAllocList(alloclist);\n\tRF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);\n\tRF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\tend_p = buf + bytesPerStripe;\n\n\trd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,\n\t    \"Rod\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\tblockNode = rd_dag_h->succedents[0];\n\tunblockNode = blockNode->succedents[0]->succedents[0];\n\n\t/* map the stripe and fill in the PDAs in the dag */\n\tasm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);\n\tasmap = asm_h->stripeMap;\n\n\tfor (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol; i++, pda = pda->next) {\n\t\tRF_ASSERT(pda);\n\t\trf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);\n\t\tRF_ASSERT(pda->numSector != 0);\n\t\tif (rf_TryToRedirectPDA(raidPtr, pda, 0))\n\t\t\tgoto out;\t/* no way to verify parity if disk is\n\t\t\t\t\t * dead.  return w/ good status */\n\t\tblockNode->succedents[i]->params[0].p = pda;\n\t\tblockNode->succedents[i]->params[2].v = psID;\n\t\tblockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t}\n\n\tRF_ASSERT(!asmap->parityInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);\n\tRF_ASSERT(asmap->parityInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))\n\t\tgoto out;\n\tblockNode->succedents[layoutPtr->numDataCol]->params[0].p = asmap->parityInfo;\n\n\t/* fire off the DAG */\n\tbzero((char *) &tracerec, sizeof(tracerec));\n\trd_dag_h->tracerec = &tracerec;\n\n\tif (rf_verifyParityDebug) {\n\t\tprintf(\"Parity verify read dag:\\n\");\n\t\trf_PrintDAGList(rd_dag_h);\n\t}\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 0;\n\trf_DispatchDAG(rd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t    (void *) mcpair);\n\twhile (!mcpair->flag)\n\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\tif (rd_dag_h->status != rf_enable) {\n\t\tRF_ERRORMSG(\"Unable to verify parity:  can't read the stripe\\n\");\n\t\tretcode = RF_PARITY_COULD_NOT_VERIFY;\n\t\tgoto out;\n\t}\n\tfor (p = buf; p < end_p; p += numbytes) {\n\t\trf_bxor(p, pbuf, numbytes, NULL);\n\t}\n\tfor (i = 0; i < numbytes; i++) {\n#if 0\n\t\tif (pbuf[i] != 0 || buf[bytesPerStripe + i] != 0) {\n\t\t\tprintf(\"Bytes: %d %d %d\\n\", i, pbuf[i], buf[bytesPerStripe + i]);\n\t\t}\n#endif\n\t\tif (pbuf[i] != buf[bytesPerStripe + i]) {\n\t\t\tif (!correct_it)\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + i], (u_char) pbuf[i]);\n\t\t\tretcode = RF_PARITY_BAD;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retcode && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnp\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->parityInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Parity verify write dag:\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\");\n\t\t\tretcode = RF_PARITY_COULD_NOT_CORRECT;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t\tif (retcode == RF_PARITY_BAD)\n\t\t\tretcode = RF_PARITY_CORRECTED;\n\t}\nout:\n\trf_FreeAccessStripeMap(asm_h);\n\trf_FreeAllocList(alloclist);\n\trf_FreeDAG(rd_dag_h);\n\trf_FreeMCPair(mcpair);\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "i",
            "layoutPtr->dataSectorsPerStripe",
            "NULL",
            "RF_DONT_REMAP"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\n\nint \nrf_RewriteParity(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint ret_val;\n\tint rc;\n\tRF_PhysDiskAddr_t pda;\n\tRF_SectorNum_t i;\n\n\tif (raidPtr->Layout.map->faultsTolerated == 0) {\n\t\t/* There isn't any parity. Call it \"okay.\" */\n\t\treturn (RF_PARITY_OKAY);\n\t}\n\tif (raidPtr->status[0] != rf_rs_optimal) {\n\t\t/*\n\t\t * We're in degraded mode.  Don't try to verify parity now! \n\t\t * XXX: this should be a \"we don't want to\", not a \n\t\t * \"we can't\" error. \n\t\t */\n\t\treturn (RF_PARITY_COULD_NOT_VERIFY);\n\t}\n\n\tret_val = 0;\n\n\tpda.startSector = 0;\n\tpda.numSector = raidPtr->Layout.sectorsPerStripeUnit;\n\trc = RF_PARITY_OKAY;\n\n\tfor (i = 0; i < raidPtr->totalSectors && \n\t\t     rc <= RF_PARITY_CORRECTED; \n\t     i += layoutPtr->dataSectorsPerStripe) {\n\t\tasm_h = rf_MapAccess(raidPtr, i, \n\t\t\t\t     layoutPtr->dataSectorsPerStripe, \n\t\t\t\t     NULL, RF_DONT_REMAP);\n\t\traidPtr->parity_rewrite_stripes_done = \n\t\t\ti / layoutPtr->dataSectorsPerStripe ;\n\t\trc = rf_VerifyParity(raidPtr, asm_h->stripeMap, 1, 0);\n\t\tswitch (rc) {\n\t\tcase RF_PARITY_OKAY:\n\t\tcase RF_PARITY_CORRECTED:\n\t\t\tbreak;\n\t\tcase RF_PARITY_BAD:\n\t\t\tprintf(\"Parity bad during correction\\n\");\n\t\t\tret_val = 1;\n\t\t\tbreak;\n\t\tcase RF_PARITY_COULD_NOT_CORRECT:\n\t\t\tprintf(\"Could not correct bad parity\\n\");\n\t\t\tret_val = 1;\n\t\t\tbreak;\n\t\tcase RF_PARITY_COULD_NOT_VERIFY:\n\t\t\tprintf(\"Could not verify parity\\n\");\n\t\t\tret_val = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Bad rc=%d from VerifyParity in RewriteParity\\n\", rc);\n\t\t\tret_val = 1;\n\t\t}\n\t\trf_FreeAccessStripeMap(asm_h);\n\t}\n\treturn (ret_val);\n}"
  }
]