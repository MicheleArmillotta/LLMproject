[
  {
    "function_name": "u24_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
    "lines": "326-344",
    "snippet": "void\nu24_init(sc)\n\tstruct uha_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* free OGM and ICM */\n\tbus_space_write_1(iot, ioh, U24_OGMCMD, 0);\n\tbus_space_write_1(iot, ioh, U24_ICMCMD, 0);\n\t/* make sure interrupts are enabled */\n#ifdef UHADEBUG\n\tprintf(\"u24_init: lmask=%02x, smask=%02x\\n\",\n\t    bus_space_read_1(iot, ioh, U24_LMASK),\n\t    bus_space_read_1(iot, ioh, U24_SMASK));\n#endif\n\tbus_space_write_1(iot, ioh, U24_LMASK, 0xd2);\t/* XXX */\n\tbus_space_write_1(iot, ioh, U24_SMASK, 0x92);\t/* XXX */\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void u24_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_SMASK",
            "0x92"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_LMASK",
            "0xd2"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"u24_init: lmask=%02x, smask=%02x\\n\"",
            "bus_space_read_1(iot, ioh, U24_LMASK)",
            "bus_space_read_1(iot, ioh, U24_SMASK)"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_SMASK"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_LMASK"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_ICMCMD",
            "0"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_OGMCMD",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid u24_init;\n\nvoid\nu24_init(sc)\n\tstruct uha_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/* free OGM and ICM */\n\tbus_space_write_1(iot, ioh, U24_OGMCMD, 0);\n\tbus_space_write_1(iot, ioh, U24_ICMCMD, 0);\n\t/* make sure interrupts are enabled */\n#ifdef UHADEBUG\n\tprintf(\"u24_init: lmask=%02x, smask=%02x\\n\",\n\t    bus_space_read_1(iot, ioh, U24_LMASK),\n\t    bus_space_read_1(iot, ioh, U24_SMASK));\n#endif\n\tbus_space_write_1(iot, ioh, U24_LMASK, 0xd2);\t/* XXX */\n\tbus_space_write_1(iot, ioh, U24_SMASK, 0x92);\t/* XXX */\n}"
  },
  {
    "function_name": "u24_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
    "lines": "277-324",
    "snippet": "int\nu24_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U24_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U24_ICMPTR);\n\t\tbus_space_write_1(iot, ioh, U24_SINT, U24_ICM_ACK);\n\t\tbus_space_write_1(iot, ioh, U24_ICMCMD, 0);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int u24_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_SINT"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uha_done",
          "args": [
            "sc",
            "mscp"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "uha_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "291-342",
          "snippet": "void\nuha_done(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = mscp->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"uha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((mscp->flags & MSCP_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (mscp->host_stat != UHA_NO_ERR) {\n\t\t\tswitch (mscp->host_stat) {\n\t\t\tcase UHA_SBUS_TIMEOUT:\t\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (mscp->target_stat != SCSI_OK) {\n\t\t\tswitch (mscp->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &mscp->mscp_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tuha_free_mscp(sc, mscp);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "void uha_free_mscp",
            "uha_init_mscp __P((struct uha_softc *, struct uha_mscp *));",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "int flags;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nuha_reset_mscp __P((struct uha_softc *, struct uha_mscp *));\nvoid uha_free_mscp;\nuha_init_mscp __P((struct uha_softc *, struct uha_mscp *));\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nint flags;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_done(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = mscp->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"uha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((mscp->flags & MSCP_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (mscp->host_stat != UHA_NO_ERR) {\n\t\t\tswitch (mscp->host_stat) {\n\t\t\tcase UHA_SBUS_TIMEOUT:\t\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (mscp->target_stat != SCSI_OK) {\n\t\t\tswitch (mscp->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &mscp->mscp_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, mscp->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tuha_free_mscp(sc, mscp);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "uha_timeout",
            "mscp"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: BAD MSCP RETURNED!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uha_mscp_phys_kv",
          "args": [
            "sc",
            "mboxval"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_ICMCMD",
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_SINT",
            "U24_ICM_ACK"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "iot",
            "ioh",
            "U24_ICMPTR"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_SINT"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_SINT"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u24_intr;\n\nint\nu24_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U24_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U24_ICMPTR);\n\t\tbus_space_write_1(iot, ioh, U24_SINT, U24_ICM_ACK);\n\t\tbus_space_write_1(iot, ioh, U24_ICMCMD, 0);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}"
  },
  {
    "function_name": "u24_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
    "lines": "253-275",
    "snippet": "int\nu24_poll(sc, xs, count)\n\tstruct uha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP)\n\t\t\tu24_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int u24_poll",
      "int u24_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "u24_intr",
          "args": [
            "sc"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "u24_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
          "lines": "277-324",
          "snippet": "int\nu24_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U24_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U24_ICMPTR);\n\t\tbus_space_write_1(iot, ioh, U24_SINT, U24_ICM_ACK);\n\t\tbus_space_write_1(iot, ioh, U24_ICMCMD, 0);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int u24_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u24_intr;\n\nint\nu24_intr(arg)\n\tvoid *arg;\n{\n\tstruct uha_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct uha_mscp *mscp;\n\tu_char uhastat;\n\tu_long mboxval;\n\n#ifdef\tUHADEBUG\n\tprintf(\"%s: uhaintr \", sc->sc_dev.dv_xname);\n#endif /*UHADEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\treturn (0);\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowledge the interrupt\n\t\t */\n\t\tuhastat = bus_space_read_1(iot, ioh, U24_SINT);\n\t\tmboxval = bus_space_read_4(iot, ioh, U24_ICMPTR);\n\t\tbus_space_write_1(iot, ioh, U24_SINT, U24_ICM_ACK);\n\t\tbus_space_write_1(iot, ioh, U24_ICMCMD, 0);\n\n#ifdef\tUHADEBUG\n\t\tprintf(\"status = 0x%x \", uhastat);\n#endif /*UHADEBUG*/\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tmscp = uha_mscp_phys_kv(sc, mboxval);\n\t\tif (!mscp) {\n\t\t\tprintf(\"%s: BAD MSCP RETURNED!\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t}\n\t\tuntimeout(uha_timeout, mscp);\n\t\tuha_done(sc, mscp);\n\n\t\tif ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)\n\t\t\treturn (1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_SINT"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u24_poll;\nint u24_intr;\n\nint\nu24_poll(sc, xs, count)\n\tstruct uha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP)\n\t\t\tu24_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "u24_start_mbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
    "lines": "222-251",
    "snippet": "void\nu24_start_mbox(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint spincount = 100000;\t/* 1s should be enough */\n\n\twhile (--spincount) {\n\t\tif ((bus_space_read_1(iot, ioh, U24_LINT) & U24_LDIP) == 0)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\tif (!spincount) {\n\t\tprintf(\"%s: uha_start_mbox, board not responding\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\tbus_space_write_4(iot, ioh, U24_OGMPTR, KVTOPHYS(mscp));\n\tif (mscp->flags & MSCP_ABORT)\n\t\tbus_space_write_1(iot, ioh, U24_OGMCMD, 0x80);\n\telse\n\t\tbus_space_write_1(iot, ioh, U24_OGMCMD, 0x01);\n\tbus_space_write_1(iot, ioh, U24_LINT, U24_OGMFULL);\n\n\tif ((mscp->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(uha_timeout, mscp, (mscp->timeout * hz) / 1000);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void u24_start_mbox"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "uha_timeout",
            "mscp",
            "(mscp->timeout * hz) / 1000"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "1143-1189",
          "snippet": "void\nahb_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ahb_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_IMMED) {\n\t\tprintf(\"\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tahb_done(sc, ecb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ecb->flags == ECB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tahb_done(sc, ecb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tecb->xs->error = XS_TIMEOUT;\n\t\tecb->flags = ECB_ABORTED;\n\t\tahb_send_mbox(sc, OP_ABORT_ECB, ecb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(ahb_timeout, ecb, 2 * hz);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ECB_IMMED_FAIL\t8",
            "#define ECB_IMMED\t4",
            "#define ECB_ABORTED\t2",
            "#define  OP_ABORT_ECB\t\t0x50"
          ],
          "globals_used": [
            "void ahb_send_mbox",
            "void ahb_done",
            "void ahb_timeout",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_IMMED_FAIL\t8\n#define ECB_IMMED\t4\n#define ECB_ABORTED\t2\n#define  OP_ABORT_ECB\t\t0x50\n\nvoid ahb_send_mbox;\nvoid ahb_done;\nvoid ahb_timeout;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ahb_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_IMMED) {\n\t\tprintf(\"\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tahb_done(sc, ecb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ecb->flags == ECB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tahb_done(sc, ecb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tecb->xs->error = XS_TIMEOUT;\n\t\tecb->flags = ECB_ABORTED;\n\t\tahb_send_mbox(sc, OP_ABORT_ECB, ecb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(ahb_timeout, ecb, 2 * hz);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_LINT",
            "U24_OGMFULL"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_OGMCMD",
            "0x01"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_OGMCMD",
            "0x80"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "iot",
            "ioh",
            "U24_OGMPTR",
            "KVTOPHYS(mscp)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "mscp"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: uha_start_mbox, board not responding\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_LINT"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid u24_start_mbox;\n\nvoid\nu24_start_mbox(sc, mscp)\n\tstruct uha_softc *sc;\n\tstruct uha_mscp *mscp;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint spincount = 100000;\t/* 1s should be enough */\n\n\twhile (--spincount) {\n\t\tif ((bus_space_read_1(iot, ioh, U24_LINT) & U24_LDIP) == 0)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\tif (!spincount) {\n\t\tprintf(\"%s: uha_start_mbox, board not responding\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\tbus_space_write_4(iot, ioh, U24_OGMPTR, KVTOPHYS(mscp));\n\tif (mscp->flags & MSCP_ABORT)\n\t\tbus_space_write_1(iot, ioh, U24_OGMCMD, 0x80);\n\telse\n\t\tbus_space_write_1(iot, ioh, U24_OGMCMD, 0x01);\n\tbus_space_write_1(iot, ioh, U24_LINT, U24_OGMFULL);\n\n\tif ((mscp->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(uha_timeout, mscp, (mscp->timeout * hz) / 1000);\n}"
  },
  {
    "function_name": "u24_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
    "lines": "162-220",
    "snippet": "int\nu24_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int8_t config0, config1, config2;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tconfig0 = bus_space_read_1(iot, ioh, U24_CONFIG + 0);\n\tconfig1 = bus_space_read_1(iot, ioh, U24_CONFIG + 1);\n\tconfig2 = bus_space_read_1(iot, ioh, U24_CONFIG + 2);\n\tif ((config0 & U24_MAGIC1) == 0 ||\n\t    (config1 & U24_MAGIC2) == 0)\n\t\treturn (0);\n\n\tdrq = -1;\n\n\tswitch (config0 & U24_IRQ_MASK) {\n\tcase U24_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U24_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U24_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U24_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u24_find: illegal irq setting %x\\n\",\n\t\t    config0 & U24_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U24_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U24_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u24_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config2 & U24_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int u24_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"u24_find: board timed out during reset\\n\""
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_LINT"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "U24_LINT",
            "UHA_ASRST"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_CONFIG + 2"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_CONFIG + 1"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "U24_CONFIG + 0"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u24_find;\n\nint\nu24_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int8_t config0, config1, config2;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tconfig0 = bus_space_read_1(iot, ioh, U24_CONFIG + 0);\n\tconfig1 = bus_space_read_1(iot, ioh, U24_CONFIG + 1);\n\tconfig2 = bus_space_read_1(iot, ioh, U24_CONFIG + 2);\n\tif ((config0 & U24_MAGIC1) == 0 ||\n\t    (config1 & U24_MAGIC2) == 0)\n\t\treturn (0);\n\n\tdrq = -1;\n\n\tswitch (config0 & U24_IRQ_MASK) {\n\tcase U24_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U24_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U24_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U24_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u24_find: illegal irq setting %x\\n\",\n\t\t    config0 & U24_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U24_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U24_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u24_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config2 & U24_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}"
  },
  {
    "function_name": "uha_eisa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
    "lines": "108-160",
    "snippet": "void\nuha_eisa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tstruct uha_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\teisa_chipset_tag_t ec = ea->ea_ec;\n\teisa_intr_handle_t ih;\n\tconst char *model, *intrstr;\n\n\tif (!strncmp(ea->ea_idstring, \"USC024\", 6))\n\t\tmodel = EISA_PRODUCT_USC0240;\n\telse\n\t\tmodel = \"unknown model!\";\n\tprintf(\": %s\\n\", model);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t    UHA_EISA_SLOT_OFFSET, UHA_EISA_IOSIZE, 0, &ioh))\n\t\tpanic(\"uha_attach: could not map I/O addresses\");\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\tif (!u24_find(iot, ioh, sc))\n\t\tpanic(\"uha_attach: u24_find failed!\");\n\n\tif (eisa_intr_map(ec, sc->sc_irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_irq);\n\t\treturn;\n\t}\n\tintrstr = eisa_intr_string(ec, ih);\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    u24_intr, sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\"%s: interrupting at %s\\n\", sc->sc_dev.dv_xname, intrstr);\n\n\t/* Save function pointers for later use. */\n\tsc->start_mbox = u24_start_mbox;\n\tsc->poll = u24_poll;\n\tsc->init = u24_init;\n\n\tuha_attach(sc);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tUHA_EISA_IOSIZE\t\t0x020",
      "#define\tUHA_EISA_SLOT_OFFSET\t0xc80"
    ],
    "globals_used": [
      "void\tuha_eisa_attach",
      "int u24_find",
      "void u24_start_mbox",
      "int u24_poll",
      "int u24_intr",
      "void u24_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uha_attach",
          "args": [
            "sc"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "uha_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/uha.c",
          "lines": "135-163",
          "snippet": "void\nuha_attach(sc)\n\tstruct uha_softc *sc;\n{\n\n\t(sc->init)(sc);\n\tTAILQ_INIT(&sc->sc_free_mscp);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifndef __OpenBSD__\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &uha_switch;\n\tsc->sc_link.device = &uha_dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n#ifdef __OpenBSD__\n\tconfig_found(&sc->sc_dev, &sc->sc_link, uhaprint);\n#else\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n#endif\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct scsi_adapter uha_switch = {\n\tuha_scsi_cmd,\n\tuhaminphys,\n\t0,\n\t0,\n};",
            "struct scsi_device uha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
            "struct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;",
            "struct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct scsi_adapter uha_switch = {\n\tuha_scsi_cmd,\n\tuhaminphys,\n\t0,\n\t0,\n};\nstruct scsi_device uha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nstruct uha_mscp *\nuha_get_mscp(sc, flags)\n\tstruct uha_softc *sc;\nstruct uha_mscp *\nuha_mscp_phys_kv(sc, mscp_phys)\n\tstruct uha_softc *sc;\n\nvoid\nuha_attach(sc)\n\tstruct uha_softc *sc;\n{\n\n\t(sc->init)(sc);\n\tTAILQ_INIT(&sc->sc_free_mscp);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n#ifndef __OpenBSD__\n\tsc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n#endif\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &uha_switch;\n\tsc->sc_link.device = &uha_dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n#ifdef __OpenBSD__\n\tconfig_found(&sc->sc_dev, &sc->sc_link, uhaprint);\n#else\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: interrupting at %s\\n\"",
            "sc->sc_dev.dv_xname",
            "intrstr"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eisa_intr_establish",
          "args": [
            "ec",
            "ih",
            "IST_LEVEL",
            "IPL_BIO",
            "u24_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_string",
          "args": [
            "ec",
            "ih"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_map",
          "args": [
            "ec",
            "sc->sc_irq",
            "&ih"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uha_attach: u24_find failed!\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u24_find",
          "args": [
            "iot",
            "ioh",
            "sc"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "u24_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
          "lines": "162-220",
          "snippet": "int\nu24_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int8_t config0, config1, config2;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tconfig0 = bus_space_read_1(iot, ioh, U24_CONFIG + 0);\n\tconfig1 = bus_space_read_1(iot, ioh, U24_CONFIG + 1);\n\tconfig2 = bus_space_read_1(iot, ioh, U24_CONFIG + 2);\n\tif ((config0 & U24_MAGIC1) == 0 ||\n\t    (config1 & U24_MAGIC2) == 0)\n\t\treturn (0);\n\n\tdrq = -1;\n\n\tswitch (config0 & U24_IRQ_MASK) {\n\tcase U24_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U24_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U24_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U24_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u24_find: illegal irq setting %x\\n\",\n\t\t    config0 & U24_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U24_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U24_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u24_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config2 & U24_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int u24_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u24_find;\n\nint\nu24_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int8_t config0, config1, config2;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tconfig0 = bus_space_read_1(iot, ioh, U24_CONFIG + 0);\n\tconfig1 = bus_space_read_1(iot, ioh, U24_CONFIG + 1);\n\tconfig2 = bus_space_read_1(iot, ioh, U24_CONFIG + 2);\n\tif ((config0 & U24_MAGIC1) == 0 ||\n\t    (config1 & U24_MAGIC2) == 0)\n\t\treturn (0);\n\n\tdrq = -1;\n\n\tswitch (config0 & U24_IRQ_MASK) {\n\tcase U24_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U24_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U24_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U24_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u24_find: illegal irq setting %x\\n\",\n\t\t    config0 & U24_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U24_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U24_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u24_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config2 & U24_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uha_attach: could not map I/O addresses\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "EISA_SLOT_ADDR(ea->ea_slot) +\n\t    UHA_EISA_SLOT_OFFSET",
            "UHA_EISA_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ea->ea_idstring",
            "\"USC024\"",
            "6"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tUHA_EISA_IOSIZE\t\t0x020\n#define\tUHA_EISA_SLOT_OFFSET\t0xc80\n\nvoid\tuha_eisa_attach;\nint u24_find;\nvoid u24_start_mbox;\nint u24_poll;\nint u24_intr;\nvoid u24_init;\n\nvoid\nuha_eisa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tstruct uha_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\teisa_chipset_tag_t ec = ea->ea_ec;\n\teisa_intr_handle_t ih;\n\tconst char *model, *intrstr;\n\n\tif (!strncmp(ea->ea_idstring, \"USC024\", 6))\n\t\tmodel = EISA_PRODUCT_USC0240;\n\telse\n\t\tmodel = \"unknown model!\";\n\tprintf(\": %s\\n\", model);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t    UHA_EISA_SLOT_OFFSET, UHA_EISA_IOSIZE, 0, &ioh))\n\t\tpanic(\"uha_attach: could not map I/O addresses\");\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\tif (!u24_find(iot, ioh, sc))\n\t\tpanic(\"uha_attach: u24_find failed!\");\n\n\tif (eisa_intr_map(ec, sc->sc_irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_irq);\n\t\treturn;\n\t}\n\tintrstr = eisa_intr_string(ec, ih);\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    u24_intr, sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\"%s: interrupting at %s\\n\", sc->sc_dev.dv_xname, intrstr);\n\n\t/* Save function pointers for later use. */\n\tsc->start_mbox = u24_start_mbox;\n\tsc->poll = u24_poll;\n\tsc->init = u24_init;\n\n\tuha_attach(sc);\n}"
  },
  {
    "function_name": "uha_eisa_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
    "lines": "80-103",
    "snippet": "int\nuha_eisa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\t/* must match one of our known ID strings */\n\tif (strncmp(ea->ea_idstring, \"USC024\", 6))\n\t\treturn (0);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t    UHA_EISA_SLOT_OFFSET, UHA_EISA_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\trv = u24_find(iot, ioh, NULL);\n\n\tbus_space_unmap(iot, ioh, UHA_EISA_IOSIZE);\n\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/uhavar.h>",
      "#include <dev/ic/uhareg.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tUHA_EISA_IOSIZE\t\t0x020",
      "#define\tUHA_EISA_SLOT_OFFSET\t0xc80"
    ],
    "globals_used": [
      "int\tuha_eisa_match",
      "int u24_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "UHA_EISA_IOSIZE"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u24_find",
          "args": [
            "iot",
            "ioh",
            "NULL"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "u24_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/uha_eisa.c",
          "lines": "162-220",
          "snippet": "int\nu24_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int8_t config0, config1, config2;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tconfig0 = bus_space_read_1(iot, ioh, U24_CONFIG + 0);\n\tconfig1 = bus_space_read_1(iot, ioh, U24_CONFIG + 1);\n\tconfig2 = bus_space_read_1(iot, ioh, U24_CONFIG + 2);\n\tif ((config0 & U24_MAGIC1) == 0 ||\n\t    (config1 & U24_MAGIC2) == 0)\n\t\treturn (0);\n\n\tdrq = -1;\n\n\tswitch (config0 & U24_IRQ_MASK) {\n\tcase U24_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U24_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U24_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U24_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u24_find: illegal irq setting %x\\n\",\n\t\t    config0 & U24_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U24_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U24_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u24_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config2 & U24_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/uhavar.h>",
            "#include <dev/ic/uhareg.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int u24_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint u24_find;\n\nint\nu24_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct uha_softc *sc;\n{\n\tu_int8_t config0, config1, config2;\n\tint irq, drq;\n\tint resetcount = 4000;\t/* 4 secs? */\n\n\tconfig0 = bus_space_read_1(iot, ioh, U24_CONFIG + 0);\n\tconfig1 = bus_space_read_1(iot, ioh, U24_CONFIG + 1);\n\tconfig2 = bus_space_read_1(iot, ioh, U24_CONFIG + 2);\n\tif ((config0 & U24_MAGIC1) == 0 ||\n\t    (config1 & U24_MAGIC2) == 0)\n\t\treturn (0);\n\n\tdrq = -1;\n\n\tswitch (config0 & U24_IRQ_MASK) {\n\tcase U24_IRQ10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase U24_IRQ11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase U24_IRQ14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase U24_IRQ15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"u24_find: illegal irq setting %x\\n\",\n\t\t    config0 & U24_IRQ_MASK);\n\t\treturn (0);\n\t}\n\n\tbus_space_write_1(iot, ioh, U24_LINT, UHA_ASRST);\n\n\twhile (--resetcount) {\n\t\tif (bus_space_read_1(iot, ioh, U24_LINT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* 1 mSec per loop */\n\t}\n\tif (!resetcount) {\n\t\tprintf(\"u24_find: board timed out during reset\\n\");\n\t\treturn (0);\n\t}\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t\tsc->sc_scsi_dev = config2 & U24_HOSTID_MASK;\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "EISA_SLOT_ADDR(ea->ea_slot) +\n\t    UHA_EISA_SLOT_OFFSET",
            "UHA_EISA_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ea->ea_idstring",
            "\"USC024\"",
            "6"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/uhavar.h>\n#include <dev/ic/uhareg.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tUHA_EISA_IOSIZE\t\t0x020\n#define\tUHA_EISA_SLOT_OFFSET\t0xc80\n\nint\tuha_eisa_match;\nint u24_find;\n\nint\nuha_eisa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\t/* must match one of our known ID strings */\n\tif (strncmp(ea->ea_idstring, \"USC024\", 6))\n\t\treturn (0);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +\n\t    UHA_EISA_SLOT_OFFSET, UHA_EISA_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\trv = u24_find(iot, ioh, NULL);\n\n\tbus_space_unmap(iot, ioh, UHA_EISA_IOSIZE);\n\n\treturn (rv);\n}"
  }
]