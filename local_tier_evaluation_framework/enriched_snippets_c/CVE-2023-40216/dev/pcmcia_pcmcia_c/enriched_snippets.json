[
  {
    "function_name": "pcmcia_card_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "868-909",
    "snippet": "int \npcmcia_card_intr(arg)\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = arg;\n\tstruct pcmcia_function *pf;\n\tint reg, ret, ret2;\n\n\tret = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n#ifdef PCMCIADEBUG\n\t\tprintf(\"%s: intr flags=%x fct=%d cor=%02x csr=%02x pin=%02x\",\n\t\t       sc->dev.dv_xname, pf->pf_flags, pf->number,\n\t\t       pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION),\n\t\t       pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS),\n\t\t       pcmcia_ccr_read(pf, PCMCIA_CCR_PIN));\n#endif\n\t\tif (pf->ih_fct != NULL &&\n\t\t    (pf->ccr_mask & (1 << (PCMCIA_CCR_STATUS / 2)))) {\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);\n\t\t\tif (reg & PCMCIA_CCR_STATUS_INTR) {\n\t\t\t\tret2 = (*pf->ih_fct)(pf->ih_arg);\n\t\t\t\tif (ret2 != 0 && ret == 0)\n\t\t\t\t\tret = ret2;\n\t\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);\n#ifdef PCMCIADEBUG\n\t\t\t\tprintf(\"; csr %02x->%02x\",\n\t\t\t\t    reg, reg & ~PCMCIA_CCR_STATUS_INTR);\n#endif\n\t\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS,\n\t\t\t\t    reg & ~PCMCIA_CCR_STATUS_INTR);\n\t\t\t}\n\t\t}\n#ifdef PCMCIADEBUG\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\n\treturn (ret);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__P((int why, void *arg));",
      "int pcmcia_card_intr",
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
      "int (*ih_fct)",
      "void *ih_arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_write",
          "args": [
            "pf",
            "PCMCIA_CCR_STATUS",
            "reg & ~PCMCIA_CCR_STATUS_INTR"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "87-98",
          "snippet": "void\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_read",
          "args": [
            "pf",
            "PCMCIA_CCR_STATUS"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "77-85",
          "snippet": "int\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pf->ih_arg"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pf",
            "pf_list"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n__P((int why, void *arg));\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\nvoid *ih_arg;\n\nint \npcmcia_card_intr(arg)\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = arg;\n\tstruct pcmcia_function *pf;\n\tint reg, ret, ret2;\n\n\tret = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n#ifdef PCMCIADEBUG\n\t\tprintf(\"%s: intr flags=%x fct=%d cor=%02x csr=%02x pin=%02x\",\n\t\t       sc->dev.dv_xname, pf->pf_flags, pf->number,\n\t\t       pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION),\n\t\t       pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS),\n\t\t       pcmcia_ccr_read(pf, PCMCIA_CCR_PIN));\n#endif\n\t\tif (pf->ih_fct != NULL &&\n\t\t    (pf->ccr_mask & (1 << (PCMCIA_CCR_STATUS / 2)))) {\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);\n\t\t\tif (reg & PCMCIA_CCR_STATUS_INTR) {\n\t\t\t\tret2 = (*pf->ih_fct)(pf->ih_arg);\n\t\t\t\tif (ret2 != 0 && ret == 0)\n\t\t\t\t\tret = ret2;\n\t\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);\n#ifdef PCMCIADEBUG\n\t\t\t\tprintf(\"; csr %02x->%02x\",\n\t\t\t\t    reg, reg & ~PCMCIA_CCR_STATUS_INTR);\n#endif\n\t\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS,\n\t\t\t\t    reg & ~PCMCIA_CCR_STATUS_INTR);\n\t\t\t}\n\t\t}\n#ifdef PCMCIADEBUG\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "pcmcia_intr_disestablish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "784-866",
    "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pcmcia_card_intr",
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
      "int ipl;",
      "int (*ih_fct)",
      "void *ih_arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_chip_intr_disestablish",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch",
            "ih"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_intr_establish",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch",
            "pf",
            "hiipl",
            "pcmcia_card_intr",
            "pf->sc"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_intr_disestablish",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch",
            "pf->sc->ih"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"changing ih ipl, but card has no ih\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_write",
          "args": [
            "pf",
            "PCMCIA_CCR_OPTION",
            "reg"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "87-98",
          "snippet": "void\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_read",
          "args": [
            "pf",
            "PCMCIA_CCR_OPTION"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "77-85",
          "snippet": "int\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_intr_disestablish",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch",
            "pf->sc->ih"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"disestablishing last function, but card has no ih\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mfc",
          "args": [
            "pf->sc"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
  },
  {
    "function_name": "pcmcia_io_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "624-679",
    "snippet": "int\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_ccr_write",
          "args": [
            "pf",
            "PCMCIA_CCR_OPTION",
            "reg"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "87-98",
          "snippet": "void\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_read",
          "args": [
            "pf",
            "PCMCIA_CCR_OPTION"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "77-85",
          "snippet": "int\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mfc",
          "args": [
            "pf->sc"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_io_map",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch",
            "width",
            "offset",
            "size",
            "pcihp",
            "windowp"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "pcmcia_function_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "570-622",
    "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_disable",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_free",
          "args": [
            "pf",
            "&pf->pf_pcmh"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2382-2395",
          "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_unmap",
          "args": [
            "pf",
            "pf->pf_ccr_window"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2584-2601",
          "snippet": "STATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcmcia_function_enable: function not initialized\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
  },
  {
    "function_name": "pcmcia_function_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "419-567",
    "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
      "int (*ih_fct)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_disable",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\"",
            "tmp->sc->dev.dv_xname",
            "tmp->number",
            "tmp->pf_ccr_window",
            "tmp->pf_ccr_offset",
            "pcmcia_ccr_read(tmp, 0x00)",
            "pcmcia_ccr_read(tmp, 0x02)",
            "pcmcia_ccr_read(tmp, 0x04)",
            "pcmcia_ccr_read(tmp, 0x06)",
            "pcmcia_ccr_read(tmp, 0x0A)",
            "pcmcia_ccr_read(tmp, 0x0C)",
            "pcmcia_ccr_read(tmp, 0x0E)",
            "pcmcia_ccr_read(tmp, 0x10)",
            "pcmcia_ccr_read(tmp, 0x12)"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_read",
          "args": [
            "tmp",
            "0x12"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "77-85",
          "snippet": "int\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_write",
          "args": [
            "pf",
            "PCMCIA_CCR_IOSIZE",
            "iosize"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "87-98",
          "snippet": "void\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mfc",
          "args": [
            "pf->sc"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mfc",
          "args": [
            "pf->sc"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_free",
          "args": [
            "pf",
            "&pf->pf_pcmh"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2382-2395",
          "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_map",
          "args": [
            "pf",
            "PCMCIA_MEM_ATTR",
            "pf->ccr_base",
            "PCMCIA_CCR_SIZE",
            "&pf->pf_pcmh",
            "&pf->pf_ccr_offset",
            "&pf->pf_ccr_window"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2509-2575",
          "snippet": "STATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "static void pccbb_pcmcia_do_mem_map",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_alloc",
          "args": [
            "pf",
            "PCMCIA_CCR_SIZE",
            "&pf->pf_pcmh"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2307-2373",
          "snippet": "STATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: pcmcia_function_enable on enabled func\\n\")"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_enable",
          "args": [
            "pf->sc->pct",
            "pf->sc->pch"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcmcia_function_enable: function not initialized\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
  },
  {
    "function_name": "pcmcia_socket_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "411-416",
    "snippet": "static inline void pcmcia_socket_disable(pct, pch)\n     pcmcia_chipset_tag_t pct;\n     pcmcia_chipset_handle_t *pch;\n{\n\tpcmcia_chip_socket_disable(pct, pch);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void pcmcia_socket_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_disable",
          "args": [
            "pct",
            "pch"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline void pcmcia_socket_disable;\n\nstatic inline void pcmcia_socket_disable(pct, pch)\n     pcmcia_chipset_tag_t pct;\n     pcmcia_chipset_handle_t *pch;\n{\n\tpcmcia_chip_socket_disable(pct, pch);\n}"
  },
  {
    "function_name": "pcmcia_socket_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "404-409",
    "snippet": "static inline void pcmcia_socket_enable(pct, pch)\n     pcmcia_chipset_tag_t pct;\n     pcmcia_chipset_handle_t *pch;\n{\n\tpcmcia_chip_socket_enable(pct, pch);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void pcmcia_socket_enable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_enable",
          "args": [
            "pct",
            "pch"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline void pcmcia_socket_enable;\n\nstatic inline void pcmcia_socket_enable(pct, pch)\n     pcmcia_chipset_tag_t pct;\n     pcmcia_chipset_handle_t *pch;\n{\n\tpcmcia_chip_socket_enable(pct, pch);\n}"
  },
  {
    "function_name": "pcmcia_function_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "392-402",
    "snippet": "void\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcmcia_function_init: function is enabled\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}"
  },
  {
    "function_name": "pcmcia_card_gettype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "367-386",
    "snippet": "int \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pf",
            "pf_list"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}"
  },
  {
    "function_name": "pcmcia_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "322-365",
    "snippet": "int\npcmcia_print(arg, pnp)\n\tvoid *arg;\n\tconst char *pnp;\n{\n\tstruct pcmcia_attach_args *pa = arg;\n\tstruct pcmcia_softc *sc = pa->pf->sc;\n\tstruct pcmcia_card *card = &sc->card;\n\tint i;\n\n\tif (pnp) {\n\t\tfor (i = 0; i < 4 && card->cis1_info[i]; i++)\n\t\t\tprintf(\"%s%s\", i ? \", \" : \"\\\"\", card->cis1_info[i]);\n\t\tprintf(\"\\\"\");\n\n\t\tif (card->manufacturer != PCMCIA_VENDOR_INVALID &&\n\t\t    card->product != PCMCIA_PRODUCT_INVALID) {\n\t\t\tif (i)\n\t\t\t\tprintf(\" \");\n\t\t\tprintf(\"(\");\n\t\t\tif (card->manufacturer != PCMCIA_VENDOR_INVALID)\n\t\t\t\tprintf(\"manufacturer 0x%x%s\",\n\t\t\t\t    card->manufacturer,\n\t\t\t\t    card->product == PCMCIA_PRODUCT_INVALID ?\n\t\t\t\t    \"\" : \", \");\n\t\t\tif (card->product != PCMCIA_PRODUCT_INVALID)\n\t\t\t\tprintf(\"product 0x%x\",\n\t\t\t\t    card->product);\n\t\t\tprintf(\")\");\n\t\t}\n\t\tif (i)\n\t\t\tprintf(\" \");\n\t\tprintf(\"at %s\", pnp);\n\t}\n\tprintf(\" function %d\", pa->pf->number);\n\n\tif (!pnp) {\n\t\tfor (i = 0; i < 3 && card->cis1_info[i]; i++)\n\t\t\tprintf(\"%s%s\", i ? \", \" : \" \\\"\", card->cis1_info[i]);\n\t\tprintf(\"\\\"\");\n\t}\n\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcmcia_print",
      "__P((int why, void *arg));",
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\\"\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_print;\n__P((int why, void *arg));\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_print(arg, pnp)\n\tvoid *arg;\n\tconst char *pnp;\n{\n\tstruct pcmcia_attach_args *pa = arg;\n\tstruct pcmcia_softc *sc = pa->pf->sc;\n\tstruct pcmcia_card *card = &sc->card;\n\tint i;\n\n\tif (pnp) {\n\t\tfor (i = 0; i < 4 && card->cis1_info[i]; i++)\n\t\t\tprintf(\"%s%s\", i ? \", \" : \"\\\"\", card->cis1_info[i]);\n\t\tprintf(\"\\\"\");\n\n\t\tif (card->manufacturer != PCMCIA_VENDOR_INVALID &&\n\t\t    card->product != PCMCIA_PRODUCT_INVALID) {\n\t\t\tif (i)\n\t\t\t\tprintf(\" \");\n\t\t\tprintf(\"(\");\n\t\t\tif (card->manufacturer != PCMCIA_VENDOR_INVALID)\n\t\t\t\tprintf(\"manufacturer 0x%x%s\",\n\t\t\t\t    card->manufacturer,\n\t\t\t\t    card->product == PCMCIA_PRODUCT_INVALID ?\n\t\t\t\t    \"\" : \", \");\n\t\t\tif (card->product != PCMCIA_PRODUCT_INVALID)\n\t\t\t\tprintf(\"product 0x%x\",\n\t\t\t\t    card->product);\n\t\t\tprintf(\")\");\n\t\t}\n\t\tif (i)\n\t\t\tprintf(\" \");\n\t\tprintf(\"at %s\", pnp);\n\t}\n\tprintf(\" function %d\", pa->pf->number);\n\n\tif (!pnp) {\n\t\tfor (i = 0; i < 3 && card->cis1_info[i]; i++)\n\t\t\tprintf(\"%s%s\", i ? \", \" : \" \\\"\", card->cis1_info[i]);\n\t\tprintf(\"\\\"\");\n\t}\n\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "pcmcia_submatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "306-320",
    "snippet": "int\npcmcia_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcmcia_attach_args *paa = aux;\n\n\tif (cf->cf_loc[0 /* PCMCIACF_FUNCTION */] !=\n\t    -1 /* PCMCIACF_FUNCTION_DEFAULT */ &&\n\t    cf->cf_loc[0 /* PCMCIACF_FUNCTION */] != paa->pf->number)\n\t\treturn (0);\n\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcmcia_submatch",
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "cf",
            "aux"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_submatch;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcmcia_attach_args *paa = aux;\n\n\tif (cf->cf_loc[0 /* PCMCIACF_FUNCTION */] !=\n\t    -1 /* PCMCIACF_FUNCTION_DEFAULT */ &&\n\t    cf->cf_loc[0 /* PCMCIACF_FUNCTION */] != paa->pf->number)\n\t\treturn (0);\n\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}"
  },
  {
    "function_name": "pcmcia_card_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "282-304",
    "snippet": "void\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_deactivate",
          "args": [
            "pf->child"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pf->cfe_head"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pf",
            "pf_list"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}"
  },
  {
    "function_name": "pcmcia_card_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "252-280",
    "snippet": "void\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: error %d detaching %s (function %d)\\n\"",
            "sc->dev.dv_xname",
            "error",
            "pf->child->dv_xname",
            "pf->number"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_detach",
          "args": [
            "pf->child",
            "flags"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pf->cfe_head"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pf",
            "pf_list"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}"
  },
  {
    "function_name": "pcmcia_card_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "159-250",
    "snippet": "int\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcmcia_submatch",
      "int\tpcmcia_print",
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
      "int (*ih_fct)",
      "void *ih_arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12))"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_read",
          "args": [
            "pf",
            "0x12"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "77-85",
          "snippet": "int\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found_sm",
          "args": [
            "&sc->dev",
            "&paa",
            "pcmcia_print",
            "pcmcia_submatch"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pf",
            "pf_list"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pf",
            "pf_list"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&sc->card.pf_head",
            "pf",
            "pf_list"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&pf->cfe_head"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "pf",
            "sizeof *pf"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *pf",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_print_cis",
          "args": [
            "sc"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_print_cis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
          "lines": "437-598",
          "snippet": "void\npcmcia_print_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct pcmcia_card *card = &sc->card;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n\tint i;\n\n\tprintf(\"%s: CIS version \", sc->dev.dv_xname);\n\tif (card->cis1_major == 4) {\n\t\tif (card->cis1_minor == 0)\n\t\t\tprintf(\"PCMCIA 1.0\\n\");\n\t\telse if (card->cis1_minor == 1)\n\t\t\tprintf(\"PCMCIA 2.0 or 2.1\\n\");\n\t} else if (card->cis1_major >= 5)\n\t\tprintf(\"PC Card Standard %d.%d\\n\", card->cis1_major, card->cis1_minor);\n\telse\n\t\tprintf(\"unknown (major=%d, minor=%d)\\n\",\n\t\t    card->cis1_major, card->cis1_minor);\n\n\tprintf(\"%s: CIS info: \", sc->dev.dv_xname);\n\tfor (i = 0; i < 4; i++) {\n\t\tif (card->cis1_info[i] == NULL)\n\t\t\tbreak;\n\t\tif (i)\n\t\t\tprintf(\", \");\n\t\tprintf(\"%s\", card->cis1_info[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tprintf(\"%s: Manufacturer code 0x%x, product 0x%x\\n\",\n\t       sc->dev.dv_xname, card->manufacturer, card->product);\n\n\tfor (pf = card->pf_head.sqh_first; pf != NULL;\n\t    pf = pf->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d: \", sc->dev.dv_xname, pf->number);\n\n\t\tswitch (pf->function) {\n\t\tcase PCMCIA_FUNCTION_UNSPEC:\n\t\t\tprintf(\"unspecified\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MULTIFUNCTION:\n\t\t\tprintf(\"multi-function\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MEMORY:\n\t\t\tprintf(\"memory\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SERIAL:\n\t\t\tprintf(\"serial port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_PARALLEL:\n\t\t\tprintf(\"parallel port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_DISK:\n\t\t\tprintf(\"fixed disk\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_VIDEO:\n\t\t\tprintf(\"video adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_NETWORK:\n\t\t\tprintf(\"network adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_AIMS:\n\t\t\tprintf(\"auto incrementing mass storage\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SCSI:\n\t\t\tprintf(\"SCSI bridge\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SECURITY:\n\t\t\tprintf(\"Security services\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_INSTRUMENT:\n\t\t\tprintf(\"Instrument\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"unknown (%d)\", pf->function);\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\", ccr addr %lx mask %lx\\n\", pf->ccr_base, pf->ccr_mask);\n\n\t\tfor (cfe = pf->cfe_head.sqh_first; cfe != NULL;\n\t\t    cfe = cfe->cfe_list.sqe_next) {\n\t\t\tprintf(\"%s: function %d, config table entry %d: \",\n\t\t\t    sc->dev.dv_xname, pf->number, cfe->number);\n\n\t\t\tswitch (cfe->iftype) {\n\t\t\tcase PCMCIA_IFTYPE_MEMORY:\n\t\t\t\tprintf(\"memory card\");\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_IFTYPE_IO:\n\t\t\t\tprintf(\"I/O card\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"card type unknown\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"; irq mask %x\", cfe->irqmask);\n\n\t\t\tif (cfe->num_iospace) {\n\t\t\t\tprintf(\"; iomask %lx, iospace\", cfe->iomask);\n\n\t\t\t\tfor (i = 0; i < cfe->num_iospace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx\",\n\t\t\t\t\t    cfe->iospace[i].start,\n\t\t\t\t\t    cfe->iospace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->iospace[i].start +\n\t\t\t\t\t      cfe->iospace[i].length - 1);\n\t\t\t}\n\t\t\tif (cfe->num_memspace) {\n\t\t\t\tprintf(\"; memspace\");\n\n\t\t\t\tfor (i = 0; i < cfe->num_memspace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx%s%lx\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr,\n\t\t\t\t\t    cfe->memspace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr +\n\t\t\t\t\t      cfe->memspace[i].length - 1,\n\t\t\t\t\t    cfe->memspace[i].hostaddr ?\n\t\t\t\t\t      \"@\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].hostaddr);\n\t\t\t}\n\t\t\tif (cfe->maxtwins)\n\t\t\t\tprintf(\"; maxtwins %d\", cfe->maxtwins);\n\n\t\t\tprintf(\";\");\n\n\t\t\tif (cfe->flags & PCMCIA_CFE_MWAIT_REQUIRED)\n\t\t\t\tprintf(\" mwait_required\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_RDYBSY_ACTIVE)\n\t\t\t\tprintf(\" rdybsy_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_WP_ACTIVE)\n\t\t\t\tprintf(\" wp_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_BVD_ACTIVE)\n\t\t\t\tprintf(\" bvd_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO8)\n\t\t\t\tprintf(\" io8\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO16)\n\t\t\t\tprintf(\" io16\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQSHARE)\n\t\t\t\tprintf(\" irqshare\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQPULSE)\n\t\t\t\tprintf(\" irqpulse\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQLEVEL)\n\t\t\t\tprintf(\" irqlevel\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_POWERDOWN)\n\t\t\t\tprintf(\" powerdown\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_READONLY)\n\t\t\t\tprintf(\" readonly\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_AUDIO)\n\t\t\t\tprintf(\" audio\");\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\tif (card->error)\n\t\tprintf(\"%s: %d errors found while parsing CIS\\n\",\n\t\t    sc->dev.dv_xname, card->error);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\npcmcia_print_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct pcmcia_card *card = &sc->card;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n\tint i;\n\n\tprintf(\"%s: CIS version \", sc->dev.dv_xname);\n\tif (card->cis1_major == 4) {\n\t\tif (card->cis1_minor == 0)\n\t\t\tprintf(\"PCMCIA 1.0\\n\");\n\t\telse if (card->cis1_minor == 1)\n\t\t\tprintf(\"PCMCIA 2.0 or 2.1\\n\");\n\t} else if (card->cis1_major >= 5)\n\t\tprintf(\"PC Card Standard %d.%d\\n\", card->cis1_major, card->cis1_minor);\n\telse\n\t\tprintf(\"unknown (major=%d, minor=%d)\\n\",\n\t\t    card->cis1_major, card->cis1_minor);\n\n\tprintf(\"%s: CIS info: \", sc->dev.dv_xname);\n\tfor (i = 0; i < 4; i++) {\n\t\tif (card->cis1_info[i] == NULL)\n\t\t\tbreak;\n\t\tif (i)\n\t\t\tprintf(\", \");\n\t\tprintf(\"%s\", card->cis1_info[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tprintf(\"%s: Manufacturer code 0x%x, product 0x%x\\n\",\n\t       sc->dev.dv_xname, card->manufacturer, card->product);\n\n\tfor (pf = card->pf_head.sqh_first; pf != NULL;\n\t    pf = pf->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d: \", sc->dev.dv_xname, pf->number);\n\n\t\tswitch (pf->function) {\n\t\tcase PCMCIA_FUNCTION_UNSPEC:\n\t\t\tprintf(\"unspecified\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MULTIFUNCTION:\n\t\t\tprintf(\"multi-function\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_MEMORY:\n\t\t\tprintf(\"memory\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SERIAL:\n\t\t\tprintf(\"serial port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_PARALLEL:\n\t\t\tprintf(\"parallel port\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_DISK:\n\t\t\tprintf(\"fixed disk\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_VIDEO:\n\t\t\tprintf(\"video adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_NETWORK:\n\t\t\tprintf(\"network adapter\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_AIMS:\n\t\t\tprintf(\"auto incrementing mass storage\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SCSI:\n\t\t\tprintf(\"SCSI bridge\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_SECURITY:\n\t\t\tprintf(\"Security services\");\n\t\t\tbreak;\n\t\tcase PCMCIA_FUNCTION_INSTRUMENT:\n\t\t\tprintf(\"Instrument\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"unknown (%d)\", pf->function);\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\", ccr addr %lx mask %lx\\n\", pf->ccr_base, pf->ccr_mask);\n\n\t\tfor (cfe = pf->cfe_head.sqh_first; cfe != NULL;\n\t\t    cfe = cfe->cfe_list.sqe_next) {\n\t\t\tprintf(\"%s: function %d, config table entry %d: \",\n\t\t\t    sc->dev.dv_xname, pf->number, cfe->number);\n\n\t\t\tswitch (cfe->iftype) {\n\t\t\tcase PCMCIA_IFTYPE_MEMORY:\n\t\t\t\tprintf(\"memory card\");\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_IFTYPE_IO:\n\t\t\t\tprintf(\"I/O card\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"card type unknown\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"; irq mask %x\", cfe->irqmask);\n\n\t\t\tif (cfe->num_iospace) {\n\t\t\t\tprintf(\"; iomask %lx, iospace\", cfe->iomask);\n\n\t\t\t\tfor (i = 0; i < cfe->num_iospace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx\",\n\t\t\t\t\t    cfe->iospace[i].start,\n\t\t\t\t\t    cfe->iospace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->iospace[i].start +\n\t\t\t\t\t      cfe->iospace[i].length - 1);\n\t\t\t}\n\t\t\tif (cfe->num_memspace) {\n\t\t\t\tprintf(\"; memspace\");\n\n\t\t\t\tfor (i = 0; i < cfe->num_memspace; i++)\n\t\t\t\t\tprintf(\" %lx%s%lx%s%lx\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr,\n\t\t\t\t\t    cfe->memspace[i].length ? \"-\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].cardaddr +\n\t\t\t\t\t      cfe->memspace[i].length - 1,\n\t\t\t\t\t    cfe->memspace[i].hostaddr ?\n\t\t\t\t\t      \"@\" : \"\",\n\t\t\t\t\t    cfe->memspace[i].hostaddr);\n\t\t\t}\n\t\t\tif (cfe->maxtwins)\n\t\t\t\tprintf(\"; maxtwins %d\", cfe->maxtwins);\n\n\t\t\tprintf(\";\");\n\n\t\t\tif (cfe->flags & PCMCIA_CFE_MWAIT_REQUIRED)\n\t\t\t\tprintf(\" mwait_required\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_RDYBSY_ACTIVE)\n\t\t\t\tprintf(\" rdybsy_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_WP_ACTIVE)\n\t\t\t\tprintf(\" wp_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_BVD_ACTIVE)\n\t\t\t\tprintf(\" bvd_active\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO8)\n\t\t\t\tprintf(\" io8\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IO16)\n\t\t\t\tprintf(\" io16\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQSHARE)\n\t\t\t\tprintf(\" irqshare\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQPULSE)\n\t\t\t\tprintf(\" irqpulse\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_IRQLEVEL)\n\t\t\t\tprintf(\" irqlevel\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_POWERDOWN)\n\t\t\t\tprintf(\" powerdown\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_READONLY)\n\t\t\t\tprintf(\" readonly\");\n\t\t\tif (cfe->flags & PCMCIA_CFE_AUDIO)\n\t\t\t\tprintf(\" audio\");\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\tif (card->error)\n\t\tprintf(\"%s: %d errors found while parsing CIS\\n\",\n\t\t    sc->dev.dv_xname, card->error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_check_cis_quirks",
          "args": [
            "sc"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_check_cis_quirks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis_quirks.c",
          "lines": "127-201",
          "snippet": "void pcmcia_check_cis_quirks(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tint wiped = 0;\n\tint i, j;\n\tstruct pcmcia_function *pf, *pf_next, *pf_last;\n\tstruct pcmcia_config_entry *cfe, *cfe_next;\n\n\tpf = NULL;\n\tpf_last = NULL;\n\n\t\n\tfor (i = 0; i < sizeof(pcmcia_cis_quirks)/sizeof(pcmcia_cis_quirks[0]);\n\t    i++) {\n\t\tif ((sc->card.manufacturer == pcmcia_cis_quirks[i].manufacturer) &&\n\t\t\t(sc->card.product == pcmcia_cis_quirks[i].product) &&\n\t\t\t(((sc->card.manufacturer != PCMCIA_VENDOR_INVALID) &&\n\t\t\t  (sc->card.product != PCMCIA_PRODUCT_INVALID)) ||\n\t\t\t ((sc->card.manufacturer == PCMCIA_VENDOR_INVALID) &&\n\t\t\t  (sc->card.product == PCMCIA_PRODUCT_INVALID) &&\n\t\t\t  sc->card.cis1_info[0] &&\n\t\t\t  (strcmp(sc->card.cis1_info[0],\n\t\t\t\t\t  pcmcia_cis_quirks[i].cis1_info[0]) == 0) &&\n\t\t\t  sc->card.cis1_info[1] &&\n\t\t\t  (strcmp(sc->card.cis1_info[1],\n\t\t\t\t\t  pcmcia_cis_quirks[i].cis1_info[1]) == 0)))) {\n\t\t\tif (!wiped) {\n\t\t\t\tif (pcmcia_verbose) {\n\t\t\t\t\tprintf(\"%s: using CIS quirks for \", sc->dev.dv_xname);\n\t\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\t\tif (sc->card.cis1_info[j] == NULL)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (j)\n\t\t\t\t\t\t\tprintf(\", \");\n\t\t\t\t\t\tprintf(\"%s\", sc->card.cis1_info[j]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t\t\t\t     pf = pf_next) {\n\t\t\t\t\tfor (cfe = SIMPLEQ_FIRST(&pf->cfe_head); cfe != NULL;\n\t\t\t\t\t     cfe = cfe_next) {\n\t\t\t\t\t\tcfe_next = SIMPLEQ_NEXT(cfe, cfe_list);\n\t\t\t\t\t\tfree(cfe, M_DEVBUF);\n\t\t\t\t\t}\n\t\t\t\t\tpf_next = SIMPLEQ_NEXT(pf, pf_list);\n\t\t\t\t\tfree(pf, M_DEVBUF);\n\t\t\t\t}\n\n\t\t\t\tSIMPLEQ_INIT(&sc->card.pf_head);\n\t\t\t\twiped = 1;\n\t\t\t}\n\n\t\t\tif (pf_last == pcmcia_cis_quirks[i].pf) {\n\t\t\t\tcfe = malloc(sizeof(*cfe), M_DEVBUF, M_NOWAIT);\n\t\t\t\t*cfe = *pcmcia_cis_quirks[i].cfe;\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&pf->cfe_head, cfe, cfe_list);\n\t\t\t} else {\n\t\t\t\tpf = malloc(sizeof(*pf), M_DEVBUF, M_NOWAIT);\n\t\t\t\t*pf = *pcmcia_cis_quirks[i].pf;\n\t\t\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\n\t\t\t\tcfe = malloc(sizeof(*cfe), M_DEVBUF, M_NOWAIT);\n\t\t\t\t*cfe = *pcmcia_cis_quirks[i].cfe;\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&pf->cfe_head, cfe, cfe_list);\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\n\t\t\t\tpf_last = pcmcia_cis_quirks[i].pf;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pcmcia_cis_quirk pcmcia_cis_quirks[] = {\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556, PCMCIA_CIS_INVALID, \n\t  &pcmcia_3cxem556_func0, &pcmcia_3cxem556_func0_cfe0 },\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556, PCMCIA_CIS_INVALID,\n\t  &pcmcia_3cxem556_func1, &pcmcia_3cxem556_func1_cfe0 },\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556B, PCMCIA_CIS_INVALID,\n\t  &pcmcia_3cxem556_func0, &pcmcia_3cxem556_func0_cfe0 },\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556B, PCMCIA_CIS_INVALID,\n\t  &pcmcia_3cxem556_func1, &pcmcia_3cxem556_func1_cfe0 },\n\t{ PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID, PCMCIA_CIS_SVEC_LANCARD,\n\t  &pcmcia_sveclancard_func0, &pcmcia_sveclancard_func0_cfe0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <sys/mbuf.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic struct pcmcia_cis_quirk pcmcia_cis_quirks[] = {\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556, PCMCIA_CIS_INVALID, \n\t  &pcmcia_3cxem556_func0, &pcmcia_3cxem556_func0_cfe0 },\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556, PCMCIA_CIS_INVALID,\n\t  &pcmcia_3cxem556_func1, &pcmcia_3cxem556_func1_cfe0 },\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556B, PCMCIA_CIS_INVALID,\n\t  &pcmcia_3cxem556_func0, &pcmcia_3cxem556_func0_cfe0 },\n\t{ PCMCIA_VENDOR_3COM, PCMCIA_PRODUCT_3COM_3CXEM556B, PCMCIA_CIS_INVALID,\n\t  &pcmcia_3cxem556_func1, &pcmcia_3cxem556_func1_cfe0 },\n\t{ PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID, PCMCIA_CIS_SVEC_LANCARD,\n\t  &pcmcia_sveclancard_func0, &pcmcia_sveclancard_func0_cfe0 },\n};\n\nvoid pcmcia_check_cis_quirks(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tint wiped = 0;\n\tint i, j;\n\tstruct pcmcia_function *pf, *pf_next, *pf_last;\n\tstruct pcmcia_config_entry *cfe, *cfe_next;\n\n\tpf = NULL;\n\tpf_last = NULL;\n\n\t\n\tfor (i = 0; i < sizeof(pcmcia_cis_quirks)/sizeof(pcmcia_cis_quirks[0]);\n\t    i++) {\n\t\tif ((sc->card.manufacturer == pcmcia_cis_quirks[i].manufacturer) &&\n\t\t\t(sc->card.product == pcmcia_cis_quirks[i].product) &&\n\t\t\t(((sc->card.manufacturer != PCMCIA_VENDOR_INVALID) &&\n\t\t\t  (sc->card.product != PCMCIA_PRODUCT_INVALID)) ||\n\t\t\t ((sc->card.manufacturer == PCMCIA_VENDOR_INVALID) &&\n\t\t\t  (sc->card.product == PCMCIA_PRODUCT_INVALID) &&\n\t\t\t  sc->card.cis1_info[0] &&\n\t\t\t  (strcmp(sc->card.cis1_info[0],\n\t\t\t\t\t  pcmcia_cis_quirks[i].cis1_info[0]) == 0) &&\n\t\t\t  sc->card.cis1_info[1] &&\n\t\t\t  (strcmp(sc->card.cis1_info[1],\n\t\t\t\t\t  pcmcia_cis_quirks[i].cis1_info[1]) == 0)))) {\n\t\t\tif (!wiped) {\n\t\t\t\tif (pcmcia_verbose) {\n\t\t\t\t\tprintf(\"%s: using CIS quirks for \", sc->dev.dv_xname);\n\t\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\t\tif (sc->card.cis1_info[j] == NULL)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (j)\n\t\t\t\t\t\t\tprintf(\", \");\n\t\t\t\t\t\tprintf(\"%s\", sc->card.cis1_info[j]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t\t\t\t     pf = pf_next) {\n\t\t\t\t\tfor (cfe = SIMPLEQ_FIRST(&pf->cfe_head); cfe != NULL;\n\t\t\t\t\t     cfe = cfe_next) {\n\t\t\t\t\t\tcfe_next = SIMPLEQ_NEXT(cfe, cfe_list);\n\t\t\t\t\t\tfree(cfe, M_DEVBUF);\n\t\t\t\t\t}\n\t\t\t\t\tpf_next = SIMPLEQ_NEXT(pf, pf_list);\n\t\t\t\t\tfree(pf, M_DEVBUF);\n\t\t\t\t}\n\n\t\t\t\tSIMPLEQ_INIT(&sc->card.pf_head);\n\t\t\t\twiped = 1;\n\t\t\t}\n\n\t\t\tif (pf_last == pcmcia_cis_quirks[i].pf) {\n\t\t\t\tcfe = malloc(sizeof(*cfe), M_DEVBUF, M_NOWAIT);\n\t\t\t\t*cfe = *pcmcia_cis_quirks[i].cfe;\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&pf->cfe_head, cfe, cfe_list);\n\t\t\t} else {\n\t\t\t\tpf = malloc(sizeof(*pf), M_DEVBUF, M_NOWAIT);\n\t\t\t\t*pf = *pcmcia_cis_quirks[i].pf;\n\t\t\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\n\t\t\t\tcfe = malloc(sizeof(*cfe), M_DEVBUF, M_NOWAIT);\n\t\t\t\t*cfe = *pcmcia_cis_quirks[i].cfe;\n\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&pf->cfe_head, cfe, cfe_list);\n\t\t\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\n\t\t\t\tpf_last = pcmcia_cis_quirks[i].pf;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_disable",
          "args": [
            "sc->pct",
            "sc->pch"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_read_cis",
          "args": [
            "sc"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_read_cis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
          "lines": "62-89",
          "snippet": "void\npcmcia_read_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct cis_state state;\n\n\tstate.count = 0;\n\tstate.gotmfc = 0;\n\n\tstate.card = &sc->card;\n\n\tstate.card->error = 0;\n\tstate.card->cis1_major = -1;\n\tstate.card->cis1_minor = -1;\n\tstate.card->cis1_info[0] = NULL;\n\tstate.card->cis1_info[1] = NULL;\n\tstate.card->cis1_info[2] = NULL;\n\tstate.card->cis1_info[3] = NULL;\n\tstate.card->manufacturer = PCMCIA_VENDOR_INVALID;\n\tstate.card->product = PCMCIA_PRODUCT_INVALID;\n\tSIMPLEQ_INIT(&state.card->pf_head);\n\n\tstate.pf = NULL;\n\n\tif (pcmcia_scan_cis((struct device *)sc, pcmcia_parse_cis_tuple,\n\t    &state) == -1)\n\t\tstate.card->error++;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcmcia_parse_cis_tuple"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_parse_cis_tuple;\n\nvoid\npcmcia_read_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct cis_state state;\n\n\tstate.count = 0;\n\tstate.gotmfc = 0;\n\n\tstate.card = &sc->card;\n\n\tstate.card->error = 0;\n\tstate.card->cis1_major = -1;\n\tstate.card->cis1_minor = -1;\n\tstate.card->cis1_info[0] = NULL;\n\tstate.card->cis1_info[1] = NULL;\n\tstate.card->cis1_info[2] = NULL;\n\tstate.card->cis1_info[3] = NULL;\n\tstate.card->manufacturer = PCMCIA_VENDOR_INVALID;\n\tstate.card->product = PCMCIA_PRODUCT_INVALID;\n\tSIMPLEQ_INIT(&state.card->pf_head);\n\n\tstate.pf = NULL;\n\n\tif (pcmcia_scan_cis((struct device *)sc, pcmcia_parse_cis_tuple,\n\t    &state) == -1)\n\t\tstate.card->error++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_enable",
          "args": [
            "sc->pct",
            "sc->pch"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_submatch;\nint\tpcmcia_print;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\nvoid *ih_arg;\n\nint\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}"
  },
  {
    "function_name": "pcmcia_power",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "134-157",
    "snippet": "void\npcmcia_power(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) arg;\n\tstruct pcmcia_function *pf;\n\tstruct device *d;\n\tint act = DVACT_ACTIVATE;\n\n\tif (why != PWR_RESUME)\n\t\tact = DVACT_DEACTIVATE;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\td = pf->child;\n\t\tif (d == NULL)\n\t\t\tcontinue;\n\t\tif (d->dv_cfdata->cf_attach->ca_activate)\n\t\t\t(*d->dv_cfdata->cf_attach->ca_activate)(d, act);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcmcia_power",
      "__P((int why, void *arg));",
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "d",
            "act"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pf->cfe_head"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pf",
            "pf_list"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->card.pf_head"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcmcia_power;\n__P((int why, void *arg));\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_power(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) arg;\n\tstruct pcmcia_function *pf;\n\tstruct device *d;\n\tint act = DVACT_ACTIVATE;\n\n\tif (why != PWR_RESUME)\n\t\tact = DVACT_DEACTIVATE;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\td = pf->child;\n\t\tif (d == NULL)\n\t\t\tcontinue;\n\t\tif (d->dv_cfdata->cf_attach->ca_activate)\n\t\t\t(*d->dv_cfdata->cf_attach->ca_activate)(d, act);\n\t}\n}"
  },
  {
    "function_name": "pcmcia_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "115-132",
    "snippet": "void\npcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcmciabus_attach_args *paa = aux;\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) self;\n\n\tprintf(\"\\n\");\n\n\tsc->pct = paa->pct;\n\tsc->pch = paa->pch;\n\tsc->iobase = paa->iobase;\n\tsc->iosize = paa->iosize;\n\n\tsc->ih = NULL;\n\tpowerhook_establish(pcmcia_power, sc);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcmcia_attach",
      "void\tpcmcia_power"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "powerhook_establish",
          "args": [
            "pcmcia_power",
            "sc"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcmcia_attach;\nvoid\tpcmcia_power;\n\nvoid\npcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcmciabus_attach_args *paa = aux;\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) self;\n\n\tprintf(\"\\n\");\n\n\tsc->pct = paa->pct;\n\tsc->pch = paa->pch;\n\tsc->iobase = paa->iobase;\n\tsc->iosize = paa->iosize;\n\n\tsc->ih = NULL;\n\tpowerhook_establish(pcmcia_power, sc);\n}"
  },
  {
    "function_name": "pcmcia_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "100-113",
    "snippet": "int\npcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcmciabus_attach_args *paa = aux;\n\n\tif (strcmp(paa->paa_busname, cf->cf_driver->cd_name))\n\t\treturn 0;\n\n\t/* If the autoconfiguration got this far, there's a socket here. */\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcmcia_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "paa->paa_busname",
            "cf->cf_driver->cd_name"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_match;\n\nint\npcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcmciabus_attach_args *paa = aux;\n\n\tif (strcmp(paa->paa_busname, cf->cf_driver->cd_name))\n\t\treturn 0;\n\n\t/* If the autoconfiguration got this far, there's a socket here. */\n\treturn (1);\n}"
  },
  {
    "function_name": "pcmcia_ccr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "87-98",
    "snippet": "void\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "pf->pf_ccrt",
            "pf->pf_ccrh",
            "pf->pf_ccr_offset + ccr",
            "val"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}"
  },
  {
    "function_name": "pcmcia_ccr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
    "lines": "77-85",
    "snippet": "int\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}",
    "includes": [
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "pf->pf_ccrt",
            "pf->pf_ccrh",
            "pf->pf_ccr_offset + ccr"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}"
  }
]