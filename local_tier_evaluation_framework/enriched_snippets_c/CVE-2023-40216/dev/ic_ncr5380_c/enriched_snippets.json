[
  {
    "function_name": "ncr5380_group0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "709-730",
    "snippet": "static int\nncr5380_group0(adapter, id, lun, opcode, addr, len, flags, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun, opcode, addr, len, flags;\n\tcaddr_t databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tunsigned char cmd[6];\n\tint i, j, sent;\n\n\tcmd[0] = opcode;\t\t/* Operation code */\n\tcmd[1] = (lun << 5) | ((addr >> 16) & 0x1F); /* Lun & MSB of addr */\n\tcmd[2] = (addr >> 8) & 0xFF;\t/* addr */\n\tcmd[3] = addr & 0xFF;\t\t/* LSB of addr */\n\tcmd[4] = len;\t\t\t/* Allocation length */\n\tcmd[5] = flags;\t\t\t/* Link/Flag */\n\n\ti = ncr5380_dorequest(sc, id, lun, cmd, 6, databuf, datalen, &sent);\n\n\treturn i;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr5380_dorequest",
          "args": [
            "sc",
            "id",
            "lun",
            "cmd",
            "6",
            "databuf",
            "datalen",
            "&sent"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_dorequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "615-686",
          "snippet": "static int\nncr5380_dorequest(sc, target, lun, cmd, cmdlen, databuf, datalen, sent)\n\tstruct ncr5380_softc *sc;\n\tint target, lun;\n\tu_char *cmd;\n\tint cmdlen;\n\tchar *databuf;\n\tint datalen, *sent;\n{\n\tregister volatile sci_regmap_t *regs = sc->sc_regs;\n\tint\tcmd_bytes_sent, r;\n\tu_char\tstat, msg, c;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d\\n\", target, lun);\n\t}\n#endif\n\n\t*sent = 0;\n\n\tif ( ( r = ncr5380_select_target(regs, 7, target, 1) ) != SCSI_RET_SUCCESS) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_dorequest: select returned %d\\n\", r);\n\t\t}\n#endif\n\n\t\tSCI_CLR_INTR(regs);\n\t\tswitch (r) {\n\n\t\tcase SCSI_RET_NEED_RESET:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, r=%d resetting...\\n\",\n\t\t\t\t   target, lun, r);\n\t\t\treset_adapter(sc);\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_RETRY:\n\t\t\treturn 0x08;\t/* Busy - tell common code to retry. */\n\n\t\tdefault:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, error=%d.\\n\",\n\t\t\t\ttarget, lun, r);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_DEVICE_DOWN:\n\t\t\treturn -1;\t/* Dead - tell common code to give up. */\n\t\t}\n\t}\n\n\tc = 0x80 | lun;\n\n\tif ((cmd_bytes_sent = ncr5380_command_transfer(regs, cmdlen,\n\t\t\t\t(u_char *) cmd, &stat, &c)) != cmdlen)\n\t{\n\t\tSCI_CLR_INTR(regs);\n\t\tif (cmd_bytes_sent >= 0) {\n\t\t\tprintf(\"Data underrun sending CCB (%d bytes of %d, sent).\\n\",\n\t\t\t\t   cmd_bytes_sent, cmdlen);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t*sent = ncr5380_data_transfer(regs, datalen, (u_char *)databuf,\n\t\t\t\t\t&stat, &msg);\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: data transfered = %d\\n\", *sent);\n\t}\n#endif\n\n\treturn stat;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;",
            "unsigned char\t\t*data;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nncr5380_dorequest(sc, target, lun, cmd, cmdlen, databuf, datalen, sent)\n\tstruct ncr5380_softc *sc;\n\tint target, lun;\n\tu_char *cmd;\n\tint cmdlen;\n\tchar *databuf;\n\tint datalen, *sent;\n{\n\tregister volatile sci_regmap_t *regs = sc->sc_regs;\n\tint\tcmd_bytes_sent, r;\n\tu_char\tstat, msg, c;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d\\n\", target, lun);\n\t}\n#endif\n\n\t*sent = 0;\n\n\tif ( ( r = ncr5380_select_target(regs, 7, target, 1) ) != SCSI_RET_SUCCESS) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_dorequest: select returned %d\\n\", r);\n\t\t}\n#endif\n\n\t\tSCI_CLR_INTR(regs);\n\t\tswitch (r) {\n\n\t\tcase SCSI_RET_NEED_RESET:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, r=%d resetting...\\n\",\n\t\t\t\t   target, lun, r);\n\t\t\treset_adapter(sc);\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_RETRY:\n\t\t\treturn 0x08;\t/* Busy - tell common code to retry. */\n\n\t\tdefault:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, error=%d.\\n\",\n\t\t\t\ttarget, lun, r);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_DEVICE_DOWN:\n\t\t\treturn -1;\t/* Dead - tell common code to give up. */\n\t\t}\n\t}\n\n\tc = 0x80 | lun;\n\n\tif ((cmd_bytes_sent = ncr5380_command_transfer(regs, cmdlen,\n\t\t\t\t(u_char *) cmd, &stat, &c)) != cmdlen)\n\t{\n\t\tSCI_CLR_INTR(regs);\n\t\tif (cmd_bytes_sent >= 0) {\n\t\t\tprintf(\"Data underrun sending CCB (%d bytes of %d, sent).\\n\",\n\t\t\t\t   cmd_bytes_sent, cmdlen);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t*sent = ncr5380_data_transfer(regs, datalen, (u_char *)databuf,\n\t\t\t\t\t&stat, &msg);\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: data transfered = %d\\n\", *sent);\n\t}\n#endif\n\n\treturn stat;\n}"
        }
      }
    ],
    "contextual_snippet": "static int\nncr5380_group0(adapter, id, lun, opcode, addr, len, flags, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun, opcode, addr, len, flags;\n\tcaddr_t databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tunsigned char cmd[6];\n\tint i, j, sent;\n\n\tcmd[0] = opcode;\t\t/* Operation code */\n\tcmd[1] = (lun << 5) | ((addr >> 16) & 0x1F); /* Lun & MSB of addr */\n\tcmd[2] = (addr >> 8) & 0xFF;\t/* addr */\n\tcmd[3] = addr & 0xFF;\t\t/* LSB of addr */\n\tcmd[4] = len;\t\t\t/* Allocation length */\n\tcmd[5] = flags;\t\t\t/* Link/Flag */\n\n\ti = ncr5380_dorequest(sc, id, lun, cmd, 6, databuf, datalen, &sent);\n\n\treturn i;\n}"
  },
  {
    "function_name": "ncr5380_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "688-707",
    "snippet": "static int\nncr5380_generic(adapter, id, lun, cmd, cmdlen, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun;\n\tstruct scsi_generic *cmd;\n\tint cmdlen;\n\tvoid *databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tint i, j, sent;\n\n\tif (cmd->opcode == TEST_UNIT_READY)\t/* XXX */\n\t\tcmd->bytes[0] = ((u_char) lun << 5);\n\n\ti = ncr5380_dorequest(sc, id, lun, (u_char *) cmd, cmdlen,\n\t\t\t\t\t databuf, datalen, &sent);\n\n\treturn i;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr5380_dorequest",
          "args": [
            "sc",
            "id",
            "lun",
            "(u_char *) cmd",
            "cmdlen",
            "databuf",
            "datalen",
            "&sent"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_dorequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "615-686",
          "snippet": "static int\nncr5380_dorequest(sc, target, lun, cmd, cmdlen, databuf, datalen, sent)\n\tstruct ncr5380_softc *sc;\n\tint target, lun;\n\tu_char *cmd;\n\tint cmdlen;\n\tchar *databuf;\n\tint datalen, *sent;\n{\n\tregister volatile sci_regmap_t *regs = sc->sc_regs;\n\tint\tcmd_bytes_sent, r;\n\tu_char\tstat, msg, c;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d\\n\", target, lun);\n\t}\n#endif\n\n\t*sent = 0;\n\n\tif ( ( r = ncr5380_select_target(regs, 7, target, 1) ) != SCSI_RET_SUCCESS) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_dorequest: select returned %d\\n\", r);\n\t\t}\n#endif\n\n\t\tSCI_CLR_INTR(regs);\n\t\tswitch (r) {\n\n\t\tcase SCSI_RET_NEED_RESET:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, r=%d resetting...\\n\",\n\t\t\t\t   target, lun, r);\n\t\t\treset_adapter(sc);\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_RETRY:\n\t\t\treturn 0x08;\t/* Busy - tell common code to retry. */\n\n\t\tdefault:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, error=%d.\\n\",\n\t\t\t\ttarget, lun, r);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_DEVICE_DOWN:\n\t\t\treturn -1;\t/* Dead - tell common code to give up. */\n\t\t}\n\t}\n\n\tc = 0x80 | lun;\n\n\tif ((cmd_bytes_sent = ncr5380_command_transfer(regs, cmdlen,\n\t\t\t\t(u_char *) cmd, &stat, &c)) != cmdlen)\n\t{\n\t\tSCI_CLR_INTR(regs);\n\t\tif (cmd_bytes_sent >= 0) {\n\t\t\tprintf(\"Data underrun sending CCB (%d bytes of %d, sent).\\n\",\n\t\t\t\t   cmd_bytes_sent, cmdlen);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t*sent = ncr5380_data_transfer(regs, datalen, (u_char *)databuf,\n\t\t\t\t\t&stat, &msg);\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: data transfered = %d\\n\", *sent);\n\t}\n#endif\n\n\treturn stat;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;",
            "unsigned char\t\t*data;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nncr5380_dorequest(sc, target, lun, cmd, cmdlen, databuf, datalen, sent)\n\tstruct ncr5380_softc *sc;\n\tint target, lun;\n\tu_char *cmd;\n\tint cmdlen;\n\tchar *databuf;\n\tint datalen, *sent;\n{\n\tregister volatile sci_regmap_t *regs = sc->sc_regs;\n\tint\tcmd_bytes_sent, r;\n\tu_char\tstat, msg, c;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d\\n\", target, lun);\n\t}\n#endif\n\n\t*sent = 0;\n\n\tif ( ( r = ncr5380_select_target(regs, 7, target, 1) ) != SCSI_RET_SUCCESS) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_dorequest: select returned %d\\n\", r);\n\t\t}\n#endif\n\n\t\tSCI_CLR_INTR(regs);\n\t\tswitch (r) {\n\n\t\tcase SCSI_RET_NEED_RESET:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, r=%d resetting...\\n\",\n\t\t\t\t   target, lun, r);\n\t\t\treset_adapter(sc);\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_RETRY:\n\t\t\treturn 0x08;\t/* Busy - tell common code to retry. */\n\n\t\tdefault:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, error=%d.\\n\",\n\t\t\t\ttarget, lun, r);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_DEVICE_DOWN:\n\t\t\treturn -1;\t/* Dead - tell common code to give up. */\n\t\t}\n\t}\n\n\tc = 0x80 | lun;\n\n\tif ((cmd_bytes_sent = ncr5380_command_transfer(regs, cmdlen,\n\t\t\t\t(u_char *) cmd, &stat, &c)) != cmdlen)\n\t{\n\t\tSCI_CLR_INTR(regs);\n\t\tif (cmd_bytes_sent >= 0) {\n\t\t\tprintf(\"Data underrun sending CCB (%d bytes of %d, sent).\\n\",\n\t\t\t\t   cmd_bytes_sent, cmdlen);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t*sent = ncr5380_data_transfer(regs, datalen, (u_char *)databuf,\n\t\t\t\t\t&stat, &msg);\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: data transfered = %d\\n\", *sent);\n\t}\n#endif\n\n\treturn stat;\n}"
        }
      }
    ],
    "contextual_snippet": "static int\nncr5380_generic(adapter, id, lun, cmd, cmdlen, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun;\n\tstruct scsi_generic *cmd;\n\tint cmdlen;\n\tvoid *databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tint i, j, sent;\n\n\tif (cmd->opcode == TEST_UNIT_READY)\t/* XXX */\n\t\tcmd->bytes[0] = ((u_char) lun << 5);\n\n\ti = ncr5380_dorequest(sc, id, lun, (u_char *) cmd, cmdlen,\n\t\t\t\t\t databuf, datalen, &sent);\n\n\treturn i;\n}"
  },
  {
    "function_name": "ncr5380_dorequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "615-686",
    "snippet": "static int\nncr5380_dorequest(sc, target, lun, cmd, cmdlen, databuf, datalen, sent)\n\tstruct ncr5380_softc *sc;\n\tint target, lun;\n\tu_char *cmd;\n\tint cmdlen;\n\tchar *databuf;\n\tint datalen, *sent;\n{\n\tregister volatile sci_regmap_t *regs = sc->sc_regs;\n\tint\tcmd_bytes_sent, r;\n\tu_char\tstat, msg, c;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d\\n\", target, lun);\n\t}\n#endif\n\n\t*sent = 0;\n\n\tif ( ( r = ncr5380_select_target(regs, 7, target, 1) ) != SCSI_RET_SUCCESS) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_dorequest: select returned %d\\n\", r);\n\t\t}\n#endif\n\n\t\tSCI_CLR_INTR(regs);\n\t\tswitch (r) {\n\n\t\tcase SCSI_RET_NEED_RESET:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, r=%d resetting...\\n\",\n\t\t\t\t   target, lun, r);\n\t\t\treset_adapter(sc);\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_RETRY:\n\t\t\treturn 0x08;\t/* Busy - tell common code to retry. */\n\n\t\tdefault:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, error=%d.\\n\",\n\t\t\t\ttarget, lun, r);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_DEVICE_DOWN:\n\t\t\treturn -1;\t/* Dead - tell common code to give up. */\n\t\t}\n\t}\n\n\tc = 0x80 | lun;\n\n\tif ((cmd_bytes_sent = ncr5380_command_transfer(regs, cmdlen,\n\t\t\t\t(u_char *) cmd, &stat, &c)) != cmdlen)\n\t{\n\t\tSCI_CLR_INTR(regs);\n\t\tif (cmd_bytes_sent >= 0) {\n\t\t\tprintf(\"Data underrun sending CCB (%d bytes of %d, sent).\\n\",\n\t\t\t\t   cmd_bytes_sent, cmdlen);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t*sent = ncr5380_data_transfer(regs, datalen, (u_char *)databuf,\n\t\t\t\t\t&stat, &msg);\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: data transfered = %d\\n\", *sent);\n\t}\n#endif\n\n\treturn stat;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "register volatile sci_regmap_t\t*regs;",
      "unsigned char\t\t*data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ncr5380_dorequest: data transfered = %d\\n\"",
            "*sent"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_data_transfer",
          "args": [
            "regs",
            "datalen",
            "(u_char *)databuf",
            "&stat",
            "&msg"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_data_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "535-610",
          "snippet": "static int\nncr5380_data_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data, *status, *msg;\n{\n\tint\tretlen = 0, xfer, phase;\n\n\tregs->sci_icmd = 0;\n\n\t*status = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tprintf(\"Command phase in data_transfer().\\n\");\n\t\t\t\treturn retlen;\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_IN);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_OUT);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tif (*msg == 0) {\n\t\t\t\t\treturn retlen;\n\t\t\t\t} else {\n\t\t\t\t\tprintf( \"message 0x%x in \"\n\t\t\t\t\t\t\"data_transfer.\\n\", *msg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf( \"Unexpected phase 0x%x in \"\n\t\t\t\t\t\"data_transfer().\\n\", phase);\nscsi_timeout_error:\n\t\t\t\treturn retlen;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;",
            "unsigned char\t\t*data;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nncr5380_data_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data, *status, *msg;\n{\n\tint\tretlen = 0, xfer, phase;\n\n\tregs->sci_icmd = 0;\n\n\t*status = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tprintf(\"Command phase in data_transfer().\\n\");\n\t\t\t\treturn retlen;\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_IN);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_OUT);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tif (*msg == 0) {\n\t\t\t\t\treturn retlen;\n\t\t\t\t} else {\n\t\t\t\t\tprintf( \"message 0x%x in \"\n\t\t\t\t\t\t\"data_transfer.\\n\", *msg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf( \"Unexpected phase 0x%x in \"\n\t\t\t\t\t\"data_transfer().\\n\", phase);\nscsi_timeout_error:\n\t\t\t\treturn retlen;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "regs"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_command_transfer",
          "args": [
            "regs",
            "cmdlen",
            "(u_char *) cmd",
            "&stat",
            "&c"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_command_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "468-533",
          "snippet": "static int\nncr5380_command_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data;\n\tu_char *status;\n\tu_char *msg;\n{\n\tint\txfer, phase;\n\n\txfer = 0;\n\tregs->sci_icmd = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_CMD);\n\t\t\t\txfer += sci_data_out(regs, SCSI_PHASE_CMD,\n\t\t\t\t\t\t   \tmaxlen, data);\n\t\t\t\tgoto out;\n\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tprintf(\"command_transfer: Data in phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tprintf(\"command_transfer: Data out phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tprintf(\"command_transfer: status in...\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tprintf(\"command_transfer: status=0x%x\\n\", *status);\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tprintf(\"command_transfer: msg in?\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"command_transfer: Unexpected phase 0x%x\\n\", phase);\n\t\t\t\tgoto err;\n\t\t}\n\t}\nscsi_timeout_error:\nerr:\n\txfer = -1;\nout:\n\treturn xfer;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;",
            "unsigned char\t\t*data;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nncr5380_command_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data;\n\tu_char *status;\n\tu_char *msg;\n{\n\tint\txfer, phase;\n\n\txfer = 0;\n\tregs->sci_icmd = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_CMD);\n\t\t\t\txfer += sci_data_out(regs, SCSI_PHASE_CMD,\n\t\t\t\t\t\t   \tmaxlen, data);\n\t\t\t\tgoto out;\n\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tprintf(\"command_transfer: Data in phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tprintf(\"command_transfer: Data out phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tprintf(\"command_transfer: status in...\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tprintf(\"command_transfer: status=0x%x\\n\", *status);\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tprintf(\"command_transfer: msg in?\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"command_transfer: Unexpected phase 0x%x\\n\", phase);\n\t\t\t\tgoto err;\n\t\t}\n\t}\nscsi_timeout_error:\nerr:\n\txfer = -1;\nout:\n\treturn xfer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_reset_scsibus",
          "args": [
            "sc"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_reset_scsibus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "139-161",
          "snippet": "static int\nncr5380_reset_scsibus(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_reset_scsibus\\n\");\n\t}\n#endif\n\n\tregs->sci_icmd = SCI_ICMD_RST;\n\tdelay(100);\n\tregs->sci_icmd = 0;\n\n\tregs->sci_mode = 0;\n\tregs->sci_tcmd = SCI_PHASE_DISC;\n\tregs->sci_sel_enb = 0;\n\n\tSCI_CLR_INTR(regs);\n\t/* XXX - Need long delay here! */\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\n\nstatic int\nncr5380_reset_scsibus(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_reset_scsibus\\n\");\n\t}\n#endif\n\n\tregs->sci_icmd = SCI_ICMD_RST;\n\tdelay(100);\n\tregs->sci_icmd = 0;\n\n\tregs->sci_mode = 0;\n\tregs->sci_tcmd = SCI_PHASE_DISC;\n\tregs->sci_sel_enb = 0;\n\n\tSCI_CLR_INTR(regs);\n\t/* XXX - Need long delay here! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_adapter",
          "args": [
            "sc"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "regs"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_select_target",
          "args": [
            "regs",
            "7",
            "target",
            "1"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_select_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "217-398",
          "snippet": "static int\nncr5380_select_target(regs, myid, tid, with_atn)\n\tregister volatile sci_regmap_t *regs;\n\tu_char myid, tid;\n\tint with_atn;\n{\n\tregister u_char\tbid, icmd;\n\tint\t\tret = SCSI_RET_RETRY;\n\tint \tarb_retries, arb_wait;\n\tint i;\n\n\t/* for our purposes.. */\n\tmyid = 1 << myid;\n\ttid = 1 << tid;\n\n\tregs->sci_sel_enb = 0; /* we don't want any interrupts. */\n\tregs->sci_tcmd = 0;\t/* get into a harmless state */\n\n\tarb_retries = ARBITRATION_RETRIES;\n\nretry_arbitration:\n\tregs->sci_mode = 0;\t/* get into a harmless state */\nwait_for_bus_free:\n\tif (--arb_retries <= 0) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_select: arb_retries expended; resetting...\\n\");\n\t\t}\n#endif\n\t\tret = SCSI_RET_NEED_RESET;\n\t\tgoto nosel;\n\t}\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\n\tif (regs->sci_bus_csr & (SCI_BUS_BSY|SCI_BUS_SEL)) {\n\t\t/* Something is sitting on the SCSI bus... */\n#ifdef DEBUG\n\t\t/* Only complain once (the last time through). */\n\t\tif (ncr5380_debug && (arb_retries <= 1)) {\n\t\t\tprintf(\"si_select_target: still BSY+SEL\\n\");\n\t\t}\n#endif\n\t\t/* Give it a little time, then try again. */\n\t\tdelay(10);\n\t\tgoto wait_for_bus_free;\n\t}\n\n\tregs->sci_odata = myid;\n\tregs->sci_mode = SCI_MODE_ARB;\n/*\tregs->sci_mode |= SCI_MODE_ARB;\tXXX? */\n\n\t/* AIP might not set if BSY went true after we checked */\n\t/* Wait up to about 100 usec. for it to appear. */\n\tarb_wait = 50;\t/* X2 */\n\tdo {\n\t\tif (regs->sci_icmd & SCI_ICMD_AIP)\n\t\t\tgoto got_aip;\n\t\tdelay(2);\n\t} while (--arb_wait > 0);\n\t/* XXX - Could have missed it? */\n#ifdef\tDEBUG\n\tif (ncr5380_debug)\n\t\tprintf(\"ncr5380_select_target: API did not appear\\n\");\n#endif\n\tgoto retry_arbitration;\n\n\tgot_aip:\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 4) {\n\t\tprintf(\"ncr5380_select_target: API after %d tries (last wait %d)\\n\",\n\t\t\t   ARBITRATION_RETRIES - arb_retries,\n\t\t\t   (50 - arb_wait));\n\t}\n#endif\n\n\tdelay(3);\t/* 2.2 uSec. arbitration delay */\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 1\\n\");\n#endif\n\t\tgoto retry_arbitration;\t/* XXX */\n\t}\n\n\tregs->sci_mode &= ~SCI_MODE_PAR_CHK;\n\tbid = regs->sci_data;\n\n\tif ((bid & ~myid) > myid) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 2\\n\");\n#endif\n\t\t/* Trying again will not help. */\n\t\tgoto lost;\n\t}\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 3\\n\");\n#endif\n\t\tgoto lost;\n\t}\n\n\t/* Won arbitration, enter selection phase now */\t\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\ticmd |= (with_atn ? (SCI_ICMD_SEL|SCI_ICMD_ATN) : SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"nosel\\n\");\n#endif\n\t\tgoto nosel;\n\t}\n\n\t/* XXX a target that violates specs might still drive the bus XXX */\n\t/* XXX should put our id out, and after the delay check nothi XXX */\n\t/* XXX ng else is out there.\t\t\t\t      XXX */\n\n\tdelay(3);\n\n\tregs->sci_sel_enb = 0;\n\n\tregs->sci_odata = myid | tid;\n\n\ticmd |= SCI_ICMD_BSY|SCI_ICMD_DATA;\n\tregs->sci_icmd = icmd;\n\n/*\tregs->sci_mode &= ~SCI_MODE_ARB;\t 2 deskew delays, too */\n\tregs->sci_mode = 0;\t\t\t/* 2 deskew delays, too */\n\t\n\ticmd &= ~SCI_ICMD_BSY;\n\tregs->sci_icmd = icmd;\n\n\t/* bus settle delay, 400ns */\n\tdelay(3);\n\n\tregs->sci_mode |= SCI_MODE_PAR_CHK;\n\n\t{\n\t\tregister int timeo  = 2500;/* 250 msecs in 100 usecs chunks */\n\t\twhile ((regs->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t\tif (--timeo > 0) {\n\t\t\t\tdelay(100);\n\t\t\t} else {\n\t\t\t\t/* This is the \"normal\" no-such-device select error. */\n#ifdef\tDEBUG\n\t\t\t\tif (ncr5380_debug)\n\t\t\t\t\tprintf(\"ncr5380_select: not BSY (nothing there)\\n\");\n#endif\n\t\t\t\tgoto nodev;\n\t\t\t}\n\t\t}\n\t}\n\n\ticmd &= ~(SCI_ICMD_DATA|SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n/*\tregs->sci_sel_enb = myid;*/\t/* looks like we should NOT have it */\n\t/* XXX - SCI_MODE_PAR_CHK ? */\n\treturn SCSI_RET_SUCCESS;\n\nnodev:\n\tret = SCSI_RET_DEVICE_DOWN;\n\tregs->sci_sel_enb = myid;\nnosel:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n\treturn ret;\n\nlost:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_select: lost arbitration\\n\");\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\n\nstatic int\nncr5380_select_target(regs, myid, tid, with_atn)\n\tregister volatile sci_regmap_t *regs;\n\tu_char myid, tid;\n\tint with_atn;\n{\n\tregister u_char\tbid, icmd;\n\tint\t\tret = SCSI_RET_RETRY;\n\tint \tarb_retries, arb_wait;\n\tint i;\n\n\t/* for our purposes.. */\n\tmyid = 1 << myid;\n\ttid = 1 << tid;\n\n\tregs->sci_sel_enb = 0; /* we don't want any interrupts. */\n\tregs->sci_tcmd = 0;\t/* get into a harmless state */\n\n\tarb_retries = ARBITRATION_RETRIES;\n\nretry_arbitration:\n\tregs->sci_mode = 0;\t/* get into a harmless state */\nwait_for_bus_free:\n\tif (--arb_retries <= 0) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_select: arb_retries expended; resetting...\\n\");\n\t\t}\n#endif\n\t\tret = SCSI_RET_NEED_RESET;\n\t\tgoto nosel;\n\t}\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\n\tif (regs->sci_bus_csr & (SCI_BUS_BSY|SCI_BUS_SEL)) {\n\t\t/* Something is sitting on the SCSI bus... */\n#ifdef DEBUG\n\t\t/* Only complain once (the last time through). */\n\t\tif (ncr5380_debug && (arb_retries <= 1)) {\n\t\t\tprintf(\"si_select_target: still BSY+SEL\\n\");\n\t\t}\n#endif\n\t\t/* Give it a little time, then try again. */\n\t\tdelay(10);\n\t\tgoto wait_for_bus_free;\n\t}\n\n\tregs->sci_odata = myid;\n\tregs->sci_mode = SCI_MODE_ARB;\n/*\tregs->sci_mode |= SCI_MODE_ARB;\tXXX? */\n\n\t/* AIP might not set if BSY went true after we checked */\n\t/* Wait up to about 100 usec. for it to appear. */\n\tarb_wait = 50;\t/* X2 */\n\tdo {\n\t\tif (regs->sci_icmd & SCI_ICMD_AIP)\n\t\t\tgoto got_aip;\n\t\tdelay(2);\n\t} while (--arb_wait > 0);\n\t/* XXX - Could have missed it? */\n#ifdef\tDEBUG\n\tif (ncr5380_debug)\n\t\tprintf(\"ncr5380_select_target: API did not appear\\n\");\n#endif\n\tgoto retry_arbitration;\n\n\tgot_aip:\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 4) {\n\t\tprintf(\"ncr5380_select_target: API after %d tries (last wait %d)\\n\",\n\t\t\t   ARBITRATION_RETRIES - arb_retries,\n\t\t\t   (50 - arb_wait));\n\t}\n#endif\n\n\tdelay(3);\t/* 2.2 uSec. arbitration delay */\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 1\\n\");\n#endif\n\t\tgoto retry_arbitration;\t/* XXX */\n\t}\n\n\tregs->sci_mode &= ~SCI_MODE_PAR_CHK;\n\tbid = regs->sci_data;\n\n\tif ((bid & ~myid) > myid) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 2\\n\");\n#endif\n\t\t/* Trying again will not help. */\n\t\tgoto lost;\n\t}\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 3\\n\");\n#endif\n\t\tgoto lost;\n\t}\n\n\t/* Won arbitration, enter selection phase now */\t\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\ticmd |= (with_atn ? (SCI_ICMD_SEL|SCI_ICMD_ATN) : SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"nosel\\n\");\n#endif\n\t\tgoto nosel;\n\t}\n\n\t/* XXX a target that violates specs might still drive the bus XXX */\n\t/* XXX should put our id out, and after the delay check nothi XXX */\n\t/* XXX ng else is out there.\t\t\t\t      XXX */\n\n\tdelay(3);\n\n\tregs->sci_sel_enb = 0;\n\n\tregs->sci_odata = myid | tid;\n\n\ticmd |= SCI_ICMD_BSY|SCI_ICMD_DATA;\n\tregs->sci_icmd = icmd;\n\n/*\tregs->sci_mode &= ~SCI_MODE_ARB;\t 2 deskew delays, too */\n\tregs->sci_mode = 0;\t\t\t/* 2 deskew delays, too */\n\t\n\ticmd &= ~SCI_ICMD_BSY;\n\tregs->sci_icmd = icmd;\n\n\t/* bus settle delay, 400ns */\n\tdelay(3);\n\n\tregs->sci_mode |= SCI_MODE_PAR_CHK;\n\n\t{\n\t\tregister int timeo  = 2500;/* 250 msecs in 100 usecs chunks */\n\t\twhile ((regs->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t\tif (--timeo > 0) {\n\t\t\t\tdelay(100);\n\t\t\t} else {\n\t\t\t\t/* This is the \"normal\" no-such-device select error. */\n#ifdef\tDEBUG\n\t\t\t\tif (ncr5380_debug)\n\t\t\t\t\tprintf(\"ncr5380_select: not BSY (nothing there)\\n\");\n#endif\n\t\t\t\tgoto nodev;\n\t\t\t}\n\t\t}\n\t}\n\n\ticmd &= ~(SCI_ICMD_DATA|SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n/*\tregs->sci_sel_enb = myid;*/\t/* looks like we should NOT have it */\n\t/* XXX - SCI_MODE_PAR_CHK ? */\n\treturn SCSI_RET_SUCCESS;\n\nnodev:\n\tret = SCSI_RET_DEVICE_DOWN;\n\tregs->sci_sel_enb = myid;\nnosel:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n\treturn ret;\n\nlost:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_select: lost arbitration\\n\");\n\t}\n#endif\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nncr5380_dorequest(sc, target, lun, cmd, cmdlen, databuf, datalen, sent)\n\tstruct ncr5380_softc *sc;\n\tint target, lun;\n\tu_char *cmd;\n\tint cmdlen;\n\tchar *databuf;\n\tint datalen, *sent;\n{\n\tregister volatile sci_regmap_t *regs = sc->sc_regs;\n\tint\tcmd_bytes_sent, r;\n\tu_char\tstat, msg, c;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d\\n\", target, lun);\n\t}\n#endif\n\n\t*sent = 0;\n\n\tif ( ( r = ncr5380_select_target(regs, 7, target, 1) ) != SCSI_RET_SUCCESS) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_dorequest: select returned %d\\n\", r);\n\t\t}\n#endif\n\n\t\tSCI_CLR_INTR(regs);\n\t\tswitch (r) {\n\n\t\tcase SCSI_RET_NEED_RESET:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, r=%d resetting...\\n\",\n\t\t\t\t   target, lun, r);\n\t\t\treset_adapter(sc);\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_RETRY:\n\t\t\treturn 0x08;\t/* Busy - tell common code to retry. */\n\n\t\tdefault:\n\t\t\tprintf(\"ncr5380_dorequest: target=%d, lun=%d, error=%d.\\n\",\n\t\t\t\ttarget, lun, r);\n\t\t\t/* fall through */\n\t\tcase SCSI_RET_DEVICE_DOWN:\n\t\t\treturn -1;\t/* Dead - tell common code to give up. */\n\t\t}\n\t}\n\n\tc = 0x80 | lun;\n\n\tif ((cmd_bytes_sent = ncr5380_command_transfer(regs, cmdlen,\n\t\t\t\t(u_char *) cmd, &stat, &c)) != cmdlen)\n\t{\n\t\tSCI_CLR_INTR(regs);\n\t\tif (cmd_bytes_sent >= 0) {\n\t\t\tprintf(\"Data underrun sending CCB (%d bytes of %d, sent).\\n\",\n\t\t\t\t   cmd_bytes_sent, cmdlen);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t*sent = ncr5380_data_transfer(regs, datalen, (u_char *)databuf,\n\t\t\t\t\t&stat, &msg);\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_dorequest: data transfered = %d\\n\", *sent);\n\t}\n#endif\n\n\treturn stat;\n}"
  },
  {
    "function_name": "ncr5380_data_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "535-610",
    "snippet": "static int\nncr5380_data_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data, *status, *msg;\n{\n\tint\tretlen = 0, xfer, phase;\n\n\tregs->sci_icmd = 0;\n\n\t*status = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tprintf(\"Command phase in data_transfer().\\n\");\n\t\t\t\treturn retlen;\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_IN);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_OUT);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tif (*msg == 0) {\n\t\t\t\t\treturn retlen;\n\t\t\t\t} else {\n\t\t\t\t\tprintf( \"message 0x%x in \"\n\t\t\t\t\t\t\"data_transfer.\\n\", *msg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf( \"Unexpected phase 0x%x in \"\n\t\t\t\t\t\"data_transfer().\\n\", phase);\nscsi_timeout_error:\n\t\t\t\treturn retlen;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "register volatile sci_regmap_t\t*regs;",
      "unsigned char\t\t*data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unexpected phase 0x%x in \"\n\t\t\t\t\t\"data_transfer().\\n\"",
            "phase"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sci_data_out",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_OUT",
            "1",
            "msg"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_OUT"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sci_data_in",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_IN",
            "1",
            "msg"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "sci_data_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "432-463",
          "snippet": "static int\nsci_data_in(regs, phase, count, data)\n\tregister volatile sci_regmap_t\t*regs;\n\tunsigned char\t\t\t*data;\n{\n\tregister unsigned char\ticmd;\n\tregister int\t\tcnt=0;\n\n\t/* ..checks.. */\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\nloop:\n\t/* SCSI bus phase not valid until REQ is true. */\n\tWAIT_FOR_REQ(regs);\n\tif (SCI_CUR_PHASE(regs->sci_bus_csr) != phase)\n\t\treturn cnt;\n\n\t*data++ = regs->sci_data;\n\ticmd |= SCI_ICMD_ACK;\n\tregs->sci_icmd = icmd;\n\n\ticmd &= ~SCI_ICMD_ACK;\n\tWAIT_FOR_NOT_REQ(regs);\n\tregs->sci_icmd = icmd;\n\t++cnt;\n\tif (--count > 0)\n\t\tgoto loop;\n\nscsi_timeout_error:\n\treturn cnt;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;",
            "unsigned char\t\t*data;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nsci_data_in(regs, phase, count, data)\n\tregister volatile sci_regmap_t\t*regs;\n\tunsigned char\t\t\t*data;\n{\n\tregister unsigned char\ticmd;\n\tregister int\t\tcnt=0;\n\n\t/* ..checks.. */\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\nloop:\n\t/* SCSI bus phase not valid until REQ is true. */\n\tWAIT_FOR_REQ(regs);\n\tif (SCI_CUR_PHASE(regs->sci_bus_csr) != phase)\n\t\treturn cnt;\n\n\t*data++ = regs->sci_data;\n\ticmd |= SCI_ICMD_ACK;\n\tregs->sci_icmd = icmd;\n\n\ticmd &= ~SCI_ICMD_ACK;\n\tWAIT_FOR_NOT_REQ(regs);\n\tregs->sci_icmd = icmd;\n\t++cnt;\n\tif (--count > 0)\n\t\tgoto loop;\n\nscsi_timeout_error:\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_IN"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_STATUS"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sci_data_out",
          "args": [
            "regs",
            "SCSI_PHASE_DATA_OUT",
            "maxlen",
            "data"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sci_pdma_out",
          "args": [
            "regs",
            "SCSI_PHASE_DATA_OUT",
            "maxlen",
            "data"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_DATA_OUT"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sci_pdma_in",
          "args": [
            "regs",
            "SCSI_PHASE_DATA_IN",
            "maxlen",
            "data"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_DATA_IN"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_CUR_PHASE",
          "args": [
            "regs->sci_bus_csr"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_FOR_REQ",
          "args": [
            "regs"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nncr5380_data_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data, *status, *msg;\n{\n\tint\tretlen = 0, xfer, phase;\n\n\tregs->sci_icmd = 0;\n\n\t*status = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tprintf(\"Command phase in data_transfer().\\n\");\n\t\t\t\treturn retlen;\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_IN);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_in(regs, SCSI_PHASE_DATA_IN,\n\t\t\t\t\t\t  \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_DATA_OUT);\n#if PSEUDO_DMA\n\t\t\t\txfer = sci_pdma_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#else\n\t\t\t\txfer = sci_data_out(regs, SCSI_PHASE_DATA_OUT,\n\t\t\t\t\t\t   \tmaxlen, data);\n#endif\n\t\t\t\tretlen += xfer;\n\t\t\t\tmaxlen -= xfer;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tif (*msg == 0) {\n\t\t\t\t\treturn retlen;\n\t\t\t\t} else {\n\t\t\t\t\tprintf( \"message 0x%x in \"\n\t\t\t\t\t\t\"data_transfer.\\n\", *msg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf( \"Unexpected phase 0x%x in \"\n\t\t\t\t\t\"data_transfer().\\n\", phase);\nscsi_timeout_error:\n\t\t\t\treturn retlen;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ncr5380_command_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "468-533",
    "snippet": "static int\nncr5380_command_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data;\n\tu_char *status;\n\tu_char *msg;\n{\n\tint\txfer, phase;\n\n\txfer = 0;\n\tregs->sci_icmd = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_CMD);\n\t\t\t\txfer += sci_data_out(regs, SCSI_PHASE_CMD,\n\t\t\t\t\t\t   \tmaxlen, data);\n\t\t\t\tgoto out;\n\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tprintf(\"command_transfer: Data in phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tprintf(\"command_transfer: Data out phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tprintf(\"command_transfer: status in...\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tprintf(\"command_transfer: status=0x%x\\n\", *status);\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tprintf(\"command_transfer: msg in?\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"command_transfer: Unexpected phase 0x%x\\n\", phase);\n\t\t\t\tgoto err;\n\t\t}\n\t}\nscsi_timeout_error:\nerr:\n\txfer = -1;\nout:\n\treturn xfer;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "register volatile sci_regmap_t\t*regs;",
      "unsigned char\t\t*data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"command_transfer: Unexpected phase 0x%x\\n\"",
            "phase"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sci_data_out",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_OUT",
            "1",
            "msg"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_OUT"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sci_data_in",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_IN",
            "1",
            "msg"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "sci_data_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "432-463",
          "snippet": "static int\nsci_data_in(regs, phase, count, data)\n\tregister volatile sci_regmap_t\t*regs;\n\tunsigned char\t\t\t*data;\n{\n\tregister unsigned char\ticmd;\n\tregister int\t\tcnt=0;\n\n\t/* ..checks.. */\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\nloop:\n\t/* SCSI bus phase not valid until REQ is true. */\n\tWAIT_FOR_REQ(regs);\n\tif (SCI_CUR_PHASE(regs->sci_bus_csr) != phase)\n\t\treturn cnt;\n\n\t*data++ = regs->sci_data;\n\ticmd |= SCI_ICMD_ACK;\n\tregs->sci_icmd = icmd;\n\n\ticmd &= ~SCI_ICMD_ACK;\n\tWAIT_FOR_NOT_REQ(regs);\n\tregs->sci_icmd = icmd;\n\t++cnt;\n\tif (--count > 0)\n\t\tgoto loop;\n\nscsi_timeout_error:\n\treturn cnt;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;",
            "unsigned char\t\t*data;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nsci_data_in(regs, phase, count, data)\n\tregister volatile sci_regmap_t\t*regs;\n\tunsigned char\t\t\t*data;\n{\n\tregister unsigned char\ticmd;\n\tregister int\t\tcnt=0;\n\n\t/* ..checks.. */\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\nloop:\n\t/* SCSI bus phase not valid until REQ is true. */\n\tWAIT_FOR_REQ(regs);\n\tif (SCI_CUR_PHASE(regs->sci_bus_csr) != phase)\n\t\treturn cnt;\n\n\t*data++ = regs->sci_data;\n\ticmd |= SCI_ICMD_ACK;\n\tregs->sci_icmd = icmd;\n\n\ticmd &= ~SCI_ICMD_ACK;\n\tWAIT_FOR_NOT_REQ(regs);\n\tregs->sci_icmd = icmd;\n\t++cnt;\n\tif (--count > 0)\n\t\tgoto loop;\n\nscsi_timeout_error:\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_MESSAGE_IN"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_STATUS"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sci_data_out",
          "args": [
            "regs",
            "SCSI_PHASE_CMD",
            "maxlen",
            "data"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_ACK",
          "args": [
            "regs",
            "SCSI_PHASE_CMD"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_CUR_PHASE",
          "args": [
            "regs->sci_bus_csr"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_FOR_REQ",
          "args": [
            "regs"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nncr5380_command_transfer(regs, maxlen, data, status, msg)\n\tregister volatile sci_regmap_t *regs;\n\tint maxlen;\n\tu_char *data;\n\tu_char *status;\n\tu_char *msg;\n{\n\tint\txfer, phase;\n\n\txfer = 0;\n\tregs->sci_icmd = 0;\n\n\twhile (1) {\n\n\t\tWAIT_FOR_REQ(regs);\n\n\t\tphase = SCI_CUR_PHASE(regs->sci_bus_csr);\n\n\t\tswitch (phase) {\n\t\t\tcase SCSI_PHASE_CMD:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_CMD);\n\t\t\t\txfer += sci_data_out(regs, SCSI_PHASE_CMD,\n\t\t\t\t\t\t   \tmaxlen, data);\n\t\t\t\tgoto out;\n\n\t\t\tcase SCSI_PHASE_DATA_IN:\n\t\t\t\tprintf(\"command_transfer: Data in phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_DATA_OUT:\n\t\t\t\tprintf(\"command_transfer: Data out phase?\\n\");\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_STATUS:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_STATUS);\n\t\t\t\tprintf(\"command_transfer: status in...\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_STATUS,\n\t\t\t\t\t  \t1, status);\n\t\t\t\tprintf(\"command_transfer: status=0x%x\\n\", *status);\n\t\t\t\tgoto err;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_IN:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_IN);\n\t\t\t\tprintf(\"command_transfer: msg in?\\n\");\n\t\t\t\tsci_data_in(regs, SCSI_PHASE_MESSAGE_IN,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tcase SCSI_PHASE_MESSAGE_OUT:\n\t\t\t\tSCI_ACK(regs,SCSI_PHASE_MESSAGE_OUT);\n\t\t\t\tsci_data_out(regs, SCSI_PHASE_MESSAGE_OUT,\n\t\t\t\t\t  \t1, msg);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"command_transfer: Unexpected phase 0x%x\\n\", phase);\n\t\t\t\tgoto err;\n\t\t}\n\t}\nscsi_timeout_error:\nerr:\n\txfer = -1;\nout:\n\treturn xfer;\n}"
  },
  {
    "function_name": "sci_data_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "432-463",
    "snippet": "static int\nsci_data_in(regs, phase, count, data)\n\tregister volatile sci_regmap_t\t*regs;\n\tunsigned char\t\t\t*data;\n{\n\tregister unsigned char\ticmd;\n\tregister int\t\tcnt=0;\n\n\t/* ..checks.. */\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\nloop:\n\t/* SCSI bus phase not valid until REQ is true. */\n\tWAIT_FOR_REQ(regs);\n\tif (SCI_CUR_PHASE(regs->sci_bus_csr) != phase)\n\t\treturn cnt;\n\n\t*data++ = regs->sci_data;\n\ticmd |= SCI_ICMD_ACK;\n\tregs->sci_icmd = icmd;\n\n\ticmd &= ~SCI_ICMD_ACK;\n\tWAIT_FOR_NOT_REQ(regs);\n\tregs->sci_icmd = icmd;\n\t++cnt;\n\tif (--count > 0)\n\t\tgoto loop;\n\nscsi_timeout_error:\n\treturn cnt;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "register volatile sci_regmap_t\t*regs;",
      "unsigned char\t\t*data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WAIT_FOR_NOT_REQ",
          "args": [
            "regs"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_CUR_PHASE",
          "args": [
            "regs->sci_bus_csr"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_FOR_REQ",
          "args": [
            "regs"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "register volatile sci_regmap_t\t*regs;\nunsigned char\t\t*data;\n\nstatic int\nsci_data_in(regs, phase, count, data)\n\tregister volatile sci_regmap_t\t*regs;\n\tunsigned char\t\t\t*data;\n{\n\tregister unsigned char\ticmd;\n\tregister int\t\tcnt=0;\n\n\t/* ..checks.. */\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\nloop:\n\t/* SCSI bus phase not valid until REQ is true. */\n\tWAIT_FOR_REQ(regs);\n\tif (SCI_CUR_PHASE(regs->sci_bus_csr) != phase)\n\t\treturn cnt;\n\n\t*data++ = regs->sci_data;\n\ticmd |= SCI_ICMD_ACK;\n\tregs->sci_icmd = icmd;\n\n\ticmd &= ~SCI_ICMD_ACK;\n\tWAIT_FOR_NOT_REQ(regs);\n\tregs->sci_icmd = icmd;\n\t++cnt;\n\tif (--count > 0)\n\t\tgoto loop;\n\nscsi_timeout_error:\n\treturn cnt;\n}"
  },
  {
    "function_name": "ncr5380_select_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "217-398",
    "snippet": "static int\nncr5380_select_target(regs, myid, tid, with_atn)\n\tregister volatile sci_regmap_t *regs;\n\tu_char myid, tid;\n\tint with_atn;\n{\n\tregister u_char\tbid, icmd;\n\tint\t\tret = SCSI_RET_RETRY;\n\tint \tarb_retries, arb_wait;\n\tint i;\n\n\t/* for our purposes.. */\n\tmyid = 1 << myid;\n\ttid = 1 << tid;\n\n\tregs->sci_sel_enb = 0; /* we don't want any interrupts. */\n\tregs->sci_tcmd = 0;\t/* get into a harmless state */\n\n\tarb_retries = ARBITRATION_RETRIES;\n\nretry_arbitration:\n\tregs->sci_mode = 0;\t/* get into a harmless state */\nwait_for_bus_free:\n\tif (--arb_retries <= 0) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_select: arb_retries expended; resetting...\\n\");\n\t\t}\n#endif\n\t\tret = SCSI_RET_NEED_RESET;\n\t\tgoto nosel;\n\t}\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\n\tif (regs->sci_bus_csr & (SCI_BUS_BSY|SCI_BUS_SEL)) {\n\t\t/* Something is sitting on the SCSI bus... */\n#ifdef DEBUG\n\t\t/* Only complain once (the last time through). */\n\t\tif (ncr5380_debug && (arb_retries <= 1)) {\n\t\t\tprintf(\"si_select_target: still BSY+SEL\\n\");\n\t\t}\n#endif\n\t\t/* Give it a little time, then try again. */\n\t\tdelay(10);\n\t\tgoto wait_for_bus_free;\n\t}\n\n\tregs->sci_odata = myid;\n\tregs->sci_mode = SCI_MODE_ARB;\n/*\tregs->sci_mode |= SCI_MODE_ARB;\tXXX? */\n\n\t/* AIP might not set if BSY went true after we checked */\n\t/* Wait up to about 100 usec. for it to appear. */\n\tarb_wait = 50;\t/* X2 */\n\tdo {\n\t\tif (regs->sci_icmd & SCI_ICMD_AIP)\n\t\t\tgoto got_aip;\n\t\tdelay(2);\n\t} while (--arb_wait > 0);\n\t/* XXX - Could have missed it? */\n#ifdef\tDEBUG\n\tif (ncr5380_debug)\n\t\tprintf(\"ncr5380_select_target: API did not appear\\n\");\n#endif\n\tgoto retry_arbitration;\n\n\tgot_aip:\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 4) {\n\t\tprintf(\"ncr5380_select_target: API after %d tries (last wait %d)\\n\",\n\t\t\t   ARBITRATION_RETRIES - arb_retries,\n\t\t\t   (50 - arb_wait));\n\t}\n#endif\n\n\tdelay(3);\t/* 2.2 uSec. arbitration delay */\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 1\\n\");\n#endif\n\t\tgoto retry_arbitration;\t/* XXX */\n\t}\n\n\tregs->sci_mode &= ~SCI_MODE_PAR_CHK;\n\tbid = regs->sci_data;\n\n\tif ((bid & ~myid) > myid) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 2\\n\");\n#endif\n\t\t/* Trying again will not help. */\n\t\tgoto lost;\n\t}\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 3\\n\");\n#endif\n\t\tgoto lost;\n\t}\n\n\t/* Won arbitration, enter selection phase now */\t\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\ticmd |= (with_atn ? (SCI_ICMD_SEL|SCI_ICMD_ATN) : SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"nosel\\n\");\n#endif\n\t\tgoto nosel;\n\t}\n\n\t/* XXX a target that violates specs might still drive the bus XXX */\n\t/* XXX should put our id out, and after the delay check nothi XXX */\n\t/* XXX ng else is out there.\t\t\t\t      XXX */\n\n\tdelay(3);\n\n\tregs->sci_sel_enb = 0;\n\n\tregs->sci_odata = myid | tid;\n\n\ticmd |= SCI_ICMD_BSY|SCI_ICMD_DATA;\n\tregs->sci_icmd = icmd;\n\n/*\tregs->sci_mode &= ~SCI_MODE_ARB;\t 2 deskew delays, too */\n\tregs->sci_mode = 0;\t\t\t/* 2 deskew delays, too */\n\t\n\ticmd &= ~SCI_ICMD_BSY;\n\tregs->sci_icmd = icmd;\n\n\t/* bus settle delay, 400ns */\n\tdelay(3);\n\n\tregs->sci_mode |= SCI_MODE_PAR_CHK;\n\n\t{\n\t\tregister int timeo  = 2500;/* 250 msecs in 100 usecs chunks */\n\t\twhile ((regs->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t\tif (--timeo > 0) {\n\t\t\t\tdelay(100);\n\t\t\t} else {\n\t\t\t\t/* This is the \"normal\" no-such-device select error. */\n#ifdef\tDEBUG\n\t\t\t\tif (ncr5380_debug)\n\t\t\t\t\tprintf(\"ncr5380_select: not BSY (nothing there)\\n\");\n#endif\n\t\t\t\tgoto nodev;\n\t\t\t}\n\t\t}\n\t}\n\n\ticmd &= ~(SCI_ICMD_DATA|SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n/*\tregs->sci_sel_enb = myid;*/\t/* looks like we should NOT have it */\n\t/* XXX - SCI_MODE_PAR_CHK ? */\n\treturn SCSI_RET_SUCCESS;\n\nnodev:\n\tret = SCSI_RET_DEVICE_DOWN;\n\tregs->sci_sel_enb = myid;\nnosel:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n\treturn ret;\n\nlost:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_select: lost arbitration\\n\");\n\t}\n#endif\n\treturn ret;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "register volatile sci_regmap_t\t*regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ncr5380_select: lost arbitration\\n\""
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      }
    ],
    "contextual_snippet": "register volatile sci_regmap_t\t*regs;\n\nstatic int\nncr5380_select_target(regs, myid, tid, with_atn)\n\tregister volatile sci_regmap_t *regs;\n\tu_char myid, tid;\n\tint with_atn;\n{\n\tregister u_char\tbid, icmd;\n\tint\t\tret = SCSI_RET_RETRY;\n\tint \tarb_retries, arb_wait;\n\tint i;\n\n\t/* for our purposes.. */\n\tmyid = 1 << myid;\n\ttid = 1 << tid;\n\n\tregs->sci_sel_enb = 0; /* we don't want any interrupts. */\n\tregs->sci_tcmd = 0;\t/* get into a harmless state */\n\n\tarb_retries = ARBITRATION_RETRIES;\n\nretry_arbitration:\n\tregs->sci_mode = 0;\t/* get into a harmless state */\nwait_for_bus_free:\n\tif (--arb_retries <= 0) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug) {\n\t\t\tprintf(\"ncr5380_select: arb_retries expended; resetting...\\n\");\n\t\t}\n#endif\n\t\tret = SCSI_RET_NEED_RESET;\n\t\tgoto nosel;\n\t}\n\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\n\tif (regs->sci_bus_csr & (SCI_BUS_BSY|SCI_BUS_SEL)) {\n\t\t/* Something is sitting on the SCSI bus... */\n#ifdef DEBUG\n\t\t/* Only complain once (the last time through). */\n\t\tif (ncr5380_debug && (arb_retries <= 1)) {\n\t\t\tprintf(\"si_select_target: still BSY+SEL\\n\");\n\t\t}\n#endif\n\t\t/* Give it a little time, then try again. */\n\t\tdelay(10);\n\t\tgoto wait_for_bus_free;\n\t}\n\n\tregs->sci_odata = myid;\n\tregs->sci_mode = SCI_MODE_ARB;\n/*\tregs->sci_mode |= SCI_MODE_ARB;\tXXX? */\n\n\t/* AIP might not set if BSY went true after we checked */\n\t/* Wait up to about 100 usec. for it to appear. */\n\tarb_wait = 50;\t/* X2 */\n\tdo {\n\t\tif (regs->sci_icmd & SCI_ICMD_AIP)\n\t\t\tgoto got_aip;\n\t\tdelay(2);\n\t} while (--arb_wait > 0);\n\t/* XXX - Could have missed it? */\n#ifdef\tDEBUG\n\tif (ncr5380_debug)\n\t\tprintf(\"ncr5380_select_target: API did not appear\\n\");\n#endif\n\tgoto retry_arbitration;\n\n\tgot_aip:\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 4) {\n\t\tprintf(\"ncr5380_select_target: API after %d tries (last wait %d)\\n\",\n\t\t\t   ARBITRATION_RETRIES - arb_retries,\n\t\t\t   (50 - arb_wait));\n\t}\n#endif\n\n\tdelay(3);\t/* 2.2 uSec. arbitration delay */\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 1\\n\");\n#endif\n\t\tgoto retry_arbitration;\t/* XXX */\n\t}\n\n\tregs->sci_mode &= ~SCI_MODE_PAR_CHK;\n\tbid = regs->sci_data;\n\n\tif ((bid & ~myid) > myid) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 2\\n\");\n#endif\n\t\t/* Trying again will not help. */\n\t\tgoto lost;\n\t}\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"lost 3\\n\");\n#endif\n\t\tgoto lost;\n\t}\n\n\t/* Won arbitration, enter selection phase now */\t\n\ticmd = regs->sci_icmd & ~(SCI_ICMD_DIFF|SCI_ICMD_TEST);\n\ticmd |= (with_atn ? (SCI_ICMD_SEL|SCI_ICMD_ATN) : SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n\n\tif (regs->sci_icmd & SCI_ICMD_LST) {\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf (\"nosel\\n\");\n#endif\n\t\tgoto nosel;\n\t}\n\n\t/* XXX a target that violates specs might still drive the bus XXX */\n\t/* XXX should put our id out, and after the delay check nothi XXX */\n\t/* XXX ng else is out there.\t\t\t\t      XXX */\n\n\tdelay(3);\n\n\tregs->sci_sel_enb = 0;\n\n\tregs->sci_odata = myid | tid;\n\n\ticmd |= SCI_ICMD_BSY|SCI_ICMD_DATA;\n\tregs->sci_icmd = icmd;\n\n/*\tregs->sci_mode &= ~SCI_MODE_ARB;\t 2 deskew delays, too */\n\tregs->sci_mode = 0;\t\t\t/* 2 deskew delays, too */\n\t\n\ticmd &= ~SCI_ICMD_BSY;\n\tregs->sci_icmd = icmd;\n\n\t/* bus settle delay, 400ns */\n\tdelay(3);\n\n\tregs->sci_mode |= SCI_MODE_PAR_CHK;\n\n\t{\n\t\tregister int timeo  = 2500;/* 250 msecs in 100 usecs chunks */\n\t\twhile ((regs->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t\tif (--timeo > 0) {\n\t\t\t\tdelay(100);\n\t\t\t} else {\n\t\t\t\t/* This is the \"normal\" no-such-device select error. */\n#ifdef\tDEBUG\n\t\t\t\tif (ncr5380_debug)\n\t\t\t\t\tprintf(\"ncr5380_select: not BSY (nothing there)\\n\");\n#endif\n\t\t\t\tgoto nodev;\n\t\t\t}\n\t\t}\n\t}\n\n\ticmd &= ~(SCI_ICMD_DATA|SCI_ICMD_SEL);\n\tregs->sci_icmd = icmd;\n/*\tregs->sci_sel_enb = myid;*/\t/* looks like we should NOT have it */\n\t/* XXX - SCI_MODE_PAR_CHK ? */\n\treturn SCSI_RET_SUCCESS;\n\nnodev:\n\tret = SCSI_RET_DEVICE_DOWN;\n\tregs->sci_sel_enb = myid;\nnosel:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n\treturn ret;\n\nlost:\n\tregs->sci_icmd = 0;\n\tregs->sci_mode = 0;\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_select: lost arbitration\\n\");\n\t}\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "ncr5380_send_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "169-215",
    "snippet": "static int\nncr5380_send_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tint\tsense;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 2)\n\t\tncr5380_show_scsi_cmd(xs);\n#endif\n\n\tsense = ncr5380_generic( xs->sc_link->adapter_softc,\n\t    xs->sc_link->target, xs->sc_link->lun, xs->cmd,\n\t    xs->cmdlen, xs->data, xs->datalen );\n\n\tswitch (sense) {\n\tcase 0:\t/* success */\n\t\txs->resid = 0;\n\t\txs->error = XS_NOERROR;\n\t\tbreak;\n\n\tcase 0x02:\t/* Check condition */\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf(\"check cond. target %d.\\n\",\n\t\t\t\t   xs->sc_link->target);\n#endif\n\t\tdelay(10);\t/* Phil's fix for slow devices. */\n\t\tncr5380_group0(xs->sc_link->adapter_softc,\n\t\t\t\t  xs->sc_link->target,\n\t\t\t\t  xs->sc_link->lun,\n\t\t\t\t  0x3, 0x0,\n\t\t\t\t  sizeof(struct scsi_sense_data),\n\t\t\t\t  0, (caddr_t) &(xs->sense),\n\t\t\t\t  sizeof(struct scsi_sense_data));\n\t\txs->error = XS_SENSE;\n\t\tbreak;\n\tcase 0x08:\t/* Busy - common code will delay, retry. */\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\tdefault:\t/* Dead - tell common code to give up. */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\n\t}\n\treturn (COMPLETE);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "unsigned char\t\t*data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr5380_group0",
          "args": [
            "xs->sc_link->adapter_softc",
            "xs->sc_link->target",
            "xs->sc_link->lun",
            "0x3",
            "0x0",
            "sizeof(struct scsi_sense_data)",
            "0",
            "(caddr_t) &(xs->sense)",
            "sizeof(struct scsi_sense_data)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_group0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "709-730",
          "snippet": "static int\nncr5380_group0(adapter, id, lun, opcode, addr, len, flags, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun, opcode, addr, len, flags;\n\tcaddr_t databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tunsigned char cmd[6];\n\tint i, j, sent;\n\n\tcmd[0] = opcode;\t\t/* Operation code */\n\tcmd[1] = (lun << 5) | ((addr >> 16) & 0x1F); /* Lun & MSB of addr */\n\tcmd[2] = (addr >> 8) & 0xFF;\t/* addr */\n\tcmd[3] = addr & 0xFF;\t\t/* LSB of addr */\n\tcmd[4] = len;\t\t\t/* Allocation length */\n\tcmd[5] = flags;\t\t\t/* Link/Flag */\n\n\ti = ncr5380_dorequest(sc, id, lun, cmd, 6, databuf, datalen, &sent);\n\n\treturn i;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int\nncr5380_group0(adapter, id, lun, opcode, addr, len, flags, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun, opcode, addr, len, flags;\n\tcaddr_t databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tunsigned char cmd[6];\n\tint i, j, sent;\n\n\tcmd[0] = opcode;\t\t/* Operation code */\n\tcmd[1] = (lun << 5) | ((addr >> 16) & 0x1F); /* Lun & MSB of addr */\n\tcmd[2] = (addr >> 8) & 0xFF;\t/* addr */\n\tcmd[3] = addr & 0xFF;\t\t/* LSB of addr */\n\tcmd[4] = len;\t\t\t/* Allocation length */\n\tcmd[5] = flags;\t\t\t/* Link/Flag */\n\n\ti = ncr5380_dorequest(sc, id, lun, cmd, 6, databuf, datalen, &sent);\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"check cond. target %d.\\n\"",
            "xs->sc_link->target"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_generic",
          "args": [
            "xs->sc_link->adapter_softc",
            "xs->sc_link->target",
            "xs->sc_link->lun",
            "xs->cmd",
            "xs->cmdlen",
            "xs->data",
            "xs->datalen"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "688-707",
          "snippet": "static int\nncr5380_generic(adapter, id, lun, cmd, cmdlen, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun;\n\tstruct scsi_generic *cmd;\n\tint cmdlen;\n\tvoid *databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tint i, j, sent;\n\n\tif (cmd->opcode == TEST_UNIT_READY)\t/* XXX */\n\t\tcmd->bytes[0] = ((u_char) lun << 5);\n\n\ti = ncr5380_dorequest(sc, id, lun, (u_char *) cmd, cmdlen,\n\t\t\t\t\t databuf, datalen, &sent);\n\n\treturn i;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int\nncr5380_generic(adapter, id, lun, cmd, cmdlen, databuf, datalen)\n\tvoid *adapter;\n\tint id, lun;\n\tstruct scsi_generic *cmd;\n\tint cmdlen;\n\tvoid *databuf;\n\tint datalen;\n{\n\tregister struct ncr5380_softc *sc = adapter;\n\tint i, j, sent;\n\n\tif (cmd->opcode == TEST_UNIT_READY)\t/* XXX */\n\t\tcmd->bytes[0] = ((u_char) lun << 5);\n\n\ti = ncr5380_dorequest(sc, id, lun, (u_char *) cmd, cmdlen,\n\t\t\t\t\t databuf, datalen, &sent);\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_show_scsi_cmd",
          "args": [
            "xs"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_show_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "90-113",
          "snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "unsigned char\t\t*data;\n\nstatic int\nncr5380_send_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tint\tsense;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 2)\n\t\tncr5380_show_scsi_cmd(xs);\n#endif\n\n\tsense = ncr5380_generic( xs->sc_link->adapter_softc,\n\t    xs->sc_link->target, xs->sc_link->lun, xs->cmd,\n\t    xs->cmdlen, xs->data, xs->datalen );\n\n\tswitch (sense) {\n\tcase 0:\t/* success */\n\t\txs->resid = 0;\n\t\txs->error = XS_NOERROR;\n\t\tbreak;\n\n\tcase 0x02:\t/* Check condition */\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf(\"check cond. target %d.\\n\",\n\t\t\t\t   xs->sc_link->target);\n#endif\n\t\tdelay(10);\t/* Phil's fix for slow devices. */\n\t\tncr5380_group0(xs->sc_link->adapter_softc,\n\t\t\t\t  xs->sc_link->target,\n\t\t\t\t  xs->sc_link->lun,\n\t\t\t\t  0x3, 0x0,\n\t\t\t\t  sizeof(struct scsi_sense_data),\n\t\t\t\t  0, (caddr_t) &(xs->sense),\n\t\t\t\t  sizeof(struct scsi_sense_data));\n\t\txs->error = XS_SENSE;\n\t\tbreak;\n\tcase 0x08:\t/* Busy - common code will delay, retry. */\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\tdefault:\t/* Dead - tell common code to give up. */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\n\t}\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "ncr5380_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "163-167",
    "snippet": "static int\nncr5380_poll(adapter, timeout)\n\tint adapter, timeout;\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static int\nncr5380_poll(adapter, timeout)\n\tint adapter, timeout;\n{\n}"
  },
  {
    "function_name": "ncr5380_reset_scsibus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "139-161",
    "snippet": "static int\nncr5380_reset_scsibus(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_reset_scsibus\\n\");\n\t}\n#endif\n\n\tregs->sci_icmd = SCI_ICMD_RST;\n\tdelay(100);\n\tregs->sci_icmd = 0;\n\n\tregs->sci_mode = 0;\n\tregs->sci_tcmd = SCI_PHASE_DISC;\n\tregs->sci_sel_enb = 0;\n\n\tSCI_CLR_INTR(regs);\n\t/* XXX - Need long delay here! */\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "register volatile sci_regmap_t\t*regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "regs"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ncr5380_reset_scsibus\\n\""
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "register volatile sci_regmap_t\t*regs;\n\nstatic int\nncr5380_reset_scsibus(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_reset_scsibus\\n\");\n\t}\n#endif\n\n\tregs->sci_icmd = SCI_ICMD_RST;\n\tdelay(100);\n\tregs->sci_icmd = 0;\n\n\tregs->sci_mode = 0;\n\tregs->sci_tcmd = SCI_PHASE_DISC;\n\tregs->sci_sel_enb = 0;\n\n\tSCI_CLR_INTR(regs);\n\t/* XXX - Need long delay here! */\n}"
  },
  {
    "function_name": "ncr5380_sbc_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "120-137",
    "snippet": "static void\nncr5380_sbc_intr(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n\tif ((regs->sci_csr & SCI_CSR_INT) == 0) {\n#ifdef\tDEBUG\n\t\tprintf (\" ncr5380_sbc_intr: spurious\\n\");\n#endif\n\t\treturn;\n\t}\n\n\tSCI_CLR_INTR(regs);\n#ifdef\tDEBUG\n\tprintf (\" ncr5380_sbc_intr\\n\");\n#endif\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "register volatile sci_regmap_t\t*regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ncr5380_sbc_intr\\n\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "regs"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "register volatile sci_regmap_t\t*regs;\n\nstatic void\nncr5380_sbc_intr(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n\tif ((regs->sci_csr & SCI_CSR_INT) == 0) {\n#ifdef\tDEBUG\n\t\tprintf (\" ncr5380_sbc_intr: spurious\\n\");\n#endif\n\t\treturn;\n\t}\n\n\tSCI_CLR_INTR(regs);\n#ifdef\tDEBUG\n\tprintf (\" ncr5380_sbc_intr\\n\");\n#endif\n}"
  },
  {
    "function_name": "ncr5380_show_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "90-113",
    "snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"si(%d:%d:%d)-RESET-\\n\"",
            "xs->sc_link->scsibus",
            "xs->sc_link->target",
            "xs->sc_link->lun"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}"
  },
  {
    "function_name": "ncr5380_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
    "lines": "45-87",
    "snippet": "static int\nncr5380_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tint flags, s, r;\n\n\tflags = xs->flags;\n\tif (xs->bp) flags |= (SCSI_NOSLEEP);\n\tif ( flags & ITSDONE ) {\n\t\tprintf(\"Already done?\");\n\t\txs->flags &= ~ITSDONE;\n\t}\n\tif ( ! ( flags & INUSE ) ) {\n\t\tprintf(\"Not in use?\");\n\t\txs->flags |= INUSE;\n\t}\n\n\ts = splbio();\n\n\tif ( flags & SCSI_RESET ) {\n\t\tprintf(\"flags & SCSIRESET.\\n\");\n\t\tncr5380_reset_scsibus(xs->sc_link->adapter_softc);\n\t\tr = COMPLETE;\n\t} else {\n\t\tr = ncr5380_send_cmd(xs);\n\t\txs->flags |= ITSDONE;\n\t\tscsi_done(xs);\n\t}\n\n\tsplx(s);\n\n\tswitch(r) {\n\tcase COMPLETE:\n\tcase SUCCESSFULLY_QUEUED:\n\t\tr = SUCCESSFULLY_QUEUED;\n\t\tif (xs->flags & SCSI_POLL)\n\t\t\tr = COMPLETE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn r;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_send_cmd",
          "args": [
            "xs"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "169-215",
          "snippet": "static int\nncr5380_send_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tint\tsense;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 2)\n\t\tncr5380_show_scsi_cmd(xs);\n#endif\n\n\tsense = ncr5380_generic( xs->sc_link->adapter_softc,\n\t    xs->sc_link->target, xs->sc_link->lun, xs->cmd,\n\t    xs->cmdlen, xs->data, xs->datalen );\n\n\tswitch (sense) {\n\tcase 0:\t/* success */\n\t\txs->resid = 0;\n\t\txs->error = XS_NOERROR;\n\t\tbreak;\n\n\tcase 0x02:\t/* Check condition */\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf(\"check cond. target %d.\\n\",\n\t\t\t\t   xs->sc_link->target);\n#endif\n\t\tdelay(10);\t/* Phil's fix for slow devices. */\n\t\tncr5380_group0(xs->sc_link->adapter_softc,\n\t\t\t\t  xs->sc_link->target,\n\t\t\t\t  xs->sc_link->lun,\n\t\t\t\t  0x3, 0x0,\n\t\t\t\t  sizeof(struct scsi_sense_data),\n\t\t\t\t  0, (caddr_t) &(xs->sense),\n\t\t\t\t  sizeof(struct scsi_sense_data));\n\t\txs->error = XS_SENSE;\n\t\tbreak;\n\tcase 0x08:\t/* Busy - common code will delay, retry. */\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\tdefault:\t/* Dead - tell common code to give up. */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\n\t}\n\treturn (COMPLETE);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "unsigned char\t\t*data;"
          ],
          "called_functions": [],
          "contextual_snippet": "unsigned char\t\t*data;\n\nstatic int\nncr5380_send_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tint\tsense;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug & 2)\n\t\tncr5380_show_scsi_cmd(xs);\n#endif\n\n\tsense = ncr5380_generic( xs->sc_link->adapter_softc,\n\t    xs->sc_link->target, xs->sc_link->lun, xs->cmd,\n\t    xs->cmdlen, xs->data, xs->datalen );\n\n\tswitch (sense) {\n\tcase 0:\t/* success */\n\t\txs->resid = 0;\n\t\txs->error = XS_NOERROR;\n\t\tbreak;\n\n\tcase 0x02:\t/* Check condition */\n#ifdef\tDEBUG\n\t\tif (ncr5380_debug)\n\t\t\tprintf(\"check cond. target %d.\\n\",\n\t\t\t\t   xs->sc_link->target);\n#endif\n\t\tdelay(10);\t/* Phil's fix for slow devices. */\n\t\tncr5380_group0(xs->sc_link->adapter_softc,\n\t\t\t\t  xs->sc_link->target,\n\t\t\t\t  xs->sc_link->lun,\n\t\t\t\t  0x3, 0x0,\n\t\t\t\t  sizeof(struct scsi_sense_data),\n\t\t\t\t  0, (caddr_t) &(xs->sense),\n\t\t\t\t  sizeof(struct scsi_sense_data));\n\t\txs->error = XS_SENSE;\n\t\tbreak;\n\tcase 0x08:\t/* Busy - common code will delay, retry. */\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\tdefault:\t/* Dead - tell common code to give up. */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\n\t}\n\treturn (COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_reset_scsibus",
          "args": [
            "xs->sc_link->adapter_softc"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_reset_scsibus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "139-161",
          "snippet": "static int\nncr5380_reset_scsibus(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_reset_scsibus\\n\");\n\t}\n#endif\n\n\tregs->sci_icmd = SCI_ICMD_RST;\n\tdelay(100);\n\tregs->sci_icmd = 0;\n\n\tregs->sci_mode = 0;\n\tregs->sci_tcmd = SCI_PHASE_DISC;\n\tregs->sci_sel_enb = 0;\n\n\tSCI_CLR_INTR(regs);\n\t/* XXX - Need long delay here! */\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "register volatile sci_regmap_t\t*regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "register volatile sci_regmap_t\t*regs;\n\nstatic int\nncr5380_reset_scsibus(ncr5380)\n\tstruct ncr5380_softc *ncr5380;\n{\n\tvolatile sci_regmap_t *regs = ncr5380->sc_regs;\n\n#ifdef\tDEBUG\n\tif (ncr5380_debug) {\n\t\tprintf(\"ncr5380_reset_scsibus\\n\");\n\t}\n#endif\n\n\tregs->sci_icmd = SCI_ICMD_RST;\n\tdelay(100);\n\tregs->sci_icmd = 0;\n\n\tregs->sci_mode = 0;\n\tregs->sci_tcmd = SCI_PHASE_DISC;\n\tregs->sci_sel_enb = 0;\n\n\tSCI_CLR_INTR(regs);\n\t/* XXX - Need long delay here! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"flags & SCSIRESET.\\n\""
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int\nncr5380_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tint flags, s, r;\n\n\tflags = xs->flags;\n\tif (xs->bp) flags |= (SCSI_NOSLEEP);\n\tif ( flags & ITSDONE ) {\n\t\tprintf(\"Already done?\");\n\t\txs->flags &= ~ITSDONE;\n\t}\n\tif ( ! ( flags & INUSE ) ) {\n\t\tprintf(\"Not in use?\");\n\t\txs->flags |= INUSE;\n\t}\n\n\ts = splbio();\n\n\tif ( flags & SCSI_RESET ) {\n\t\tprintf(\"flags & SCSIRESET.\\n\");\n\t\tncr5380_reset_scsibus(xs->sc_link->adapter_softc);\n\t\tr = COMPLETE;\n\t} else {\n\t\tr = ncr5380_send_cmd(xs);\n\t\txs->flags |= ITSDONE;\n\t\tscsi_done(xs);\n\t}\n\n\tsplx(s);\n\n\tswitch(r) {\n\tcase COMPLETE:\n\tcase SUCCESSFULLY_QUEUED:\n\t\tr = SUCCESSFULLY_QUEUED;\n\t\tif (xs->flags & SCSI_POLL)\n\t\t\tr = COMPLETE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn r;\n}"
  }
]