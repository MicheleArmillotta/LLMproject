[
  {
    "function_name": "pdq_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "1327-1575",
    "snippet": "pdq_t *\npdq_initialize(\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    const char *name,\n    int unit,\n    void *ctx,\n    pdq_type_t type)\n{\n    pdq_t *pdq;\n    pdq_state_t state;\n    const pdq_uint32_t contig_bytes = (sizeof(pdq_descriptor_block_t) * 2) - PDQ_OS_PAGESIZE;\n    pdq_uint8_t *p;\n    int idx;\n\n    PDQ_ASSERT(sizeof(pdq_descriptor_block_t) == 8192);\n    PDQ_ASSERT(sizeof(pdq_consumer_block_t) == 64);\n    PDQ_ASSERT(sizeof(pdq_response_filter_get_t) == PDQ_SIZE_RESPONSE_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_cmd_addr_filter_set_t) == PDQ_SIZE_CMD_ADDR_FILTER_SET);\n    PDQ_ASSERT(sizeof(pdq_response_addr_filter_get_t) == PDQ_SIZE_RESPONSE_ADDR_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_response_status_chars_get_t) == PDQ_SIZE_RESPONSE_STATUS_CHARS_GET);\n    PDQ_ASSERT(sizeof(pdq_response_fddi_mib_get_t) == PDQ_SIZE_RESPONSE_FDDI_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_response_dec_ext_mib_get_t) == PDQ_SIZE_RESPONSE_DEC_EXT_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_unsolicited_event_t) == 512);\n\n    pdq = (pdq_t *) PDQ_OS_MEMALLOC(sizeof(pdq_t));\n    if (pdq == NULL) {\n\tPDQ_PRINTF((\"malloc(%d) failed\\n\", sizeof(*pdq)));\n\treturn NULL;\n    }\n    PDQ_OS_MEMZERO(pdq, sizeof(pdq_t));\n    pdq->pdq_type = type;\n    pdq->pdq_unit = unit;\n    pdq->pdq_os_ctx = (void *) ctx;\n    pdq->pdq_os_name = name;\n    pdq->pdq_flags = PDQ_PRINTCHARS;\n    /*\n     * Allocate the additional data structures required by\n     * the PDQ driver.  Allocate a contiguous region of memory\n     * for the descriptor block.  We need to allocated enough\n     * to guarantee that we will a get 8KB block of memory aligned\n     * on a 8KB boundary.  This turns to require that we allocate\n     * (N*2 - 1 page) pages of memory.  On machine with less than\n     * a 8KB page size, it mean we will allocate more memory than\n     * we need.  The extra will be used for the unsolicited event\n     * buffers (though on machines with 8KB pages we will to allocate\n     * them separately since there will be nothing left overs.)\n     */\n    p = (pdq_uint8_t *) PDQ_OS_MEMALLOC_CONTIG(contig_bytes);\n    if (p != NULL) {\n\tpdq_physaddr_t physaddr = PDQ_OS_VA_TO_PA(pdq, p);\n\t/*\n\t * Assert that we really got contiguous memory.  This isn't really\n\t * needed on systems that actually have physical contiguous allocation\n\t * routines, but on those systems that don't ...\n\t */\n\tfor (idx = PDQ_OS_PAGESIZE; idx < 0x2000; idx += PDQ_OS_PAGESIZE) {\n\t    if (PDQ_OS_VA_TO_PA(pdq, p + idx) - physaddr != idx)\n\t\tgoto cleanup_and_return;\n\t}\n\tphysaddr &= 0x1FFF;\n\tif (physaddr) {\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) p;\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) &p[0x2000 - physaddr];\n\t} else {\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) p;\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) &p[0x2000];\n\t}\n    }\n    if (contig_bytes == sizeof(pdq_descriptor_block_t)) {\n\tpdq->pdq_unsolicited_info.ui_events =\n\t    (pdq_unsolicited_event_t *) PDQ_OS_MEMALLOC(\n\t\tPDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n    }\n\n    /*\n     * Make sure everything got allocated.  If not, free what did\n     * get allocated and return.\n     */\n    if (pdq->pdq_dbp == NULL || pdq->pdq_unsolicited_info.ui_events == NULL) {\n      cleanup_and_return:\n\tif (p /* pdq->pdq_dbp */ != NULL)\n\t    PDQ_OS_MEMFREE_CONTIG(p /* pdq->pdq_dbp */, contig_bytes);\n\tif (contig_bytes == sizeof(pdq_descriptor_block_t) && pdq->pdq_unsolicited_info.ui_events != NULL)\n\t    PDQ_OS_MEMFREE(pdq->pdq_unsolicited_info.ui_events,\n\t\t\t   PDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n\tPDQ_OS_MEMFREE(pdq, sizeof(pdq_t));\n\treturn NULL;\n    }\n\n    pdq->pdq_cbp = (volatile pdq_consumer_block_t *) &pdq->pdq_dbp->pdqdb_consumer;\n    pdq->pdq_command_info.ci_bufstart = (pdq_uint8_t *) pdq->pdq_dbp->pdqdb_command_pool;\n    pdq->pdq_rx_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_receive_buffers;\n\n    pdq->pdq_host_smt_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_host_smt_buffers;\n\n    PDQ_PRINTF((\"\\nPDQ Descriptor Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp));\n    PDQ_PRINTF((\"    Recieve Queue          = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_receives));\n    PDQ_PRINTF((\"    Transmit Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_transmits));\n    PDQ_PRINTF((\"    Host SMT Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_host_smt));\n    PDQ_PRINTF((\"    Command Response Queue = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_responses));\n    PDQ_PRINTF((\"    Command Request Queue  = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_requests));\n    PDQ_PRINTF((\"PDQ Consumer Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_cbp));\n\n    /*\n     * Zero out the descriptor block.  Not really required but\n     * it pays to be neat.  This will also zero out the consumer\n     * block, command pool, and buffer pointers for the receive\n     * host_smt rings.\n     */\n    PDQ_OS_MEMZERO(pdq->pdq_dbp, sizeof(*pdq->pdq_dbp));\n\n    /*\n     * Initialize the CSR references.\n     * the DEFAA (FutureBus+) skips a longword between registers\n     */\n    pdq_init_csrs(&pdq->pdq_csrs, bus, csr_base, pdq->pdq_type == PDQ_DEFAA ? 2 : 1);\n    if (pdq->pdq_type == PDQ_DEFPA)\n\tpdq_init_pci_csrs(&pdq->pdq_pci_csrs, bus, csr_base, 1);\n\n    PDQ_PRINTF((\"PDQ CSRs: BASE = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_csrs.csr_base));\n    PDQ_PRINTF((\"    Port Reset                = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_reset, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_reset)));\n    PDQ_PRINTF((\"    Host Data                 = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_data, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_data)));\n    PDQ_PRINTF((\"    Port Control              = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_control, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_control)));\n    PDQ_PRINTF((\"    Port Data A               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_a, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_a)));\n    PDQ_PRINTF((\"    Port Data B               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_b, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_b)));\n    PDQ_PRINTF((\"    Port Status               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_status, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status)));\n    PDQ_PRINTF((\"    Host Int Type 0           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_type_0, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0)));\n    PDQ_PRINTF((\"    Host Int Enable           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_enable, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_enable)));\n    PDQ_PRINTF((\"    Type 2 Producer           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_type_2_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_type_2_producer)));\n    PDQ_PRINTF((\"    Command Response Producer = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_response_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_response_producer)));\n    PDQ_PRINTF((\"    Command Request Producer  = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_request_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_request_producer)));\n    PDQ_PRINTF((\"    Host SMT Producer         = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_smt_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_smt_producer)));\n    PDQ_PRINTF((\"    Unsolicited Producer      = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_unsolicited_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_unsolicited_producer)));\n\n    /*\n     * Initialize the command information block\n     */\n    pdq->pdq_command_info.ci_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_command_info.ci_bufstart);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_requests)/sizeof(pdq->pdq_dbp->pdqdb_command_requests[0]); idx++) {\n\tpdq_txdesc_t *txd = &pdq->pdq_dbp->pdqdb_command_requests[idx];\n\n\ttxd->txd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\ttxd->txd_eop = txd->txd_sop = 1;\n\ttxd->txd_pa_hi = 0;\n    }\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_responses)/sizeof(pdq->pdq_dbp->pdqdb_command_responses[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_command_responses[idx];\n\n\trxd->rxd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_lo = 0;\n    }\n\n    /*\n     * Initialize the unsolicited event information block\n     */\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_unsolicited_info.ui_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_unsolicited_info.ui_events);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events)/sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_unsolicited_events[idx];\n\tpdq_unsolicited_event_t *event = &pdq->pdq_unsolicited_info.ui_events[idx & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_hi = sizeof(pdq_unsolicited_event_t) / 16;\n\trxd->rxd_pa_lo = pdq->pdq_unsolicited_info.ui_pa_bufstart + (const pdq_uint8_t *) event\n\t    - (const pdq_uint8_t *) pdq->pdq_unsolicited_info.ui_events;\n\trxd->rxd_pa_hi = 0;\n    }\n    /*\n     * Initialize the receive information blocks (normal and SMT).\n     */\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    pdq->pdq_rx_info.rx_target = pdq->pdq_rx_info.rx_free - PDQ_RX_SEGCNT * 8;\n\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n    pdq->pdq_host_smt_info.rx_target = pdq->pdq_host_smt_info.rx_free - PDQ_RX_SEGCNT * 3;\n\n    /*\n     * Initialize the transmit information block.\n     */\n    pdq->pdq_tx_hdr[0] = PDQ_FDDI_PH0;\n    pdq->pdq_tx_hdr[1] = PDQ_FDDI_PH1;\n    pdq->pdq_tx_hdr[2] = PDQ_FDDI_PH2;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_seg_len = sizeof(pdq->pdq_tx_hdr);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_sop = 1;\n    pdq->pdq_tx_info.tx_hdrdesc.txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_tx_hdr);\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n\n    /*\n     * Stop the PDQ if it is running and put it into a known state.\n     */\n    state = pdq_stop(pdq);\n\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    /*\n     * If the adapter is not the state we expect, then the initialization\n     * failed.  Cleanup and exit.\n     */\n#if defined(PDQVERBOSE)\n    if (state == PDQS_HALTED) {\n\tpdq_halt_code_t halt_code = PDQ_PSTS_HALT_ID(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n\tprintf(\"Halt code = %d (%s)\\n\", halt_code, pdq_halt_codes[halt_code]);\n\tif (halt_code == PDQH_DMA_ERROR && pdq->pdq_type == PDQ_DEFPA)\n\t    PDQ_PRINTF((\"PFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t       PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0) & PDQ_HOST_INT_FATAL_ERROR));\n    }\n#endif\n    if (state == PDQS_RESET || state == PDQS_HALTED || state == PDQS_UPGRADE)\n\tgoto cleanup_and_return;\n\n    PDQ_PRINTF((\"PDQ Hardware Address = %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n\t   pdq->pdq_hwaddr.lanaddr_bytes[0], pdq->pdq_hwaddr.lanaddr_bytes[1],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[2], pdq->pdq_hwaddr.lanaddr_bytes[3],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[4], pdq->pdq_hwaddr.lanaddr_bytes[5]));\n    PDQ_PRINTF((\"PDQ Firmware Revision = %c%c%c%c\\n\",\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3]));\n    PDQ_PRINTF((\"PDQ Chip Revision = \"));\n    switch (pdq->pdq_chip_rev) {\n\tcase PDQ_CHIP_REV_A_B_OR_C: PDQ_PRINTF((\"Rev C or below\")); break;\n\tcase PDQ_CHIP_REV_D: PDQ_PRINTF((\"Rev D\")); break;\n\tcase PDQ_CHIP_REV_E: PDQ_PRINTF((\"Rev E\")); break;\n\tdefault: PDQ_PRINTF((\"Unknown Rev %d\", (int) pdq->pdq_chip_rev));\n    }\n    PDQ_PRINTF((\"\\n\"));\n\n    return pdq;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const pdq_halt_codes[] = {\n    \"Selftest Timeout\", \"Host Bus Parity Error\", \"Host Directed Fault\",\n    \"Software Fault\", \"Hardware Fault\", \"PC Trace Path Test\",\n    \"DMA Error\", \"Image CRC Error\", \"Adapter Processer Error\"\n};",
      "static const char * const pdq_adapter_states[] = {\n    \"Reset\", \"Upgrade\", \"DMA Unavailable\", \"DMA Available\",\n    \"Link Available\", \"Link Unavailable\", \"Halted\", \"Ring Member\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"Unknown Rev %d\", (int) pdq->pdq_chip_rev)"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"Rev E\")"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"Rev D\")"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"Rev C or below\")"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Chip Revision = \")"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Firmware Revision = %c%c%c%c\\n\",\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3])"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Hardware Address = %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n\t   pdq->pdq_hwaddr.lanaddr_bytes[0], pdq->pdq_hwaddr.lanaddr_bytes[1],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[2], pdq->pdq_hwaddr.lanaddr_bytes[3],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[4], pdq->pdq_hwaddr.lanaddr_bytes[5])"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t       PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0) & PDQ_HOST_INT_FATAL_ERROR)"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_host_int_type_0"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_status"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Halt code = %d (%s)\\n\"",
            "halt_code",
            "pdq_halt_codes[halt_code]"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_HALT_ID",
          "args": [
            "PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status)"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_port_status"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state == PDQS_DMA_AVAILABLE"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state])"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_stop",
          "args": [
            "pdq"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "975-1168",
          "snippet": "pdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\npdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state])"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status)"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_port_status"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "pdq->pdq_tx_hdr"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_transmits"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_host_smt"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_receives"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "pdq->pdq_unsolicited_info.ui_events"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "pdq->pdq_command_info.ci_bufstart"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Unsolicited Producer      = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_unsolicited_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_unsolicited_producer))"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_unsolicited_producer"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Host SMT Producer         = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_smt_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_smt_producer))"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_host_smt_producer"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Command Request Producer  = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_request_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_request_producer))"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_cmd_request_producer"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Command Response Producer = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_response_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_response_producer))"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_cmd_response_producer"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Type 2 Producer           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_type_2_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_type_2_producer))"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_type_2_producer"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Host Int Enable           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_enable, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_enable))"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_host_int_enable"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Host Int Type 0           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_type_0, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0))"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_host_int_type_0"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Port Status               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_status, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status))"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_port_status"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Port Data B               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_b, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_b))"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_port_data_b"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Port Data A               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_a, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_a))"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_port_data_a"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Port Control              = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_control, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_control))"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_port_control"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Host Data                 = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_data, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_data))"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_host_data"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Port Reset                = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_reset, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_reset))"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_csrs",
            "csr_port_reset"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ CSRs: BASE = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_csrs.csr_base)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_init_pci_csrs",
          "args": [
            "&pdq->pdq_pci_csrs",
            "bus",
            "csr_base",
            "1"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_init_pci_csrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "236-249",
          "snippet": "static void\npdq_init_pci_csrs(\n    pdq_pci_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_pfi_mode_control\t= PDQ_CSR_OFFSET(csr_base, 16 * csrsize);\n    csrs->csr_pfi_status\t= PDQ_CSR_OFFSET(csr_base, 17 * csrsize);\n    csrs->csr_fifo_write\t= PDQ_CSR_OFFSET(csr_base, 18 * csrsize);\n    csrs->csr_fifo_read\t\t= PDQ_CSR_OFFSET(csr_base, 19 * csrsize);\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_init_pci_csrs(\n    pdq_pci_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_pfi_mode_control\t= PDQ_CSR_OFFSET(csr_base, 16 * csrsize);\n    csrs->csr_pfi_status\t= PDQ_CSR_OFFSET(csr_base, 17 * csrsize);\n    csrs->csr_fifo_write\t= PDQ_CSR_OFFSET(csr_base, 18 * csrsize);\n    csrs->csr_fifo_read\t\t= PDQ_CSR_OFFSET(csr_base, 19 * csrsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_init_csrs",
          "args": [
            "&pdq->pdq_csrs",
            "bus",
            "csr_base",
            "pdq->pdq_type == PDQ_DEFAA ? 2 : 1"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_init_csrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "212-234",
          "snippet": "static void\npdq_init_csrs(\n    pdq_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_port_reset\t\t= PDQ_CSR_OFFSET(csr_base,  0 * csrsize);\n    csrs->csr_host_data\t\t\t= PDQ_CSR_OFFSET(csr_base,  1 * csrsize);\n    csrs->csr_port_control\t\t= PDQ_CSR_OFFSET(csr_base,  2 * csrsize);\n    csrs->csr_port_data_a\t\t= PDQ_CSR_OFFSET(csr_base,  3 * csrsize);\n    csrs->csr_port_data_b\t\t= PDQ_CSR_OFFSET(csr_base,  4 * csrsize);\n    csrs->csr_port_status\t\t= PDQ_CSR_OFFSET(csr_base,  5 * csrsize);\n    csrs->csr_host_int_type_0\t\t= PDQ_CSR_OFFSET(csr_base,  6 * csrsize);\n    csrs->csr_host_int_enable\t\t= PDQ_CSR_OFFSET(csr_base,  7 * csrsize);\n    csrs->csr_type_2_producer\t\t= PDQ_CSR_OFFSET(csr_base,  8 * csrsize);\n    csrs->csr_cmd_response_producer\t= PDQ_CSR_OFFSET(csr_base, 10 * csrsize);\n    csrs->csr_cmd_request_producer\t= PDQ_CSR_OFFSET(csr_base, 11 * csrsize);\n    csrs->csr_host_smt_producer\t\t= PDQ_CSR_OFFSET(csr_base, 12 * csrsize);\n    csrs->csr_unsolicited_producer\t= PDQ_CSR_OFFSET(csr_base, 13 * csrsize);\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_init_csrs(\n    pdq_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_port_reset\t\t= PDQ_CSR_OFFSET(csr_base,  0 * csrsize);\n    csrs->csr_host_data\t\t\t= PDQ_CSR_OFFSET(csr_base,  1 * csrsize);\n    csrs->csr_port_control\t\t= PDQ_CSR_OFFSET(csr_base,  2 * csrsize);\n    csrs->csr_port_data_a\t\t= PDQ_CSR_OFFSET(csr_base,  3 * csrsize);\n    csrs->csr_port_data_b\t\t= PDQ_CSR_OFFSET(csr_base,  4 * csrsize);\n    csrs->csr_port_status\t\t= PDQ_CSR_OFFSET(csr_base,  5 * csrsize);\n    csrs->csr_host_int_type_0\t\t= PDQ_CSR_OFFSET(csr_base,  6 * csrsize);\n    csrs->csr_host_int_enable\t\t= PDQ_CSR_OFFSET(csr_base,  7 * csrsize);\n    csrs->csr_type_2_producer\t\t= PDQ_CSR_OFFSET(csr_base,  8 * csrsize);\n    csrs->csr_cmd_response_producer\t= PDQ_CSR_OFFSET(csr_base, 10 * csrsize);\n    csrs->csr_cmd_request_producer\t= PDQ_CSR_OFFSET(csr_base, 11 * csrsize);\n    csrs->csr_host_smt_producer\t\t= PDQ_CSR_OFFSET(csr_base, 12 * csrsize);\n    csrs->csr_unsolicited_producer\t= PDQ_CSR_OFFSET(csr_base, 13 * csrsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMZERO",
          "args": [
            "pdq->pdq_dbp",
            "sizeof(*pdq->pdq_dbp)"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Consumer Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_cbp)"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Command Request Queue  = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_requests)"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Command Response Queue = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_responses)"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Host SMT Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_host_smt)"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Transmit Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_transmits)"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"    Recieve Queue          = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_receives)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"\\nPDQ Descriptor Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp)"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMFREE",
          "args": [
            "pdq",
            "sizeof(pdq_t)"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMFREE",
          "args": [
            "pdq->pdq_unsolicited_info.ui_events",
            "PDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t)"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMFREE_CONTIG",
          "args": [
            "p/* pdq->pdq_dbp */",
            "contig_bytes"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMALLOC",
          "args": [
            "PDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "p + idx"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "p"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMALLOC_CONTIG",
          "args": [
            "contig_bytes"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMZERO",
          "args": [
            "pdq",
            "sizeof(pdq_t)"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"malloc(%d) failed\\n\", sizeof(*pdq))"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMALLOC",
          "args": [
            "sizeof(pdq_t)"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_unsolicited_event_t) == 512"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_response_dec_ext_mib_get_t) == PDQ_SIZE_RESPONSE_DEC_EXT_MIB_GET"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_response_fddi_mib_get_t) == PDQ_SIZE_RESPONSE_FDDI_MIB_GET"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_response_status_chars_get_t) == PDQ_SIZE_RESPONSE_STATUS_CHARS_GET"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_response_addr_filter_get_t) == PDQ_SIZE_RESPONSE_ADDR_FILTER_GET"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_cmd_addr_filter_set_t) == PDQ_SIZE_CMD_ADDR_FILTER_SET"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_response_filter_get_t) == PDQ_SIZE_RESPONSE_FILTER_GET"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_consumer_block_t) == 64"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "sizeof(pdq_descriptor_block_t) == 8192"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_halt_codes[] = {\n    \"Selftest Timeout\", \"Host Bus Parity Error\", \"Host Directed Fault\",\n    \"Software Fault\", \"Hardware Fault\", \"PC Trace Path Test\",\n    \"DMA Error\", \"Image CRC Error\", \"Adapter Processer Error\"\n};\nstatic const char * const pdq_adapter_states[] = {\n    \"Reset\", \"Upgrade\", \"DMA Unavailable\", \"DMA Available\",\n    \"Link Available\", \"Link Unavailable\", \"Halted\", \"Ring Member\"\n};\n\npdq_t *\npdq_initialize(\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    const char *name,\n    int unit,\n    void *ctx,\n    pdq_type_t type)\n{\n    pdq_t *pdq;\n    pdq_state_t state;\n    const pdq_uint32_t contig_bytes = (sizeof(pdq_descriptor_block_t) * 2) - PDQ_OS_PAGESIZE;\n    pdq_uint8_t *p;\n    int idx;\n\n    PDQ_ASSERT(sizeof(pdq_descriptor_block_t) == 8192);\n    PDQ_ASSERT(sizeof(pdq_consumer_block_t) == 64);\n    PDQ_ASSERT(sizeof(pdq_response_filter_get_t) == PDQ_SIZE_RESPONSE_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_cmd_addr_filter_set_t) == PDQ_SIZE_CMD_ADDR_FILTER_SET);\n    PDQ_ASSERT(sizeof(pdq_response_addr_filter_get_t) == PDQ_SIZE_RESPONSE_ADDR_FILTER_GET);\n    PDQ_ASSERT(sizeof(pdq_response_status_chars_get_t) == PDQ_SIZE_RESPONSE_STATUS_CHARS_GET);\n    PDQ_ASSERT(sizeof(pdq_response_fddi_mib_get_t) == PDQ_SIZE_RESPONSE_FDDI_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_response_dec_ext_mib_get_t) == PDQ_SIZE_RESPONSE_DEC_EXT_MIB_GET);\n    PDQ_ASSERT(sizeof(pdq_unsolicited_event_t) == 512);\n\n    pdq = (pdq_t *) PDQ_OS_MEMALLOC(sizeof(pdq_t));\n    if (pdq == NULL) {\n\tPDQ_PRINTF((\"malloc(%d) failed\\n\", sizeof(*pdq)));\n\treturn NULL;\n    }\n    PDQ_OS_MEMZERO(pdq, sizeof(pdq_t));\n    pdq->pdq_type = type;\n    pdq->pdq_unit = unit;\n    pdq->pdq_os_ctx = (void *) ctx;\n    pdq->pdq_os_name = name;\n    pdq->pdq_flags = PDQ_PRINTCHARS;\n    /*\n     * Allocate the additional data structures required by\n     * the PDQ driver.  Allocate a contiguous region of memory\n     * for the descriptor block.  We need to allocated enough\n     * to guarantee that we will a get 8KB block of memory aligned\n     * on a 8KB boundary.  This turns to require that we allocate\n     * (N*2 - 1 page) pages of memory.  On machine with less than\n     * a 8KB page size, it mean we will allocate more memory than\n     * we need.  The extra will be used for the unsolicited event\n     * buffers (though on machines with 8KB pages we will to allocate\n     * them separately since there will be nothing left overs.)\n     */\n    p = (pdq_uint8_t *) PDQ_OS_MEMALLOC_CONTIG(contig_bytes);\n    if (p != NULL) {\n\tpdq_physaddr_t physaddr = PDQ_OS_VA_TO_PA(pdq, p);\n\t/*\n\t * Assert that we really got contiguous memory.  This isn't really\n\t * needed on systems that actually have physical contiguous allocation\n\t * routines, but on those systems that don't ...\n\t */\n\tfor (idx = PDQ_OS_PAGESIZE; idx < 0x2000; idx += PDQ_OS_PAGESIZE) {\n\t    if (PDQ_OS_VA_TO_PA(pdq, p + idx) - physaddr != idx)\n\t\tgoto cleanup_and_return;\n\t}\n\tphysaddr &= 0x1FFF;\n\tif (physaddr) {\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) p;\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) &p[0x2000 - physaddr];\n\t} else {\n\t    pdq->pdq_dbp = (pdq_descriptor_block_t *) p;\n\t    pdq->pdq_unsolicited_info.ui_events = (pdq_unsolicited_event_t *) &p[0x2000];\n\t}\n    }\n    if (contig_bytes == sizeof(pdq_descriptor_block_t)) {\n\tpdq->pdq_unsolicited_info.ui_events =\n\t    (pdq_unsolicited_event_t *) PDQ_OS_MEMALLOC(\n\t\tPDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n    }\n\n    /*\n     * Make sure everything got allocated.  If not, free what did\n     * get allocated and return.\n     */\n    if (pdq->pdq_dbp == NULL || pdq->pdq_unsolicited_info.ui_events == NULL) {\n      cleanup_and_return:\n\tif (p /* pdq->pdq_dbp */ != NULL)\n\t    PDQ_OS_MEMFREE_CONTIG(p /* pdq->pdq_dbp */, contig_bytes);\n\tif (contig_bytes == sizeof(pdq_descriptor_block_t) && pdq->pdq_unsolicited_info.ui_events != NULL)\n\t    PDQ_OS_MEMFREE(pdq->pdq_unsolicited_info.ui_events,\n\t\t\t   PDQ_NUM_UNSOLICITED_EVENTS * sizeof(pdq_unsolicited_event_t));\n\tPDQ_OS_MEMFREE(pdq, sizeof(pdq_t));\n\treturn NULL;\n    }\n\n    pdq->pdq_cbp = (volatile pdq_consumer_block_t *) &pdq->pdq_dbp->pdqdb_consumer;\n    pdq->pdq_command_info.ci_bufstart = (pdq_uint8_t *) pdq->pdq_dbp->pdqdb_command_pool;\n    pdq->pdq_rx_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_receive_buffers;\n\n    pdq->pdq_host_smt_info.rx_buffers = (void *) pdq->pdq_dbp->pdqdb_host_smt_buffers;\n\n    PDQ_PRINTF((\"\\nPDQ Descriptor Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp));\n    PDQ_PRINTF((\"    Recieve Queue          = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_receives));\n    PDQ_PRINTF((\"    Transmit Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_transmits));\n    PDQ_PRINTF((\"    Host SMT Queue         = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_host_smt));\n    PDQ_PRINTF((\"    Command Response Queue = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_responses));\n    PDQ_PRINTF((\"    Command Request Queue  = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_dbp->pdqdb_command_requests));\n    PDQ_PRINTF((\"PDQ Consumer Block = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_cbp));\n\n    /*\n     * Zero out the descriptor block.  Not really required but\n     * it pays to be neat.  This will also zero out the consumer\n     * block, command pool, and buffer pointers for the receive\n     * host_smt rings.\n     */\n    PDQ_OS_MEMZERO(pdq->pdq_dbp, sizeof(*pdq->pdq_dbp));\n\n    /*\n     * Initialize the CSR references.\n     * the DEFAA (FutureBus+) skips a longword between registers\n     */\n    pdq_init_csrs(&pdq->pdq_csrs, bus, csr_base, pdq->pdq_type == PDQ_DEFAA ? 2 : 1);\n    if (pdq->pdq_type == PDQ_DEFPA)\n\tpdq_init_pci_csrs(&pdq->pdq_pci_csrs, bus, csr_base, 1);\n\n    PDQ_PRINTF((\"PDQ CSRs: BASE = \" PDQ_OS_PTR_FMT \"\\n\", pdq->pdq_csrs.csr_base));\n    PDQ_PRINTF((\"    Port Reset                = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_reset, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_reset)));\n    PDQ_PRINTF((\"    Host Data                 = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_data, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_data)));\n    PDQ_PRINTF((\"    Port Control              = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_control, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_control)));\n    PDQ_PRINTF((\"    Port Data A               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_a, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_a)));\n    PDQ_PRINTF((\"    Port Data B               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_data_b, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_data_b)));\n    PDQ_PRINTF((\"    Port Status               = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_port_status, PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status)));\n    PDQ_PRINTF((\"    Host Int Type 0           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_type_0, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0)));\n    PDQ_PRINTF((\"    Host Int Enable           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_int_enable, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_enable)));\n    PDQ_PRINTF((\"    Type 2 Producer           = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_type_2_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_type_2_producer)));\n    PDQ_PRINTF((\"    Command Response Producer = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_response_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_response_producer)));\n    PDQ_PRINTF((\"    Command Request Producer  = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_cmd_request_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_cmd_request_producer)));\n    PDQ_PRINTF((\"    Host SMT Producer         = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_host_smt_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_smt_producer)));\n    PDQ_PRINTF((\"    Unsolicited Producer      = \" PDQ_OS_PTR_FMT \" [0x%08x]\\n\",\n\t   pdq->pdq_csrs.csr_unsolicited_producer, PDQ_CSR_READ(&pdq->pdq_csrs, csr_unsolicited_producer)));\n\n    /*\n     * Initialize the command information block\n     */\n    pdq->pdq_command_info.ci_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_command_info.ci_bufstart);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_requests)/sizeof(pdq->pdq_dbp->pdqdb_command_requests[0]); idx++) {\n\tpdq_txdesc_t *txd = &pdq->pdq_dbp->pdqdb_command_requests[idx];\n\n\ttxd->txd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\ttxd->txd_eop = txd->txd_sop = 1;\n\ttxd->txd_pa_hi = 0;\n    }\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_command_responses)/sizeof(pdq->pdq_dbp->pdqdb_command_responses[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_command_responses[idx];\n\n\trxd->rxd_pa_lo = pdq->pdq_command_info.ci_pa_bufstart;\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_lo = 0;\n    }\n\n    /*\n     * Initialize the unsolicited event information block\n     */\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_unsolicited_info.ui_pa_bufstart = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_unsolicited_info.ui_events);\n    for (idx = 0; idx < sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events)/sizeof(pdq->pdq_dbp->pdqdb_unsolicited_events[0]); idx++) {\n\tpdq_rxdesc_t *rxd = &pdq->pdq_dbp->pdqdb_unsolicited_events[idx];\n\tpdq_unsolicited_event_t *event = &pdq->pdq_unsolicited_info.ui_events[idx & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\trxd->rxd_sop = 1;\n\trxd->rxd_seg_cnt = 0;\n\trxd->rxd_seg_len_hi = sizeof(pdq_unsolicited_event_t) / 16;\n\trxd->rxd_pa_lo = pdq->pdq_unsolicited_info.ui_pa_bufstart + (const pdq_uint8_t *) event\n\t    - (const pdq_uint8_t *) pdq->pdq_unsolicited_info.ui_events;\n\trxd->rxd_pa_hi = 0;\n    }\n    /*\n     * Initialize the receive information blocks (normal and SMT).\n     */\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    pdq->pdq_rx_info.rx_target = pdq->pdq_rx_info.rx_free - PDQ_RX_SEGCNT * 8;\n\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n    pdq->pdq_host_smt_info.rx_target = pdq->pdq_host_smt_info.rx_free - PDQ_RX_SEGCNT * 3;\n\n    /*\n     * Initialize the transmit information block.\n     */\n    pdq->pdq_tx_hdr[0] = PDQ_FDDI_PH0;\n    pdq->pdq_tx_hdr[1] = PDQ_FDDI_PH1;\n    pdq->pdq_tx_hdr[2] = PDQ_FDDI_PH2;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_seg_len = sizeof(pdq->pdq_tx_hdr);\n    pdq->pdq_tx_info.tx_hdrdesc.txd_sop = 1;\n    pdq->pdq_tx_info.tx_hdrdesc.txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, pdq->pdq_tx_hdr);\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n\n    /*\n     * Stop the PDQ if it is running and put it into a known state.\n     */\n    state = pdq_stop(pdq);\n\n    PDQ_PRINTF((\"PDQ Adapter State = %s\\n\", pdq_adapter_states[state]));\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    /*\n     * If the adapter is not the state we expect, then the initialization\n     * failed.  Cleanup and exit.\n     */\n#if defined(PDQVERBOSE)\n    if (state == PDQS_HALTED) {\n\tpdq_halt_code_t halt_code = PDQ_PSTS_HALT_ID(PDQ_CSR_READ(&pdq->pdq_csrs, csr_port_status));\n\tprintf(\"Halt code = %d (%s)\\n\", halt_code, pdq_halt_codes[halt_code]);\n\tif (halt_code == PDQH_DMA_ERROR && pdq->pdq_type == PDQ_DEFPA)\n\t    PDQ_PRINTF((\"PFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t       PDQ_CSR_READ(&pdq->pdq_csrs, csr_host_int_type_0) & PDQ_HOST_INT_FATAL_ERROR));\n    }\n#endif\n    if (state == PDQS_RESET || state == PDQS_HALTED || state == PDQS_UPGRADE)\n\tgoto cleanup_and_return;\n\n    PDQ_PRINTF((\"PDQ Hardware Address = %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n\t   pdq->pdq_hwaddr.lanaddr_bytes[0], pdq->pdq_hwaddr.lanaddr_bytes[1],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[2], pdq->pdq_hwaddr.lanaddr_bytes[3],\n\t   pdq->pdq_hwaddr.lanaddr_bytes[4], pdq->pdq_hwaddr.lanaddr_bytes[5]));\n    PDQ_PRINTF((\"PDQ Firmware Revision = %c%c%c%c\\n\",\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3]));\n    PDQ_PRINTF((\"PDQ Chip Revision = \"));\n    switch (pdq->pdq_chip_rev) {\n\tcase PDQ_CHIP_REV_A_B_OR_C: PDQ_PRINTF((\"Rev C or below\")); break;\n\tcase PDQ_CHIP_REV_D: PDQ_PRINTF((\"Rev D\")); break;\n\tcase PDQ_CHIP_REV_E: PDQ_PRINTF((\"Rev E\")); break;\n\tdefault: PDQ_PRINTF((\"Unknown Rev %d\", (int) pdq->pdq_chip_rev));\n    }\n    PDQ_PRINTF((\"\\n\"));\n\n    return pdq;\n}"
  },
  {
    "function_name": "pdq_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "1244-1325",
    "snippet": "int\npdq_interrupt(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t data;\n    int progress = 0;\n\n    if (pdq->pdq_type == PDQ_DEFPA)\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x18);\n\n    while ((data = PDQ_CSR_READ(csrs, csr_port_status)) & PDQ_PSTS_INTR_PENDING) {\n\tprogress = 1;\n\tPDQ_PRINTF((\"PDQ Interrupt: Status = 0x%08x\\n\", data));\n\tif (data & PDQ_PSTS_RCV_DATA_PENDING) {\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t}\n\tif (data & PDQ_PSTS_HOST_SMT_PENDING) {\n\t    pdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t    PDQ_DO_HOST_SMT_PRODUCER(pdq);\n\t}\n\tif (data & PDQ_PSTS_XMT_DATA_PENDING)\n\t    pdq_process_transmitted_data(pdq);\n\tif (data & PDQ_PSTS_UNSOL_PENDING)\n\t    pdq_process_unsolicited_events(pdq);\n\tif (data & PDQ_PSTS_CMD_RSP_PENDING)\n\t    pdq_process_command_responses(pdq);\n\tif (data & PDQ_PSTS_TYPE_0_PENDING) {\n\t    data = PDQ_CSR_READ(csrs, csr_host_int_type_0);\n\t    if (data & PDQ_HOST_INT_STATE_CHANGE) {\n\t\tpdq_state_t state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t\tprintf(PDQ_OS_PREFIX \"%s\", PDQ_OS_PREFIX_ARGS, pdq_adapter_states[state]);\n\t\tif (state == PDQS_LINK_UNAVAILABLE) {\n\t\t    pdq->pdq_flags &= ~PDQ_TXOK;\n\t\t} else if (state == PDQS_LINK_AVAILABLE) {\n\t\t    pdq->pdq_flags |= PDQ_TXOK;\n\t\t    pdq_os_restart_transmitter(pdq);\n\t\t} else if (state == PDQS_HALTED) {\n\t\t    pdq_response_error_log_get_t log_entry;\n\t\t    pdq_halt_code_t halt_code = PDQ_PSTS_HALT_ID(PDQ_CSR_READ(csrs, csr_port_status));\n\t\t    printf(\": halt code = %d (%s)\\n\",\n\t\t\t   halt_code, pdq_halt_codes[halt_code]);\n\t\t    if (halt_code == PDQH_DMA_ERROR && pdq->pdq_type == PDQ_DEFPA) {\n\t\t\tPDQ_PRINTF((\"\\tPFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t\t       data & PDQ_HOST_INT_FATAL_ERROR));\n\t\t    }\n\t\t    pdq_read_error_log(pdq, &log_entry);\n\t\t    pdq_stop(pdq);\n\t\t    if (pdq->pdq_flags & PDQ_RUNNING)\n\t\t\tpdq_run(pdq);\n\t\t    return 1;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_STATE_CHANGE);\n\t    }\n\t    if (data & PDQ_HOST_INT_FATAL_ERROR) {\n\t\tpdq_stop(pdq);\n\t\tif (pdq->pdq_flags & PDQ_RUNNING)\n\t\t    pdq_run(pdq);\n\t\treturn 1;\n\t    }\n\t    if (data & PDQ_HOST_INT_XMT_DATA_FLUSH) {\n\t\tprintf(PDQ_OS_PREFIX \"Flushing transmit queue\\n\", PDQ_OS_PREFIX_ARGS);\n\t\tpdq->pdq_flags &= ~PDQ_TXOK;\n\t\tpdq_flush_transmitter(pdq);\n\t\tpdq_do_port_control(csrs, PDQ_PCTL_XMT_DATA_FLUSH_DONE);\n\t\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_XMT_DATA_FLUSH);\n\t    }\n\t}\n\tif (pdq->pdq_type == PDQ_DEFPA)\n\t    PDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x18);\n    }\n    return progress;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const pdq_halt_codes[] = {\n    \"Selftest Timeout\", \"Host Bus Parity Error\", \"Host Directed Fault\",\n    \"Software Fault\", \"Hardware Fault\", \"PC Trace Path Test\",\n    \"DMA Error\", \"Image CRC Error\", \"Adapter Processer Error\"\n};",
      "static const char * const pdq_adapter_states[] = {\n    \"Reset\", \"Upgrade\", \"DMA Unavailable\", \"DMA Available\",\n    \"Link Available\", \"Link Unavailable\", \"Halted\", \"Ring Member\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_status",
            "0x18"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_type_0",
            "PDQ_HOST_INT_XMT_DATA_FLUSH"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_do_port_control",
          "args": [
            "csrs",
            "PDQ_PCTL_XMT_DATA_FLUSH_DONE"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_do_port_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "264-282",
          "snippet": "static pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_flush_transmitter",
          "args": [
            "pdq"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_flush_transmitter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "917-940",
          "snippet": "void\npdq_flush_transmitter(\n    pdq_t *pdq)\n{\n    volatile pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n\n    for (;;) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tif (pdu == NULL)\n\t    break;\n\t/*\n\t * Don't call transmit done since the packet never made it\n\t * out on the wire.\n\t */\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n\n    tx->tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    tx->tx_completion = cbp->pdqcb_transmits = tx->tx_producer;\n\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_flush_transmitter(\n    pdq_t *pdq)\n{\n    volatile pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n\n    for (;;) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tif (pdu == NULL)\n\t    break;\n\t/*\n\t * Don't call transmit done since the packet never made it\n\t * out on the wire.\n\t */\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n\n    tx->tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    tx->tx_completion = cbp->pdqcb_transmits = tx->tx_producer;\n\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "PDQ_OS_PREFIX \"Flushing transmit queue\\n\"",
            "PDQ_OS_PREFIX_ARGS"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_run",
          "args": [
            "pdq"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "1170-1242",
          "snippet": "void\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_stop",
          "args": [
            "pdq"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "975-1168",
          "snippet": "pdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\npdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_type_0",
            "PDQ_HOST_INT_STATE_CHANGE"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_read_error_log",
          "args": [
            "pdq",
            "&log_entry"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_read_error_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "324-340",
          "snippet": "static pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"\\tPFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t\t       data & PDQ_HOST_INT_FATAL_ERROR)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_status"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_HALT_ID",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_os_restart_transmitter",
          "args": [
            "pdq"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_os_restart_transmitter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "218-230",
          "snippet": "void\npdq_os_restart_transmitter(\n    pdq_t *pdq)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    sc->sc_if.if_flags &= ~IFF_OACTIVE;\n    if (sc->sc_if.if_snd.ifq_head != NULL) {\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\tpdq_ifstart(&sc->sc_if);\n    } else {\n\tsc->sc_if.if_timer = 0;\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_restart_transmitter(\n    pdq_t *pdq)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    sc->sc_if.if_flags &= ~IFF_OACTIVE;\n    if (sc->sc_if.if_snd.ifq_head != NULL) {\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\tpdq_ifstart(&sc->sc_if);\n    } else {\n\tsc->sc_if.if_timer = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_int_type_0"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_process_command_responses",
          "args": [
            "pdq"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_command_responses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "547-591",
          "snippet": "static void\npdq_process_command_responses(\n    pdq_t * const pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    volatile const pdq_consumer_block_t * const cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    const pdq_response_generic_t *rspgen;\n\n    /*\n     * We have to process the command and response in tandem so\n     * just wait for the response to be consumed.  If it has been\n     * consumed then the command must have been as well.\n     */\n\n    if (cbp->pdqcb_command_response == ci->ci_response_completion)\n\treturn;\n\n    PDQ_ASSERT(cbp->pdqcb_command_request != ci->ci_request_completion);\n\n    rspgen = (const pdq_response_generic_t *) ci->ci_bufstart;\n    PDQ_ASSERT(rspgen->generic_status == PDQR_SUCCESS);\n    PDQ_PRINTF((\"PDQ Process Command Response: %s completed (status=%d)\\n\",\n\t\tpdq_cmd_info[rspgen->generic_op].cmd_name,\n\t\trspgen->generic_status));\n\n    if (rspgen->generic_op == PDQC_STATUS_CHARS_GET && (pdq->pdq_flags & PDQ_PRINTCHARS)) {\n\tpdq->pdq_flags &= ~PDQ_PRINTCHARS;\n\tpdq_print_fddi_chars(pdq, (const pdq_response_status_chars_get_t *) rspgen);\n    }\n\n    PDQ_ADVANCE(ci->ci_request_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n    PDQ_ADVANCE(ci->ci_response_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n    ci->ci_command_active = 0;\n\n    if (ci->ci_pending_commands != 0) {\n\tpdq_queue_commands(pdq);\n    } else {\n\tPDQ_CSR_WRITE(csrs, csr_cmd_response_producer,\n\t\t      ci->ci_response_producer | (ci->ci_response_completion << 8));\n\tPDQ_CSR_WRITE(csrs, csr_cmd_request_producer,\n\t\t      ci->ci_request_producer | (ci->ci_request_completion << 8));\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};\n\nstatic void\npdq_process_command_responses(\n    pdq_t * const pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    volatile const pdq_consumer_block_t * const cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    const pdq_response_generic_t *rspgen;\n\n    /*\n     * We have to process the command and response in tandem so\n     * just wait for the response to be consumed.  If it has been\n     * consumed then the command must have been as well.\n     */\n\n    if (cbp->pdqcb_command_response == ci->ci_response_completion)\n\treturn;\n\n    PDQ_ASSERT(cbp->pdqcb_command_request != ci->ci_request_completion);\n\n    rspgen = (const pdq_response_generic_t *) ci->ci_bufstart;\n    PDQ_ASSERT(rspgen->generic_status == PDQR_SUCCESS);\n    PDQ_PRINTF((\"PDQ Process Command Response: %s completed (status=%d)\\n\",\n\t\tpdq_cmd_info[rspgen->generic_op].cmd_name,\n\t\trspgen->generic_status));\n\n    if (rspgen->generic_op == PDQC_STATUS_CHARS_GET && (pdq->pdq_flags & PDQ_PRINTCHARS)) {\n\tpdq->pdq_flags &= ~PDQ_PRINTCHARS;\n\tpdq_print_fddi_chars(pdq, (const pdq_response_status_chars_get_t *) rspgen);\n    }\n\n    PDQ_ADVANCE(ci->ci_request_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n    PDQ_ADVANCE(ci->ci_response_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n    ci->ci_command_active = 0;\n\n    if (ci->ci_pending_commands != 0) {\n\tpdq_queue_commands(pdq);\n    } else {\n\tPDQ_CSR_WRITE(csrs, csr_cmd_response_producer,\n\t\t      ci->ci_response_producer | (ci->ci_response_completion << 8));\n\tPDQ_CSR_WRITE(csrs, csr_cmd_request_producer,\n\t\t      ci->ci_request_producer | (ci->ci_request_completion << 8));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_process_unsolicited_events",
          "args": [
            "pdq"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_unsolicited_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "599-645",
          "snippet": "static void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};",
            "static const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};\nstatic const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};\n\nstatic void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_process_transmitted_data",
          "args": [
            "pdq"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_transmitted_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "890-915",
          "snippet": "static void\npdq_process_transmitted_data(\n    pdq_t *pdq)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t completion = tx->tx_completion;\n\n    while (completion != cbp->pdqcb_transmits) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tpdq_uint32_t descriptor_count = tx->tx_descriptor_count[completion];\n\tPDQ_ASSERT(dbp->pdqdb_transmits[completion].txd_sop == 1);\n\tPDQ_ASSERT(dbp->pdqdb_transmits[(completion + descriptor_count - 1) & PDQ_RING_MASK(dbp->pdqdb_transmits)].txd_eop == 1);\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tpdq_os_transmit_done(pdq, pdu);\n\ttx->tx_free += descriptor_count;\n\n\tPDQ_ADVANCE(completion, descriptor_count, PDQ_RING_MASK(dbp->pdqdb_transmits));\n    }\n    if (tx->tx_completion != completion) {\n\ttx->tx_completion = completion;\n\tpdq_os_restart_transmitter(pdq);\n    }\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_process_transmitted_data(\n    pdq_t *pdq)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t completion = tx->tx_completion;\n\n    while (completion != cbp->pdqcb_transmits) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tpdq_uint32_t descriptor_count = tx->tx_descriptor_count[completion];\n\tPDQ_ASSERT(dbp->pdqdb_transmits[completion].txd_sop == 1);\n\tPDQ_ASSERT(dbp->pdqdb_transmits[(completion + descriptor_count - 1) & PDQ_RING_MASK(dbp->pdqdb_transmits)].txd_eop == 1);\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tpdq_os_transmit_done(pdq, pdu);\n\ttx->tx_free += descriptor_count;\n\n\tPDQ_ADVANCE(completion, descriptor_count, PDQ_RING_MASK(dbp->pdqdb_transmits));\n    }\n    if (tx->tx_completion != completion) {\n\ttx->tx_completion = completion;\n\tpdq_os_restart_transmitter(pdq);\n    }\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_DO_HOST_SMT_PRODUCER",
          "args": [
            "pdq"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_process_received_data",
          "args": [
            "pdq",
            "&pdq->pdq_host_smt_info",
            "pdq->pdq_dbp->pdqdb_host_smt",
            "pdq->pdq_cbp->pdqcb_host_smt",
            "PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt)"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_received_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "647-820",
          "snippet": "static void\npdq_process_received_data(\n    pdq_t *pdq,\n    pdq_rx_info_t *rx,\n    pdq_rxdesc_t *receives,\n    pdq_uint32_t completion_goal,\n    pdq_uint32_t ring_mask)\n{\n    pdq_uint32_t completion = rx->rx_completion;\n    pdq_uint32_t producer = rx->rx_producer;\n    PDQ_OS_DATABUF_T **buffers = (PDQ_OS_DATABUF_T **) rx->rx_buffers;\n    pdq_rxdesc_t *rxd;\n    pdq_uint32_t idx;\n\n    while (completion != completion_goal) {\n\tPDQ_OS_DATABUF_T *fpdu, *lpdu, *npdu;\n\tpdq_uint8_t *dataptr;\n\tpdq_uint32_t fc, datalen, pdulen, segcnt;\n\tpdq_rxstatus_t status;\n\n\tfpdu = lpdu = buffers[completion];\n\tPDQ_ASSERT(fpdu != NULL);\n\n\tdataptr = PDQ_OS_DATABUF_PTR(fpdu);\n\tstatus = *(pdq_rxstatus_t *) dataptr;\n\tif ((status.rxs_status & 0x200000) == 0) {\n\t    datalen = status.rxs_status & 0x1FFF;\n\t    fc = dataptr[PDQ_RX_FC_OFFSET];\n\t    switch (fc & (PDQ_FDDIFC_C|PDQ_FDDIFC_L|PDQ_FDDIFC_F)) {\n\t\tcase PDQ_FDDI_LLC_ASYNC:\n\t\tcase PDQ_FDDI_LLC_SYNC:\n\t\tcase PDQ_FDDI_IMP_ASYNC:\n\t\tcase PDQ_FDDI_IMP_SYNC: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_LLC_MIN) {\n\t\t\tPDQ_PRINTF((\"discard: bad length %d\\n\", datalen));\n\t\t\tgoto discard_frame;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tcase PDQ_FDDI_SMT: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_SMT_MIN)\n\t\t\tgoto discard_frame;\n\t\t    break;\n\t\t}\n\t\tdefault: {\n\t\t    PDQ_PRINTF((\"discard: bad fc 0x%x\\n\", fc));\n\t\t    goto discard_frame;\n\t\t}\n\t    }\n\t    /*\n\t     * Update the lengths of the data buffers now that we know\n\t     * the real length.\n\t     */\n\t    pdulen = datalen - 4 /* CRC */;\n\t    segcnt = (pdulen + PDQ_RX_FC_OFFSET + PDQ_OS_DATABUF_SIZE - 1) / PDQ_OS_DATABUF_SIZE; \n\t    PDQ_OS_DATABUF_ALLOC(npdu);\n\t    if (npdu == NULL) {\n\t\tPDQ_PRINTF((\"discard: no databuf #0\\n\"));\n\t\tgoto discard_frame;\n\t    }\n\t    buffers[completion] = npdu;\n\t    for (idx = 1; idx < segcnt; idx++) {\n\t\tPDQ_OS_DATABUF_ALLOC(npdu);\n\t\tif (npdu == NULL) {\n\t\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t\t    PDQ_OS_DATABUF_FREE(fpdu);\n\t\t    goto discard_frame;\n\t\t}\n\t\tPDQ_OS_DATABUF_NEXT_SET(lpdu, buffers[(completion + idx) & ring_mask]);\n\t\tlpdu = PDQ_OS_DATABUF_NEXT(lpdu);\n\t\tbuffers[(completion + idx) & ring_mask] = npdu;\n\t    }\n\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t    for (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t\tbuffers[(producer + idx) & ring_mask] = \n\t\t    buffers[(completion + idx) & ring_mask];\n\t\tbuffers[(completion + idx) & ring_mask] = NULL;\n\t    }\n\t    PDQ_OS_DATABUF_ADJ(fpdu, PDQ_RX_FC_OFFSET);\n\t    if (segcnt == 1) {\n\t\tPDQ_OS_DATABUF_LEN_SET(fpdu, pdulen);\n\t    } else {\n\t\tPDQ_OS_DATABUF_LEN_SET(lpdu, pdulen + PDQ_RX_FC_OFFSET - (segcnt - 1) * PDQ_OS_DATABUF_SIZE);\n\t    }\n\t    pdq_os_receive_pdu(pdq, fpdu, pdulen);\n\t    rx->rx_free += PDQ_RX_SEGCNT;\n\t    PDQ_ADVANCE(producer, PDQ_RX_SEGCNT, ring_mask);\n\t    PDQ_ADVANCE(completion, PDQ_RX_SEGCNT, ring_mask);\n\t    continue;\n\t} else {\n\t    PDQ_PRINTF((\"discard: bad pdu 0x%x(%d.%d.%d.%d.%d)\\n\", status.rxs_status,\n\t\t\tstatus.rxs_rcc_badpdu, status.rxs_rcc_badcrc,\n\t\t\tstatus.rxs_rcc_reason, status.rxs_fsc, status.rxs_fsb_e));\n\t    if (status.rxs_rcc_reason == 7)\n\t\tgoto discard_frame;\n\t    if (status.rxs_rcc_reason != 0) {\n\t\t/* hardware fault */\n\t    }\n\t    if (status.rxs_rcc_badcrc) {\n\t\tprintf(PDQ_OS_PREFIX \" MAC CRC error (source=%x-%x-%x-%x-%x-%x)\\n\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       dataptr[PDQ_RX_FC_OFFSET+1],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+2],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+3],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+4],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+5],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+6]);\n\t\t/* rx->rx_badcrc++; */\n\t    } else if (status.rxs_fsc == 0 || status.rxs_fsb_e == 1) {\n\t\t/* rx->rx_frame_status_errors++; */\n\t    } else {\n\t\t/* hardware fault */\n\t    }\n\t}\n      discard_frame:\n\t/*\n\t * Discarded frames go right back on the queue; therefore\n\t * ring entries were freed.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    buffers[producer] = buffers[completion];\n\t    buffers[completion] = NULL;\n\t    rxd = &receives[rx->rx_producer];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(buffers[rx->rx_producer]));\n\t    PDQ_ADVANCE(rx->rx_producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(completion, 1, ring_mask);\n\t}\n    }\n    rx->rx_completion = completion;\n\n    while (rx->rx_free > PDQ_RX_SEGCNT && rx->rx_free > rx->rx_target) {\n\tPDQ_OS_DATABUF_T *pdu;\n\t/*\n\t * Allocate the needed number of data buffers.\n\t * Try to obtain them from our free queue before\n\t * asking the system for more.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    if ((pdu = buffers[(rx->rx_producer + idx) & ring_mask]) == NULL) {\n\t\tPDQ_OS_DATABUF_ALLOC(pdu);\n\t\tif (pdu == NULL)\n\t\t    break;\n\t\tbuffers[(rx->rx_producer + idx) & ring_mask] = pdu;\n\t    }\n\t    rxd = &receives[(rx->rx_producer + idx) & ring_mask];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(pdu));\n\t}\n\tif (idx < PDQ_RX_SEGCNT) {\n\t    /*\n\t     * We didn't get all databufs required to complete a new\n\t     * receive buffer.  Keep the ones we got and retry a bit\n\t     * later for the rest.\n\t     */\n\t    break;\n\t}\n\tPDQ_ADVANCE(rx->rx_producer, PDQ_RX_SEGCNT, ring_mask);\n\trx->rx_free -= PDQ_RX_SEGCNT;\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_process_received_data(\n    pdq_t *pdq,\n    pdq_rx_info_t *rx,\n    pdq_rxdesc_t *receives,\n    pdq_uint32_t completion_goal,\n    pdq_uint32_t ring_mask)\n{\n    pdq_uint32_t completion = rx->rx_completion;\n    pdq_uint32_t producer = rx->rx_producer;\n    PDQ_OS_DATABUF_T **buffers = (PDQ_OS_DATABUF_T **) rx->rx_buffers;\n    pdq_rxdesc_t *rxd;\n    pdq_uint32_t idx;\n\n    while (completion != completion_goal) {\n\tPDQ_OS_DATABUF_T *fpdu, *lpdu, *npdu;\n\tpdq_uint8_t *dataptr;\n\tpdq_uint32_t fc, datalen, pdulen, segcnt;\n\tpdq_rxstatus_t status;\n\n\tfpdu = lpdu = buffers[completion];\n\tPDQ_ASSERT(fpdu != NULL);\n\n\tdataptr = PDQ_OS_DATABUF_PTR(fpdu);\n\tstatus = *(pdq_rxstatus_t *) dataptr;\n\tif ((status.rxs_status & 0x200000) == 0) {\n\t    datalen = status.rxs_status & 0x1FFF;\n\t    fc = dataptr[PDQ_RX_FC_OFFSET];\n\t    switch (fc & (PDQ_FDDIFC_C|PDQ_FDDIFC_L|PDQ_FDDIFC_F)) {\n\t\tcase PDQ_FDDI_LLC_ASYNC:\n\t\tcase PDQ_FDDI_LLC_SYNC:\n\t\tcase PDQ_FDDI_IMP_ASYNC:\n\t\tcase PDQ_FDDI_IMP_SYNC: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_LLC_MIN) {\n\t\t\tPDQ_PRINTF((\"discard: bad length %d\\n\", datalen));\n\t\t\tgoto discard_frame;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tcase PDQ_FDDI_SMT: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_SMT_MIN)\n\t\t\tgoto discard_frame;\n\t\t    break;\n\t\t}\n\t\tdefault: {\n\t\t    PDQ_PRINTF((\"discard: bad fc 0x%x\\n\", fc));\n\t\t    goto discard_frame;\n\t\t}\n\t    }\n\t    /*\n\t     * Update the lengths of the data buffers now that we know\n\t     * the real length.\n\t     */\n\t    pdulen = datalen - 4 /* CRC */;\n\t    segcnt = (pdulen + PDQ_RX_FC_OFFSET + PDQ_OS_DATABUF_SIZE - 1) / PDQ_OS_DATABUF_SIZE; \n\t    PDQ_OS_DATABUF_ALLOC(npdu);\n\t    if (npdu == NULL) {\n\t\tPDQ_PRINTF((\"discard: no databuf #0\\n\"));\n\t\tgoto discard_frame;\n\t    }\n\t    buffers[completion] = npdu;\n\t    for (idx = 1; idx < segcnt; idx++) {\n\t\tPDQ_OS_DATABUF_ALLOC(npdu);\n\t\tif (npdu == NULL) {\n\t\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t\t    PDQ_OS_DATABUF_FREE(fpdu);\n\t\t    goto discard_frame;\n\t\t}\n\t\tPDQ_OS_DATABUF_NEXT_SET(lpdu, buffers[(completion + idx) & ring_mask]);\n\t\tlpdu = PDQ_OS_DATABUF_NEXT(lpdu);\n\t\tbuffers[(completion + idx) & ring_mask] = npdu;\n\t    }\n\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t    for (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t\tbuffers[(producer + idx) & ring_mask] = \n\t\t    buffers[(completion + idx) & ring_mask];\n\t\tbuffers[(completion + idx) & ring_mask] = NULL;\n\t    }\n\t    PDQ_OS_DATABUF_ADJ(fpdu, PDQ_RX_FC_OFFSET);\n\t    if (segcnt == 1) {\n\t\tPDQ_OS_DATABUF_LEN_SET(fpdu, pdulen);\n\t    } else {\n\t\tPDQ_OS_DATABUF_LEN_SET(lpdu, pdulen + PDQ_RX_FC_OFFSET - (segcnt - 1) * PDQ_OS_DATABUF_SIZE);\n\t    }\n\t    pdq_os_receive_pdu(pdq, fpdu, pdulen);\n\t    rx->rx_free += PDQ_RX_SEGCNT;\n\t    PDQ_ADVANCE(producer, PDQ_RX_SEGCNT, ring_mask);\n\t    PDQ_ADVANCE(completion, PDQ_RX_SEGCNT, ring_mask);\n\t    continue;\n\t} else {\n\t    PDQ_PRINTF((\"discard: bad pdu 0x%x(%d.%d.%d.%d.%d)\\n\", status.rxs_status,\n\t\t\tstatus.rxs_rcc_badpdu, status.rxs_rcc_badcrc,\n\t\t\tstatus.rxs_rcc_reason, status.rxs_fsc, status.rxs_fsb_e));\n\t    if (status.rxs_rcc_reason == 7)\n\t\tgoto discard_frame;\n\t    if (status.rxs_rcc_reason != 0) {\n\t\t/* hardware fault */\n\t    }\n\t    if (status.rxs_rcc_badcrc) {\n\t\tprintf(PDQ_OS_PREFIX \" MAC CRC error (source=%x-%x-%x-%x-%x-%x)\\n\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       dataptr[PDQ_RX_FC_OFFSET+1],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+2],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+3],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+4],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+5],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+6]);\n\t\t/* rx->rx_badcrc++; */\n\t    } else if (status.rxs_fsc == 0 || status.rxs_fsb_e == 1) {\n\t\t/* rx->rx_frame_status_errors++; */\n\t    } else {\n\t\t/* hardware fault */\n\t    }\n\t}\n      discard_frame:\n\t/*\n\t * Discarded frames go right back on the queue; therefore\n\t * ring entries were freed.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    buffers[producer] = buffers[completion];\n\t    buffers[completion] = NULL;\n\t    rxd = &receives[rx->rx_producer];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(buffers[rx->rx_producer]));\n\t    PDQ_ADVANCE(rx->rx_producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(completion, 1, ring_mask);\n\t}\n    }\n    rx->rx_completion = completion;\n\n    while (rx->rx_free > PDQ_RX_SEGCNT && rx->rx_free > rx->rx_target) {\n\tPDQ_OS_DATABUF_T *pdu;\n\t/*\n\t * Allocate the needed number of data buffers.\n\t * Try to obtain them from our free queue before\n\t * asking the system for more.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    if ((pdu = buffers[(rx->rx_producer + idx) & ring_mask]) == NULL) {\n\t\tPDQ_OS_DATABUF_ALLOC(pdu);\n\t\tif (pdu == NULL)\n\t\t    break;\n\t\tbuffers[(rx->rx_producer + idx) & ring_mask] = pdu;\n\t    }\n\t    rxd = &receives[(rx->rx_producer + idx) & ring_mask];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(pdu));\n\t}\n\tif (idx < PDQ_RX_SEGCNT) {\n\t    /*\n\t     * We didn't get all databufs required to complete a new\n\t     * receive buffer.  Keep the ones we got and retry a bit\n\t     * later for the rest.\n\t     */\n\t    break;\n\t}\n\tPDQ_ADVANCE(rx->rx_producer, PDQ_RX_SEGCNT, ring_mask);\n\trx->rx_free -= PDQ_RX_SEGCNT;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_host_smt"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_DO_TYPE2_PRODUCER",
          "args": [
            "pdq"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_receives"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Interrupt: Status = 0x%08x\\n\", data)"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_status",
            "0x18"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_halt_codes[] = {\n    \"Selftest Timeout\", \"Host Bus Parity Error\", \"Host Directed Fault\",\n    \"Software Fault\", \"Hardware Fault\", \"PC Trace Path Test\",\n    \"DMA Error\", \"Image CRC Error\", \"Adapter Processer Error\"\n};\nstatic const char * const pdq_adapter_states[] = {\n    \"Reset\", \"Upgrade\", \"DMA Unavailable\", \"DMA Available\",\n    \"Link Available\", \"Link Unavailable\", \"Halted\", \"Ring Member\"\n};\n\nint\npdq_interrupt(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t data;\n    int progress = 0;\n\n    if (pdq->pdq_type == PDQ_DEFPA)\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x18);\n\n    while ((data = PDQ_CSR_READ(csrs, csr_port_status)) & PDQ_PSTS_INTR_PENDING) {\n\tprogress = 1;\n\tPDQ_PRINTF((\"PDQ Interrupt: Status = 0x%08x\\n\", data));\n\tif (data & PDQ_PSTS_RCV_DATA_PENDING) {\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t}\n\tif (data & PDQ_PSTS_HOST_SMT_PENDING) {\n\t    pdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t    PDQ_DO_HOST_SMT_PRODUCER(pdq);\n\t}\n\tif (data & PDQ_PSTS_XMT_DATA_PENDING)\n\t    pdq_process_transmitted_data(pdq);\n\tif (data & PDQ_PSTS_UNSOL_PENDING)\n\t    pdq_process_unsolicited_events(pdq);\n\tif (data & PDQ_PSTS_CMD_RSP_PENDING)\n\t    pdq_process_command_responses(pdq);\n\tif (data & PDQ_PSTS_TYPE_0_PENDING) {\n\t    data = PDQ_CSR_READ(csrs, csr_host_int_type_0);\n\t    if (data & PDQ_HOST_INT_STATE_CHANGE) {\n\t\tpdq_state_t state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t\tprintf(PDQ_OS_PREFIX \"%s\", PDQ_OS_PREFIX_ARGS, pdq_adapter_states[state]);\n\t\tif (state == PDQS_LINK_UNAVAILABLE) {\n\t\t    pdq->pdq_flags &= ~PDQ_TXOK;\n\t\t} else if (state == PDQS_LINK_AVAILABLE) {\n\t\t    pdq->pdq_flags |= PDQ_TXOK;\n\t\t    pdq_os_restart_transmitter(pdq);\n\t\t} else if (state == PDQS_HALTED) {\n\t\t    pdq_response_error_log_get_t log_entry;\n\t\t    pdq_halt_code_t halt_code = PDQ_PSTS_HALT_ID(PDQ_CSR_READ(csrs, csr_port_status));\n\t\t    printf(\": halt code = %d (%s)\\n\",\n\t\t\t   halt_code, pdq_halt_codes[halt_code]);\n\t\t    if (halt_code == PDQH_DMA_ERROR && pdq->pdq_type == PDQ_DEFPA) {\n\t\t\tPDQ_PRINTF((\"\\tPFI status = 0x%x, Host 0 Fatal Interrupt = 0x%x\\n\",\n\t\t\t       PDQ_CSR_READ(&pdq->pdq_pci_csrs, csr_pfi_status),\n\t\t\t       data & PDQ_HOST_INT_FATAL_ERROR));\n\t\t    }\n\t\t    pdq_read_error_log(pdq, &log_entry);\n\t\t    pdq_stop(pdq);\n\t\t    if (pdq->pdq_flags & PDQ_RUNNING)\n\t\t\tpdq_run(pdq);\n\t\t    return 1;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_STATE_CHANGE);\n\t    }\n\t    if (data & PDQ_HOST_INT_FATAL_ERROR) {\n\t\tpdq_stop(pdq);\n\t\tif (pdq->pdq_flags & PDQ_RUNNING)\n\t\t    pdq_run(pdq);\n\t\treturn 1;\n\t    }\n\t    if (data & PDQ_HOST_INT_XMT_DATA_FLUSH) {\n\t\tprintf(PDQ_OS_PREFIX \"Flushing transmit queue\\n\", PDQ_OS_PREFIX_ARGS);\n\t\tpdq->pdq_flags &= ~PDQ_TXOK;\n\t\tpdq_flush_transmitter(pdq);\n\t\tpdq_do_port_control(csrs, PDQ_PCTL_XMT_DATA_FLUSH_DONE);\n\t\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_XMT_DATA_FLUSH);\n\t    }\n\t}\n\tif (pdq->pdq_type == PDQ_DEFPA)\n\t    PDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x18);\n    }\n    return progress;\n}"
  },
  {
    "function_name": "pdq_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "1170-1242",
    "snippet": "void\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdq_queue_commands",
          "args": [
            "pdq"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_queue_commands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "438-545",
          "snippet": "static void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [
            "#define\tPDQ_CMD_RX_ALIGNMENT\t16"
          ],
          "globals_used": [
            "static const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\n#define\tPDQ_CMD_RX_ALIGNMENT\t16\n\nstatic const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};\n\nstatic void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_process_unsolicited_events",
          "args": [
            "pdq"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_unsolicited_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "599-645",
          "snippet": "static void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};",
            "static const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};\nstatic const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};\n\nstatic void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_smt_producer",
            "pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_process_received_data",
          "args": [
            "pdq",
            "&pdq->pdq_host_smt_info",
            "pdq->pdq_dbp->pdqdb_host_smt",
            "pdq->pdq_cbp->pdqcb_host_smt",
            "PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt)"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_received_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "647-820",
          "snippet": "static void\npdq_process_received_data(\n    pdq_t *pdq,\n    pdq_rx_info_t *rx,\n    pdq_rxdesc_t *receives,\n    pdq_uint32_t completion_goal,\n    pdq_uint32_t ring_mask)\n{\n    pdq_uint32_t completion = rx->rx_completion;\n    pdq_uint32_t producer = rx->rx_producer;\n    PDQ_OS_DATABUF_T **buffers = (PDQ_OS_DATABUF_T **) rx->rx_buffers;\n    pdq_rxdesc_t *rxd;\n    pdq_uint32_t idx;\n\n    while (completion != completion_goal) {\n\tPDQ_OS_DATABUF_T *fpdu, *lpdu, *npdu;\n\tpdq_uint8_t *dataptr;\n\tpdq_uint32_t fc, datalen, pdulen, segcnt;\n\tpdq_rxstatus_t status;\n\n\tfpdu = lpdu = buffers[completion];\n\tPDQ_ASSERT(fpdu != NULL);\n\n\tdataptr = PDQ_OS_DATABUF_PTR(fpdu);\n\tstatus = *(pdq_rxstatus_t *) dataptr;\n\tif ((status.rxs_status & 0x200000) == 0) {\n\t    datalen = status.rxs_status & 0x1FFF;\n\t    fc = dataptr[PDQ_RX_FC_OFFSET];\n\t    switch (fc & (PDQ_FDDIFC_C|PDQ_FDDIFC_L|PDQ_FDDIFC_F)) {\n\t\tcase PDQ_FDDI_LLC_ASYNC:\n\t\tcase PDQ_FDDI_LLC_SYNC:\n\t\tcase PDQ_FDDI_IMP_ASYNC:\n\t\tcase PDQ_FDDI_IMP_SYNC: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_LLC_MIN) {\n\t\t\tPDQ_PRINTF((\"discard: bad length %d\\n\", datalen));\n\t\t\tgoto discard_frame;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tcase PDQ_FDDI_SMT: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_SMT_MIN)\n\t\t\tgoto discard_frame;\n\t\t    break;\n\t\t}\n\t\tdefault: {\n\t\t    PDQ_PRINTF((\"discard: bad fc 0x%x\\n\", fc));\n\t\t    goto discard_frame;\n\t\t}\n\t    }\n\t    /*\n\t     * Update the lengths of the data buffers now that we know\n\t     * the real length.\n\t     */\n\t    pdulen = datalen - 4 /* CRC */;\n\t    segcnt = (pdulen + PDQ_RX_FC_OFFSET + PDQ_OS_DATABUF_SIZE - 1) / PDQ_OS_DATABUF_SIZE; \n\t    PDQ_OS_DATABUF_ALLOC(npdu);\n\t    if (npdu == NULL) {\n\t\tPDQ_PRINTF((\"discard: no databuf #0\\n\"));\n\t\tgoto discard_frame;\n\t    }\n\t    buffers[completion] = npdu;\n\t    for (idx = 1; idx < segcnt; idx++) {\n\t\tPDQ_OS_DATABUF_ALLOC(npdu);\n\t\tif (npdu == NULL) {\n\t\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t\t    PDQ_OS_DATABUF_FREE(fpdu);\n\t\t    goto discard_frame;\n\t\t}\n\t\tPDQ_OS_DATABUF_NEXT_SET(lpdu, buffers[(completion + idx) & ring_mask]);\n\t\tlpdu = PDQ_OS_DATABUF_NEXT(lpdu);\n\t\tbuffers[(completion + idx) & ring_mask] = npdu;\n\t    }\n\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t    for (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t\tbuffers[(producer + idx) & ring_mask] = \n\t\t    buffers[(completion + idx) & ring_mask];\n\t\tbuffers[(completion + idx) & ring_mask] = NULL;\n\t    }\n\t    PDQ_OS_DATABUF_ADJ(fpdu, PDQ_RX_FC_OFFSET);\n\t    if (segcnt == 1) {\n\t\tPDQ_OS_DATABUF_LEN_SET(fpdu, pdulen);\n\t    } else {\n\t\tPDQ_OS_DATABUF_LEN_SET(lpdu, pdulen + PDQ_RX_FC_OFFSET - (segcnt - 1) * PDQ_OS_DATABUF_SIZE);\n\t    }\n\t    pdq_os_receive_pdu(pdq, fpdu, pdulen);\n\t    rx->rx_free += PDQ_RX_SEGCNT;\n\t    PDQ_ADVANCE(producer, PDQ_RX_SEGCNT, ring_mask);\n\t    PDQ_ADVANCE(completion, PDQ_RX_SEGCNT, ring_mask);\n\t    continue;\n\t} else {\n\t    PDQ_PRINTF((\"discard: bad pdu 0x%x(%d.%d.%d.%d.%d)\\n\", status.rxs_status,\n\t\t\tstatus.rxs_rcc_badpdu, status.rxs_rcc_badcrc,\n\t\t\tstatus.rxs_rcc_reason, status.rxs_fsc, status.rxs_fsb_e));\n\t    if (status.rxs_rcc_reason == 7)\n\t\tgoto discard_frame;\n\t    if (status.rxs_rcc_reason != 0) {\n\t\t/* hardware fault */\n\t    }\n\t    if (status.rxs_rcc_badcrc) {\n\t\tprintf(PDQ_OS_PREFIX \" MAC CRC error (source=%x-%x-%x-%x-%x-%x)\\n\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       dataptr[PDQ_RX_FC_OFFSET+1],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+2],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+3],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+4],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+5],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+6]);\n\t\t/* rx->rx_badcrc++; */\n\t    } else if (status.rxs_fsc == 0 || status.rxs_fsb_e == 1) {\n\t\t/* rx->rx_frame_status_errors++; */\n\t    } else {\n\t\t/* hardware fault */\n\t    }\n\t}\n      discard_frame:\n\t/*\n\t * Discarded frames go right back on the queue; therefore\n\t * ring entries were freed.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    buffers[producer] = buffers[completion];\n\t    buffers[completion] = NULL;\n\t    rxd = &receives[rx->rx_producer];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(buffers[rx->rx_producer]));\n\t    PDQ_ADVANCE(rx->rx_producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(completion, 1, ring_mask);\n\t}\n    }\n    rx->rx_completion = completion;\n\n    while (rx->rx_free > PDQ_RX_SEGCNT && rx->rx_free > rx->rx_target) {\n\tPDQ_OS_DATABUF_T *pdu;\n\t/*\n\t * Allocate the needed number of data buffers.\n\t * Try to obtain them from our free queue before\n\t * asking the system for more.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    if ((pdu = buffers[(rx->rx_producer + idx) & ring_mask]) == NULL) {\n\t\tPDQ_OS_DATABUF_ALLOC(pdu);\n\t\tif (pdu == NULL)\n\t\t    break;\n\t\tbuffers[(rx->rx_producer + idx) & ring_mask] = pdu;\n\t    }\n\t    rxd = &receives[(rx->rx_producer + idx) & ring_mask];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(pdu));\n\t}\n\tif (idx < PDQ_RX_SEGCNT) {\n\t    /*\n\t     * We didn't get all databufs required to complete a new\n\t     * receive buffer.  Keep the ones we got and retry a bit\n\t     * later for the rest.\n\t     */\n\t    break;\n\t}\n\tPDQ_ADVANCE(rx->rx_producer, PDQ_RX_SEGCNT, ring_mask);\n\trx->rx_free -= PDQ_RX_SEGCNT;\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_process_received_data(\n    pdq_t *pdq,\n    pdq_rx_info_t *rx,\n    pdq_rxdesc_t *receives,\n    pdq_uint32_t completion_goal,\n    pdq_uint32_t ring_mask)\n{\n    pdq_uint32_t completion = rx->rx_completion;\n    pdq_uint32_t producer = rx->rx_producer;\n    PDQ_OS_DATABUF_T **buffers = (PDQ_OS_DATABUF_T **) rx->rx_buffers;\n    pdq_rxdesc_t *rxd;\n    pdq_uint32_t idx;\n\n    while (completion != completion_goal) {\n\tPDQ_OS_DATABUF_T *fpdu, *lpdu, *npdu;\n\tpdq_uint8_t *dataptr;\n\tpdq_uint32_t fc, datalen, pdulen, segcnt;\n\tpdq_rxstatus_t status;\n\n\tfpdu = lpdu = buffers[completion];\n\tPDQ_ASSERT(fpdu != NULL);\n\n\tdataptr = PDQ_OS_DATABUF_PTR(fpdu);\n\tstatus = *(pdq_rxstatus_t *) dataptr;\n\tif ((status.rxs_status & 0x200000) == 0) {\n\t    datalen = status.rxs_status & 0x1FFF;\n\t    fc = dataptr[PDQ_RX_FC_OFFSET];\n\t    switch (fc & (PDQ_FDDIFC_C|PDQ_FDDIFC_L|PDQ_FDDIFC_F)) {\n\t\tcase PDQ_FDDI_LLC_ASYNC:\n\t\tcase PDQ_FDDI_LLC_SYNC:\n\t\tcase PDQ_FDDI_IMP_ASYNC:\n\t\tcase PDQ_FDDI_IMP_SYNC: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_LLC_MIN) {\n\t\t\tPDQ_PRINTF((\"discard: bad length %d\\n\", datalen));\n\t\t\tgoto discard_frame;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tcase PDQ_FDDI_SMT: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_SMT_MIN)\n\t\t\tgoto discard_frame;\n\t\t    break;\n\t\t}\n\t\tdefault: {\n\t\t    PDQ_PRINTF((\"discard: bad fc 0x%x\\n\", fc));\n\t\t    goto discard_frame;\n\t\t}\n\t    }\n\t    /*\n\t     * Update the lengths of the data buffers now that we know\n\t     * the real length.\n\t     */\n\t    pdulen = datalen - 4 /* CRC */;\n\t    segcnt = (pdulen + PDQ_RX_FC_OFFSET + PDQ_OS_DATABUF_SIZE - 1) / PDQ_OS_DATABUF_SIZE; \n\t    PDQ_OS_DATABUF_ALLOC(npdu);\n\t    if (npdu == NULL) {\n\t\tPDQ_PRINTF((\"discard: no databuf #0\\n\"));\n\t\tgoto discard_frame;\n\t    }\n\t    buffers[completion] = npdu;\n\t    for (idx = 1; idx < segcnt; idx++) {\n\t\tPDQ_OS_DATABUF_ALLOC(npdu);\n\t\tif (npdu == NULL) {\n\t\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t\t    PDQ_OS_DATABUF_FREE(fpdu);\n\t\t    goto discard_frame;\n\t\t}\n\t\tPDQ_OS_DATABUF_NEXT_SET(lpdu, buffers[(completion + idx) & ring_mask]);\n\t\tlpdu = PDQ_OS_DATABUF_NEXT(lpdu);\n\t\tbuffers[(completion + idx) & ring_mask] = npdu;\n\t    }\n\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t    for (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t\tbuffers[(producer + idx) & ring_mask] = \n\t\t    buffers[(completion + idx) & ring_mask];\n\t\tbuffers[(completion + idx) & ring_mask] = NULL;\n\t    }\n\t    PDQ_OS_DATABUF_ADJ(fpdu, PDQ_RX_FC_OFFSET);\n\t    if (segcnt == 1) {\n\t\tPDQ_OS_DATABUF_LEN_SET(fpdu, pdulen);\n\t    } else {\n\t\tPDQ_OS_DATABUF_LEN_SET(lpdu, pdulen + PDQ_RX_FC_OFFSET - (segcnt - 1) * PDQ_OS_DATABUF_SIZE);\n\t    }\n\t    pdq_os_receive_pdu(pdq, fpdu, pdulen);\n\t    rx->rx_free += PDQ_RX_SEGCNT;\n\t    PDQ_ADVANCE(producer, PDQ_RX_SEGCNT, ring_mask);\n\t    PDQ_ADVANCE(completion, PDQ_RX_SEGCNT, ring_mask);\n\t    continue;\n\t} else {\n\t    PDQ_PRINTF((\"discard: bad pdu 0x%x(%d.%d.%d.%d.%d)\\n\", status.rxs_status,\n\t\t\tstatus.rxs_rcc_badpdu, status.rxs_rcc_badcrc,\n\t\t\tstatus.rxs_rcc_reason, status.rxs_fsc, status.rxs_fsb_e));\n\t    if (status.rxs_rcc_reason == 7)\n\t\tgoto discard_frame;\n\t    if (status.rxs_rcc_reason != 0) {\n\t\t/* hardware fault */\n\t    }\n\t    if (status.rxs_rcc_badcrc) {\n\t\tprintf(PDQ_OS_PREFIX \" MAC CRC error (source=%x-%x-%x-%x-%x-%x)\\n\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       dataptr[PDQ_RX_FC_OFFSET+1],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+2],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+3],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+4],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+5],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+6]);\n\t\t/* rx->rx_badcrc++; */\n\t    } else if (status.rxs_fsc == 0 || status.rxs_fsb_e == 1) {\n\t\t/* rx->rx_frame_status_errors++; */\n\t    } else {\n\t\t/* hardware fault */\n\t    }\n\t}\n      discard_frame:\n\t/*\n\t * Discarded frames go right back on the queue; therefore\n\t * ring entries were freed.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    buffers[producer] = buffers[completion];\n\t    buffers[completion] = NULL;\n\t    rxd = &receives[rx->rx_producer];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(buffers[rx->rx_producer]));\n\t    PDQ_ADVANCE(rx->rx_producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(completion, 1, ring_mask);\n\t}\n    }\n    rx->rx_completion = completion;\n\n    while (rx->rx_free > PDQ_RX_SEGCNT && rx->rx_free > rx->rx_target) {\n\tPDQ_OS_DATABUF_T *pdu;\n\t/*\n\t * Allocate the needed number of data buffers.\n\t * Try to obtain them from our free queue before\n\t * asking the system for more.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    if ((pdu = buffers[(rx->rx_producer + idx) & ring_mask]) == NULL) {\n\t\tPDQ_OS_DATABUF_ALLOC(pdu);\n\t\tif (pdu == NULL)\n\t\t    break;\n\t\tbuffers[(rx->rx_producer + idx) & ring_mask] = pdu;\n\t    }\n\t    rxd = &receives[(rx->rx_producer + idx) & ring_mask];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(pdu));\n\t}\n\tif (idx < PDQ_RX_SEGCNT) {\n\t    /*\n\t     * We didn't get all databufs required to complete a new\n\t     * receive buffer.  Keep the ones we got and retry a bit\n\t     * later for the rest.\n\t     */\n\t    break;\n\t}\n\tPDQ_ADVANCE(rx->rx_producer, PDQ_RX_SEGCNT, ring_mask);\n\trx->rx_free -= PDQ_RX_SEGCNT;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_host_smt"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_STATUS_CHARS_GET"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_ADDR_FILTER_SET"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_FILTER_SET"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_STATUS_CHARS_GET"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_START"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_ADDR_FILTER_SET"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_FILTER_SET"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_smt_producer",
            "pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8)"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_host_smt"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_DO_TYPE2_PRODUCER",
          "args": [
            "pdq"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_receives"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_enable",
            "PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_type_0",
            "0xFF"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state != PDQS_RING_MEMBER"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state != PDQS_UPGRADE"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state != PDQS_HALTED"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state != PDQS_RESET"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state != PDQS_DMA_UNAVAILABLE"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_run(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state != PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(state != PDQS_RESET);\n    PDQ_ASSERT(state != PDQS_HALTED);\n    PDQ_ASSERT(state != PDQS_UPGRADE);\n    PDQ_ASSERT(state != PDQS_RING_MEMBER);\n    switch (state) {\n\tcase PDQS_DMA_AVAILABLE: {\n\t    /*\n\t     * The PDQ after being reset screws up some of its state.\n\t     * So we need to clear all the errors/interrupts so the real\n\t     * ones will get through.\n\t     */\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n\t    PDQ_CSR_WRITE(csrs, csr_host_int_enable, PDQ_HOST_INT_STATE_CHANGE|PDQ_HOST_INT_XMT_DATA_FLUSH\n\t\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE|PDQ_HOST_INT_UNSOL_ENABLE\n\t\t|PDQ_HOST_INT_RX_ENABLE|PDQ_HOST_INT_TX_ENABLE|PDQ_HOST_INT_HOST_SMT_ENABLE);\n\t    /*\n\t     * Set the MAC and address filters and start up the PDQ.\n\t     */\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_process_received_data(pdq, &pdq->pdq_rx_info,\n\t\t\t\t      pdq->pdq_dbp->pdqdb_receives,\n\t\t\t\t      pdq->pdq_cbp->pdqcb_receives,\n\t\t\t\t      PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives));\n\t    PDQ_DO_TYPE2_PRODUCER(pdq);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET) | PDQ_BITMASK(PDQC_START);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    pdq->pdq_command_info.ci_pending_commands = PDQ_BITMASK(PDQC_FILTER_SET)\n\t\t| PDQ_BITMASK(PDQC_ADDR_FILTER_SET);\n\t    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\t\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n\t    if (pdq->pdq_flags & PDQ_PASS_SMT) {\n\t\tpdq_process_received_data(pdq, &pdq->pdq_host_smt_info,\n\t\t\t\t\t  pdq->pdq_dbp->pdqdb_host_smt,\n\t\t\t\t\t  pdq->pdq_cbp->pdqcb_host_smt,\n\t\t\t\t\t  PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt));\n\t\tPDQ_CSR_WRITE(csrs, csr_host_smt_producer,\n\t\t\t      pdq->pdq_host_smt_info.rx_producer\n\t\t\t          | (pdq->pdq_host_smt_info.rx_completion << 8));\n\t    }\n\t    pdq_process_unsolicited_events(pdq);\n\t    pdq_queue_commands(pdq);\n\t    break;\n\t}\n\tcase PDQS_RING_MEMBER: {\n\t}\n\tdefault:\n    }\n}"
  },
  {
    "function_name": "pdq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "975-1168",
    "snippet": "pdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_USEC_DELAY",
          "args": [
            "1000"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_process_command_responses",
          "args": [
            "pdq"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_command_responses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "547-591",
          "snippet": "static void\npdq_process_command_responses(\n    pdq_t * const pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    volatile const pdq_consumer_block_t * const cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    const pdq_response_generic_t *rspgen;\n\n    /*\n     * We have to process the command and response in tandem so\n     * just wait for the response to be consumed.  If it has been\n     * consumed then the command must have been as well.\n     */\n\n    if (cbp->pdqcb_command_response == ci->ci_response_completion)\n\treturn;\n\n    PDQ_ASSERT(cbp->pdqcb_command_request != ci->ci_request_completion);\n\n    rspgen = (const pdq_response_generic_t *) ci->ci_bufstart;\n    PDQ_ASSERT(rspgen->generic_status == PDQR_SUCCESS);\n    PDQ_PRINTF((\"PDQ Process Command Response: %s completed (status=%d)\\n\",\n\t\tpdq_cmd_info[rspgen->generic_op].cmd_name,\n\t\trspgen->generic_status));\n\n    if (rspgen->generic_op == PDQC_STATUS_CHARS_GET && (pdq->pdq_flags & PDQ_PRINTCHARS)) {\n\tpdq->pdq_flags &= ~PDQ_PRINTCHARS;\n\tpdq_print_fddi_chars(pdq, (const pdq_response_status_chars_get_t *) rspgen);\n    }\n\n    PDQ_ADVANCE(ci->ci_request_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n    PDQ_ADVANCE(ci->ci_response_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n    ci->ci_command_active = 0;\n\n    if (ci->ci_pending_commands != 0) {\n\tpdq_queue_commands(pdq);\n    } else {\n\tPDQ_CSR_WRITE(csrs, csr_cmd_response_producer,\n\t\t      ci->ci_response_producer | (ci->ci_response_completion << 8));\n\tPDQ_CSR_WRITE(csrs, csr_cmd_request_producer,\n\t\t      ci->ci_request_producer | (ci->ci_request_completion << 8));\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};\n\nstatic void\npdq_process_command_responses(\n    pdq_t * const pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    volatile const pdq_consumer_block_t * const cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    const pdq_response_generic_t *rspgen;\n\n    /*\n     * We have to process the command and response in tandem so\n     * just wait for the response to be consumed.  If it has been\n     * consumed then the command must have been as well.\n     */\n\n    if (cbp->pdqcb_command_response == ci->ci_response_completion)\n\treturn;\n\n    PDQ_ASSERT(cbp->pdqcb_command_request != ci->ci_request_completion);\n\n    rspgen = (const pdq_response_generic_t *) ci->ci_bufstart;\n    PDQ_ASSERT(rspgen->generic_status == PDQR_SUCCESS);\n    PDQ_PRINTF((\"PDQ Process Command Response: %s completed (status=%d)\\n\",\n\t\tpdq_cmd_info[rspgen->generic_op].cmd_name,\n\t\trspgen->generic_status));\n\n    if (rspgen->generic_op == PDQC_STATUS_CHARS_GET && (pdq->pdq_flags & PDQ_PRINTCHARS)) {\n\tpdq->pdq_flags &= ~PDQ_PRINTCHARS;\n\tpdq_print_fddi_chars(pdq, (const pdq_response_status_chars_get_t *) rspgen);\n    }\n\n    PDQ_ADVANCE(ci->ci_request_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n    PDQ_ADVANCE(ci->ci_response_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n    ci->ci_command_active = 0;\n\n    if (ci->ci_pending_commands != 0) {\n\tpdq_queue_commands(pdq);\n    } else {\n\tPDQ_CSR_WRITE(csrs, csr_cmd_response_producer,\n\t\t      ci->ci_response_producer | (ci->ci_response_completion << 8));\n\tPDQ_CSR_WRITE(csrs, csr_cmd_request_producer,\n\t\t      ci->ci_request_producer | (ci->ci_request_completion << 8));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_queue_commands",
          "args": [
            "pdq"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_queue_commands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "438-545",
          "snippet": "static void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [
            "#define\tPDQ_CMD_RX_ALIGNMENT\t16"
          ],
          "globals_used": [
            "static const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\n#define\tPDQ_CMD_RX_ALIGNMENT\t16\n\nstatic const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};\n\nstatic void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_STATUS_CHARS_GET"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_BITMASK",
          "args": [
            "PDQC_START"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_enable",
            "0"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_type_0",
            "0xFF"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state == PDQS_DMA_AVAILABLE"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_USEC_DELAY",
          "args": [
            "1000"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"Transition to DMA Available took %d spins\\n\", cnt)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_do_port_control",
          "args": [
            "csrs",
            "PDQ_PCTL_DMA_INIT"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_do_port_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "264-282",
          "snippet": "static pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "pdq->pdq_dbp"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_b",
            "0"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "pdq->pdq_cbp"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_b",
            "0"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "PDQ_SUB_CMD_DMA_BURST_SIZE_SET"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_b",
            "PDQ_DMA_BURST_8LW"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_b",
            "PDQ_DMA_BURST_16LW"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_process_unsolicited_events",
          "args": [
            "pdq"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_process_unsolicited_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "599-645",
          "snippet": "static void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};",
            "static const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};\nstatic const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};\n\nstatic void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_mode_control",
            "PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_mode_control",
            "PDQ_PFI_MODE_DMA_ENABLE"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_transmits"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_host_smt"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_FREE",
          "args": [
            "buffers[idx]"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_SIZE",
          "args": [
            "pdq->pdq_dbp->pdqdb_host_smt"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_receives"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_FREE",
          "args": [
            "buffers[idx]"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_SIZE",
          "args": [
            "pdq->pdq_dbp->pdqdb_receives"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_flush_databuf_queue",
          "args": [
            "&pdq->pdq_tx_info.tx_txq"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_flush_databuf_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "251-262",
          "snippet": "static void\npdq_flush_databuf_queue(\n    pdq_databuf_queue_t *q)\n{\n    PDQ_OS_DATABUF_T *pdu;\n    for (;;) {\n\tPDQ_OS_DATABUF_DEQUEUE(q, pdu);\n\tif (pdu == NULL)\n\t    return;\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_flush_databuf_queue(\n    pdq_databuf_queue_t *q)\n{\n    PDQ_OS_DATABUF_T *pdu;\n    for (;;) {\n\tPDQ_OS_DATABUF_DEQUEUE(q, pdu);\n\tif (pdu == NULL)\n\t    return;\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_status",
            "0x10"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "&pdq->pdq_pci_csrs",
            "csr_pfi_mode_control",
            "0"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_read_chiprev",
          "args": [
            "&pdq->pdq_csrs"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_read_chiprev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "342-353",
          "snippet": "static pdq_chip_rev_t\npdq_read_chiprev(\n    const pdq_csrs_t * const csrs)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_PDQ_REV_GET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    return (pdq_chip_rev_t) data;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_chip_rev_t\npdq_read_chiprev(\n    const pdq_csrs_t * const csrs)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_PDQ_REV_GET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    return (pdq_chip_rev_t) data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_read_fwrev",
          "args": [
            "&pdq->pdq_csrs",
            "&pdq->pdq_fwrev"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_read_fwrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "308-322",
          "snippet": "static void\npdq_read_fwrev(\n    const pdq_csrs_t * const csrs,\n    pdq_fwrev_t *fwrev)\n{\n    pdq_uint32_t data;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    fwrev->fwrev_bytes[3] = (data >> 0) & 0xFF;\n    fwrev->fwrev_bytes[2] = (data >> 8) & 0xFF;\n    fwrev->fwrev_bytes[1] = (data >> 16) & 0xFF;\n    fwrev->fwrev_bytes[0] = (data >> 24) & 0xFF;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_read_fwrev(\n    const pdq_csrs_t * const csrs,\n    pdq_fwrev_t *fwrev)\n{\n    pdq_uint32_t data;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    fwrev->fwrev_bytes[3] = (data >> 0) & 0xFF;\n    fwrev->fwrev_bytes[2] = (data >> 8) & 0xFF;\n    fwrev->fwrev_bytes[1] = (data >> 16) & 0xFF;\n    fwrev->fwrev_bytes[0] = (data >> 24) & 0xFF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdq_read_mla",
          "args": [
            "&pdq->pdq_csrs",
            "&pdq->pdq_hwaddr"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_read_mla",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "284-306",
          "snippet": "static void\npdq_read_mla(\n    const pdq_csrs_t * const csrs,\n    pdq_lanaddr_t *hwaddr)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[0] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[1] = (data >> 8) & 0xFF;\n    hwaddr->lanaddr_bytes[2] = (data >> 16) & 0xFF;\n    hwaddr->lanaddr_bytes[3] = (data >> 24) & 0xFF;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 1);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[4] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[5] = (data >> 8) & 0xFF;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_read_mla(\n    const pdq_csrs_t * const csrs,\n    pdq_lanaddr_t *hwaddr)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[0] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[1] = (data >> 8) & 0xFF;\n    hwaddr->lanaddr_bytes[2] = (data >> 16) & 0xFF;\n    hwaddr->lanaddr_bytes[3] = (data >> 24) & 0xFF;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 1);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[4] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[5] = (data >> 8) & 0xFF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state == PDQS_DMA_UNAVAILABLE"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_b",
            "0"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "0"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state == PDQS_DMA_AVAILABLE"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_b",
            "0"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "PDQ_SUB_CMD_LINK_UNINIT"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state == PDQS_DMA_UNAVAILABLE"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_hwreset",
          "args": [
            "pdq"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_hwreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "942-969",
          "snippet": "void\npdq_hwreset(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n    int cnt;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state == PDQS_DMA_UNAVAILABLE)\n\treturn;\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  (state == PDQS_HALTED) ? 0 : PDQ_PRESET_SKIP_SELFTEST);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 1);\n    PDQ_OS_USEC_DELAY(100);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 0);\n    for (cnt = 45000;;cnt--) {\n\tPDQ_OS_USEC_DELAY(1000);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_DMA_UNAVAILABLE || cnt == 0)\n\t    break;\n    }\n    PDQ_PRINTF((\"PDQ Reset spun %d cycles\\n\", 45000 - cnt));\n    PDQ_OS_USEC_DELAY(10000);\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(cnt > 0);\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_hwreset(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n    int cnt;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state == PDQS_DMA_UNAVAILABLE)\n\treturn;\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  (state == PDQS_HALTED) ? 0 : PDQ_PRESET_SKIP_SELFTEST);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 1);\n    PDQ_OS_USEC_DELAY(100);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 0);\n    for (cnt = 45000;;cnt--) {\n\tPDQ_OS_USEC_DELAY(1000);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_DMA_UNAVAILABLE || cnt == 0)\n\t    break;\n    }\n    PDQ_PRINTF((\"PDQ Reset spun %d cycles\\n\", 45000 - cnt));\n    PDQ_OS_USEC_DELAY(10000);\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(cnt > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\npdq_state_t\npdq_stop(\n    pdq_t *pdq)\n{\n    pdq_state_t state;\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    int cnt, pass = 0, idx;\n    PDQ_OS_DATABUF_T **buffers;\n\n  restart:\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state != PDQS_DMA_UNAVAILABLE) {\n\tpdq_hwreset(pdq);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tPDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    }\n#if 0\n    switch (state) {\n\tcase PDQS_RING_MEMBER:\n\tcase PDQS_LINK_UNAVAILABLE:\n\tcase PDQS_LINK_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_LINK_UNINIT);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_AVAILABLE: {\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n\t    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n\t    pdq_do_port_control(csrs, PDQ_PCTL_DMA_UNINIT);\n\t    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\t    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n\t    /* FALL THROUGH */\n\t}\n\tcase PDQS_DMA_UNAVAILABLE: {\n\t    break;\n\t}\n    }\n#endif\n    /*\n     * Now we should be in DMA_UNAVAILABLE.  So bring the PDQ into\n     * DMA_AVAILABLE.\n     */\n\n    /*\n     * Obtain the hardware address and firmware revisions\n     * (MLA = my long address which is FDDI speak for hardware address)\n     */\n    pdq_read_mla(&pdq->pdq_csrs, &pdq->pdq_hwaddr);\n    pdq_read_fwrev(&pdq->pdq_csrs, &pdq->pdq_fwrev);\n    pdq->pdq_chip_rev = pdq_read_chiprev(&pdq->pdq_csrs);\n\n    if (pdq->pdq_type == PDQ_DEFPA) {\n\t/*\n\t * Disable interrupts and DMA.\n\t */\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control, 0);\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_status, 0x10);\n    }\n\n    /*\n     * Flush all the databuf queues.\n     */\n    pdq_flush_databuf_queue(&pdq->pdq_tx_info.tx_txq);\n    pdq->pdq_flags &= ~PDQ_TXOK;\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_rx_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_receives); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_rx_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_receives);\n    buffers = (PDQ_OS_DATABUF_T **) pdq->pdq_host_smt_info.rx_buffers;\n    for (idx = 0; idx < PDQ_RING_SIZE(pdq->pdq_dbp->pdqdb_host_smt); idx++) {\n\tif (buffers[idx] != NULL) {\n\t    PDQ_OS_DATABUF_FREE(buffers[idx]);\n\t    buffers[idx] = NULL;\n\t}\n    }\n    pdq->pdq_host_smt_info.rx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_host_smt);\n\n    /*\n     * Reset the consumer indexes to 0.\n     */\n    pdq->pdq_cbp->pdqcb_receives = 0;\n    pdq->pdq_cbp->pdqcb_transmits = 0;\n    pdq->pdq_cbp->pdqcb_host_smt = 0;\n    pdq->pdq_cbp->pdqcb_unsolicited_event = 0;\n    pdq->pdq_cbp->pdqcb_command_response = 0;\n    pdq->pdq_cbp->pdqcb_command_request = 0;\n\n    /*\n     * Reset the producer and completion indexes to 0.\n     */\n    pdq->pdq_command_info.ci_request_producer = 0;\n    pdq->pdq_command_info.ci_response_producer = 0;\n    pdq->pdq_command_info.ci_request_completion = 0;\n    pdq->pdq_command_info.ci_response_completion = 0;\n    pdq->pdq_unsolicited_info.ui_producer = 0;\n    pdq->pdq_unsolicited_info.ui_completion = 0;\n    pdq->pdq_rx_info.rx_producer = 0;\n    pdq->pdq_rx_info.rx_completion = 0;\n    pdq->pdq_tx_info.tx_producer = 0;\n    pdq->pdq_tx_info.tx_completion = 0;\n    pdq->pdq_host_smt_info.rx_producer = 0;\n    pdq->pdq_host_smt_info.rx_completion = 0;\n\n    pdq->pdq_command_info.ci_command_active = 0;\n    pdq->pdq_unsolicited_info.ui_free = PDQ_NUM_UNSOLICITED_EVENTS;\n    pdq->pdq_tx_info.tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n\n    /*\n     * Allow the DEFPA to do DMA.  Then program the physical \n     * addresses of the consumer and descriptor blocks.\n     */\n    if (pdq->pdq_type == PDQ_DEFPA) {\n#ifdef PDQTEST\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE);\n#else\n\tPDQ_CSR_WRITE(&pdq->pdq_pci_csrs, csr_pfi_mode_control,\n\t\t      PDQ_PFI_MODE_DMA_ENABLE\n\t    /*|PDQ_PFI_MODE_PFI_PCI_INTR*/|PDQ_PFI_MODE_PDQ_PCI_INTR);\n#endif\n    }\n\n    /*\n     * Make sure the unsolicited queue has events ...\n     */\n    pdq_process_unsolicited_events(pdq);\n\n    if (pdq->pdq_type == PDQ_DEFEA && pdq->pdq_chip_rev == PDQ_CHIP_REV_E)\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_16LW);\n    else\n\tPDQ_CSR_WRITE(csrs, csr_port_data_b, PDQ_DMA_BURST_8LW);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_DMA_BURST_SIZE_SET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_OS_VA_TO_PA(pdq, pdq->pdq_cbp));\n    pdq_do_port_control(csrs, PDQ_PCTL_CONSUMER_BLOCK);\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_b, 0);\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  PDQ_OS_VA_TO_PA(pdq, pdq->pdq_dbp) | PDQ_DMA_INIT_LW_BSWAP_DATA);\n    pdq_do_port_control(csrs, PDQ_PCTL_DMA_INIT);\n\n    for (cnt = 0; cnt < 1000; cnt++) {\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_HALTED) {\n\t    if (pass > 0)\n\t\treturn PDQS_HALTED;\n\t    pass = 1;\n\t    goto restart;\n\t}\n\tif (state == PDQS_DMA_AVAILABLE) {\n\t    PDQ_PRINTF((\"Transition to DMA Available took %d spins\\n\", cnt));\n\t    break;\n\t}\n\tPDQ_OS_USEC_DELAY(1000);\n    }\n    PDQ_ASSERT(state == PDQS_DMA_AVAILABLE);\n    \n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, 0xFF);\n    PDQ_CSR_WRITE(csrs, csr_host_int_enable, 0) /* PDQ_HOST_INT_STATE_CHANGE\n\t|PDQ_HOST_INT_FATAL_ERROR|PDQ_HOST_INT_CMD_RSP_ENABLE\n\t|PDQ_HOST_INT_UNSOL_ENABLE */;\n\n    /*\n     * Any other command but START should be valid.\n     */\n    pdq->pdq_command_info.ci_pending_commands &= ~(PDQ_BITMASK(PDQC_START));\n    if (pdq->pdq_flags & PDQ_PRINTCHARS)\n\tpdq->pdq_command_info.ci_pending_commands |= PDQ_BITMASK(PDQC_STATUS_CHARS_GET);\n    pdq_queue_commands(pdq);\n\n    if (pdq->pdq_flags & PDQ_PRINTCHARS) {\n\t/*\n\t * Now wait (up to 100ms) for the command(s) to finish.\n\t */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t    pdq_process_command_responses(pdq);\n\t    if (pdq->pdq_command_info.ci_response_producer == pdq->pdq_command_info.ci_response_completion)\n\t\tbreak;\n\t    PDQ_OS_USEC_DELAY(1000);\n\t}\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    }\n\n    return state;\n}"
  },
  {
    "function_name": "pdq_hwreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "942-969",
    "snippet": "void\npdq_hwreset(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n    int cnt;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state == PDQS_DMA_UNAVAILABLE)\n\treturn;\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  (state == PDQS_HALTED) ? 0 : PDQ_PRESET_SKIP_SELFTEST);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 1);\n    PDQ_OS_USEC_DELAY(100);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 0);\n    for (cnt = 45000;;cnt--) {\n\tPDQ_OS_USEC_DELAY(1000);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_DMA_UNAVAILABLE || cnt == 0)\n\t    break;\n    }\n    PDQ_PRINTF((\"PDQ Reset spun %d cycles\\n\", 45000 - cnt));\n    PDQ_OS_USEC_DELAY(10000);\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(cnt > 0);\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "cnt > 0"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "state == PDQS_DMA_UNAVAILABLE"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_USEC_DELAY",
          "args": [
            "10000"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Reset spun %d cycles\\n\", 45000 - cnt)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_USEC_DELAY",
          "args": [
            "1000"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_reset",
            "0"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_USEC_DELAY",
          "args": [
            "100"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_reset",
            "1"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "(state == PDQS_HALTED) ? 0 : PDQ_PRESET_SKIP_SELFTEST"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PSTS_ADAPTER_STATE",
          "args": [
            "PDQ_CSR_READ(csrs, csr_port_status)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_status"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_hwreset(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_state_t state;\n    int cnt;\n\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    if (state == PDQS_DMA_UNAVAILABLE)\n\treturn;\n    PDQ_CSR_WRITE(csrs, csr_port_data_a,\n\t\t  (state == PDQS_HALTED) ? 0 : PDQ_PRESET_SKIP_SELFTEST);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 1);\n    PDQ_OS_USEC_DELAY(100);\n    PDQ_CSR_WRITE(csrs, csr_port_reset, 0);\n    for (cnt = 45000;;cnt--) {\n\tPDQ_OS_USEC_DELAY(1000);\n\tstate = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n\tif (state == PDQS_DMA_UNAVAILABLE || cnt == 0)\n\t    break;\n    }\n    PDQ_PRINTF((\"PDQ Reset spun %d cycles\\n\", 45000 - cnt));\n    PDQ_OS_USEC_DELAY(10000);\n    state = PDQ_PSTS_ADAPTER_STATE(PDQ_CSR_READ(csrs, csr_port_status));\n    PDQ_ASSERT(state == PDQS_DMA_UNAVAILABLE);\n    PDQ_ASSERT(cnt > 0);\n}"
  },
  {
    "function_name": "pdq_flush_transmitter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "917-940",
    "snippet": "void\npdq_flush_transmitter(\n    pdq_t *pdq)\n{\n    volatile pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n\n    for (;;) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tif (pdu == NULL)\n\t    break;\n\t/*\n\t * Don't call transmit done since the packet never made it\n\t * out on the wire.\n\t */\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n\n    tx->tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    tx->tx_completion = cbp->pdqcb_transmits = tx->tx_producer;\n\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_DO_TYPE2_PRODUCER",
          "args": [
            "pdq"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "pdq->pdq_dbp->pdqdb_transmits"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_FREE",
          "args": [
            "pdu"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_DEQUEUE",
          "args": [
            "&tx->tx_txq",
            "pdu"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nvoid\npdq_flush_transmitter(\n    pdq_t *pdq)\n{\n    volatile pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n\n    for (;;) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tif (pdu == NULL)\n\t    break;\n\t/*\n\t * Don't call transmit done since the packet never made it\n\t * out on the wire.\n\t */\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n\n    tx->tx_free = PDQ_RING_MASK(pdq->pdq_dbp->pdqdb_transmits);\n    tx->tx_completion = cbp->pdqcb_transmits = tx->tx_producer;\n\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}"
  },
  {
    "function_name": "pdq_process_transmitted_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "890-915",
    "snippet": "static void\npdq_process_transmitted_data(\n    pdq_t *pdq)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t completion = tx->tx_completion;\n\n    while (completion != cbp->pdqcb_transmits) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tpdq_uint32_t descriptor_count = tx->tx_descriptor_count[completion];\n\tPDQ_ASSERT(dbp->pdqdb_transmits[completion].txd_sop == 1);\n\tPDQ_ASSERT(dbp->pdqdb_transmits[(completion + descriptor_count - 1) & PDQ_RING_MASK(dbp->pdqdb_transmits)].txd_eop == 1);\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tpdq_os_transmit_done(pdq, pdu);\n\ttx->tx_free += descriptor_count;\n\n\tPDQ_ADVANCE(completion, descriptor_count, PDQ_RING_MASK(dbp->pdqdb_transmits));\n    }\n    if (tx->tx_completion != completion) {\n\ttx->tx_completion = completion;\n\tpdq_os_restart_transmitter(pdq);\n    }\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_DO_TYPE2_PRODUCER",
          "args": [
            "pdq"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_os_restart_transmitter",
          "args": [
            "pdq"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_os_restart_transmitter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "218-230",
          "snippet": "void\npdq_os_restart_transmitter(\n    pdq_t *pdq)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    sc->sc_if.if_flags &= ~IFF_OACTIVE;\n    if (sc->sc_if.if_snd.ifq_head != NULL) {\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\tpdq_ifstart(&sc->sc_if);\n    } else {\n\tsc->sc_if.if_timer = 0;\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_restart_transmitter(\n    pdq_t *pdq)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    sc->sc_if.if_flags &= ~IFF_OACTIVE;\n    if (sc->sc_if.if_snd.ifq_head != NULL) {\n\tsc->sc_if.if_timer = PDQ_OS_TX_TIMEOUT;\n\tpdq_ifstart(&sc->sc_if);\n    } else {\n\tsc->sc_if.if_timer = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "completion",
            "descriptor_count",
            "PDQ_RING_MASK(dbp->pdqdb_transmits)"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_transmits"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_os_transmit_done",
          "args": [
            "pdq",
            "pdu"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_os_transmit_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "232-244",
          "snippet": "void\npdq_os_transmit_done(\n    pdq_t *pdq,\n    struct mbuf *m)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n#endif\n    m_freem(m);\n    sc->sc_if.if_opackets++;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_transmit_done(\n    pdq_t *pdq,\n    struct mbuf *m)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n#endif\n    m_freem(m);\n    sc->sc_if.if_opackets++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_DEQUEUE",
          "args": [
            "&tx->tx_txq",
            "pdu"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "dbp->pdqdb_transmits[(completion + descriptor_count - 1) & PDQ_RING_MASK(dbp->pdqdb_transmits)].txd_eop == 1"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_transmits"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "dbp->pdqdb_transmits[completion].txd_sop == 1"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_process_transmitted_data(\n    pdq_t *pdq)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t completion = tx->tx_completion;\n\n    while (completion != cbp->pdqcb_transmits) {\n\tPDQ_OS_DATABUF_T *pdu;\n\tpdq_uint32_t descriptor_count = tx->tx_descriptor_count[completion];\n\tPDQ_ASSERT(dbp->pdqdb_transmits[completion].txd_sop == 1);\n\tPDQ_ASSERT(dbp->pdqdb_transmits[(completion + descriptor_count - 1) & PDQ_RING_MASK(dbp->pdqdb_transmits)].txd_eop == 1);\n\tPDQ_OS_DATABUF_DEQUEUE(&tx->tx_txq, pdu);\n\tpdq_os_transmit_done(pdq, pdu);\n\ttx->tx_free += descriptor_count;\n\n\tPDQ_ADVANCE(completion, descriptor_count, PDQ_RING_MASK(dbp->pdqdb_transmits));\n    }\n    if (tx->tx_completion != completion) {\n\ttx->tx_completion = completion;\n\tpdq_os_restart_transmitter(pdq);\n    }\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n}"
  },
  {
    "function_name": "pdq_queue_transmit_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "822-888",
    "snippet": "pdq_boolean_t\npdq_queue_transmit_data(\n    pdq_t *pdq,\n    PDQ_OS_DATABUF_T *pdu)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t producer = tx->tx_producer;\n    pdq_txdesc_t *eop = NULL;\n    PDQ_OS_DATABUF_T *pdu0;\n    pdq_uint32_t freecnt;\n\n    if (tx->tx_free < 1)\n\treturn PDQ_FALSE;\n\n    dbp->pdqdb_transmits[producer] = tx->tx_hdrdesc;\n    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\n    for (freecnt = tx->tx_free - 1, pdu0 = pdu; pdu0 != NULL && freecnt > 0;) {\n\tpdq_uint32_t fraglen, datalen = PDQ_OS_DATABUF_LEN(pdu0);\n\tconst pdq_uint8_t *dataptr = PDQ_OS_DATABUF_PTR(pdu0);\n\n\t/*\n\t * The first segment is limited to the space remaining in\n\t * page.  All segments after that can be up to a full page\n\t * in size.\n\t */\n\tfraglen = PDQ_OS_PAGESIZE - ((dataptr - (pdq_uint8_t *) NULL) & (PDQ_OS_PAGESIZE-1));\n\twhile (datalen > 0 && freecnt > 0) {\n\t    pdq_uint32_t seglen = (fraglen < datalen ? fraglen : datalen);\n\n\t    /*\n\t     * Initialize the transmit descriptor\n\t     */\n\t    eop = &dbp->pdqdb_transmits[producer];\n\t    eop->txd_seg_len = seglen;\n\t    eop->txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, dataptr);\n\t    eop->txd_sop = eop->txd_eop = eop->txd_pa_hi = 0;\n\n\t    datalen -= seglen;\n\t    dataptr += seglen;\n\t    fraglen = PDQ_OS_PAGESIZE;\n\t    freecnt--;\n\t    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\t}\n\tpdu0 = PDQ_OS_DATABUF_NEXT(pdu0);\n    }\n    if (pdu0 != NULL) {\n\tPDQ_ASSERT(freecnt == 0);\n\t/*\n\t * If we still have data to process then the ring was too full\n\t * to store the PDU.  Return FALSE so the caller will requeue\n\t * the PDU for later.\n\t */\n\treturn PDQ_FALSE;\n    }\n    /*\n     * Everything went fine.  Finish it up.\n     */\n    tx->tx_descriptor_count[tx->tx_producer] = tx->tx_free - freecnt;\n    eop->txd_eop = 1;\n    PDQ_OS_DATABUF_ENQUEUE(&tx->tx_txq, pdu);\n    tx->tx_producer = producer;\n    tx->tx_free = freecnt;\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n    return PDQ_TRUE;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_DO_TYPE2_PRODUCER",
          "args": [
            "pdq"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_ENQUEUE",
          "args": [
            "&tx->tx_txq",
            "pdu"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "freecnt == 0"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_NEXT",
          "args": [
            "pdu0"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "producer",
            "1",
            "PDQ_RING_MASK(dbp->pdqdb_transmits)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_transmits"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "dataptr"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_PTR",
          "args": [
            "pdu0"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_LEN",
          "args": [
            "pdu0"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "producer",
            "1",
            "PDQ_RING_MASK(dbp->pdqdb_transmits)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_transmits"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\npdq_boolean_t\npdq_queue_transmit_data(\n    pdq_t *pdq,\n    PDQ_OS_DATABUF_T *pdu)\n{\n    pdq_tx_info_t *tx = &pdq->pdq_tx_info;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    pdq_uint32_t producer = tx->tx_producer;\n    pdq_txdesc_t *eop = NULL;\n    PDQ_OS_DATABUF_T *pdu0;\n    pdq_uint32_t freecnt;\n\n    if (tx->tx_free < 1)\n\treturn PDQ_FALSE;\n\n    dbp->pdqdb_transmits[producer] = tx->tx_hdrdesc;\n    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\n    for (freecnt = tx->tx_free - 1, pdu0 = pdu; pdu0 != NULL && freecnt > 0;) {\n\tpdq_uint32_t fraglen, datalen = PDQ_OS_DATABUF_LEN(pdu0);\n\tconst pdq_uint8_t *dataptr = PDQ_OS_DATABUF_PTR(pdu0);\n\n\t/*\n\t * The first segment is limited to the space remaining in\n\t * page.  All segments after that can be up to a full page\n\t * in size.\n\t */\n\tfraglen = PDQ_OS_PAGESIZE - ((dataptr - (pdq_uint8_t *) NULL) & (PDQ_OS_PAGESIZE-1));\n\twhile (datalen > 0 && freecnt > 0) {\n\t    pdq_uint32_t seglen = (fraglen < datalen ? fraglen : datalen);\n\n\t    /*\n\t     * Initialize the transmit descriptor\n\t     */\n\t    eop = &dbp->pdqdb_transmits[producer];\n\t    eop->txd_seg_len = seglen;\n\t    eop->txd_pa_lo = PDQ_OS_VA_TO_PA(pdq, dataptr);\n\t    eop->txd_sop = eop->txd_eop = eop->txd_pa_hi = 0;\n\n\t    datalen -= seglen;\n\t    dataptr += seglen;\n\t    fraglen = PDQ_OS_PAGESIZE;\n\t    freecnt--;\n\t    PDQ_ADVANCE(producer, 1, PDQ_RING_MASK(dbp->pdqdb_transmits));\n\t}\n\tpdu0 = PDQ_OS_DATABUF_NEXT(pdu0);\n    }\n    if (pdu0 != NULL) {\n\tPDQ_ASSERT(freecnt == 0);\n\t/*\n\t * If we still have data to process then the ring was too full\n\t * to store the PDU.  Return FALSE so the caller will requeue\n\t * the PDU for later.\n\t */\n\treturn PDQ_FALSE;\n    }\n    /*\n     * Everything went fine.  Finish it up.\n     */\n    tx->tx_descriptor_count[tx->tx_producer] = tx->tx_free - freecnt;\n    eop->txd_eop = 1;\n    PDQ_OS_DATABUF_ENQUEUE(&tx->tx_txq, pdu);\n    tx->tx_producer = producer;\n    tx->tx_free = freecnt;\n    PDQ_DO_TYPE2_PRODUCER(pdq);\n    return PDQ_TRUE;\n}"
  },
  {
    "function_name": "pdq_process_received_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "647-820",
    "snippet": "static void\npdq_process_received_data(\n    pdq_t *pdq,\n    pdq_rx_info_t *rx,\n    pdq_rxdesc_t *receives,\n    pdq_uint32_t completion_goal,\n    pdq_uint32_t ring_mask)\n{\n    pdq_uint32_t completion = rx->rx_completion;\n    pdq_uint32_t producer = rx->rx_producer;\n    PDQ_OS_DATABUF_T **buffers = (PDQ_OS_DATABUF_T **) rx->rx_buffers;\n    pdq_rxdesc_t *rxd;\n    pdq_uint32_t idx;\n\n    while (completion != completion_goal) {\n\tPDQ_OS_DATABUF_T *fpdu, *lpdu, *npdu;\n\tpdq_uint8_t *dataptr;\n\tpdq_uint32_t fc, datalen, pdulen, segcnt;\n\tpdq_rxstatus_t status;\n\n\tfpdu = lpdu = buffers[completion];\n\tPDQ_ASSERT(fpdu != NULL);\n\n\tdataptr = PDQ_OS_DATABUF_PTR(fpdu);\n\tstatus = *(pdq_rxstatus_t *) dataptr;\n\tif ((status.rxs_status & 0x200000) == 0) {\n\t    datalen = status.rxs_status & 0x1FFF;\n\t    fc = dataptr[PDQ_RX_FC_OFFSET];\n\t    switch (fc & (PDQ_FDDIFC_C|PDQ_FDDIFC_L|PDQ_FDDIFC_F)) {\n\t\tcase PDQ_FDDI_LLC_ASYNC:\n\t\tcase PDQ_FDDI_LLC_SYNC:\n\t\tcase PDQ_FDDI_IMP_ASYNC:\n\t\tcase PDQ_FDDI_IMP_SYNC: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_LLC_MIN) {\n\t\t\tPDQ_PRINTF((\"discard: bad length %d\\n\", datalen));\n\t\t\tgoto discard_frame;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tcase PDQ_FDDI_SMT: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_SMT_MIN)\n\t\t\tgoto discard_frame;\n\t\t    break;\n\t\t}\n\t\tdefault: {\n\t\t    PDQ_PRINTF((\"discard: bad fc 0x%x\\n\", fc));\n\t\t    goto discard_frame;\n\t\t}\n\t    }\n\t    /*\n\t     * Update the lengths of the data buffers now that we know\n\t     * the real length.\n\t     */\n\t    pdulen = datalen - 4 /* CRC */;\n\t    segcnt = (pdulen + PDQ_RX_FC_OFFSET + PDQ_OS_DATABUF_SIZE - 1) / PDQ_OS_DATABUF_SIZE; \n\t    PDQ_OS_DATABUF_ALLOC(npdu);\n\t    if (npdu == NULL) {\n\t\tPDQ_PRINTF((\"discard: no databuf #0\\n\"));\n\t\tgoto discard_frame;\n\t    }\n\t    buffers[completion] = npdu;\n\t    for (idx = 1; idx < segcnt; idx++) {\n\t\tPDQ_OS_DATABUF_ALLOC(npdu);\n\t\tif (npdu == NULL) {\n\t\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t\t    PDQ_OS_DATABUF_FREE(fpdu);\n\t\t    goto discard_frame;\n\t\t}\n\t\tPDQ_OS_DATABUF_NEXT_SET(lpdu, buffers[(completion + idx) & ring_mask]);\n\t\tlpdu = PDQ_OS_DATABUF_NEXT(lpdu);\n\t\tbuffers[(completion + idx) & ring_mask] = npdu;\n\t    }\n\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t    for (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t\tbuffers[(producer + idx) & ring_mask] = \n\t\t    buffers[(completion + idx) & ring_mask];\n\t\tbuffers[(completion + idx) & ring_mask] = NULL;\n\t    }\n\t    PDQ_OS_DATABUF_ADJ(fpdu, PDQ_RX_FC_OFFSET);\n\t    if (segcnt == 1) {\n\t\tPDQ_OS_DATABUF_LEN_SET(fpdu, pdulen);\n\t    } else {\n\t\tPDQ_OS_DATABUF_LEN_SET(lpdu, pdulen + PDQ_RX_FC_OFFSET - (segcnt - 1) * PDQ_OS_DATABUF_SIZE);\n\t    }\n\t    pdq_os_receive_pdu(pdq, fpdu, pdulen);\n\t    rx->rx_free += PDQ_RX_SEGCNT;\n\t    PDQ_ADVANCE(producer, PDQ_RX_SEGCNT, ring_mask);\n\t    PDQ_ADVANCE(completion, PDQ_RX_SEGCNT, ring_mask);\n\t    continue;\n\t} else {\n\t    PDQ_PRINTF((\"discard: bad pdu 0x%x(%d.%d.%d.%d.%d)\\n\", status.rxs_status,\n\t\t\tstatus.rxs_rcc_badpdu, status.rxs_rcc_badcrc,\n\t\t\tstatus.rxs_rcc_reason, status.rxs_fsc, status.rxs_fsb_e));\n\t    if (status.rxs_rcc_reason == 7)\n\t\tgoto discard_frame;\n\t    if (status.rxs_rcc_reason != 0) {\n\t\t/* hardware fault */\n\t    }\n\t    if (status.rxs_rcc_badcrc) {\n\t\tprintf(PDQ_OS_PREFIX \" MAC CRC error (source=%x-%x-%x-%x-%x-%x)\\n\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       dataptr[PDQ_RX_FC_OFFSET+1],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+2],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+3],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+4],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+5],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+6]);\n\t\t/* rx->rx_badcrc++; */\n\t    } else if (status.rxs_fsc == 0 || status.rxs_fsb_e == 1) {\n\t\t/* rx->rx_frame_status_errors++; */\n\t    } else {\n\t\t/* hardware fault */\n\t    }\n\t}\n      discard_frame:\n\t/*\n\t * Discarded frames go right back on the queue; therefore\n\t * ring entries were freed.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    buffers[producer] = buffers[completion];\n\t    buffers[completion] = NULL;\n\t    rxd = &receives[rx->rx_producer];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(buffers[rx->rx_producer]));\n\t    PDQ_ADVANCE(rx->rx_producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(completion, 1, ring_mask);\n\t}\n    }\n    rx->rx_completion = completion;\n\n    while (rx->rx_free > PDQ_RX_SEGCNT && rx->rx_free > rx->rx_target) {\n\tPDQ_OS_DATABUF_T *pdu;\n\t/*\n\t * Allocate the needed number of data buffers.\n\t * Try to obtain them from our free queue before\n\t * asking the system for more.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    if ((pdu = buffers[(rx->rx_producer + idx) & ring_mask]) == NULL) {\n\t\tPDQ_OS_DATABUF_ALLOC(pdu);\n\t\tif (pdu == NULL)\n\t\t    break;\n\t\tbuffers[(rx->rx_producer + idx) & ring_mask] = pdu;\n\t    }\n\t    rxd = &receives[(rx->rx_producer + idx) & ring_mask];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(pdu));\n\t}\n\tif (idx < PDQ_RX_SEGCNT) {\n\t    /*\n\t     * We didn't get all databufs required to complete a new\n\t     * receive buffer.  Keep the ones we got and retry a bit\n\t     * later for the rest.\n\t     */\n\t    break;\n\t}\n\tPDQ_ADVANCE(rx->rx_producer, PDQ_RX_SEGCNT, ring_mask);\n\trx->rx_free -= PDQ_RX_SEGCNT;\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "rx->rx_producer",
            "PDQ_RX_SEGCNT",
            "ring_mask"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "PDQ_OS_DATABUF_PTR(pdu)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_PTR",
          "args": [
            "pdu"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_ALLOC",
          "args": [
            "pdu"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "completion",
            "1",
            "ring_mask"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "producer",
            "1",
            "ring_mask"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "rx->rx_producer",
            "1",
            "ring_mask"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_VA_TO_PA",
          "args": [
            "pdq",
            "PDQ_OS_DATABUF_PTR(buffers[rx->rx_producer])"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_PTR",
          "args": [
            "buffers[rx->rx_producer]"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "PDQ_OS_PREFIX \" MAC CRC error (source=%x-%x-%x-%x-%x-%x)\\n\"",
            "PDQ_OS_PREFIX_ARGS",
            "dataptr[PDQ_RX_FC_OFFSET+1]",
            "dataptr[PDQ_RX_FC_OFFSET+2]",
            "dataptr[PDQ_RX_FC_OFFSET+3]",
            "dataptr[PDQ_RX_FC_OFFSET+4]",
            "dataptr[PDQ_RX_FC_OFFSET+5]",
            "dataptr[PDQ_RX_FC_OFFSET+6]"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"discard: bad pdu 0x%x(%d.%d.%d.%d.%d)\\n\", status.rxs_status,\n\t\t\tstatus.rxs_rcc_badpdu, status.rxs_rcc_badcrc,\n\t\t\tstatus.rxs_rcc_reason, status.rxs_fsc, status.rxs_fsb_e)"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "completion",
            "PDQ_RX_SEGCNT",
            "ring_mask"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "producer",
            "PDQ_RX_SEGCNT",
            "ring_mask"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_os_receive_pdu",
          "args": [
            "pdq",
            "fpdu",
            "pdulen"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_os_receive_pdu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "192-216",
          "snippet": "void\npdq_os_receive_pdu(\n    pdq_t *pdq,\n    struct mbuf *m,\n    size_t pktlen)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct fddi_header *fh = mtod(m, struct fddi_header *);\n\n    sc->sc_if.if_ipackets++;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n    if ((fh->fddi_fc & (FDDIFC_L|FDDIFC_F)) != FDDIFC_LLC_ASYNC) {\n\tm_freem(m);\n\treturn;\n    }\n#endif\n\n    m->m_data += sizeof(struct fddi_header);\n    m->m_len  -= sizeof(struct fddi_header);\n    m->m_pkthdr.len = pktlen - sizeof(struct fddi_header);\n    m->m_pkthdr.rcvif = &sc->sc_if;\n    fddi_input(&sc->sc_if, fh, m);\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_receive_pdu(\n    pdq_t *pdq,\n    struct mbuf *m,\n    size_t pktlen)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct fddi_header *fh = mtod(m, struct fddi_header *);\n\n    sc->sc_if.if_ipackets++;\n#if NBPFILTER > 0\n    if (sc->sc_bpf != NULL)\n\tPDQ_BPF_MTAP(sc, m);\n    if ((fh->fddi_fc & (FDDIFC_L|FDDIFC_F)) != FDDIFC_LLC_ASYNC) {\n\tm_freem(m);\n\treturn;\n    }\n#endif\n\n    m->m_data += sizeof(struct fddi_header);\n    m->m_len  -= sizeof(struct fddi_header);\n    m->m_pkthdr.len = pktlen - sizeof(struct fddi_header);\n    m->m_pkthdr.rcvif = &sc->sc_if;\n    fddi_input(&sc->sc_if, fh, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_LEN_SET",
          "args": [
            "lpdu",
            "pdulen + PDQ_RX_FC_OFFSET - (segcnt - 1) * PDQ_OS_DATABUF_SIZE"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_LEN_SET",
          "args": [
            "fpdu",
            "pdulen"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_ADJ",
          "args": [
            "fpdu",
            "PDQ_RX_FC_OFFSET"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_NEXT_SET",
          "args": [
            "lpdu",
            "NULL"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_NEXT",
          "args": [
            "lpdu"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_NEXT_SET",
          "args": [
            "lpdu",
            "buffers[(completion + idx) & ring_mask]"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_FREE",
          "args": [
            "fpdu"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_NEXT_SET",
          "args": [
            "lpdu",
            "NULL"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_ALLOC",
          "args": [
            "npdu"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"discard: no databuf #0\\n\")"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_ALLOC",
          "args": [
            "npdu"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"discard: bad fc 0x%x\\n\", fc)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"discard: bad length %d\\n\", datalen)"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_PTR",
          "args": [
            "fpdu"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "fpdu != NULL"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_process_received_data(\n    pdq_t *pdq,\n    pdq_rx_info_t *rx,\n    pdq_rxdesc_t *receives,\n    pdq_uint32_t completion_goal,\n    pdq_uint32_t ring_mask)\n{\n    pdq_uint32_t completion = rx->rx_completion;\n    pdq_uint32_t producer = rx->rx_producer;\n    PDQ_OS_DATABUF_T **buffers = (PDQ_OS_DATABUF_T **) rx->rx_buffers;\n    pdq_rxdesc_t *rxd;\n    pdq_uint32_t idx;\n\n    while (completion != completion_goal) {\n\tPDQ_OS_DATABUF_T *fpdu, *lpdu, *npdu;\n\tpdq_uint8_t *dataptr;\n\tpdq_uint32_t fc, datalen, pdulen, segcnt;\n\tpdq_rxstatus_t status;\n\n\tfpdu = lpdu = buffers[completion];\n\tPDQ_ASSERT(fpdu != NULL);\n\n\tdataptr = PDQ_OS_DATABUF_PTR(fpdu);\n\tstatus = *(pdq_rxstatus_t *) dataptr;\n\tif ((status.rxs_status & 0x200000) == 0) {\n\t    datalen = status.rxs_status & 0x1FFF;\n\t    fc = dataptr[PDQ_RX_FC_OFFSET];\n\t    switch (fc & (PDQ_FDDIFC_C|PDQ_FDDIFC_L|PDQ_FDDIFC_F)) {\n\t\tcase PDQ_FDDI_LLC_ASYNC:\n\t\tcase PDQ_FDDI_LLC_SYNC:\n\t\tcase PDQ_FDDI_IMP_ASYNC:\n\t\tcase PDQ_FDDI_IMP_SYNC: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_LLC_MIN) {\n\t\t\tPDQ_PRINTF((\"discard: bad length %d\\n\", datalen));\n\t\t\tgoto discard_frame;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tcase PDQ_FDDI_SMT: {\n\t\t    if (datalen > PDQ_FDDI_MAX || datalen < PDQ_FDDI_SMT_MIN)\n\t\t\tgoto discard_frame;\n\t\t    break;\n\t\t}\n\t\tdefault: {\n\t\t    PDQ_PRINTF((\"discard: bad fc 0x%x\\n\", fc));\n\t\t    goto discard_frame;\n\t\t}\n\t    }\n\t    /*\n\t     * Update the lengths of the data buffers now that we know\n\t     * the real length.\n\t     */\n\t    pdulen = datalen - 4 /* CRC */;\n\t    segcnt = (pdulen + PDQ_RX_FC_OFFSET + PDQ_OS_DATABUF_SIZE - 1) / PDQ_OS_DATABUF_SIZE; \n\t    PDQ_OS_DATABUF_ALLOC(npdu);\n\t    if (npdu == NULL) {\n\t\tPDQ_PRINTF((\"discard: no databuf #0\\n\"));\n\t\tgoto discard_frame;\n\t    }\n\t    buffers[completion] = npdu;\n\t    for (idx = 1; idx < segcnt; idx++) {\n\t\tPDQ_OS_DATABUF_ALLOC(npdu);\n\t\tif (npdu == NULL) {\n\t\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t\t    PDQ_OS_DATABUF_FREE(fpdu);\n\t\t    goto discard_frame;\n\t\t}\n\t\tPDQ_OS_DATABUF_NEXT_SET(lpdu, buffers[(completion + idx) & ring_mask]);\n\t\tlpdu = PDQ_OS_DATABUF_NEXT(lpdu);\n\t\tbuffers[(completion + idx) & ring_mask] = npdu;\n\t    }\n\t    PDQ_OS_DATABUF_NEXT_SET(lpdu, NULL);\n\t    for (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t\tbuffers[(producer + idx) & ring_mask] = \n\t\t    buffers[(completion + idx) & ring_mask];\n\t\tbuffers[(completion + idx) & ring_mask] = NULL;\n\t    }\n\t    PDQ_OS_DATABUF_ADJ(fpdu, PDQ_RX_FC_OFFSET);\n\t    if (segcnt == 1) {\n\t\tPDQ_OS_DATABUF_LEN_SET(fpdu, pdulen);\n\t    } else {\n\t\tPDQ_OS_DATABUF_LEN_SET(lpdu, pdulen + PDQ_RX_FC_OFFSET - (segcnt - 1) * PDQ_OS_DATABUF_SIZE);\n\t    }\n\t    pdq_os_receive_pdu(pdq, fpdu, pdulen);\n\t    rx->rx_free += PDQ_RX_SEGCNT;\n\t    PDQ_ADVANCE(producer, PDQ_RX_SEGCNT, ring_mask);\n\t    PDQ_ADVANCE(completion, PDQ_RX_SEGCNT, ring_mask);\n\t    continue;\n\t} else {\n\t    PDQ_PRINTF((\"discard: bad pdu 0x%x(%d.%d.%d.%d.%d)\\n\", status.rxs_status,\n\t\t\tstatus.rxs_rcc_badpdu, status.rxs_rcc_badcrc,\n\t\t\tstatus.rxs_rcc_reason, status.rxs_fsc, status.rxs_fsb_e));\n\t    if (status.rxs_rcc_reason == 7)\n\t\tgoto discard_frame;\n\t    if (status.rxs_rcc_reason != 0) {\n\t\t/* hardware fault */\n\t    }\n\t    if (status.rxs_rcc_badcrc) {\n\t\tprintf(PDQ_OS_PREFIX \" MAC CRC error (source=%x-%x-%x-%x-%x-%x)\\n\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       dataptr[PDQ_RX_FC_OFFSET+1],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+2],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+3],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+4],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+5],\n\t\t       dataptr[PDQ_RX_FC_OFFSET+6]);\n\t\t/* rx->rx_badcrc++; */\n\t    } else if (status.rxs_fsc == 0 || status.rxs_fsb_e == 1) {\n\t\t/* rx->rx_frame_status_errors++; */\n\t    } else {\n\t\t/* hardware fault */\n\t    }\n\t}\n      discard_frame:\n\t/*\n\t * Discarded frames go right back on the queue; therefore\n\t * ring entries were freed.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    buffers[producer] = buffers[completion];\n\t    buffers[completion] = NULL;\n\t    rxd = &receives[rx->rx_producer];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(buffers[rx->rx_producer]));\n\t    PDQ_ADVANCE(rx->rx_producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(producer, 1, ring_mask);\t\n\t    PDQ_ADVANCE(completion, 1, ring_mask);\n\t}\n    }\n    rx->rx_completion = completion;\n\n    while (rx->rx_free > PDQ_RX_SEGCNT && rx->rx_free > rx->rx_target) {\n\tPDQ_OS_DATABUF_T *pdu;\n\t/*\n\t * Allocate the needed number of data buffers.\n\t * Try to obtain them from our free queue before\n\t * asking the system for more.\n\t */\n\tfor (idx = 0; idx < PDQ_RX_SEGCNT; idx++) {\n\t    if ((pdu = buffers[(rx->rx_producer + idx) & ring_mask]) == NULL) {\n\t\tPDQ_OS_DATABUF_ALLOC(pdu);\n\t\tif (pdu == NULL)\n\t\t    break;\n\t\tbuffers[(rx->rx_producer + idx) & ring_mask] = pdu;\n\t    }\n\t    rxd = &receives[(rx->rx_producer + idx) & ring_mask];\n\t    if (idx == 0) {\n\t\trxd->rxd_sop = 1; rxd->rxd_seg_cnt = PDQ_RX_SEGCNT - 1;\n\t    } else {\n\t\trxd->rxd_sop = 0; rxd->rxd_seg_cnt = 0;\n\t    }\n\t    rxd->rxd_pa_hi = 0;\n\t    rxd->rxd_seg_len_hi = PDQ_OS_DATABUF_SIZE / 16;\n\t    rxd->rxd_pa_lo = PDQ_OS_VA_TO_PA(pdq, PDQ_OS_DATABUF_PTR(pdu));\n\t}\n\tif (idx < PDQ_RX_SEGCNT) {\n\t    /*\n\t     * We didn't get all databufs required to complete a new\n\t     * receive buffer.  Keep the ones we got and retry a bit\n\t     * later for the rest.\n\t     */\n\t    break;\n\t}\n\tPDQ_ADVANCE(rx->rx_producer, PDQ_RX_SEGCNT, ring_mask);\n\trx->rx_free -= PDQ_RX_SEGCNT;\n    }\n}"
  },
  {
    "function_name": "pdq_process_unsolicited_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "599-645",
    "snippet": "static void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};",
      "static const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_unsolicited_producer",
            "ui->ui_producer | (ui->ui_completion << 8)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "ui->ui_producer",
            "ui->ui_free",
            "PDQ_RING_MASK(dbp->pdqdb_unsolicited_events)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_unsolicited_events"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "ui->ui_completion",
            "1",
            "PDQ_RING_MASK(dbp->pdqdb_unsolicited_events)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_unsolicited_events"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_entities[] = {\n    \"Station\", \"Link\", \"Phy Port\"\n};\nstatic const char * const * const pdq_event_codes[] = {\n    pdq_station_events,\n    pdq_link_events,\n    pdq_phy_events\n};\n\nstatic void\npdq_process_unsolicited_events(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_unsolicited_info_t *ui = &pdq->pdq_unsolicited_info;\n    volatile const pdq_consumer_block_t *cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t *dbp = pdq->pdq_dbp;\n    const pdq_unsolicited_event_t *event;\n    pdq_rxdesc_t *rxd;\n\n    /*\n     * Process each unsolicited event (if any).\n     */\n\n    while (cbp->pdqcb_unsolicited_event != ui->ui_completion) {\n\trxd = &dbp->pdqdb_unsolicited_events[ui->ui_completion];\n\tevent = &ui->ui_events[ui->ui_completion & (PDQ_NUM_UNSOLICITED_EVENTS-1)];\n\n\tswitch (event->event_type) {\n\t    case PDQ_UNSOLICITED_EVENT: {\n\t\tprintf(PDQ_OS_PREFIX \"Unsolicited Event: %s: %s\",\n\t\t       PDQ_OS_PREFIX_ARGS,\n\t\t       pdq_entities[event->event_entity],\n\t\t       pdq_event_codes[event->event_entity][event->event_code.value]);\n\t\tif (event->event_entity == PDQ_ENTITY_PHY_PORT)\n\t\t    printf(\"[%d]\", event->event_index);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\t    }\n\t    case PDQ_UNSOLICITED_COUNTERS: {\n\t\tbreak;\n\t    }\n\t}\n\tPDQ_ADVANCE(ui->ui_completion, 1, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n\tui->ui_free++;\n    }\n\n    /*\n     * Now give back the event buffers back to the PDQ.\n     */\n    PDQ_ADVANCE(ui->ui_producer, ui->ui_free, PDQ_RING_MASK(dbp->pdqdb_unsolicited_events));\n    ui->ui_free = 0;\n\n    PDQ_CSR_WRITE(csrs, csr_unsolicited_producer,\n\t\t  ui->ui_producer | (ui->ui_completion << 8));\n}"
  },
  {
    "function_name": "pdq_process_command_responses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "547-591",
    "snippet": "static void\npdq_process_command_responses(\n    pdq_t * const pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    volatile const pdq_consumer_block_t * const cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    const pdq_response_generic_t *rspgen;\n\n    /*\n     * We have to process the command and response in tandem so\n     * just wait for the response to be consumed.  If it has been\n     * consumed then the command must have been as well.\n     */\n\n    if (cbp->pdqcb_command_response == ci->ci_response_completion)\n\treturn;\n\n    PDQ_ASSERT(cbp->pdqcb_command_request != ci->ci_request_completion);\n\n    rspgen = (const pdq_response_generic_t *) ci->ci_bufstart;\n    PDQ_ASSERT(rspgen->generic_status == PDQR_SUCCESS);\n    PDQ_PRINTF((\"PDQ Process Command Response: %s completed (status=%d)\\n\",\n\t\tpdq_cmd_info[rspgen->generic_op].cmd_name,\n\t\trspgen->generic_status));\n\n    if (rspgen->generic_op == PDQC_STATUS_CHARS_GET && (pdq->pdq_flags & PDQ_PRINTCHARS)) {\n\tpdq->pdq_flags &= ~PDQ_PRINTCHARS;\n\tpdq_print_fddi_chars(pdq, (const pdq_response_status_chars_get_t *) rspgen);\n    }\n\n    PDQ_ADVANCE(ci->ci_request_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n    PDQ_ADVANCE(ci->ci_response_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n    ci->ci_command_active = 0;\n\n    if (ci->ci_pending_commands != 0) {\n\tpdq_queue_commands(pdq);\n    } else {\n\tPDQ_CSR_WRITE(csrs, csr_cmd_response_producer,\n\t\t      ci->ci_response_producer | (ci->ci_response_completion << 8));\n\tPDQ_CSR_WRITE(csrs, csr_cmd_request_producer,\n\t\t      ci->ci_request_producer | (ci->ci_request_completion << 8));\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_cmd_request_producer",
            "ci->ci_request_producer | (ci->ci_request_completion << 8)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_cmd_response_producer",
            "ci->ci_response_producer | (ci->ci_response_completion << 8)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_queue_commands",
          "args": [
            "pdq"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_queue_commands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "438-545",
          "snippet": "static void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [
            "#define\tPDQ_CMD_RX_ALIGNMENT\t16"
          ],
          "globals_used": [
            "static const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\n#define\tPDQ_CMD_RX_ALIGNMENT\t16\n\nstatic const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};\n\nstatic void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "ci->ci_response_completion",
            "1",
            "PDQ_RING_MASK(dbp->pdqdb_command_responses)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_command_responses"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "ci->ci_request_completion",
            "1",
            "PDQ_RING_MASK(dbp->pdqdb_command_requests)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_command_requests"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_print_fddi_chars",
          "args": [
            "pdq",
            "(const pdq_response_status_chars_get_t *) rspgen"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_print_fddi_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "165-210",
          "snippet": "static void\npdq_print_fddi_chars(\n    pdq_t *pdq,\n    const pdq_response_status_chars_get_t *rsp)\n{\n    const char hexchars[] = \"0123456789abcdef\";\n\n    printf(PDQ_OS_PREFIX \"DEC %s FDDI %s Controller\\n\",\n\t   PDQ_OS_PREFIX_ARGS, pdq_descriptions[pdq->pdq_type],\n\t   pdq_station_types[rsp->status_chars_get.station_type]);\n\n    printf(PDQ_OS_PREFIX \"FDDI address %c%c:%c%c:%c%c:%c%c:%c%c:%c%c, FW=%c%c%c%c, HW=%c\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] & 0x0F],\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3],\n\t   rsp->status_chars_get.module_rev.fwrev_bytes[0]);\n\n    if (rsp->status_chars_get.smt_version_id < PDQ_ARRAY_SIZE(pdq_smt_versions)) {\n\tprintf(\", SMT %s\\n\", pdq_smt_versions[rsp->status_chars_get.smt_version_id]);\n    }\n\n    printf(PDQ_OS_PREFIX \"FDDI Port%s = %c (PMD = %s)\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS ? \"[A]\" : \"\",\n\t   pdq_phy_types[rsp->status_chars_get.phy_type[0]],\n\t   pdq_pmd_types[rsp->status_chars_get.pmd_type[0] / 100][rsp->status_chars_get.pmd_type[0] % 100]);\n\n    if (rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS)\n\tprintf(\", FDDI Port[B] = %c (PMD = %s)\",\n\t       pdq_phy_types[rsp->status_chars_get.phy_type[1]],\n\t       pdq_pmd_types[rsp->status_chars_get.pmd_type[1] / 100][rsp->status_chars_get.pmd_type[1] % 100]);\n\n    printf(\"\\n\");\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const pdq_station_types[] = {\n    \"SAS\", \"DAC\", \"SAC\", \"NAC\", \"DAS\"\n};",
            "static const char * const pdq_smt_versions[] = { \"\", \"V6.2\", \"V7.2\", \"V7.3\" };",
            "static const char pdq_phy_types[] = \"ABSM\";",
            "static const char * const * const pdq_pmd_types[] = { \n    pdq_pmd_types0, pdq_pmd_types100\n};",
            "static const char * const pdq_descriptions[] = {\n    \"DEFPA PCI\",\n    \"DEFEA EISA\",\n    \"DEFTA TC\",\n    \"DEFAA Futurebus\",\n    \"DEFQA Q-bus\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_station_types[] = {\n    \"SAS\", \"DAC\", \"SAC\", \"NAC\", \"DAS\"\n};\nstatic const char * const pdq_smt_versions[] = { \"\", \"V6.2\", \"V7.2\", \"V7.3\" };\nstatic const char pdq_phy_types[] = \"ABSM\";\nstatic const char * const * const pdq_pmd_types[] = { \n    pdq_pmd_types0, pdq_pmd_types100\n};\nstatic const char * const pdq_descriptions[] = {\n    \"DEFPA PCI\",\n    \"DEFEA EISA\",\n    \"DEFTA TC\",\n    \"DEFAA Futurebus\",\n    \"DEFQA Q-bus\",\n};\n\nstatic void\npdq_print_fddi_chars(\n    pdq_t *pdq,\n    const pdq_response_status_chars_get_t *rsp)\n{\n    const char hexchars[] = \"0123456789abcdef\";\n\n    printf(PDQ_OS_PREFIX \"DEC %s FDDI %s Controller\\n\",\n\t   PDQ_OS_PREFIX_ARGS, pdq_descriptions[pdq->pdq_type],\n\t   pdq_station_types[rsp->status_chars_get.station_type]);\n\n    printf(PDQ_OS_PREFIX \"FDDI address %c%c:%c%c:%c%c:%c%c:%c%c:%c%c, FW=%c%c%c%c, HW=%c\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] & 0x0F],\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3],\n\t   rsp->status_chars_get.module_rev.fwrev_bytes[0]);\n\n    if (rsp->status_chars_get.smt_version_id < PDQ_ARRAY_SIZE(pdq_smt_versions)) {\n\tprintf(\", SMT %s\\n\", pdq_smt_versions[rsp->status_chars_get.smt_version_id]);\n    }\n\n    printf(PDQ_OS_PREFIX \"FDDI Port%s = %c (PMD = %s)\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS ? \"[A]\" : \"\",\n\t   pdq_phy_types[rsp->status_chars_get.phy_type[0]],\n\t   pdq_pmd_types[rsp->status_chars_get.pmd_type[0] / 100][rsp->status_chars_get.pmd_type[0] % 100]);\n\n    if (rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS)\n\tprintf(\", FDDI Port[B] = %c (PMD = %s)\",\n\t       pdq_phy_types[rsp->status_chars_get.phy_type[1]],\n\t       pdq_pmd_types[rsp->status_chars_get.pmd_type[1] / 100][rsp->status_chars_get.pmd_type[1] % 100]);\n\n    printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Process Command Response: %s completed (status=%d)\\n\",\n\t\tpdq_cmd_info[rspgen->generic_op].cmd_name,\n\t\trspgen->generic_status)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "rspgen->generic_status == PDQR_SUCCESS"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "cbp->pdqcb_command_request != ci->ci_request_completion"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};\n\nstatic void\npdq_process_command_responses(\n    pdq_t * const pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    volatile const pdq_consumer_block_t * const cbp = pdq->pdq_cbp;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    const pdq_response_generic_t *rspgen;\n\n    /*\n     * We have to process the command and response in tandem so\n     * just wait for the response to be consumed.  If it has been\n     * consumed then the command must have been as well.\n     */\n\n    if (cbp->pdqcb_command_response == ci->ci_response_completion)\n\treturn;\n\n    PDQ_ASSERT(cbp->pdqcb_command_request != ci->ci_request_completion);\n\n    rspgen = (const pdq_response_generic_t *) ci->ci_bufstart;\n    PDQ_ASSERT(rspgen->generic_status == PDQR_SUCCESS);\n    PDQ_PRINTF((\"PDQ Process Command Response: %s completed (status=%d)\\n\",\n\t\tpdq_cmd_info[rspgen->generic_op].cmd_name,\n\t\trspgen->generic_status));\n\n    if (rspgen->generic_op == PDQC_STATUS_CHARS_GET && (pdq->pdq_flags & PDQ_PRINTCHARS)) {\n\tpdq->pdq_flags &= ~PDQ_PRINTCHARS;\n\tpdq_print_fddi_chars(pdq, (const pdq_response_status_chars_get_t *) rspgen);\n    }\n\n    PDQ_ADVANCE(ci->ci_request_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n    PDQ_ADVANCE(ci->ci_response_completion, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n    ci->ci_command_active = 0;\n\n    if (ci->ci_pending_commands != 0) {\n\tpdq_queue_commands(pdq);\n    } else {\n\tPDQ_CSR_WRITE(csrs, csr_cmd_response_producer,\n\t\t      ci->ci_response_producer | (ci->ci_response_completion << 8));\n\tPDQ_CSR_WRITE(csrs, csr_cmd_request_producer,\n\t\t      ci->ci_request_producer | (ci->ci_request_completion << 8));\n    }\n}"
  },
  {
    "function_name": "pdq_queue_commands",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "438-545",
    "snippet": "static void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [
      "#define\tPDQ_CMD_RX_ALIGNMENT\t16"
    ],
    "globals_used": [
      "static const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_cmd_request_producer",
            "ci->ci_request_producer | (ci->ci_request_completion << 8)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_cmd_response_producer",
            "ci->ci_response_producer | (ci->ci_response_completion << 8)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_os_addr_fill",
          "args": [
            "pdq",
            "addr",
            "61"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_os_addr_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq_ifsubr.c",
          "lines": "246-265",
          "snippet": "void\npdq_os_addr_fill(\n    pdq_t *pdq,\n    pdq_lanaddr_t *addr,\n    size_t num_addrs)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);\n    while (enm != NULL && num_addrs > 0) {\n\t((u_short *) addr->lanaddr_bytes)[0] = ((u_short *) enm->enm_addrlo)[0];\n\t((u_short *) addr->lanaddr_bytes)[1] = ((u_short *) enm->enm_addrlo)[1];\n\t((u_short *) addr->lanaddr_bytes)[2] = ((u_short *) enm->enm_addrlo)[2];\n\tETHER_NEXT_MULTI(step, enm);\n\taddr++;\n\tnum_addrs--;\n    }\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\"",
            "#include <vm/vm_param.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <i386/isa/isavar.h>",
            "#include <net/if_fddi.h>",
            "#include <netinet/if_fddi.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/devconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n#include <vm/vm_param.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <i386/isa/isavar.h>\n#include <net/if_fddi.h>\n#include <netinet/if_fddi.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/devconf.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid\npdq_os_addr_fill(\n    pdq_t *pdq,\n    pdq_lanaddr_t *addr,\n    size_t num_addrs)\n{\n    pdq_softc_t *sc = (pdq_softc_t *) pdq->pdq_os_ctx;\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);\n    while (enm != NULL && num_addrs > 0) {\n\t((u_short *) addr->lanaddr_bytes)[0] = ((u_short *) enm->enm_addrlo)[0];\n\t((u_short *) addr->lanaddr_bytes)[1] = ((u_short *) enm->enm_addrlo)[1];\n\t((u_short *) addr->lanaddr_bytes)[2] = ((u_short *) enm->enm_addrlo)[2];\n\tETHER_NEXT_MULTI(step, enm);\n\taddr++;\n\tnum_addrs--;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_OS_MEMZERO",
          "args": [
            "ci->ci_bufstart",
            "cmdlen"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "ci->ci_response_producer",
            "1",
            "PDQ_RING_MASK(dbp->pdqdb_command_responses)"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_command_responses"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ADVANCE",
          "args": [
            "ci->ci_request_producer",
            "1",
            "PDQ_RING_MASK(dbp->pdqdb_command_requests)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_RING_MASK",
          "args": [
            "dbp->pdqdb_command_requests"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ROUNDUP",
          "args": [
            "pdq_cmd_info[op].rsp_len",
            "PDQ_CMD_RX_ALIGNMENT"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_ROUNDUP",
          "args": [
            "pdq_cmd_info[op].cmd_len",
            "PDQ_CMD_RX_ALIGNMENT"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(int) op - 1"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\n#define\tPDQ_CMD_RX_ALIGNMENT\t16\n\nstatic const struct {\n    size_t cmd_len;\n    size_t rsp_len;\n    const char *cmd_name;\n} pdq_cmd_info[] = {\n    { sizeof(pdq_cmd_generic_t),\t\t/* 0 - PDQC_START */\n      sizeof(pdq_response_generic_t),\n      \"Start\"\n    },\n    { sizeof(pdq_cmd_filter_set_t),\t\t/* 1 - PDQC_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 2 - PDQC_FILTER_GET */\n      sizeof(pdq_response_filter_get_t),\n      \"Filter Get\"\n    },\n    { sizeof(pdq_cmd_chars_set_t),\t\t/* 3 - PDQC_CHARS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Chars Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 4 - PDQC_STATUS_CHARS_GET */\n      sizeof(pdq_response_status_chars_get_t),\n      \"Status Chars Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 5 - PDQC_COUNTERS_GET */\n      sizeof(pdq_response_counters_get_t),\n      \"Counters Get\"\n    },\n    { sizeof(pdq_cmd_counters_set_t),\t\t/* 6 - PDQC_COUNTERS_SET */\n      sizeof(pdq_response_generic_t),\n      \"Counters Set\"\n    },\n#else\n    { 0, 0, \"Counters Get\" },\n    { 0, 0, \"Counters Set\" },\n#endif\n    { sizeof(pdq_cmd_addr_filter_set_t),\t/* 7 - PDQC_ADDR_FILTER_SET */\n      sizeof(pdq_response_generic_t),\n      \"Addr Filter Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 8 - PDQC_ADDR_FILTER_GET */\n      sizeof(pdq_response_addr_filter_get_t),\n      \"Addr Filter Get\"\n    },\n#if 0\n    { sizeof(pdq_cmd_generic_t),\t\t/* 9 - PDQC_ERROR_LOG_CLEAR */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Clear\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 10 - PDQC_ERROR_LOG_SET */\n      sizeof(pdq_response_generic_t),\n      \"Error Log Set\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 11 - PDQC_FDDI_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"FDDI MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 12 - PDQC_DEC_EXT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Ext MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 13 - PDQC_DEC_SPECIFIC_GET */\n      sizeof(pdq_response_generic_t),\n      \"DEC Specific Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 14 - PDQC_SNMP_SET */\n      sizeof(pdq_response_generic_t),\n      \"SNMP Set\"\n    },\n    { 0, 0, \"N/A\" },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 16 - PDQC_SMT_MIB_GET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Get\"\n    },\n    { sizeof(pdq_cmd_generic_t),\t\t/* 17 - PDQC_SMT_MIB_SET */\n      sizeof(pdq_response_generic_t),\n      \"SMT MIB Set\",\n    },\n#endif\n};\n\nstatic void\npdq_queue_commands(\n    pdq_t *pdq)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_command_info_t * const ci = &pdq->pdq_command_info;\n    pdq_descriptor_block_t * const dbp = pdq->pdq_dbp;\n    pdq_cmd_code_t op;\n    pdq_uint32_t cmdlen, rsplen, mask;\n\n    /*\n     * If there are commands or responses active or there aren't\n     * any pending commands, then don't queue any more.\n     */\n    if (ci->ci_command_active || ci->ci_pending_commands == 0)\n\treturn;\n\n    /*\n     * Determine which command needs to be queued.\n     */\n    op = PDQC_SMT_MIB_SET;\n    for (mask = 1 << ((int) op); (mask & ci->ci_pending_commands) == 0; mask >>= 1)\n\top = (pdq_cmd_code_t) ((int) op - 1);\n    /*\n     * Obtain the sizes needed for the command and response.\n     * Round up to PDQ_CMD_RX_ALIGNMENT so the receive buffer is\n     * always properly aligned.\n     */\n    cmdlen = PDQ_ROUNDUP(pdq_cmd_info[op].cmd_len, PDQ_CMD_RX_ALIGNMENT);\n    rsplen = PDQ_ROUNDUP(pdq_cmd_info[op].rsp_len, PDQ_CMD_RX_ALIGNMENT);\n    if (cmdlen < rsplen)\n\tcmdlen = rsplen;\n    /*\n     * Since only one command at a time will be queued, there will always\n     * be enough space.\n     */\n\n    /*\n     * Obtain and fill in the descriptor for the command (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_requests[ci->ci_request_producer].txd_seg_len = cmdlen;\n    PDQ_ADVANCE(ci->ci_request_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_requests));\n\n    /*\n     * Obtain and fill in the descriptor for the response (descriptor is\n     * pre-initialized)\n     */\n    dbp->pdqdb_command_responses[ci->ci_response_producer].rxd_seg_len_hi = cmdlen / 16;\n    PDQ_ADVANCE(ci->ci_response_producer, 1, PDQ_RING_MASK(dbp->pdqdb_command_responses));\n\n    /*\n     * Clear the command area, set the opcode, and the command from the pending\n     * mask.\n     */\n\n    PDQ_OS_MEMZERO(ci->ci_bufstart, cmdlen);\n    *(pdq_cmd_code_t *) ci->ci_bufstart = op;\n    ci->ci_pending_commands &= ~mask;\n\n    /*\n     * Fill in the command area, if needed.\n     */\n    switch (op) {\n\tcase PDQC_FILTER_SET: {\n\t    pdq_cmd_filter_set_t *filter_set = (pdq_cmd_filter_set_t *) ci->ci_bufstart;\n\t    unsigned idx = 0;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_IND_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PROMISC ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_GROUP_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_ALLMULTI ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_PROM;\n\t    filter_set->filter_set_items[idx].filter_state = ((pdq->pdq_flags & (PDQ_PROMISC|PDQ_PASS_SMT)) == (PDQ_PROMISC|PDQ_PASS_SMT) ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_SMT_USER;\n\t    filter_set->filter_set_items[idx].filter_state = (pdq->pdq_flags & PDQ_PASS_SMT ? PDQ_FILTER_PASS : PDQ_FILTER_BLOCK);\n\t    idx++;\n\t    filter_set->filter_set_items[idx].item_code = PDQI_EOL;\n\t    break;\n\t}\n\tcase PDQC_ADDR_FILTER_SET: {\n\t    pdq_cmd_addr_filter_set_t *addr_filter_set = (pdq_cmd_addr_filter_set_t *) ci->ci_bufstart;\n\t    pdq_lanaddr_t *addr = addr_filter_set->addr_filter_set_addresses;\n\t    addr->lanaddr_bytes[0] = 0xFF;\n\t    addr->lanaddr_bytes[1] = 0xFF;\n\t    addr->lanaddr_bytes[2] = 0xFF;\n\t    addr->lanaddr_bytes[3] = 0xFF;\n\t    addr->lanaddr_bytes[4] = 0xFF;\n\t    addr->lanaddr_bytes[5] = 0xFF;\n\t    addr++;\n\t    pdq_os_addr_fill(pdq, addr, 61);\n\t    break;\n\t}\n\tdefault:\n    }\n    /*\n     * At this point the command is done.  All that needs to be done is to\n     * produce it to the PDQ.\n     */\n    PDQ_PRINTF((\"PDQ Queue Command Request: %s queued\\n\",\n\t\tpdq_cmd_info[op].cmd_name));\n\n    ci->ci_command_active++;\n    PDQ_CSR_WRITE(csrs, csr_cmd_response_producer, ci->ci_response_producer | (ci->ci_response_completion << 8));\n    PDQ_CSR_WRITE(csrs, csr_cmd_request_producer, ci->ci_request_producer | (ci->ci_request_completion << 8));\n}"
  },
  {
    "function_name": "pdq_read_chiprev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "342-353",
    "snippet": "static pdq_chip_rev_t\npdq_read_chiprev(\n    const pdq_csrs_t * const csrs)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_PDQ_REV_GET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    return (pdq_chip_rev_t) data;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_data"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_do_port_control",
          "args": [
            "csrs",
            "PDQ_PCTL_SUB_CMD"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_do_port_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "264-282",
          "snippet": "static pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "PDQ_SUB_CMD_PDQ_REV_GET"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_chip_rev_t\npdq_read_chiprev(\n    const pdq_csrs_t * const csrs)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, PDQ_SUB_CMD_PDQ_REV_GET);\n    pdq_do_port_control(csrs, PDQ_PCTL_SUB_CMD);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    return (pdq_chip_rev_t) data;\n}"
  },
  {
    "function_name": "pdq_read_error_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "324-340",
    "snippet": "static pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_data"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_do_port_control",
          "args": [
            "csrs",
            "PDQ_PCTL_FW_REV_READ"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_do_port_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "264-282",
          "snippet": "static pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}"
  },
  {
    "function_name": "pdq_read_fwrev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "308-322",
    "snippet": "static void\npdq_read_fwrev(\n    const pdq_csrs_t * const csrs,\n    pdq_fwrev_t *fwrev)\n{\n    pdq_uint32_t data;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    fwrev->fwrev_bytes[3] = (data >> 0) & 0xFF;\n    fwrev->fwrev_bytes[2] = (data >> 8) & 0xFF;\n    fwrev->fwrev_bytes[1] = (data >> 16) & 0xFF;\n    fwrev->fwrev_bytes[0] = (data >> 24) & 0xFF;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_data"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_do_port_control",
          "args": [
            "csrs",
            "PDQ_PCTL_FW_REV_READ"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_do_port_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "264-282",
          "snippet": "static pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_read_fwrev(\n    const pdq_csrs_t * const csrs,\n    pdq_fwrev_t *fwrev)\n{\n    pdq_uint32_t data;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    fwrev->fwrev_bytes[3] = (data >> 0) & 0xFF;\n    fwrev->fwrev_bytes[2] = (data >> 8) & 0xFF;\n    fwrev->fwrev_bytes[1] = (data >> 16) & 0xFF;\n    fwrev->fwrev_bytes[0] = (data >> 24) & 0xFF;\n}"
  },
  {
    "function_name": "pdq_read_mla",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "284-306",
    "snippet": "static void\npdq_read_mla(\n    const pdq_csrs_t * const csrs,\n    pdq_lanaddr_t *hwaddr)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[0] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[1] = (data >> 8) & 0xFF;\n    hwaddr->lanaddr_bytes[2] = (data >> 16) & 0xFF;\n    hwaddr->lanaddr_bytes[3] = (data >> 24) & 0xFF;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 1);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[4] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[5] = (data >> 8) & 0xFF;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_data"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdq_do_port_control",
          "args": [
            "csrs",
            "PDQ_PCTL_MLA_READ"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_do_port_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "264-282",
          "snippet": "static pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_data"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_data_a",
            "0"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_read_mla(\n    const pdq_csrs_t * const csrs,\n    pdq_lanaddr_t *hwaddr)\n{\n    pdq_uint32_t data;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 0);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[0] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[1] = (data >> 8) & 0xFF;\n    hwaddr->lanaddr_bytes[2] = (data >> 16) & 0xFF;\n    hwaddr->lanaddr_bytes[3] = (data >> 24) & 0xFF;\n\n    PDQ_CSR_WRITE(csrs, csr_port_data_a, 1);\n    pdq_do_port_control(csrs, PDQ_PCTL_MLA_READ);\n    data = PDQ_CSR_READ(csrs, csr_host_data);\n\n    hwaddr->lanaddr_bytes[4] = (data >> 0) & 0xFF;\n    hwaddr->lanaddr_bytes[5] = (data >> 8) & 0xFF;\n}"
  },
  {
    "function_name": "pdq_do_port_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "264-282",
    "snippet": "static pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_ASSERT",
          "args": [
            "0"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_port_control"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_type_0",
            "PDQ_HOST_INT_CSR_CMD_DONE"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_int_type_0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_PRINTF",
          "args": [
            "(\"CSR cmd spun %d times\\n\", cnt)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_READ",
          "args": [
            "csrs",
            "csr_host_int_type_0"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_port_control",
            "PDQ_PCTL_CMD_ERROR | cmd"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_WRITE",
          "args": [
            "csrs",
            "csr_host_int_type_0",
            "PDQ_HOST_INT_CSR_CMD_DONE"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_do_port_control(\n    const pdq_csrs_t * const csrs,\n    pdq_uint32_t cmd)\n{\n    int cnt = 0;\n    PDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n    PDQ_CSR_WRITE(csrs, csr_port_control, PDQ_PCTL_CMD_ERROR | cmd);\n    while ((PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) == 0 && cnt < 33000000)\n\tcnt++;\n    PDQ_PRINTF((\"CSR cmd spun %d times\\n\", cnt));\n    if (PDQ_CSR_READ(csrs, csr_host_int_type_0) & PDQ_HOST_INT_CSR_CMD_DONE) {\n\tPDQ_CSR_WRITE(csrs, csr_host_int_type_0, PDQ_HOST_INT_CSR_CMD_DONE);\n\treturn (PDQ_CSR_READ(csrs, csr_port_control) & PDQ_PCTL_CMD_ERROR) ? PDQ_FALSE : PDQ_TRUE;\n    }\n    /* adapter failure */\n    PDQ_ASSERT(0);\n    return PDQ_FALSE;\n}"
  },
  {
    "function_name": "pdq_flush_databuf_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "251-262",
    "snippet": "static void\npdq_flush_databuf_queue(\n    pdq_databuf_queue_t *q)\n{\n    PDQ_OS_DATABUF_T *pdu;\n    for (;;) {\n\tPDQ_OS_DATABUF_DEQUEUE(q, pdu);\n\tif (pdu == NULL)\n\t    return;\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_FREE",
          "args": [
            "pdu"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_OS_DATABUF_DEQUEUE",
          "args": [
            "q",
            "pdu"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_flush_databuf_queue(\n    pdq_databuf_queue_t *q)\n{\n    PDQ_OS_DATABUF_T *pdu;\n    for (;;) {\n\tPDQ_OS_DATABUF_DEQUEUE(q, pdu);\n\tif (pdu == NULL)\n\t    return;\n\tPDQ_OS_DATABUF_FREE(pdu);\n    }\n}"
  },
  {
    "function_name": "pdq_init_pci_csrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "236-249",
    "snippet": "static void\npdq_init_pci_csrs(\n    pdq_pci_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_pfi_mode_control\t= PDQ_CSR_OFFSET(csr_base, 16 * csrsize);\n    csrs->csr_pfi_status\t= PDQ_CSR_OFFSET(csr_base, 17 * csrsize);\n    csrs->csr_fifo_write\t= PDQ_CSR_OFFSET(csr_base, 18 * csrsize);\n    csrs->csr_fifo_read\t\t= PDQ_CSR_OFFSET(csr_base, 19 * csrsize);\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "19 * csrsize"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "18 * csrsize"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "17 * csrsize"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "16 * csrsize"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_init_pci_csrs(\n    pdq_pci_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_pfi_mode_control\t= PDQ_CSR_OFFSET(csr_base, 16 * csrsize);\n    csrs->csr_pfi_status\t= PDQ_CSR_OFFSET(csr_base, 17 * csrsize);\n    csrs->csr_fifo_write\t= PDQ_CSR_OFFSET(csr_base, 18 * csrsize);\n    csrs->csr_fifo_read\t\t= PDQ_CSR_OFFSET(csr_base, 19 * csrsize);\n}"
  },
  {
    "function_name": "pdq_init_csrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "212-234",
    "snippet": "static void\npdq_init_csrs(\n    pdq_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_port_reset\t\t= PDQ_CSR_OFFSET(csr_base,  0 * csrsize);\n    csrs->csr_host_data\t\t\t= PDQ_CSR_OFFSET(csr_base,  1 * csrsize);\n    csrs->csr_port_control\t\t= PDQ_CSR_OFFSET(csr_base,  2 * csrsize);\n    csrs->csr_port_data_a\t\t= PDQ_CSR_OFFSET(csr_base,  3 * csrsize);\n    csrs->csr_port_data_b\t\t= PDQ_CSR_OFFSET(csr_base,  4 * csrsize);\n    csrs->csr_port_status\t\t= PDQ_CSR_OFFSET(csr_base,  5 * csrsize);\n    csrs->csr_host_int_type_0\t\t= PDQ_CSR_OFFSET(csr_base,  6 * csrsize);\n    csrs->csr_host_int_enable\t\t= PDQ_CSR_OFFSET(csr_base,  7 * csrsize);\n    csrs->csr_type_2_producer\t\t= PDQ_CSR_OFFSET(csr_base,  8 * csrsize);\n    csrs->csr_cmd_response_producer\t= PDQ_CSR_OFFSET(csr_base, 10 * csrsize);\n    csrs->csr_cmd_request_producer\t= PDQ_CSR_OFFSET(csr_base, 11 * csrsize);\n    csrs->csr_host_smt_producer\t\t= PDQ_CSR_OFFSET(csr_base, 12 * csrsize);\n    csrs->csr_unsolicited_producer\t= PDQ_CSR_OFFSET(csr_base, 13 * csrsize);\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "13 * csrsize"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "12 * csrsize"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "11 * csrsize"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "10 * csrsize"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "8 * csrsize"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "7 * csrsize"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "6 * csrsize"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "5 * csrsize"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "4 * csrsize"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "3 * csrsize"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "2 * csrsize"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "1 * csrsize"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDQ_CSR_OFFSET",
          "args": [
            "csr_base",
            "0 * csrsize"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic void\npdq_init_csrs(\n    pdq_csrs_t *csrs,\n    pdq_bus_t bus,\n    pdq_bus_memaddr_t csr_base,\n    size_t csrsize)\n{\n    csrs->csr_bus = bus;\n    csrs->csr_base = csr_base;\n    csrs->csr_port_reset\t\t= PDQ_CSR_OFFSET(csr_base,  0 * csrsize);\n    csrs->csr_host_data\t\t\t= PDQ_CSR_OFFSET(csr_base,  1 * csrsize);\n    csrs->csr_port_control\t\t= PDQ_CSR_OFFSET(csr_base,  2 * csrsize);\n    csrs->csr_port_data_a\t\t= PDQ_CSR_OFFSET(csr_base,  3 * csrsize);\n    csrs->csr_port_data_b\t\t= PDQ_CSR_OFFSET(csr_base,  4 * csrsize);\n    csrs->csr_port_status\t\t= PDQ_CSR_OFFSET(csr_base,  5 * csrsize);\n    csrs->csr_host_int_type_0\t\t= PDQ_CSR_OFFSET(csr_base,  6 * csrsize);\n    csrs->csr_host_int_enable\t\t= PDQ_CSR_OFFSET(csr_base,  7 * csrsize);\n    csrs->csr_type_2_producer\t\t= PDQ_CSR_OFFSET(csr_base,  8 * csrsize);\n    csrs->csr_cmd_response_producer\t= PDQ_CSR_OFFSET(csr_base, 10 * csrsize);\n    csrs->csr_cmd_request_producer\t= PDQ_CSR_OFFSET(csr_base, 11 * csrsize);\n    csrs->csr_host_smt_producer\t\t= PDQ_CSR_OFFSET(csr_base, 12 * csrsize);\n    csrs->csr_unsolicited_producer\t= PDQ_CSR_OFFSET(csr_base, 13 * csrsize);\n}"
  },
  {
    "function_name": "pdq_print_fddi_chars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
    "lines": "165-210",
    "snippet": "static void\npdq_print_fddi_chars(\n    pdq_t *pdq,\n    const pdq_response_status_chars_get_t *rsp)\n{\n    const char hexchars[] = \"0123456789abcdef\";\n\n    printf(PDQ_OS_PREFIX \"DEC %s FDDI %s Controller\\n\",\n\t   PDQ_OS_PREFIX_ARGS, pdq_descriptions[pdq->pdq_type],\n\t   pdq_station_types[rsp->status_chars_get.station_type]);\n\n    printf(PDQ_OS_PREFIX \"FDDI address %c%c:%c%c:%c%c:%c%c:%c%c:%c%c, FW=%c%c%c%c, HW=%c\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] & 0x0F],\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3],\n\t   rsp->status_chars_get.module_rev.fwrev_bytes[0]);\n\n    if (rsp->status_chars_get.smt_version_id < PDQ_ARRAY_SIZE(pdq_smt_versions)) {\n\tprintf(\", SMT %s\\n\", pdq_smt_versions[rsp->status_chars_get.smt_version_id]);\n    }\n\n    printf(PDQ_OS_PREFIX \"FDDI Port%s = %c (PMD = %s)\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS ? \"[A]\" : \"\",\n\t   pdq_phy_types[rsp->status_chars_get.phy_type[0]],\n\t   pdq_pmd_types[rsp->status_chars_get.pmd_type[0] / 100][rsp->status_chars_get.pmd_type[0] % 100]);\n\n    if (rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS)\n\tprintf(\", FDDI Port[B] = %c (PMD = %s)\",\n\t       pdq_phy_types[rsp->status_chars_get.phy_type[1]],\n\t       pdq_pmd_types[rsp->status_chars_get.pmd_type[1] / 100][rsp->status_chars_get.pmd_type[1] % 100]);\n\n    printf(\"\\n\");\n}",
    "includes": [
      "#include \"pdqreg.h\"",
      "#include \"pdqvar.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const pdq_station_types[] = {\n    \"SAS\", \"DAC\", \"SAC\", \"NAC\", \"DAS\"\n};",
      "static const char * const pdq_smt_versions[] = { \"\", \"V6.2\", \"V7.2\", \"V7.3\" };",
      "static const char pdq_phy_types[] = \"ABSM\";",
      "static const char * const * const pdq_pmd_types[] = { \n    pdq_pmd_types0, pdq_pmd_types100\n};",
      "static const char * const pdq_descriptions[] = {\n    \"DEFPA PCI\",\n    \"DEFEA EISA\",\n    \"DEFTA TC\",\n    \"DEFAA Futurebus\",\n    \"DEFQA Q-bus\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDQ_ARRAY_SIZE",
          "args": [
            "pdq_smt_versions"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic const char * const pdq_station_types[] = {\n    \"SAS\", \"DAC\", \"SAC\", \"NAC\", \"DAS\"\n};\nstatic const char * const pdq_smt_versions[] = { \"\", \"V6.2\", \"V7.2\", \"V7.3\" };\nstatic const char pdq_phy_types[] = \"ABSM\";\nstatic const char * const * const pdq_pmd_types[] = { \n    pdq_pmd_types0, pdq_pmd_types100\n};\nstatic const char * const pdq_descriptions[] = {\n    \"DEFPA PCI\",\n    \"DEFEA EISA\",\n    \"DEFTA TC\",\n    \"DEFAA Futurebus\",\n    \"DEFQA Q-bus\",\n};\n\nstatic void\npdq_print_fddi_chars(\n    pdq_t *pdq,\n    const pdq_response_status_chars_get_t *rsp)\n{\n    const char hexchars[] = \"0123456789abcdef\";\n\n    printf(PDQ_OS_PREFIX \"DEC %s FDDI %s Controller\\n\",\n\t   PDQ_OS_PREFIX_ARGS, pdq_descriptions[pdq->pdq_type],\n\t   pdq_station_types[rsp->status_chars_get.station_type]);\n\n    printf(PDQ_OS_PREFIX \"FDDI address %c%c:%c%c:%c%c:%c%c:%c%c:%c%c, FW=%c%c%c%c, HW=%c\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[0] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[1] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[2] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[3] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[4] & 0x0F],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] >> 4],\n\t   hexchars[pdq->pdq_hwaddr.lanaddr_bytes[5] & 0x0F],\n\t   pdq->pdq_fwrev.fwrev_bytes[0], pdq->pdq_fwrev.fwrev_bytes[1],\n\t   pdq->pdq_fwrev.fwrev_bytes[2], pdq->pdq_fwrev.fwrev_bytes[3],\n\t   rsp->status_chars_get.module_rev.fwrev_bytes[0]);\n\n    if (rsp->status_chars_get.smt_version_id < PDQ_ARRAY_SIZE(pdq_smt_versions)) {\n\tprintf(\", SMT %s\\n\", pdq_smt_versions[rsp->status_chars_get.smt_version_id]);\n    }\n\n    printf(PDQ_OS_PREFIX \"FDDI Port%s = %c (PMD = %s)\",\n\t   PDQ_OS_PREFIX_ARGS,\n\t   rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS ? \"[A]\" : \"\",\n\t   pdq_phy_types[rsp->status_chars_get.phy_type[0]],\n\t   pdq_pmd_types[rsp->status_chars_get.pmd_type[0] / 100][rsp->status_chars_get.pmd_type[0] % 100]);\n\n    if (rsp->status_chars_get.station_type == PDQ_STATION_TYPE_DAS)\n\tprintf(\", FDDI Port[B] = %c (PMD = %s)\",\n\t       pdq_phy_types[rsp->status_chars_get.phy_type[1]],\n\t       pdq_pmd_types[rsp->status_chars_get.pmd_type[1] / 100][rsp->status_chars_get.pmd_type[1] % 100]);\n\n    printf(\"\\n\");\n}"
  }
]