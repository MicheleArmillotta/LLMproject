[
  {
    "function_name": "am7990_zerobuf_gap16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1279-1298",
    "snippet": "void\nam7990_zerobuf_gap16(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbzero(bptr + boff, xfer);\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "16"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "bptr + boff",
            "xfer"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_zerobuf_gap16(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbzero(bptr + boff, xfer);\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}"
  },
  {
    "function_name": "am7990_copyfrombuf_gap16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1255-1277",
    "snippet": "void\nam7990_copyfrombuf_gap16(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(bptr + boff, to, xfer);\n\t\tto += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "16"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "bptr + boff",
            "to",
            "xfer"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_copyfrombuf_gap16(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(bptr + boff, to, xfer);\n\t\tto += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}"
  },
  {
    "function_name": "am7990_copytobuf_gap16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1230-1253",
    "snippet": "void\nam7990_copytobuf_gap16(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(from, bptr + boff, xfer);\n\t\tfrom += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "16"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "from",
            "bptr + boff",
            "xfer"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_copytobuf_gap16(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister caddr_t bptr;\n\tregister int xfer;\n\n\tbptr = buf + ((boff << 1) & ~0x1f);\n\tboff &= 0xf;\n\txfer = min(len, 16 - boff);\n\twhile (len > 0) {\n\t\tbcopy(from, bptr + boff, xfer);\n\t\tfrom += xfer;\n\t\tbptr += 32;\n\t\tboff = 0;\n\t\tlen -= xfer;\n\t\txfer = min(len, 16);\n\t}\n}"
  },
  {
    "function_name": "am7990_zerobuf_gap2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1202-1222",
    "snippet": "void\nam7990_zerobuf_gap2(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister volatile u_int16_t *bptr;\n\n\tif ((unsigned)boff & 0x1) {\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*bptr &= 0xff;\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 0) {\n\t\t*bptr = 0;\n\t\tbptr += 2;\n\t\tlen -= 2;\n\t}\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_zerobuf_gap2(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister volatile u_int16_t *bptr;\n\n\tif ((unsigned)boff & 0x1) {\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*bptr &= 0xff;\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 0) {\n\t\t*bptr = 0;\n\t\tbptr += 2;\n\t\tlen -= 2;\n\t}\n}"
  },
  {
    "function_name": "am7990_copyfrombuf_gap2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1172-1200",
    "snippet": "void\nam7990_copyfrombuf_gap2(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister volatile u_int16_t *bptr;\n\tregister u_int16_t tmp;\n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*to++ = (*bptr >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\ttmp = *bptr;\n\t\t*to++ = tmp & 0xff;\n\t\t*to++ = (tmp >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*to = *bptr & 0xff;\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_copyfrombuf_gap2(sc, tov, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *tov;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t to = tov;\n\tregister volatile u_int16_t *bptr;\n\tregister u_int16_t tmp;\n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*to++ = (*bptr >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\ttmp = *bptr;\n\t\t*to++ = tmp & 0xff;\n\t\t*to++ = (tmp >> 8) & 0xff;\n\t\tbptr += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*to = *bptr & 0xff;\n}"
  },
  {
    "function_name": "am7990_copytobuf_gap2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1143-1170",
    "snippet": "void\nam7990_copytobuf_gap2(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister volatile u_int16_t *bptr;\n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*bptr = (*from++ << 8) | (*bptr & 0xff);\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\t*bptr = (from[1] << 8) | (from[0] & 0xff);\n\t\tbptr += 2;\n\t\tfrom += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*bptr = (u_int16_t)*from;\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_copytobuf_gap2(sc, fromv, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *fromv;\n\tint boff;\n\tregister int len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\tregister caddr_t from = fromv;\n\tregister volatile u_int16_t *bptr;\n\n\tif (boff & 0x1) {\n\t\t/* handle unaligned first byte */\n\t\tbptr = ((volatile u_int16_t *)buf) + (boff - 1);\n\t\t*bptr = (*from++ << 8) | (*bptr & 0xff);\n\t\tbptr += 2;\n\t\tlen--;\n\t} else\n\t\tbptr = ((volatile u_int16_t *)buf) + boff;\n\twhile (len > 1) {\n\t\t*bptr = (from[1] << 8) | (from[0] & 0xff);\n\t\tbptr += 2;\n\t\tfrom += 2;\n\t\tlen -= 2;\n\t}\n\tif (len == 1)\n\t\t*bptr = (u_int16_t)*from;\n}"
  },
  {
    "function_name": "am7990_zerobuf_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1117-1128",
    "snippet": "void\nam7990_zerobuf_contig(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\n\t/*\n\t * Just let bzero() do the work\n\t */\n\tbzero(buf + boff, len);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "buf + boff",
            "len"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_zerobuf_contig(sc, boff, len)\n\tstruct am7990_softc *sc;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\n\t/*\n\t * Just let bzero() do the work\n\t */\n\tbzero(buf + boff, len);\n}"
  },
  {
    "function_name": "am7990_copyfrombuf_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1103-1115",
    "snippet": "void\nam7990_copyfrombuf_contig(sc, to, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *to;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\n\t/*\n\t * Just call bcopy() to do the work.\n\t */\n\tbcopy(buf + boff, to, len);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "buf + boff",
            "to",
            "len"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_copyfrombuf_contig(sc, to, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *to;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\n\t/*\n\t * Just call bcopy() to do the work.\n\t */\n\tbcopy(buf + boff, to, len);\n}"
  },
  {
    "function_name": "am7990_copytobuf_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1089-1101",
    "snippet": "void\nam7990_copytobuf_contig(sc, from, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *from;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\n\t/*\n\t * Just call bcopy() to do the work.\n\t */\n\tbcopy(from, buf + boff, len);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "from",
            "buf + boff",
            "len"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_copytobuf_contig(sc, from, boff, len)\n\tstruct am7990_softc *sc;\n\tvoid *from;\n\tint boff, len;\n{\n\tvolatile caddr_t buf = sc->sc_mem;\n\n\t/*\n\t * Just call bcopy() to do the work.\n\t */\n\tbcopy(from, buf + boff, len);\n}"
  },
  {
    "function_name": "am7990_setladrf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "1005-1070",
    "snippet": "void\nam7990_setladrf(ac, af)\n\tstruct arpcom *ac;\n\tu_int16_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = 0x0000;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Set the corresponding bit in the filter. */\n\t\taf[crc >> 4] |= 1 << (crc & 0xf);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = 0xffff;\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_CMP\tether_cmp",
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "integrate struct",
      "integrate struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_CMP",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_CMP\tether_cmp\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate struct;\nintegrate struct;\n\nvoid\nam7990_setladrf(ac, af)\n\tstruct arpcom *ac;\n\tu_int16_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = 0x0000;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Set the corresponding bit in the filter. */\n\t\taf[crc >> 4] |= 1 << (crc & 0xf);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = 0xffff;\n}"
  },
  {
    "function_name": "am7990_xmit_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "974-999",
    "snippet": "void\nam7990_xmit_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct letmd tmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, no), sizeof(tmd));\n\tlen = -tmd.tmd2;\n\tprintf(\"%s: transmit buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits, tmd.tmd2, tmd.tmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_TBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t    ntohs(eh.ether_type));\n\t}\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" src %s type %04x\\n\"",
            "ether_sprintf(eh.ether_shost)",
            "ntohs(eh.ether_type)"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "eh.ether_type"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "eh.ether_shost"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "eh.ether_dhost"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&eh",
            "LE_TBUFADDR(sc, no)",
            "sizeof(eh)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_TBUFADDR",
          "args": [
            "sc",
            "no"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&tmd",
            "LE_TMDADDR(sc, no)",
            "sizeof(tmd)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_TMDADDR",
          "args": [
            "sc",
            "no"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_xmit_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct letmd tmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, no), sizeof(tmd));\n\tlen = -tmd.tmd2;\n\tprintf(\"%s: transmit buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits, tmd.tmd2, tmd.tmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_TBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t    ntohs(eh.ether_type));\n\t}\n}"
  },
  {
    "function_name": "am7990_recv_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "947-972",
    "snippet": "void\nam7990_recv_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct lermd rmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &rmd, LE_RMDADDR(sc, no), sizeof(rmd));\n\tlen = rmd.rmd3;\n\tprintf(\"%s: receive buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits, rmd.rmd2, rmd.rmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_RBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t\tntohs(eh.ether_type));\n\t}\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" src %s type %04x\\n\"",
            "ether_sprintf(eh.ether_shost)",
            "ntohs(eh.ether_type)"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "eh.ether_type"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "eh.ether_shost"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "eh.ether_dhost"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&eh",
            "LE_RBUFADDR(sc, no)",
            "sizeof(eh)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_RBUFADDR",
          "args": [
            "sc",
            "no"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&rmd",
            "LE_RMDADDR(sc, no)",
            "sizeof(rmd)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_RMDADDR",
          "args": [
            "sc",
            "no"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_recv_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct lermd rmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &rmd, LE_RMDADDR(sc, no), sizeof(rmd));\n\tlen = rmd.rmd3;\n\tprintf(\"%s: receive buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits, rmd.rmd2, rmd.rmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_RBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t\tntohs(eh.ether_type));\n\t}\n}"
  },
  {
    "function_name": "am7990_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "938-944",
    "snippet": "hide void\nam7990_shutdown(arg)\n\tvoid *arg;\n{\n\n\tam7990_stop((struct am7990_softc *)arg);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "hide void",
      "integrate struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "am7990_stop",
          "args": [
            "(struct am7990_softc *)arg"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "297-303",
          "snippet": "void\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nhide void;\nintegrate struct;\n\nhide void\nam7990_shutdown(arg)\n\tvoid *arg;\n{\n\n\tam7990_stop((struct am7990_softc *)arg);\n}"
  },
  {
    "function_name": "am7990_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "837-936",
    "snippet": "int\nam7990_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tam7990_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tam7990_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tam7990_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    \t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tam7990_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\t/*am7990_stop(sc);*/\n\t\t\tam7990_init(sc);\n\t\t}\n#ifdef LEDEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = 1;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tam7990_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tif (sc->sc_hasifmedia)\n\t\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);\n\t\telse\n\t\t\terror = EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_ifmedia",
            "cmd"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_reset",
          "args": [
            "sc"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "217-226",
          "snippet": "void\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_init",
          "args": [
            "sc"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "309-355",
          "snippet": "void\nam7990_init(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int timo;\n\tu_long a;\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n\tDELAY(100);\n\n\t/* Newer LANCE chips have a reset register */\n\tif (sc->sc_hwreset)\n\t\t(*sc->sc_hwreset)(sc);\n\n\t/* Set the correct byte swapping mode, etc. */\n\t(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);\n\n\t/* Set up LANCE init block. */\n\tam7990_meminit(sc);\n\n\t/* Give LANCE the physical address of its init block. */\n\ta = sc->sc_addr + LE_INITADDR(sc);\n\t(*sc->sc_wrcsr)(sc, LE_CSR1, a);\n\t(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);\n\n\t/* Try to initialize the LANCE. */\n\tDELAY(100);\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);\n\n\t/* Wait for initialization to finish. */\n\tfor (timo = 100000; timo; timo--)\n\t\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)\n\t\t\tbreak;\n\n\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {\n\t\t/* Start the LANCE. */\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |\n\t\t    LE_C0_IDON);\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t\tam7990_start(ifp);\n\t} else\n\t\tprintf(\"%s: controller failed to initialize\\n\", sc->sc_dev.dv_xname);\n\tif (sc->sc_hwinit)\n\t\t(*sc->sc_hwinit)(sc);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_init(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int timo;\n\tu_long a;\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n\tDELAY(100);\n\n\t/* Newer LANCE chips have a reset register */\n\tif (sc->sc_hwreset)\n\t\t(*sc->sc_hwreset)(sc);\n\n\t/* Set the correct byte swapping mode, etc. */\n\t(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);\n\n\t/* Set up LANCE init block. */\n\tam7990_meminit(sc);\n\n\t/* Give LANCE the physical address of its init block. */\n\ta = sc->sc_addr + LE_INITADDR(sc);\n\t(*sc->sc_wrcsr)(sc, LE_CSR1, a);\n\t(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);\n\n\t/* Try to initialize the LANCE. */\n\tDELAY(100);\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);\n\n\t/* Wait for initialization to finish. */\n\tfor (timo = 100000; timo; timo--)\n\t\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)\n\t\t\tbreak;\n\n\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {\n\t\t/* Start the LANCE. */\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |\n\t\t    LE_C0_IDON);\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t\tam7990_start(ifp);\n\t} else\n\t\tprintf(\"%s: controller failed to initialize\\n\", sc->sc_dev.dv_xname);\n\tif (sc->sc_hwinit)\n\t\t(*sc->sc_hwinit)(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "am7990_stop",
          "args": [
            "sc"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "297-303",
          "snippet": "void\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nint\nam7990_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tam7990_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tam7990_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tam7990_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    \t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tam7990_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\t/*am7990_stop(sc);*/\n\t\t\tam7990_init(sc);\n\t\t}\n#ifdef LEDEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = 1;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tam7990_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tif (sc->sc_hasifmedia)\n\t\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);\n\t\telse\n\t\t\terror = EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "am7990_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "751-832",
    "snippet": "void\nam7990_start(ifp)\n\tregister struct ifnet *ifp;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tregister int bix;\n\tregister struct mbuf *m;\n\tstruct letmd tmd;\n\tint rp;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tbix = sc->sc_last_td;\n\n\tfor (;;) {\n\t\trp = LE_TMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tprintf(\"missing buffer, no_td = %d, last_td = %d\\n\",\n\t\t\t    sc->sc_no_td, sc->sc_last_td);\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0)\n\t\t\tbreak;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If BPF is listening on this interface, let it see the packet\n\t\t * before we commit it to the wire.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmit buffer.\n\t\t */\n\t\tlen = am7990_put(sc, LE_TBUFADDR(sc, bix), m);\n\n#ifdef LEDEBUG\n\t\tif (len > ETHERMTU + sizeof(struct ether_header))\n\t\t\tprintf(\"packet length %d\\n\", len);\n#endif\n\n\t\tifp->if_timer = 5;\n\n\t\t/*\n\t\t * Init transmit registers, and set transmit start flag.\n\t\t */\n\t\ttmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;\n\t\ttmd.tmd2 = -len | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\n\t\t(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tam7990_xmit_print(sc, sc->sc_last_td);\n#endif\n\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\tif (++sc->sc_no_td == sc->sc_ntbuf) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"\\nequal!\\n\");\n#endif\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tsc->sc_last_td = bix;\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "am7990_put __P((struct am7990_softc *, int, struct mbuf *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nequal!\\n\""
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0",
            "LE_C0_INEA | LE_C0_TDMD"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_xmit_print",
          "args": [
            "sc",
            "sc->sc_last_td"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_xmit_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "974-999",
          "snippet": "void\nam7990_xmit_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct letmd tmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, no), sizeof(tmd));\n\tlen = -tmd.tmd2;\n\tprintf(\"%s: transmit buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits, tmd.tmd2, tmd.tmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_TBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t    ntohs(eh.ether_type));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_xmit_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct letmd tmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, no), sizeof(tmd));\n\tlen = -tmd.tmd2;\n\tprintf(\"%s: transmit buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits, tmd.tmd2, tmd.tmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_TBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t    ntohs(eh.ether_type));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&tmd",
            "rp",
            "sizeof(tmd)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_put",
          "args": [
            "sc",
            "LE_TBUFADDR(sc, bix)",
            "m"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "361-386",
          "snippet": "integrate int\nam7990_put(sc, boff, m)\n\tstruct am7990_softc *sc;\n\tint boff;\n\tregister struct mbuf *m;\n{\n\tregister struct mbuf *n;\n\tregister int len, tlen = 0;\n\n\tfor (; m; m = n) {\n\t\tlen = m->m_len;\n\t\tif (len == 0) {\n\t\t\tMFREE(m, n);\n\t\t\tcontinue;\n\t\t}\n\t\t(*sc->sc_copytobuf)(sc, mtod(m, caddr_t), boff, len);\n\t\tboff += len;\n\t\ttlen += len;\n\t\tMFREE(m, n);\n\t}\n\tif (tlen < LEMINSIZE) {\n\t\t(*sc->sc_zerobuf)(sc, boff, LEMINSIZE - tlen);\n\t\ttlen = LEMINSIZE;\n\t}\n\treturn (tlen);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "integrate void",
            "am7990_rint __P((struct am7990_softc *));",
            "integrate void",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate int",
            "am7990_put __P((struct am7990_softc *, int, struct mbuf *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nam7990_put __P((struct am7990_softc *, int, struct mbuf *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate int\nam7990_put(sc, boff, m)\n\tstruct am7990_softc *sc;\n\tint boff;\n\tregister struct mbuf *m;\n{\n\tregister struct mbuf *n;\n\tregister int len, tlen = 0;\n\n\tfor (; m; m = n) {\n\t\tlen = m->m_len;\n\t\tif (len == 0) {\n\t\t\tMFREE(m, n);\n\t\t\tcontinue;\n\t\t}\n\t\t(*sc->sc_copytobuf)(sc, mtod(m, caddr_t), boff, len);\n\t\tboff += len;\n\t\ttlen += len;\n\t\tMFREE(m, n);\n\t}\n\tif (tlen < LEMINSIZE) {\n\t\t(*sc->sc_zerobuf)(sc, boff, LEMINSIZE - tlen);\n\t\ttlen = LEMINSIZE;\n\t}\n\treturn (tlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LE_TBUFADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&tmd",
            "rp",
            "sizeof(tmd)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_TMDADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nam7990_put __P((struct am7990_softc *, int, struct mbuf *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_start(ifp)\n\tregister struct ifnet *ifp;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tregister int bix;\n\tregister struct mbuf *m;\n\tstruct letmd tmd;\n\tint rp;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tbix = sc->sc_last_td;\n\n\tfor (;;) {\n\t\trp = LE_TMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tprintf(\"missing buffer, no_td = %d, last_td = %d\\n\",\n\t\t\t    sc->sc_no_td, sc->sc_last_td);\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0)\n\t\t\tbreak;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If BPF is listening on this interface, let it see the packet\n\t\t * before we commit it to the wire.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmit buffer.\n\t\t */\n\t\tlen = am7990_put(sc, LE_TBUFADDR(sc, bix), m);\n\n#ifdef LEDEBUG\n\t\tif (len > ETHERMTU + sizeof(struct ether_header))\n\t\t\tprintf(\"packet length %d\\n\", len);\n#endif\n\n\t\tifp->if_timer = 5;\n\n\t\t/*\n\t\t * Init transmit registers, and set transmit start flag.\n\t\t */\n\t\ttmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;\n\t\ttmd.tmd2 = -len | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\n\t\t(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tam7990_xmit_print(sc, sc->sc_last_td);\n#endif\n\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\tif (++sc->sc_no_td == sc->sc_ntbuf) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"\\nequal!\\n\");\n#endif\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tsc->sc_last_td = bix;\n}"
  },
  {
    "function_name": "am7990_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "733-743",
    "snippet": "void\nam7990_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct am7990_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\n\tam7990_reset(sc);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "am7990_reset",
          "args": [
            "sc"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "217-226",
          "snippet": "void\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct am7990_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\n\tam7990_reset(sc);\n}"
  },
  {
    "function_name": "am7990_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "663-729",
    "snippet": "int\nam7990_intr(arg)\n\tregister void *arg;\n{\n\tregister struct am7990_softc *sc = arg;\n\tregister u_int16_t isr;\n\n\tisr = (*sc->sc_rdcsr)(sc, LE_CSR0);\n#ifdef LEDEBUG\n\tif (sc->sc_debug){\n\t\tprintf(\"%s: am7990_intr entering with isr=%04x\\n\",\n\t\t    sc->sc_dev.dv_xname, isr);\n\t\tprintf(\" isr: 0x%b\\n\", isr, LE_C0_BITS);\n\t}\n#endif\n\tif ((isr & LE_C0_INTR) == 0)\n\t\treturn (0);\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0,\n\t    isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR |\n\t\t   LE_C0_RINT | LE_C0_TINT | LE_C0_IDON));\n\tif (isr & LE_C0_ERR) {\n\t\tif (isr & LE_C0_BABL) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"%s: babble\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tifp->if_oerrors++;\n\t\t}\n#if 0\n\t\tif (isr & LE_C0_CERR) {\n\t\t\tprintf(\"%s: collision error\\n\", sc->sc_dev.dv_xname);\n\t\t\tifp->if_collisions++;\n\t\t}\n#endif\n\t\tif (isr & LE_C0_MISS) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"%s: missed packet\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t}\n\t\tif (isr & LE_C0_MERR) {\n\t\t\tprintf(\"%s: memory error\\n\", sc->sc_dev.dv_xname);\n\t\t\tam7990_reset(sc);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif ((isr & LE_C0_RXON) == 0) {\n\t\tprintf(\"%s: receiver disabled\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_ierrors++;\n\t\tam7990_reset(sc);\n\t\treturn (1);\n\t}\n\tif ((isr & LE_C0_TXON) == 0) {\n\t\tprintf(\"%s: transmitter disabled\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tam7990_reset(sc);\n\t\treturn (1);\n\t}\n\n\tif (isr & LE_C0_RINT)\n\t\tam7990_rint(sc);\n\tif (isr & LE_C0_TINT)\n\t\tam7990_tint(sc);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "am7990_tint",
          "args": [
            "sc"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "581-658",
          "snippet": "integrate void\nam7990_tint(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int bix;\n\tstruct letmd tmd;\n\n\tbix = sc->sc_first_td;\n\n\tfor (;;) {\n\t\tif (sc->sc_no_td <= 0)\n\t\t\tbreak;\n\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"trans tmd: \"\n\t\t\t    \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t    \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits,\n\t\t\t    tmd.tmd2, tmd.tmd3);\n#endif\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\tif (tmd.tmd1_bits & LE_T1_ERR) {\n\t\t\tif (tmd.tmd3 & LE_T3_BUFF)\n\t\t\t\tprintf(\"%s: transmit buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\telse if (tmd.tmd3 & LE_T3_UFLO)\n\t\t\t\tprintf(\"%s: underflow\\n\", sc->sc_dev.dv_xname);\n\t\t\tif (tmd.tmd3 & (LE_T3_BUFF | LE_T3_UFLO)) {\n\t\t\t\tam7990_reset(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCAR) {\n\t\t\t\tif (sc->sc_nocarrier)\n\t\t\t\t\t(*sc->sc_nocarrier)(sc);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: lost carrier\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCOL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (tmd.tmd3 & LE_T3_RTRY) {\n\t\t\t\tprintf(\"%s: excessive collisions, tdr %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    tmd.tmd3 & LE_T3_TDR_MASK);\n\t\t\t\tifp->if_collisions += 16;\n\t\t\t}\n\t\t\tifp->if_oerrors++;\n\t\t} else {\n\t\t\tif (tmd.tmd1_bits & LE_T1_ONE)\n\t\t\t\tifp->if_collisions++;\n\t\t\telse if (tmd.tmd1_bits & LE_T1_MORE)\n\t\t\t\t/* Real number is unknown. */\n\t\t\t\tifp->if_collisions += 2;\n\t\t\tifp->if_opackets++;\n\t\t}\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\t--sc->sc_no_td;\n\t}\n\n\tsc->sc_first_td = bix;\n\n\tam7990_start(ifp);\n\n\tif (sc->sc_no_td == 0)\n\t\tifp->if_timer = 0;\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "integrate void",
            "am7990_rint __P((struct am7990_softc *));",
            "integrate void",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate int",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate void\nam7990_tint(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int bix;\n\tstruct letmd tmd;\n\n\tbix = sc->sc_first_td;\n\n\tfor (;;) {\n\t\tif (sc->sc_no_td <= 0)\n\t\t\tbreak;\n\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"trans tmd: \"\n\t\t\t    \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t    \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits,\n\t\t\t    tmd.tmd2, tmd.tmd3);\n#endif\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\tif (tmd.tmd1_bits & LE_T1_ERR) {\n\t\t\tif (tmd.tmd3 & LE_T3_BUFF)\n\t\t\t\tprintf(\"%s: transmit buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\telse if (tmd.tmd3 & LE_T3_UFLO)\n\t\t\t\tprintf(\"%s: underflow\\n\", sc->sc_dev.dv_xname);\n\t\t\tif (tmd.tmd3 & (LE_T3_BUFF | LE_T3_UFLO)) {\n\t\t\t\tam7990_reset(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCAR) {\n\t\t\t\tif (sc->sc_nocarrier)\n\t\t\t\t\t(*sc->sc_nocarrier)(sc);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: lost carrier\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCOL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (tmd.tmd3 & LE_T3_RTRY) {\n\t\t\t\tprintf(\"%s: excessive collisions, tdr %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    tmd.tmd3 & LE_T3_TDR_MASK);\n\t\t\t\tifp->if_collisions += 16;\n\t\t\t}\n\t\t\tifp->if_oerrors++;\n\t\t} else {\n\t\t\tif (tmd.tmd1_bits & LE_T1_ONE)\n\t\t\t\tifp->if_collisions++;\n\t\t\telse if (tmd.tmd1_bits & LE_T1_MORE)\n\t\t\t\t/* Real number is unknown. */\n\t\t\t\tifp->if_collisions += 2;\n\t\t\tifp->if_opackets++;\n\t\t}\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\t--sc->sc_no_td;\n\t}\n\n\tsc->sc_first_td = bix;\n\n\tam7990_start(ifp);\n\n\tif (sc->sc_no_td == 0)\n\t\tifp->if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am7990_rint",
          "args": [
            "sc"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_rint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "506-579",
          "snippet": "integrate void\nam7990_rint(sc)\n\tstruct am7990_softc *sc;\n{\n\tregister int bix;\n\tint rp;\n\tstruct lermd rmd;\n\n\tbix = sc->sc_last_rd;\n\n\t/* Process all buffers with valid data. */\n\tfor (;;) {\n\t\trp = LE_RMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &rmd, rp, sizeof(rmd));\n\n\t\tif (rmd.rmd1_bits & LE_R1_OWN)\n\t\t\tbreak;\n\n\t\tif (rmd.rmd1_bits & LE_R1_ERR) {\n\t\t\tif (rmd.rmd1_bits & LE_R1_ENP) {\n#ifdef LEDEBUG\n\t\t\t\tif ((rmd.rmd1_bits & LE_R1_OFLO) == 0) {\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_FRAM)\n\t\t\t\t\t\tprintf(\"%s: framing error\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_CRC)\n\t\t\t\t\t\tprintf(\"%s: crc mismatch\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tif (rmd.rmd1_bits & LE_R1_OFLO)\n\t\t\t\t\tprintf(\"%s: overflow\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (rmd.rmd1_bits & LE_R1_BUFF)\n\t\t\t\tprintf(\"%s: receive buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else if ((rmd.rmd1_bits & (LE_R1_STP | LE_R1_ENP)) !=\n\t\t    (LE_R1_STP | LE_R1_ENP)) {\n\t\t\tprintf(\"%s: dropping chained buffer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else {\n#ifdef LEDEBUG1\n\t\t\tif (sc->sc_debug)\n\t\t\t\tam7990_recv_print(sc, sc->sc_last_rd);\n#endif\n\t\t\tam7990_read(sc, LE_RBUFADDR(sc, bix),\n\t\t\t    (int)rmd.rmd3 - 4);\n\t\t}\n\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, rp, sizeof(rmd));\n\n#ifdef LEDEBUG1\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"sc->sc_last_rd = %x, rmd: \"\n\t\t\t       \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t       \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t\tsc->sc_last_rd,\n\t\t\t\trmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits,\n\t\t\t\trmd.rmd2, rmd.rmd3);\n#endif\n\n\t\tif (++bix == sc->sc_nrbuf)\n\t\t\tbix = 0;\n\t}\n\n\tsc->sc_last_rd = bix;\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "integrate void",
            "am7990_rint __P((struct am7990_softc *));",
            "integrate void",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate int",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate void\nam7990_rint(sc)\n\tstruct am7990_softc *sc;\n{\n\tregister int bix;\n\tint rp;\n\tstruct lermd rmd;\n\n\tbix = sc->sc_last_rd;\n\n\t/* Process all buffers with valid data. */\n\tfor (;;) {\n\t\trp = LE_RMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &rmd, rp, sizeof(rmd));\n\n\t\tif (rmd.rmd1_bits & LE_R1_OWN)\n\t\t\tbreak;\n\n\t\tif (rmd.rmd1_bits & LE_R1_ERR) {\n\t\t\tif (rmd.rmd1_bits & LE_R1_ENP) {\n#ifdef LEDEBUG\n\t\t\t\tif ((rmd.rmd1_bits & LE_R1_OFLO) == 0) {\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_FRAM)\n\t\t\t\t\t\tprintf(\"%s: framing error\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_CRC)\n\t\t\t\t\t\tprintf(\"%s: crc mismatch\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tif (rmd.rmd1_bits & LE_R1_OFLO)\n\t\t\t\t\tprintf(\"%s: overflow\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (rmd.rmd1_bits & LE_R1_BUFF)\n\t\t\t\tprintf(\"%s: receive buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else if ((rmd.rmd1_bits & (LE_R1_STP | LE_R1_ENP)) !=\n\t\t    (LE_R1_STP | LE_R1_ENP)) {\n\t\t\tprintf(\"%s: dropping chained buffer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else {\n#ifdef LEDEBUG1\n\t\t\tif (sc->sc_debug)\n\t\t\t\tam7990_recv_print(sc, sc->sc_last_rd);\n#endif\n\t\t\tam7990_read(sc, LE_RBUFADDR(sc, bix),\n\t\t\t    (int)rmd.rmd3 - 4);\n\t\t}\n\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, rp, sizeof(rmd));\n\n#ifdef LEDEBUG1\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"sc->sc_last_rd = %x, rmd: \"\n\t\t\t       \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t       \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t\tsc->sc_last_rd,\n\t\t\t\trmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits,\n\t\t\t\trmd.rmd2, rmd.rmd3);\n#endif\n\n\t\tif (++bix == sc->sc_nrbuf)\n\t\t\tbix = 0;\n\t}\n\n\tsc->sc_last_rd = bix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am7990_reset",
          "args": [
            "sc"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "217-226",
          "snippet": "void\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: transmitter disabled\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0",
            "isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR |\n\t\t   LE_C0_RINT | LE_C0_TINT | LE_C0_IDON)"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nint\nam7990_intr(arg)\n\tregister void *arg;\n{\n\tregister struct am7990_softc *sc = arg;\n\tregister u_int16_t isr;\n\n\tisr = (*sc->sc_rdcsr)(sc, LE_CSR0);\n#ifdef LEDEBUG\n\tif (sc->sc_debug){\n\t\tprintf(\"%s: am7990_intr entering with isr=%04x\\n\",\n\t\t    sc->sc_dev.dv_xname, isr);\n\t\tprintf(\" isr: 0x%b\\n\", isr, LE_C0_BITS);\n\t}\n#endif\n\tif ((isr & LE_C0_INTR) == 0)\n\t\treturn (0);\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0,\n\t    isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR |\n\t\t   LE_C0_RINT | LE_C0_TINT | LE_C0_IDON));\n\tif (isr & LE_C0_ERR) {\n\t\tif (isr & LE_C0_BABL) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"%s: babble\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tifp->if_oerrors++;\n\t\t}\n#if 0\n\t\tif (isr & LE_C0_CERR) {\n\t\t\tprintf(\"%s: collision error\\n\", sc->sc_dev.dv_xname);\n\t\t\tifp->if_collisions++;\n\t\t}\n#endif\n\t\tif (isr & LE_C0_MISS) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"%s: missed packet\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t}\n\t\tif (isr & LE_C0_MERR) {\n\t\t\tprintf(\"%s: memory error\\n\", sc->sc_dev.dv_xname);\n\t\t\tam7990_reset(sc);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif ((isr & LE_C0_RXON) == 0) {\n\t\tprintf(\"%s: receiver disabled\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_ierrors++;\n\t\tam7990_reset(sc);\n\t\treturn (1);\n\t}\n\tif ((isr & LE_C0_TXON) == 0) {\n\t\tprintf(\"%s: transmitter disabled\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_oerrors++;\n\t\tam7990_reset(sc);\n\t\treturn (1);\n\t}\n\n\tif (isr & LE_C0_RINT)\n\t\tam7990_rint(sc);\n\tif (isr & LE_C0_TINT)\n\t\tam7990_tint(sc);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "am7990_tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "581-658",
    "snippet": "integrate void\nam7990_tint(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int bix;\n\tstruct letmd tmd;\n\n\tbix = sc->sc_first_td;\n\n\tfor (;;) {\n\t\tif (sc->sc_no_td <= 0)\n\t\t\tbreak;\n\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"trans tmd: \"\n\t\t\t    \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t    \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits,\n\t\t\t    tmd.tmd2, tmd.tmd3);\n#endif\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\tif (tmd.tmd1_bits & LE_T1_ERR) {\n\t\t\tif (tmd.tmd3 & LE_T3_BUFF)\n\t\t\t\tprintf(\"%s: transmit buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\telse if (tmd.tmd3 & LE_T3_UFLO)\n\t\t\t\tprintf(\"%s: underflow\\n\", sc->sc_dev.dv_xname);\n\t\t\tif (tmd.tmd3 & (LE_T3_BUFF | LE_T3_UFLO)) {\n\t\t\t\tam7990_reset(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCAR) {\n\t\t\t\tif (sc->sc_nocarrier)\n\t\t\t\t\t(*sc->sc_nocarrier)(sc);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: lost carrier\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCOL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (tmd.tmd3 & LE_T3_RTRY) {\n\t\t\t\tprintf(\"%s: excessive collisions, tdr %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    tmd.tmd3 & LE_T3_TDR_MASK);\n\t\t\t\tifp->if_collisions += 16;\n\t\t\t}\n\t\t\tifp->if_oerrors++;\n\t\t} else {\n\t\t\tif (tmd.tmd1_bits & LE_T1_ONE)\n\t\t\t\tifp->if_collisions++;\n\t\t\telse if (tmd.tmd1_bits & LE_T1_MORE)\n\t\t\t\t/* Real number is unknown. */\n\t\t\t\tifp->if_collisions += 2;\n\t\t\tifp->if_opackets++;\n\t\t}\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\t--sc->sc_no_td;\n\t}\n\n\tsc->sc_first_td = bix;\n\n\tam7990_start(ifp);\n\n\tif (sc->sc_no_td == 0)\n\t\tifp->if_timer = 0;\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "integrate void",
      "am7990_rint __P((struct am7990_softc *));",
      "integrate void",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate int",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "am7990_start",
          "args": [
            "ifp"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "751-832",
          "snippet": "void\nam7990_start(ifp)\n\tregister struct ifnet *ifp;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tregister int bix;\n\tregister struct mbuf *m;\n\tstruct letmd tmd;\n\tint rp;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tbix = sc->sc_last_td;\n\n\tfor (;;) {\n\t\trp = LE_TMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tprintf(\"missing buffer, no_td = %d, last_td = %d\\n\",\n\t\t\t    sc->sc_no_td, sc->sc_last_td);\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0)\n\t\t\tbreak;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If BPF is listening on this interface, let it see the packet\n\t\t * before we commit it to the wire.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmit buffer.\n\t\t */\n\t\tlen = am7990_put(sc, LE_TBUFADDR(sc, bix), m);\n\n#ifdef LEDEBUG\n\t\tif (len > ETHERMTU + sizeof(struct ether_header))\n\t\t\tprintf(\"packet length %d\\n\", len);\n#endif\n\n\t\tifp->if_timer = 5;\n\n\t\t/*\n\t\t * Init transmit registers, and set transmit start flag.\n\t\t */\n\t\ttmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;\n\t\ttmd.tmd2 = -len | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\n\t\t(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tam7990_xmit_print(sc, sc->sc_last_td);\n#endif\n\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\tif (++sc->sc_no_td == sc->sc_ntbuf) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"\\nequal!\\n\");\n#endif\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tsc->sc_last_td = bix;\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "am7990_put __P((struct am7990_softc *, int, struct mbuf *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nam7990_put __P((struct am7990_softc *, int, struct mbuf *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_start(ifp)\n\tregister struct ifnet *ifp;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tregister int bix;\n\tregister struct mbuf *m;\n\tstruct letmd tmd;\n\tint rp;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tbix = sc->sc_last_td;\n\n\tfor (;;) {\n\t\trp = LE_TMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tprintf(\"missing buffer, no_td = %d, last_td = %d\\n\",\n\t\t\t    sc->sc_no_td, sc->sc_last_td);\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0)\n\t\t\tbreak;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If BPF is listening on this interface, let it see the packet\n\t\t * before we commit it to the wire.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmit buffer.\n\t\t */\n\t\tlen = am7990_put(sc, LE_TBUFADDR(sc, bix), m);\n\n#ifdef LEDEBUG\n\t\tif (len > ETHERMTU + sizeof(struct ether_header))\n\t\t\tprintf(\"packet length %d\\n\", len);\n#endif\n\n\t\tifp->if_timer = 5;\n\n\t\t/*\n\t\t * Init transmit registers, and set transmit start flag.\n\t\t */\n\t\ttmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;\n\t\ttmd.tmd2 = -len | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\n\t\t(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tam7990_xmit_print(sc, sc->sc_last_td);\n#endif\n\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\tif (++sc->sc_no_td == sc->sc_ntbuf) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"\\nequal!\\n\");\n#endif\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tsc->sc_last_td = bix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: excessive collisions, tdr %d\\n\"",
            "sc->sc_dev.dv_xname",
            "tmd.tmd3 & LE_T3_TDR_MASK"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_reset",
          "args": [
            "sc"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "217-226",
          "snippet": "void\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&tmd",
            "LE_TMDADDR(sc, bix)",
            "sizeof(tmd)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_TMDADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate void\nam7990_tint(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int bix;\n\tstruct letmd tmd;\n\n\tbix = sc->sc_first_td;\n\n\tfor (;;) {\n\t\tif (sc->sc_no_td <= 0)\n\t\t\tbreak;\n\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"trans tmd: \"\n\t\t\t    \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t    \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits,\n\t\t\t    tmd.tmd2, tmd.tmd3);\n#endif\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN)\n\t\t\tbreak;\n\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\tif (tmd.tmd1_bits & LE_T1_ERR) {\n\t\t\tif (tmd.tmd3 & LE_T3_BUFF)\n\t\t\t\tprintf(\"%s: transmit buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\telse if (tmd.tmd3 & LE_T3_UFLO)\n\t\t\t\tprintf(\"%s: underflow\\n\", sc->sc_dev.dv_xname);\n\t\t\tif (tmd.tmd3 & (LE_T3_BUFF | LE_T3_UFLO)) {\n\t\t\t\tam7990_reset(sc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCAR) {\n\t\t\t\tif (sc->sc_nocarrier)\n\t\t\t\t\t(*sc->sc_nocarrier)(sc);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%s: lost carrier\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (tmd.tmd3 & LE_T3_LCOL)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (tmd.tmd3 & LE_T3_RTRY) {\n\t\t\t\tprintf(\"%s: excessive collisions, tdr %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    tmd.tmd3 & LE_T3_TDR_MASK);\n\t\t\t\tifp->if_collisions += 16;\n\t\t\t}\n\t\t\tifp->if_oerrors++;\n\t\t} else {\n\t\t\tif (tmd.tmd1_bits & LE_T1_ONE)\n\t\t\t\tifp->if_collisions++;\n\t\t\telse if (tmd.tmd1_bits & LE_T1_MORE)\n\t\t\t\t/* Real number is unknown. */\n\t\t\t\tifp->if_collisions += 2;\n\t\t\tifp->if_opackets++;\n\t\t}\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\t--sc->sc_no_td;\n\t}\n\n\tsc->sc_first_td = bix;\n\n\tam7990_start(ifp);\n\n\tif (sc->sc_no_td == 0)\n\t\tifp->if_timer = 0;\n}"
  },
  {
    "function_name": "am7990_rint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "506-579",
    "snippet": "integrate void\nam7990_rint(sc)\n\tstruct am7990_softc *sc;\n{\n\tregister int bix;\n\tint rp;\n\tstruct lermd rmd;\n\n\tbix = sc->sc_last_rd;\n\n\t/* Process all buffers with valid data. */\n\tfor (;;) {\n\t\trp = LE_RMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &rmd, rp, sizeof(rmd));\n\n\t\tif (rmd.rmd1_bits & LE_R1_OWN)\n\t\t\tbreak;\n\n\t\tif (rmd.rmd1_bits & LE_R1_ERR) {\n\t\t\tif (rmd.rmd1_bits & LE_R1_ENP) {\n#ifdef LEDEBUG\n\t\t\t\tif ((rmd.rmd1_bits & LE_R1_OFLO) == 0) {\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_FRAM)\n\t\t\t\t\t\tprintf(\"%s: framing error\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_CRC)\n\t\t\t\t\t\tprintf(\"%s: crc mismatch\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tif (rmd.rmd1_bits & LE_R1_OFLO)\n\t\t\t\t\tprintf(\"%s: overflow\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (rmd.rmd1_bits & LE_R1_BUFF)\n\t\t\t\tprintf(\"%s: receive buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else if ((rmd.rmd1_bits & (LE_R1_STP | LE_R1_ENP)) !=\n\t\t    (LE_R1_STP | LE_R1_ENP)) {\n\t\t\tprintf(\"%s: dropping chained buffer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else {\n#ifdef LEDEBUG1\n\t\t\tif (sc->sc_debug)\n\t\t\t\tam7990_recv_print(sc, sc->sc_last_rd);\n#endif\n\t\t\tam7990_read(sc, LE_RBUFADDR(sc, bix),\n\t\t\t    (int)rmd.rmd3 - 4);\n\t\t}\n\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, rp, sizeof(rmd));\n\n#ifdef LEDEBUG1\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"sc->sc_last_rd = %x, rmd: \"\n\t\t\t       \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t       \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t\tsc->sc_last_rd,\n\t\t\t\trmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits,\n\t\t\t\trmd.rmd2, rmd.rmd3);\n#endif\n\n\t\tif (++bix == sc->sc_nrbuf)\n\t\t\tbix = 0;\n\t}\n\n\tsc->sc_last_rd = bix;\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "integrate void",
      "am7990_rint __P((struct am7990_softc *));",
      "integrate void",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate int",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sc->sc_last_rd = %x, rmd: \"\n\t\t\t       \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t       \"bcnt %04x, mcnt %04x\\n\"",
            "sc->sc_last_rd",
            "rmd.rmd0",
            "rmd.rmd1_hadr",
            "rmd.rmd1_bits",
            "rmd.rmd2",
            "rmd.rmd3"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&rmd",
            "rp",
            "sizeof(rmd)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_read",
          "args": [
            "sc",
            "LE_RBUFADDR(sc, bix)",
            "(int)rmd.rmd3 - 4"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "447-504",
          "snippet": "integrate void\nam7990_read(sc, boff, len)\n\tregister struct am7990_softc *sc;\n\tint boff, len;\n{\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHERMTU + sizeof(struct ether_header)) {\n#ifdef LEDEBUG\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = am7990_get(sc, boff, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef LANCE_REVC_BUG\n\t/*\n\t * The old LANCE (Rev. C) chips have a bug which causes\n\t * garbage to be inserted in front of the received packet.\n\t * The work-around is to ignore packets with an invalid\n\t * destination address (garbage will usually not match).\n\t * Of course, this precludes multicast support...\n\t */\n\tif (ETHER_CMP(eh->ether_dhost, sc->sc_arpcom.ac_enaddr) &&\n\t    ETHER_CMP(eh->ether_dhost, etherbroadcastaddr)) {\n\t\tm_freem(m);\n\t\treturn;\n\t}\n#endif\n\n\t/* Pass the packet up, with the ether header sort-of removed. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_CMP\tether_cmp",
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "integrate void",
            "am7990_rint __P((struct am7990_softc *));",
            "integrate void",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate int",
            "am7990_put __P((struct am7990_softc *, int, struct mbuf *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_CMP\tether_cmp\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nam7990_put __P((struct am7990_softc *, int, struct mbuf *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate void\nam7990_read(sc, boff, len)\n\tregister struct am7990_softc *sc;\n\tint boff, len;\n{\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHERMTU + sizeof(struct ether_header)) {\n#ifdef LEDEBUG\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = am7990_get(sc, boff, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef LANCE_REVC_BUG\n\t/*\n\t * The old LANCE (Rev. C) chips have a bug which causes\n\t * garbage to be inserted in front of the received packet.\n\t * The work-around is to ignore packets with an invalid\n\t * destination address (garbage will usually not match).\n\t * Of course, this precludes multicast support...\n\t */\n\tif (ETHER_CMP(eh->ether_dhost, sc->sc_arpcom.ac_enaddr) &&\n\t    ETHER_CMP(eh->ether_dhost, etherbroadcastaddr)) {\n\t\tm_freem(m);\n\t\treturn;\n\t}\n#endif\n\n\t/* Pass the packet up, with the ether header sort-of removed. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LE_RBUFADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_recv_print",
          "args": [
            "sc",
            "sc->sc_last_rd"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_recv_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "947-972",
          "snippet": "void\nam7990_recv_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct lermd rmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &rmd, LE_RMDADDR(sc, no), sizeof(rmd));\n\tlen = rmd.rmd3;\n\tprintf(\"%s: receive buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits, rmd.rmd2, rmd.rmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_RBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t\tntohs(eh.ether_type));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_recv_print(sc, no)\n\tstruct am7990_softc *sc;\n\tint no;\n{\n\tstruct lermd rmd;\n\tu_int16_t len;\n\tstruct ether_header eh;\n\n\t(*sc->sc_copyfromdesc)(sc, &rmd, LE_RMDADDR(sc, no), sizeof(rmd));\n\tlen = rmd.rmd3;\n\tprintf(\"%s: receive buffer %d, len = %d\\n\", sc->sc_dev.dv_xname, no,\n\t    len);\n\tprintf(\"%s: status %04x\\n\", sc->sc_dev.dv_xname,\n\t    (*sc->sc_rdcsr)(sc, LE_CSR0));\n\tprintf(\"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits, rmd.rmd2, rmd.rmd3);\n\tif (len >= sizeof(eh)) {\n\t\t(*sc->sc_copyfrombuf)(sc, &eh, LE_RBUFADDR(sc, no), sizeof(eh));\n\t\tprintf(\"%s: dst %s\", sc->sc_dev.dv_xname,\n\t\t\tether_sprintf(eh.ether_dhost));\n\t\tprintf(\" src %s type %04x\\n\", ether_sprintf(eh.ether_shost),\n\t\t\tntohs(eh.ether_type));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&rmd",
            "rp",
            "sizeof(rmd)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_RMDADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate void\nam7990_rint(sc)\n\tstruct am7990_softc *sc;\n{\n\tregister int bix;\n\tint rp;\n\tstruct lermd rmd;\n\n\tbix = sc->sc_last_rd;\n\n\t/* Process all buffers with valid data. */\n\tfor (;;) {\n\t\trp = LE_RMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &rmd, rp, sizeof(rmd));\n\n\t\tif (rmd.rmd1_bits & LE_R1_OWN)\n\t\t\tbreak;\n\n\t\tif (rmd.rmd1_bits & LE_R1_ERR) {\n\t\t\tif (rmd.rmd1_bits & LE_R1_ENP) {\n#ifdef LEDEBUG\n\t\t\t\tif ((rmd.rmd1_bits & LE_R1_OFLO) == 0) {\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_FRAM)\n\t\t\t\t\t\tprintf(\"%s: framing error\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\tif (rmd.rmd1_bits & LE_R1_CRC)\n\t\t\t\t\t\tprintf(\"%s: crc mismatch\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tif (rmd.rmd1_bits & LE_R1_OFLO)\n\t\t\t\t\tprintf(\"%s: overflow\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t}\n\t\t\tif (rmd.rmd1_bits & LE_R1_BUFF)\n\t\t\t\tprintf(\"%s: receive buffer error\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else if ((rmd.rmd1_bits & (LE_R1_STP | LE_R1_ENP)) !=\n\t\t    (LE_R1_STP | LE_R1_ENP)) {\n\t\t\tprintf(\"%s: dropping chained buffer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tifp->if_ierrors++;\n\t\t} else {\n#ifdef LEDEBUG1\n\t\t\tif (sc->sc_debug)\n\t\t\t\tam7990_recv_print(sc, sc->sc_last_rd);\n#endif\n\t\t\tam7990_read(sc, LE_RBUFADDR(sc, bix),\n\t\t\t    (int)rmd.rmd3 - 4);\n\t\t}\n\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, rp, sizeof(rmd));\n\n#ifdef LEDEBUG1\n\t\tif (sc->sc_debug)\n\t\t\tprintf(\"sc->sc_last_rd = %x, rmd: \"\n\t\t\t       \"ladr %04x, hadr %02x, flags %02x, \"\n\t\t\t       \"bcnt %04x, mcnt %04x\\n\",\n\t\t\t\tsc->sc_last_rd,\n\t\t\t\trmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits,\n\t\t\t\trmd.rmd2, rmd.rmd3);\n#endif\n\n\t\tif (++bix == sc->sc_nrbuf)\n\t\t\tbix = 0;\n\t}\n\n\tsc->sc_last_rd = bix;\n}"
  },
  {
    "function_name": "am7990_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "447-504",
    "snippet": "integrate void\nam7990_read(sc, boff, len)\n\tregister struct am7990_softc *sc;\n\tint boff, len;\n{\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHERMTU + sizeof(struct ether_header)) {\n#ifdef LEDEBUG\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = am7990_get(sc, boff, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef LANCE_REVC_BUG\n\t/*\n\t * The old LANCE (Rev. C) chips have a bug which causes\n\t * garbage to be inserted in front of the received packet.\n\t * The work-around is to ignore packets with an invalid\n\t * destination address (garbage will usually not match).\n\t * Of course, this precludes multicast support...\n\t */\n\tif (ETHER_CMP(eh->ether_dhost, sc->sc_arpcom.ac_enaddr) &&\n\t    ETHER_CMP(eh->ether_dhost, etherbroadcastaddr)) {\n\t\tm_freem(m);\n\t\treturn;\n\t}\n#endif\n\n\t/* Pass the packet up, with the ether header sort-of removed. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_CMP\tether_cmp",
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "integrate void",
      "am7990_rint __P((struct am7990_softc *));",
      "integrate void",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate int",
      "am7990_put __P((struct am7990_softc *, int, struct mbuf *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_CMP",
          "args": [
            "eh->ether_dhost",
            "etherbroadcastaddr"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_CMP",
          "args": [
            "eh->ether_dhost",
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_get",
          "args": [
            "sc",
            "boff",
            "len"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: invalid packet size %d; dropping\\n\"",
            "sc->sc_dev.dv_xname",
            "len"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_CMP\tether_cmp\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nam7990_put __P((struct am7990_softc *, int, struct mbuf *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate void\nam7990_read(sc, boff, len)\n\tregister struct am7990_softc *sc;\n\tint boff, len;\n{\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHERMTU + sizeof(struct ether_header)) {\n#ifdef LEDEBUG\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = am7990_get(sc, boff, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef LANCE_REVC_BUG\n\t/*\n\t * The old LANCE (Rev. C) chips have a bug which causes\n\t * garbage to be inserted in front of the received packet.\n\t * The work-around is to ignore packets with an invalid\n\t * destination address (garbage will usually not match).\n\t * Of course, this precludes multicast support...\n\t */\n\tif (ETHER_CMP(eh->ether_dhost, sc->sc_arpcom.ac_enaddr) &&\n\t    ETHER_CMP(eh->ether_dhost, etherbroadcastaddr)) {\n\t\tm_freem(m);\n\t\treturn;\n\t}\n#endif\n\n\t/* Pass the packet up, with the ether header sort-of removed. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}"
  },
  {
    "function_name": "am7990_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "361-386",
    "snippet": "integrate int\nam7990_put(sc, boff, m)\n\tstruct am7990_softc *sc;\n\tint boff;\n\tregister struct mbuf *m;\n{\n\tregister struct mbuf *n;\n\tregister int len, tlen = 0;\n\n\tfor (; m; m = n) {\n\t\tlen = m->m_len;\n\t\tif (len == 0) {\n\t\t\tMFREE(m, n);\n\t\t\tcontinue;\n\t\t}\n\t\t(*sc->sc_copytobuf)(sc, mtod(m, caddr_t), boff, len);\n\t\tboff += len;\n\t\ttlen += len;\n\t\tMFREE(m, n);\n\t}\n\tif (tlen < LEMINSIZE) {\n\t\t(*sc->sc_zerobuf)(sc, boff, LEMINSIZE - tlen);\n\t\ttlen = LEMINSIZE;\n\t}\n\treturn (tlen);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "integrate void",
      "am7990_rint __P((struct am7990_softc *));",
      "integrate void",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate int",
      "am7990_put __P((struct am7990_softc *, int, struct mbuf *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "boff",
            "LEMINSIZE - tlen"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "n"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "mtod(m, caddr_t)",
            "boff",
            "len"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "n"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nintegrate void;\nam7990_rint __P((struct am7990_softc *));\nintegrate void;\nam7990_tint __P((struct am7990_softc *));\nintegrate int;\nam7990_put __P((struct am7990_softc *, int, struct mbuf *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nintegrate int\nam7990_put(sc, boff, m)\n\tstruct am7990_softc *sc;\n\tint boff;\n\tregister struct mbuf *m;\n{\n\tregister struct mbuf *n;\n\tregister int len, tlen = 0;\n\n\tfor (; m; m = n) {\n\t\tlen = m->m_len;\n\t\tif (len == 0) {\n\t\t\tMFREE(m, n);\n\t\t\tcontinue;\n\t\t}\n\t\t(*sc->sc_copytobuf)(sc, mtod(m, caddr_t), boff, len);\n\t\tboff += len;\n\t\ttlen += len;\n\t\tMFREE(m, n);\n\t}\n\tif (tlen < LEMINSIZE) {\n\t\t(*sc->sc_zerobuf)(sc, boff, LEMINSIZE - tlen);\n\t\ttlen = LEMINSIZE;\n\t}\n\treturn (tlen);\n}"
  },
  {
    "function_name": "am7990_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "309-355",
    "snippet": "void\nam7990_init(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int timo;\n\tu_long a;\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n\tDELAY(100);\n\n\t/* Newer LANCE chips have a reset register */\n\tif (sc->sc_hwreset)\n\t\t(*sc->sc_hwreset)(sc);\n\n\t/* Set the correct byte swapping mode, etc. */\n\t(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);\n\n\t/* Set up LANCE init block. */\n\tam7990_meminit(sc);\n\n\t/* Give LANCE the physical address of its init block. */\n\ta = sc->sc_addr + LE_INITADDR(sc);\n\t(*sc->sc_wrcsr)(sc, LE_CSR1, a);\n\t(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);\n\n\t/* Try to initialize the LANCE. */\n\tDELAY(100);\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);\n\n\t/* Wait for initialization to finish. */\n\tfor (timo = 100000; timo; timo--)\n\t\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)\n\t\t\tbreak;\n\n\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {\n\t\t/* Start the LANCE. */\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |\n\t\t    LE_C0_IDON);\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t\tam7990_start(ifp);\n\t} else\n\t\tprintf(\"%s: controller failed to initialize\\n\", sc->sc_dev.dv_xname);\n\tif (sc->sc_hwinit)\n\t\t(*sc->sc_hwinit)(sc);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: controller failed to initialize\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "am7990_start",
          "args": [
            "ifp"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "751-832",
          "snippet": "void\nam7990_start(ifp)\n\tregister struct ifnet *ifp;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tregister int bix;\n\tregister struct mbuf *m;\n\tstruct letmd tmd;\n\tint rp;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tbix = sc->sc_last_td;\n\n\tfor (;;) {\n\t\trp = LE_TMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tprintf(\"missing buffer, no_td = %d, last_td = %d\\n\",\n\t\t\t    sc->sc_no_td, sc->sc_last_td);\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0)\n\t\t\tbreak;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If BPF is listening on this interface, let it see the packet\n\t\t * before we commit it to the wire.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmit buffer.\n\t\t */\n\t\tlen = am7990_put(sc, LE_TBUFADDR(sc, bix), m);\n\n#ifdef LEDEBUG\n\t\tif (len > ETHERMTU + sizeof(struct ether_header))\n\t\t\tprintf(\"packet length %d\\n\", len);\n#endif\n\n\t\tifp->if_timer = 5;\n\n\t\t/*\n\t\t * Init transmit registers, and set transmit start flag.\n\t\t */\n\t\ttmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;\n\t\ttmd.tmd2 = -len | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\n\t\t(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tam7990_xmit_print(sc, sc->sc_last_td);\n#endif\n\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\tif (++sc->sc_no_td == sc->sc_ntbuf) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"\\nequal!\\n\");\n#endif\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tsc->sc_last_td = bix;\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "am7990_put __P((struct am7990_softc *, int, struct mbuf *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nam7990_put __P((struct am7990_softc *, int, struct mbuf *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_start(ifp)\n\tregister struct ifnet *ifp;\n{\n\tregister struct am7990_softc *sc = ifp->if_softc;\n\tregister int bix;\n\tregister struct mbuf *m;\n\tstruct letmd tmd;\n\tint rp;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tbix = sc->sc_last_td;\n\n\tfor (;;) {\n\t\trp = LE_TMDADDR(sc, bix);\n\t\t(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));\n\n\t\tif (tmd.tmd1_bits & LE_T1_OWN) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tprintf(\"missing buffer, no_td = %d, last_td = %d\\n\",\n\t\t\t    sc->sc_no_td, sc->sc_last_td);\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0)\n\t\t\tbreak;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If BPF is listening on this interface, let it see the packet\n\t\t * before we commit it to the wire.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmit buffer.\n\t\t */\n\t\tlen = am7990_put(sc, LE_TBUFADDR(sc, bix), m);\n\n#ifdef LEDEBUG\n\t\tif (len > ETHERMTU + sizeof(struct ether_header))\n\t\t\tprintf(\"packet length %d\\n\", len);\n#endif\n\n\t\tifp->if_timer = 5;\n\n\t\t/*\n\t\t * Init transmit registers, and set transmit start flag.\n\t\t */\n\t\ttmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;\n\t\ttmd.tmd2 = -len | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\n\t\t(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));\n\n#ifdef LEDEBUG\n\t\tif (sc->sc_debug)\n\t\t\tam7990_xmit_print(sc, sc->sc_last_td);\n#endif\n\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);\n\n\t\tif (++bix == sc->sc_ntbuf)\n\t\t\tbix = 0;\n\n\t\tif (++sc->sc_no_td == sc->sc_ntbuf) {\n#ifdef LEDEBUG\n\t\t\tprintf(\"\\nequal!\\n\");\n#endif\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tsc->sc_last_td = bix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0",
            "LE_C0_INEA | LE_C0_STRT |\n\t\t    LE_C0_IDON"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0",
            "LE_C0_INIT"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR2",
            "a >> 16"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR1",
            "a"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_INITADDR",
          "args": [
            "sc"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_meminit",
          "args": [
            "sc"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR3",
            "sc->sc_conf3"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0",
            "LE_C0_STOP"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_init(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int timo;\n\tu_long a;\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n\tDELAY(100);\n\n\t/* Newer LANCE chips have a reset register */\n\tif (sc->sc_hwreset)\n\t\t(*sc->sc_hwreset)(sc);\n\n\t/* Set the correct byte swapping mode, etc. */\n\t(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);\n\n\t/* Set up LANCE init block. */\n\tam7990_meminit(sc);\n\n\t/* Give LANCE the physical address of its init block. */\n\ta = sc->sc_addr + LE_INITADDR(sc);\n\t(*sc->sc_wrcsr)(sc, LE_CSR1, a);\n\t(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);\n\n\t/* Try to initialize the LANCE. */\n\tDELAY(100);\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);\n\n\t/* Wait for initialization to finish. */\n\tfor (timo = 100000; timo; timo--)\n\t\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)\n\t\t\tbreak;\n\n\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {\n\t\t/* Start the LANCE. */\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |\n\t\t    LE_C0_IDON);\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t\tam7990_start(ifp);\n\t} else\n\t\tprintf(\"%s: controller failed to initialize\\n\", sc->sc_dev.dv_xname);\n\tif (sc->sc_hwinit)\n\t\t(*sc->sc_hwinit)(sc);\n}"
  },
  {
    "function_name": "am7990_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "297-303",
    "snippet": "void\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "LE_CSR0",
            "LE_C0_STOP"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}"
  },
  {
    "function_name": "am7990_meminit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "231-295",
    "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&tmd",
            "LE_TMDADDR(sc, bix)",
            "sizeof(tmd)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_TMDADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_TBUFADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&rmd",
            "LE_RMDADDR(sc, bix)",
            "sizeof(rmd)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_RMDADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_RBUFADDR",
          "args": [
            "sc",
            "bix"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "&init",
            "LE_INITADDR(sc)",
            "sizeof(init)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_INITADDR",
          "args": [
            "sc"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "sc->sc_ntbuf"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LE_TMDADDR",
          "args": [
            "sc",
            "0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LE_RMDADDR",
          "args": [
            "sc",
            "0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_setladrf",
          "args": [
            "&sc->sc_arpcom",
            "init.init_ladrf"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_setladrf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "1005-1070",
          "snippet": "void\nam7990_setladrf(ac, af)\n\tstruct arpcom *ac;\n\tu_int16_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = 0x0000;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Set the corresponding bit in the filter. */\n\t\taf[crc >> 4] |= 1 << (crc & 0xf);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = 0xffff;\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_CMP\tether_cmp",
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "integrate struct",
            "integrate struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_CMP\tether_cmp\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nintegrate struct;\nintegrate struct;\n\nvoid\nam7990_setladrf(ac, af)\n\tstruct arpcom *ac;\n\tu_int16_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = 0x0000;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Set the corresponding bit in the filter. */\n\t\taf[crc >> 4] |= 1 << (crc & 0xf);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = 0xffff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
  },
  {
    "function_name": "am7990_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "217-226",
    "snippet": "void\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "am7990_init",
          "args": [
            "sc"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "309-355",
          "snippet": "void\nam7990_init(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int timo;\n\tu_long a;\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n\tDELAY(100);\n\n\t/* Newer LANCE chips have a reset register */\n\tif (sc->sc_hwreset)\n\t\t(*sc->sc_hwreset)(sc);\n\n\t/* Set the correct byte swapping mode, etc. */\n\t(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);\n\n\t/* Set up LANCE init block. */\n\tam7990_meminit(sc);\n\n\t/* Give LANCE the physical address of its init block. */\n\ta = sc->sc_addr + LE_INITADDR(sc);\n\t(*sc->sc_wrcsr)(sc, LE_CSR1, a);\n\t(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);\n\n\t/* Try to initialize the LANCE. */\n\tDELAY(100);\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);\n\n\t/* Wait for initialization to finish. */\n\tfor (timo = 100000; timo; timo--)\n\t\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)\n\t\t\tbreak;\n\n\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {\n\t\t/* Start the LANCE. */\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |\n\t\t    LE_C0_IDON);\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t\tam7990_start(ifp);\n\t} else\n\t\tprintf(\"%s: controller failed to initialize\\n\", sc->sc_dev.dv_xname);\n\tif (sc->sc_hwinit)\n\t\t(*sc->sc_hwinit)(sc);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_init(sc)\n\tregister struct am7990_softc *sc;\n{\n\tregister int timo;\n\tu_long a;\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n\tDELAY(100);\n\n\t/* Newer LANCE chips have a reset register */\n\tif (sc->sc_hwreset)\n\t\t(*sc->sc_hwreset)(sc);\n\n\t/* Set the correct byte swapping mode, etc. */\n\t(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);\n\n\t/* Set up LANCE init block. */\n\tam7990_meminit(sc);\n\n\t/* Give LANCE the physical address of its init block. */\n\ta = sc->sc_addr + LE_INITADDR(sc);\n\t(*sc->sc_wrcsr)(sc, LE_CSR1, a);\n\t(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);\n\n\t/* Try to initialize the LANCE. */\n\tDELAY(100);\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);\n\n\t/* Wait for initialization to finish. */\n\tfor (timo = 100000; timo; timo--)\n\t\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)\n\t\t\tbreak;\n\n\tif ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {\n\t\t/* Start the LANCE. */\n\t\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |\n\t\t    LE_C0_IDON);\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\t\tam7990_start(ifp);\n\t} else\n\t\tprintf(\"%s: controller failed to initialize\\n\", sc->sc_dev.dv_xname);\n\tif (sc->sc_hwinit)\n\t\t(*sc->sc_hwinit)(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_reset(sc)\n\tstruct am7990_softc *sc;\n{\n\tint s;\n\n\ts = splimp();\n\tam7990_init(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "am7990_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "131-215",
    "snippet": "void\nam7990_config(sc)\n\tstruct am7990_softc *sc;\n{\n\tint mem;\n\n\t/* Make sure the chip is stopped. */\n\tam7990_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = am7990_start;\n\tifp->if_ioctl = am7990_ioctl;\n\tifp->if_watchdog = am7990_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n#ifdef LANCE_REVC_BUG\n\tifp->if_flags &= ~IFF_MULTICAST;\n#endif\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tif (sc->sc_memsize > 262144)\n\t\tsc->sc_memsize = 262144;\n\n\tswitch (sc->sc_memsize) {\n\tcase 8192:\n\t\tsc->sc_nrbuf = 4;\n\t\tsc->sc_ntbuf = 1;\n\t\tbreak;\n\tcase 16384:\n\t\tsc->sc_nrbuf = 8;\n\t\tsc->sc_ntbuf = 2;\n\t\tbreak;\n\tcase 32768:\n\t\tsc->sc_nrbuf = 16;\n\t\tsc->sc_ntbuf = 4;\n\t\tbreak;\n\tcase 65536:\n\t\tsc->sc_nrbuf = 32;\n\t\tsc->sc_ntbuf = 8;\n\t\tbreak;\n\tcase 131072:\n\t\tsc->sc_nrbuf = 64;\n\t\tsc->sc_ntbuf = 16;\n\t\tbreak;\n\tcase 262144:\n\t\tsc->sc_nrbuf = 128;\n\t\tsc->sc_ntbuf = 32;\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"am7990_config: weird memory size %d\", sc->sc_memsize);\n\t}\n\n\tprintf(\": address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\tprintf(\"%s: %d receive buffers, %d transmit buffers\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_nrbuf, sc->sc_ntbuf);\n\n\tsc->sc_sh = shutdownhook_establish(am7990_shutdown, sc);\n\tif (sc->sc_sh == NULL)\n\t\tpanic(\"am7990_config: can't establish shutdownhook\");\n\n\tmem = 0;\n\tsc->sc_initaddr = mem;\n\tmem += sizeof(struct leinit);\n\tsc->sc_rmdaddr = mem;\n\tmem += sizeof(struct lermd) * sc->sc_nrbuf;\n\tsc->sc_tmdaddr = mem;\n\tmem += sizeof(struct letmd) * sc->sc_ntbuf;\n\tsc->sc_rbufaddr = mem;\n\tmem += LEBLEN * sc->sc_nrbuf;\n\tsc->sc_tbufaddr = mem;\n\tmem += LEBLEN * sc->sc_ntbuf;\n#ifdef notyet\n\tif (mem > ...)\n\t\tpanic(...);\n#endif\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifp\t(&sc->sc_arpcom.ac_if)"
    ],
    "globals_used": [
      "am7990_rint __P((struct am7990_softc *));",
      "am7990_tint __P((struct am7990_softc *));",
      "integrate struct",
      "integrate struct",
      "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "..."
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"am7990_config: can't establish shutdownhook\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "am7990_shutdown",
            "sc"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d receive buffers, %d transmit buffers\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_nrbuf",
            "sc->sc_ntbuf"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"am7990_config: weird memory size %d\"",
            "sc->sc_memsize"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "am7990_stop",
          "args": [
            "sc"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "297-303",
          "snippet": "void\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_stop(sc)\n\tstruct am7990_softc *sc;\n{\n\n\t(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_config(sc)\n\tstruct am7990_softc *sc;\n{\n\tint mem;\n\n\t/* Make sure the chip is stopped. */\n\tam7990_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = am7990_start;\n\tifp->if_ioctl = am7990_ioctl;\n\tifp->if_watchdog = am7990_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n#ifdef LANCE_REVC_BUG\n\tifp->if_flags &= ~IFF_MULTICAST;\n#endif\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tif (sc->sc_memsize > 262144)\n\t\tsc->sc_memsize = 262144;\n\n\tswitch (sc->sc_memsize) {\n\tcase 8192:\n\t\tsc->sc_nrbuf = 4;\n\t\tsc->sc_ntbuf = 1;\n\t\tbreak;\n\tcase 16384:\n\t\tsc->sc_nrbuf = 8;\n\t\tsc->sc_ntbuf = 2;\n\t\tbreak;\n\tcase 32768:\n\t\tsc->sc_nrbuf = 16;\n\t\tsc->sc_ntbuf = 4;\n\t\tbreak;\n\tcase 65536:\n\t\tsc->sc_nrbuf = 32;\n\t\tsc->sc_ntbuf = 8;\n\t\tbreak;\n\tcase 131072:\n\t\tsc->sc_nrbuf = 64;\n\t\tsc->sc_ntbuf = 16;\n\t\tbreak;\n\tcase 262144:\n\t\tsc->sc_nrbuf = 128;\n\t\tsc->sc_ntbuf = 32;\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"am7990_config: weird memory size %d\", sc->sc_memsize);\n\t}\n\n\tprintf(\": address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\tprintf(\"%s: %d receive buffers, %d transmit buffers\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_nrbuf, sc->sc_ntbuf);\n\n\tsc->sc_sh = shutdownhook_establish(am7990_shutdown, sc);\n\tif (sc->sc_sh == NULL)\n\t\tpanic(\"am7990_config: can't establish shutdownhook\");\n\n\tmem = 0;\n\tsc->sc_initaddr = mem;\n\tmem += sizeof(struct leinit);\n\tsc->sc_rmdaddr = mem;\n\tmem += sizeof(struct lermd) * sc->sc_nrbuf;\n\tsc->sc_tmdaddr = mem;\n\tmem += sizeof(struct letmd) * sc->sc_ntbuf;\n\tsc->sc_rbufaddr = mem;\n\tmem += LEBLEN * sc->sc_nrbuf;\n\tsc->sc_tbufaddr = mem;\n\tmem += LEBLEN * sc->sc_ntbuf;\n#ifdef notyet\n\tif (mem > ...)\n\t\tpanic(...);\n#endif\n}"
  },
  {
    "function_name": "ether_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
    "lines": "101-114",
    "snippet": "static inline u_short\nether_cmp(one, two)\n\tvoid *one, *two;\n{\n\tregister u_int16_t *a = (u_short *) one;\n\tregister u_int16_t *b = (u_short *) two;\n\tregister u_int16_t diff;\n\n\tdiff  = *a++ - *b++;\n\tdiff |= *a++ - *b++;\n\tdiff |= *a++ - *b++;\n\n\treturn (diff);\n}",
    "includes": [
      "#include <dev/ic/am7990var.h>",
      "#include <dev/ic/am7990reg.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline u_short\nether_cmp(one, two)\n\tvoid *one, *two;\n{\n\tregister u_int16_t *a = (u_short *) one;\n\tregister u_int16_t *b = (u_short *) two;\n\tregister u_int16_t diff;\n\n\tdiff  = *a++ - *b++;\n\tdiff |= *a++ - *b++;\n\tdiff |= *a++ - *b++;\n\n\treturn (diff);\n}"
  }
]