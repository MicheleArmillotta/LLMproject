[
  {
    "function_name": "pas_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pas.c",
    "lines": "424-431",
    "snippet": "int\npas_getdev(addr, retp)\n\tvoid *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = pas_device;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/pasreg.h>",
      "#include <dev/isa/sbreg.h>",
      "#include <dev/isa/sbdspvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpas_getdev",
      "static struct audio_device pas_device = {\n\t\"PAS,??\",\n\t\"\",\n\t\"pas\"\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/pasreg.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/sbdspvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpas_getdev;\nstatic struct audio_device pas_device = {\n\t\"PAS,??\",\n\t\"\",\n\t\"pas\"\n};\n\nint\npas_getdev(addr, retp)\n\tvoid *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = pas_device;\n\treturn 0;\n}"
  },
  {
    "function_name": "pasattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pas.c",
    "lines": "401-422",
    "snippet": "void\npasattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pas_softc *sc = (struct pas_softc *)self;\n\tstruct isa_attach_args *ia = (struct isa_attach_args *)aux;\n\tint iobase = ia->ia_iobase;\n\t\n\tsc->sc_sbdsp.sc_iobase = iobase;\n\tsc->sc_sbdsp.sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, sbdsp_intr, &sc->sc_sbdsp, sc->sc_sbdsp.sc_dev.dv_xname);\n\n\tprintf(\" ProAudio Spectrum %s [rev %d] \", pasnames[sc->model], sc->rev);\n\t\n\tsbdsp_attach(&sc->sc_sbdsp);\n\n\tsprintf(pas_device.name, \"pas,%s\", pasnames[sc->model]);\n\tsprintf(pas_device.version, \"%d\", sc->rev);\n\n\taudio_attach_mi(&pas_hw_if, &sc->sc_sbdsp, &sc->sc_sbdsp.sc_dev);\n}",
    "includes": [
      "#include <dev/isa/pasreg.h>",
      "#include <dev/isa/sbreg.h>",
      "#include <dev/isa/sbdspvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct audio_hw_if pas_hw_if = {\n\tsbdsp_open,\n\tsbdsp_close,\n\t0,\n\tsbdsp_query_encoding,\n\tsbdsp_set_params,\n\tsbdsp_round_blocksize,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\tsbdsp_haltdma,\n\tsbdsp_haltdma,\n\tsbdsp_speaker_ctl,\n\tpas_getdev,\n\t0,\n\tsbdsp_mixer_set_port,\n\tsbdsp_mixer_get_port,\n\tsbdsp_mixer_query_devinfo,\n\tsb_malloc,\n\tsb_free,\n\tsb_round,\n        sb_mappage,\n\tsbdsp_get_props,\n\tsbdsp_trigger_output,\n\tsbdsp_trigger_input\n};",
      "static char *pasnames[] = {\n\t\"\",\n\t\"Plus\",\n\t\"CDPC\",\n\t\"16\",\n\t\"16Basic\"\n};",
      "static struct audio_device pas_device = {\n\t\"PAS,??\",\n\t\"\",\n\t\"pas\"\n};",
      "void\tpasattach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "&pas_hw_if",
            "&sc->sc_sbdsp",
            "&sc->sc_sbdsp.sc_dev"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pas_device.version",
            "\"%d\"",
            "sc->rev"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pas_device.name",
            "\"pas,%s\"",
            "pasnames[sc->model]"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbdsp_attach",
          "args": [
            "&sc->sc_sbdsp"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "sbdsp_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/sbdsp.c",
          "lines": "327-405",
          "snippet": "void\nsbdsp_attach(sc)\n\tstruct sbdsp_softc *sc;\n{\n\tstruct audio_params pparams, rparams;\n        int i;\n        u_int v;\n\n\t/*\n\t * Create our DMA maps.\n\t */\n\tif (sc->sc_drq8 != -1) {\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq8,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_drq8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (sc->sc_drq16 != -1 && sc->sc_drq16 != sc->sc_drq8) {\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq16,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_drq16);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpparams = audio_default;\n\trparams = audio_default;\n        sbdsp_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n\tsbdsp_set_in_ports(sc, 1 << SB_MIC_VOL);\n\n\tif (sc->sc_mixer_model != SBM_NONE) {\n        \t/* Reset the mixer.*/\n\t\tsbdsp_mix_write(sc, SBP_MIX_RESET, SBP_MIX_RESET);\n                /* And set our own default values */\n\t\tfor (i = 0; i < SB_NDEVS; i++) {\n\t\t\tswitch(i) {\n\t\t\tcase SB_MIC_VOL:\n\t\t\tcase SB_LINE_IN_VOL:\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\t\t\tcase SB_BASS:\n\t\t\tcase SB_TREBLE:\n\t\t\t\tv = SB_ADJUST_GAIN(sc, AUDIO_MAX_GAIN/2);\n\t\t\t\tbreak;\n\t\t\tcase SB_CD_IN_MUTE:\n\t\t\tcase SB_MIC_IN_MUTE:\n\t\t\tcase SB_LINE_IN_MUTE:\n\t\t\tcase SB_MIDI_IN_MUTE:\n\t\t\tcase SB_CD_SWAP:\n\t\t\tcase SB_MIC_SWAP:\n\t\t\tcase SB_LINE_SWAP:\n\t\t\tcase SB_MIDI_SWAP:\n\t\t\tcase SB_CD_OUT_MUTE:\n\t\t\tcase SB_MIC_OUT_MUTE:\n\t\t\tcase SB_LINE_OUT_MUTE:\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = SB_ADJUST_GAIN(sc, AUDIO_MAX_GAIN / 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc->gain[i][SB_LEFT] = sc->gain[i][SB_RIGHT] = v;\n\t\t\tsbdsp_set_mixer_gain(sc, i);\n\t\t}\n\t\tsc->in_filter = 0;\t/* no filters turned on, please */\n\t}\n\n\tprintf(\": dsp v%d.%02d%s\\n\",\n\t       SBVER_MAJOR(sc->sc_version), SBVER_MINOR(sc->sc_version),\n\t       sc->sc_model == SB_JAZZ ? \": <Jazz16>\" : \"\");\n\n\tsc->sc_fullduplex = ISSB16CLASS(sc) && \n\t\tsc->sc_drq8 != -1 && sc->sc_drq16 != -1 &&\n\t\tsc->sc_drq8 != sc->sc_drq16;\n}",
          "includes": [
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsbdsp_set_mixer_gain",
            "int\tsbdsp_set_in_ports"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/sbdspvar.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid\tsbdsp_set_mixer_gain;\nint\tsbdsp_set_in_ports;\n\nvoid\nsbdsp_attach(sc)\n\tstruct sbdsp_softc *sc;\n{\n\tstruct audio_params pparams, rparams;\n        int i;\n        u_int v;\n\n\t/*\n\t * Create our DMA maps.\n\t */\n\tif (sc->sc_drq8 != -1) {\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq8,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_drq8);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (sc->sc_drq16 != -1 && sc->sc_drq16 != sc->sc_drq8) {\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq16,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_drq16);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpparams = audio_default;\n\trparams = audio_default;\n        sbdsp_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n\tsbdsp_set_in_ports(sc, 1 << SB_MIC_VOL);\n\n\tif (sc->sc_mixer_model != SBM_NONE) {\n        \t/* Reset the mixer.*/\n\t\tsbdsp_mix_write(sc, SBP_MIX_RESET, SBP_MIX_RESET);\n                /* And set our own default values */\n\t\tfor (i = 0; i < SB_NDEVS; i++) {\n\t\t\tswitch(i) {\n\t\t\tcase SB_MIC_VOL:\n\t\t\tcase SB_LINE_IN_VOL:\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\t\t\tcase SB_BASS:\n\t\t\tcase SB_TREBLE:\n\t\t\t\tv = SB_ADJUST_GAIN(sc, AUDIO_MAX_GAIN/2);\n\t\t\t\tbreak;\n\t\t\tcase SB_CD_IN_MUTE:\n\t\t\tcase SB_MIC_IN_MUTE:\n\t\t\tcase SB_LINE_IN_MUTE:\n\t\t\tcase SB_MIDI_IN_MUTE:\n\t\t\tcase SB_CD_SWAP:\n\t\t\tcase SB_MIC_SWAP:\n\t\t\tcase SB_LINE_SWAP:\n\t\t\tcase SB_MIDI_SWAP:\n\t\t\tcase SB_CD_OUT_MUTE:\n\t\t\tcase SB_MIC_OUT_MUTE:\n\t\t\tcase SB_LINE_OUT_MUTE:\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = SB_ADJUST_GAIN(sc, AUDIO_MAX_GAIN / 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc->gain[i][SB_LEFT] = sc->gain[i][SB_RIGHT] = v;\n\t\t\tsbdsp_set_mixer_gain(sc, i);\n\t\t}\n\t\tsc->in_filter = 0;\t/* no filters turned on, please */\n\t}\n\n\tprintf(\": dsp v%d.%02d%s\\n\",\n\t       SBVER_MAJOR(sc->sc_version), SBVER_MINOR(sc->sc_version),\n\t       sc->sc_model == SB_JAZZ ? \": <Jazz16>\" : \"\");\n\n\tsc->sc_fullduplex = ISSB16CLASS(sc) && \n\t\tsc->sc_drq8 != -1 && sc->sc_drq16 != -1 &&\n\t\tsc->sc_drq8 != sc->sc_drq16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ProAudio Spectrum %s [rev %d] \"",
            "pasnames[sc->model]",
            "sc->rev"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_AUDIO",
            "sbdsp_intr",
            "&sc->sc_sbdsp",
            "sc->sc_sbdsp.sc_dev.dv_xname"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pasreg.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/sbdspvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_hw_if pas_hw_if = {\n\tsbdsp_open,\n\tsbdsp_close,\n\t0,\n\tsbdsp_query_encoding,\n\tsbdsp_set_params,\n\tsbdsp_round_blocksize,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\tsbdsp_haltdma,\n\tsbdsp_haltdma,\n\tsbdsp_speaker_ctl,\n\tpas_getdev,\n\t0,\n\tsbdsp_mixer_set_port,\n\tsbdsp_mixer_get_port,\n\tsbdsp_mixer_query_devinfo,\n\tsb_malloc,\n\tsb_free,\n\tsb_round,\n        sb_mappage,\n\tsbdsp_get_props,\n\tsbdsp_trigger_output,\n\tsbdsp_trigger_input\n};\nstatic char *pasnames[] = {\n\t\"\",\n\t\"Plus\",\n\t\"CDPC\",\n\t\"16\",\n\t\"16Basic\"\n};\nstatic struct audio_device pas_device = {\n\t\"PAS,??\",\n\t\"\",\n\t\"pas\"\n};\nvoid\tpasattach;\n\nvoid\npasattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pas_softc *sc = (struct pas_softc *)self;\n\tstruct isa_attach_args *ia = (struct isa_attach_args *)aux;\n\tint iobase = ia->ia_iobase;\n\t\n\tsc->sc_sbdsp.sc_iobase = iobase;\n\tsc->sc_sbdsp.sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, sbdsp_intr, &sc->sc_sbdsp, sc->sc_sbdsp.sc_dev.dv_xname);\n\n\tprintf(\" ProAudio Spectrum %s [rev %d] \", pasnames[sc->model], sc->rev);\n\t\n\tsbdsp_attach(&sc->sc_sbdsp);\n\n\tsprintf(pas_device.name, \"pas,%s\", pasnames[sc->model]);\n\tsprintf(pas_device.version, \"%d\", sc->rev);\n\n\taudio_attach_mi(&pas_hw_if, &sc->sc_sbdsp, &sc->sc_sbdsp.sc_dev);\n}"
  },
  {
    "function_name": "pasprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pas.c",
    "lines": "261-395",
    "snippet": "int\npasprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pas_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tint iobase;\n\tu_char id, t;\n\n        /* ensure we can set this up as a sound blaster */\n       \tif (!SB_BASE_VALID(ia->ia_iobase)) {\n\t\tDPRINTF((\"pas: configured SB iobase 0x%x invalid\\n\", ia->ia_iobase));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * WARNING: Setting an option like W:1 or so that disables\n\t * warm boot reset of the card will screw up this detect code\n\t * something fierce.  Adding code to handle this means possibly\n\t * interfering with other cards on the bus if you have something\n\t * on base port 0x388.  SO be forewarned. \n\t */\n\t/* Talk to first board */\n\toutb(MASTER_DECODE, 0xbc);\n\t/* Set base address */\n\n#if 0\n\t/* XXX Need to setup pseudo device */\n\t/* XXX What are good io addrs ? */\n\tif (iobase != PAS_DEFAULT_BASE) {\n\t\tDPRINTF((\"pas: configured iobase %d invalid\\n\", iobase));\n\t\treturn 0;\n\t}\n#else\n\t/* Start out talking to native PAS */\n\tiobase = PAS_DEFAULT_BASE;\n#endif\n\n\toutb(MASTER_DECODE, iobase >> 2);\n\t/* One wait-state */\n\tpaswrite(1, WAIT_STATE);\n\n\tid = pasread(INTERRUPT_MASK);\n\tif (id == 0xff || id == 0xfe) {\n\t\t/* sanity */\n\t\tDPRINTF((\"pas: bogus card id\\n\"));\n\t\treturn 0;\n\t}\n\t/*\n\t * We probably have a PAS-series board, now check for a\n\t * PAS2-series board by trying to change the board revision\n\t * bits.  PAS2-series hardware won't let you do this because\n\t * the bits are read-only.\n\t */\n\tt = id ^ 0xe0;\n\tpaswrite(t, INTERRUPT_MASK);\n\tt = inb(INTERRUPT_MASK);\n\tpaswrite(id, INTERRUPT_MASK);\n\n\tif (t != id) {\n\t\t/* Not a PAS2 */\n\t\tDPRINTF((\"pas: detected card but PAS2 test failed\\n\"));\n\t\treturn 0;\n\t}\n\t/*XXX*/\n\tt = pasread(OPERATION_MODE_1) & 0xf;\n\tsc->model = O_M_1_to_card[t];\n\tif (sc->model != 0) {\n\t\tsc->rev = pasread(BOARD_REV_ID);\n\t}\n\telse {\n\t\tDPRINTF((\"pas: bogus model id\\n\"));\n\t\treturn 0;\n\t}\n\n        if (sc->model >= 0) {\n                if (ia->ia_irq == IRQUNK) {\n                        DPRINTF((\"pas: sb emulation requires known irq\\n\"));\n                        return (0);\n                } \n                pasconf(sc->model, ia->ia_iobase, ia->ia_irq, 1);\n        } else {\n                DPRINTF((\"pas: could not probe pas\\n\"));\n                return (0);\n        }\n\n\t/* Now a SoundBlaster, so set up proper bus-space hooks\n         * appropriately\n         */\n\n\tsc->sc_sbdsp.sc_iobase = ia->ia_iobase;\n\tsc->sc_sbdsp.sc_iot = ia->ia_iot;\n\n\t/* Map i/o space [we map 24 ports which is the max of the sb and pro */\n\tif (bus_space_map(sc->sc_sbdsp.sc_iot, ia->ia_iobase, SBP_NPORT, 0,\n\t    &sc->sc_sbdsp.sc_ioh)) {\n\t\tDPRINTF((\"pas: can't map i/o space 0x%x/%d in probe\\n\",\n\t\t    ia->ia_iobase, SBP_NPORT));\n\t\treturn 0;\n\t}\n\n\tif (sbdsp_reset(&sc->sc_sbdsp) < 0) {\n\t\tDPRINTF((\"pas: couldn't reset card\\n\"));\n\t\tgoto unmap;\n\t}\n\n\t/*\n\t * Cannot auto-discover DMA channel.\n\t */\n\tif (!SB_DRQ_VALID(ia->ia_drq)) {\n\t\tDPRINTF((\"pas: configured dma chan %d invalid\\n\", ia->ia_drq));\n\t\tgoto unmap;\n\t}\n\tif (!SB_IRQ_VALID(ia->ia_irq)) {\n\t\tDPRINTF((\"pas: configured irq chan %d invalid\\n\", ia->ia_irq));\n\t\tgoto unmap;\n\t}\n\n\tsc->sc_sbdsp.sc_irq = ia->ia_irq;\n\tsc->sc_sbdsp.sc_drq8 = ia->ia_drq;\n\tsc->sc_sbdsp.sc_drq16 = -1; /* XXX */\n\t\n\tif (sbdsp_probe(&sc->sc_sbdsp) == 0) {\n\t\tDPRINTF((\"pas: sbdsp probe failed\\n\"));\n\t\tgoto unmap;\n\t}\n\n\tia->ia_iosize = SB_NPORT;\n\treturn 1;\n\n unmap:\n\tbus_space_unmap(sc->sc_sbdsp.sc_iot, sc->sc_sbdsp.sc_ioh, SBP_NPORT);\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/pasreg.h>",
      "#include <dev/isa/sbreg.h>",
      "#include <dev/isa/sbdspvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpasconf",
      "int\tpasprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_sbdsp.sc_iot",
            "sc->sc_sbdsp.sc_ioh",
            "SBP_NPORT"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: sbdsp probe failed\\n\")"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbdsp_probe",
          "args": [
            "&sc->sc_sbdsp"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "sbdsp_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/sbdsp.c",
          "lines": "230-250",
          "snippet": "int\nsbdsp_probe(sc)\n\tstruct sbdsp_softc *sc;\n{\n\n\tif (sbdsp_reset(sc) < 0) {\n\t\tDPRINTF((\"sbdsp: couldn't reset card\\n\"));\n\t\treturn 0;\n\t}\n\t/* if flags set, go and probe the jazz16 stuff */\n\tif (sc->sc_dev.dv_cfdata->cf_flags & 1)\n\t\tsbdsp_jazz16_probe(sc);\n\telse\n\t\tsbversion(sc);\n\tif (sc->sc_model == SB_UNK) {\n\t\t/* Unknown SB model found. */\n\t\tDPRINTF((\"sbdsp: unknown SB model found\\n\"));\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsbversion",
            "void\tsbdsp_jazz16_probe",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/sbdspvar.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid\tsbversion;\nvoid\tsbdsp_jazz16_probe;\nint flags;\n\nint\nsbdsp_probe(sc)\n\tstruct sbdsp_softc *sc;\n{\n\n\tif (sbdsp_reset(sc) < 0) {\n\t\tDPRINTF((\"sbdsp: couldn't reset card\\n\"));\n\t\treturn 0;\n\t}\n\t/* if flags set, go and probe the jazz16 stuff */\n\tif (sc->sc_dev.dv_cfdata->cf_flags & 1)\n\t\tsbdsp_jazz16_probe(sc);\n\telse\n\t\tsbversion(sc);\n\tif (sc->sc_model == SB_UNK) {\n\t\t/* Unknown SB model found. */\n\t\tDPRINTF((\"sbdsp: unknown SB model found\\n\"));\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: configured irq chan %d invalid\\n\", ia->ia_irq)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_IRQ_VALID",
          "args": [
            "ia->ia_irq"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: configured dma chan %d invalid\\n\", ia->ia_drq)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DRQ_VALID",
          "args": [
            "ia->ia_drq"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: couldn't reset card\\n\")"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbdsp_reset",
          "args": [
            "&sc->sc_sbdsp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "sbdsp_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/sbdsp.c",
          "lines": "918-949",
          "snippet": "int\nsbdsp_reset(sc)\n\tstruct sbdsp_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_intr8 = 0;\n\tsc->sc_intr16 = 0;\n\tif (sc->sc_i.run != SB_NOTRUNNING) {\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_i.dmachan);\n\t\tsc->sc_i.run = SB_NOTRUNNING;\n\t}\n\tif (sc->sc_o.run != SB_NOTRUNNING) {\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_o.dmachan);\n\t\tsc->sc_o.run = SB_NOTRUNNING;\n\t}\n\n\t/*\n\t * See SBK, section 11.3.\n\t * We pulse a reset signal into the card.\n\t * Gee, what a brilliant hardware design.\n\t */\n\tbus_space_write_1(iot, ioh, SBP_DSP_RESET, 1);\n\tdelay(10);\n\tbus_space_write_1(iot, ioh, SBP_DSP_RESET, 0);\n\tdelay(30);\n\tif (sbdsp_rdsp(sc) != SB_MAGIC)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/sbdspvar.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nint\nsbdsp_reset(sc)\n\tstruct sbdsp_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tsc->sc_intr8 = 0;\n\tsc->sc_intr16 = 0;\n\tif (sc->sc_i.run != SB_NOTRUNNING) {\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_i.dmachan);\n\t\tsc->sc_i.run = SB_NOTRUNNING;\n\t}\n\tif (sc->sc_o.run != SB_NOTRUNNING) {\n\t\tisa_dmaabort(sc->sc_isa, sc->sc_o.dmachan);\n\t\tsc->sc_o.run = SB_NOTRUNNING;\n\t}\n\n\t/*\n\t * See SBK, section 11.3.\n\t * We pulse a reset signal into the card.\n\t * Gee, what a brilliant hardware design.\n\t */\n\tbus_space_write_1(iot, ioh, SBP_DSP_RESET, 1);\n\tdelay(10);\n\tbus_space_write_1(iot, ioh, SBP_DSP_RESET, 0);\n\tdelay(30);\n\tif (sbdsp_rdsp(sc) != SB_MAGIC)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: can't map i/o space 0x%x/%d in probe\\n\",\n\t\t    ia->ia_iobase, SBP_NPORT)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_sbdsp.sc_iot",
            "ia->ia_iobase",
            "SBP_NPORT",
            "0",
            "&sc->sc_sbdsp.sc_ioh"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: could not probe pas\\n\")"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pasconf",
          "args": [
            "sc->model",
            "ia->ia_iobase",
            "ia->ia_irq",
            "1"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "pasconf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pas.c",
          "lines": "163-241",
          "snippet": "void\npasconf(model, sbbase, sbirq, sbdrq)\n\tint model;\n\tint sbbase;\n\tint sbirq;\n\tint sbdrq;\n{\n\tpaswrite(0x00, INTERRUPT_MASK);\n\t/* Local timer control register */\n\tpaswrite(0x36, SAMPLE_COUNTER_CONTROL);\n\t/* Sample rate timer (16 bit) */\n\tpaswrite(0x36, SAMPLE_RATE_TIMER);\n\tpaswrite(0, SAMPLE_RATE_TIMER);\n\t/* Local timer control register */\n\tpaswrite(0x74, SAMPLE_COUNTER_CONTROL);\n\t/* Sample count register (16 bit) */\n\tpaswrite(0x74, SAMPLE_BUFFER_COUNTER);\n\tpaswrite(0, SAMPLE_BUFFER_COUNTER);\n\n\tpaswrite(P_C_PCM_MONO | P_C_PCM_DAC_MODE |\n\t\t  P_C_MIXER_CROSS_L_TO_L | P_C_MIXER_CROSS_R_TO_R,\n\t\t  PCM_CONTROL);\n\tpaswrite(S_M_PCM_RESET | S_M_FM_RESET |\n\t\t  S_M_SB_RESET | S_M_MIXER_RESET, SERIAL_MIXER);\n\n/*XXX*/\n\tpaswrite(I_C_1_BOOT_RESET_ENABLE|1, IO_CONFIGURATION_1);\n\n\tpaswrite(I_C_2_PCM_DMA_DISABLED, IO_CONFIGURATION_2);\n\tpaswrite(I_C_3_PCM_IRQ_DISABLED, IO_CONFIGURATION_3);\n\t\n#ifdef BROKEN_BUS_CLOCK \n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND |\n\t\t  S_C_1_FM_EMULATE_CLOCK, SYSTEM_CONFIGURATION_1);\n#else\n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND,\n\t\t  SYSTEM_CONFIGURATION_1);     \n#endif\n\n\t/*XXX*/\n\tpaswrite(0, SYSTEM_CONFIGURATION_2);\n\tpaswrite(0, SYSTEM_CONFIGURATION_3);\n\n\t/* Sets mute off and selects filter rate of 17.897 kHz */\n\tpaswrite(F_F_MIXER_UNMUTE | 0x01, FILTER_FREQUENCY);\n\n\tif (model == PAS_16 || model == PAS_16BASIC)\n\t\tpaswrite(8, PRESCALE_DIVIDER);\n\telse\n\t\tpaswrite(0, PRESCALE_DIVIDER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_PCM, PARALLEL_MIXER);\n\tpaswrite(5, PARALLEL_MIXER);\n\t\t\n\t/*\n\t * Setup SoundBlaster emulation.\n\t */\n\tpaswrite((sbbase >> 4) & 0xf, EMULATION_ADDRESS);\n\tpaswrite(E_C_SB_IRQ_translate[sbirq] | E_C_SB_DMA_translate[sbdrq],\n\t\t EMULATION_CONFIGURATION);\n\tpaswrite(C_E_SB_ENABLE, COMPATIBILITY_ENABLE);\n\n\t/*\n\t * Set mid-range levels.\n\t */\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MODE, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_LOUDNESS | P_M_MV508_ENHANCE_NONE, PARALLEL_MIXER);\t\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_A, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_B, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_SB, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_OUTPUTMIX | 30, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_MIC, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_INPUTMIX | 30, PARALLEL_MIXER);\n}",
          "includes": [
            "#include <dev/isa/pasreg.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpasconf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/pasreg.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/sbdspvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpasconf;\n\nvoid\npasconf(model, sbbase, sbirq, sbdrq)\n\tint model;\n\tint sbbase;\n\tint sbirq;\n\tint sbdrq;\n{\n\tpaswrite(0x00, INTERRUPT_MASK);\n\t/* Local timer control register */\n\tpaswrite(0x36, SAMPLE_COUNTER_CONTROL);\n\t/* Sample rate timer (16 bit) */\n\tpaswrite(0x36, SAMPLE_RATE_TIMER);\n\tpaswrite(0, SAMPLE_RATE_TIMER);\n\t/* Local timer control register */\n\tpaswrite(0x74, SAMPLE_COUNTER_CONTROL);\n\t/* Sample count register (16 bit) */\n\tpaswrite(0x74, SAMPLE_BUFFER_COUNTER);\n\tpaswrite(0, SAMPLE_BUFFER_COUNTER);\n\n\tpaswrite(P_C_PCM_MONO | P_C_PCM_DAC_MODE |\n\t\t  P_C_MIXER_CROSS_L_TO_L | P_C_MIXER_CROSS_R_TO_R,\n\t\t  PCM_CONTROL);\n\tpaswrite(S_M_PCM_RESET | S_M_FM_RESET |\n\t\t  S_M_SB_RESET | S_M_MIXER_RESET, SERIAL_MIXER);\n\n/*XXX*/\n\tpaswrite(I_C_1_BOOT_RESET_ENABLE|1, IO_CONFIGURATION_1);\n\n\tpaswrite(I_C_2_PCM_DMA_DISABLED, IO_CONFIGURATION_2);\n\tpaswrite(I_C_3_PCM_IRQ_DISABLED, IO_CONFIGURATION_3);\n\t\n#ifdef BROKEN_BUS_CLOCK \n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND |\n\t\t  S_C_1_FM_EMULATE_CLOCK, SYSTEM_CONFIGURATION_1);\n#else\n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND,\n\t\t  SYSTEM_CONFIGURATION_1);     \n#endif\n\n\t/*XXX*/\n\tpaswrite(0, SYSTEM_CONFIGURATION_2);\n\tpaswrite(0, SYSTEM_CONFIGURATION_3);\n\n\t/* Sets mute off and selects filter rate of 17.897 kHz */\n\tpaswrite(F_F_MIXER_UNMUTE | 0x01, FILTER_FREQUENCY);\n\n\tif (model == PAS_16 || model == PAS_16BASIC)\n\t\tpaswrite(8, PRESCALE_DIVIDER);\n\telse\n\t\tpaswrite(0, PRESCALE_DIVIDER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_PCM, PARALLEL_MIXER);\n\tpaswrite(5, PARALLEL_MIXER);\n\t\t\n\t/*\n\t * Setup SoundBlaster emulation.\n\t */\n\tpaswrite((sbbase >> 4) & 0xf, EMULATION_ADDRESS);\n\tpaswrite(E_C_SB_IRQ_translate[sbirq] | E_C_SB_DMA_translate[sbdrq],\n\t\t EMULATION_CONFIGURATION);\n\tpaswrite(C_E_SB_ENABLE, COMPATIBILITY_ENABLE);\n\n\t/*\n\t * Set mid-range levels.\n\t */\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MODE, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_LOUDNESS | P_M_MV508_ENHANCE_NONE, PARALLEL_MIXER);\t\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_A, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_B, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_SB, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_OUTPUTMIX | 30, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_MIC, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_INPUTMIX | 30, PARALLEL_MIXER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: sb emulation requires known irq\\n\")"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: bogus model id\\n\")"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pasread",
          "args": [
            "BOARD_REV_ID"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pasread",
          "args": [
            "OPERATION_MODE_1"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: detected card but PAS2 test failed\\n\")"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "id",
            "INTERRUPT_MASK"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "INTERRUPT_MASK"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "t",
            "INTERRUPT_MASK"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: bogus card id\\n\")"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pasread",
          "args": [
            "INTERRUPT_MASK"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "1",
            "WAIT_STATE"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "MASTER_DECODE",
            "iobase >> 2"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: configured iobase %d invalid\\n\", iobase)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pas: configured SB iobase 0x%x invalid\\n\", ia->ia_iobase)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BASE_VALID",
          "args": [
            "ia->ia_iobase"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pasreg.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/sbdspvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpasconf;\nint\tpasprobe;\n\nint\npasprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pas_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tint iobase;\n\tu_char id, t;\n\n        /* ensure we can set this up as a sound blaster */\n       \tif (!SB_BASE_VALID(ia->ia_iobase)) {\n\t\tDPRINTF((\"pas: configured SB iobase 0x%x invalid\\n\", ia->ia_iobase));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * WARNING: Setting an option like W:1 or so that disables\n\t * warm boot reset of the card will screw up this detect code\n\t * something fierce.  Adding code to handle this means possibly\n\t * interfering with other cards on the bus if you have something\n\t * on base port 0x388.  SO be forewarned. \n\t */\n\t/* Talk to first board */\n\toutb(MASTER_DECODE, 0xbc);\n\t/* Set base address */\n\n#if 0\n\t/* XXX Need to setup pseudo device */\n\t/* XXX What are good io addrs ? */\n\tif (iobase != PAS_DEFAULT_BASE) {\n\t\tDPRINTF((\"pas: configured iobase %d invalid\\n\", iobase));\n\t\treturn 0;\n\t}\n#else\n\t/* Start out talking to native PAS */\n\tiobase = PAS_DEFAULT_BASE;\n#endif\n\n\toutb(MASTER_DECODE, iobase >> 2);\n\t/* One wait-state */\n\tpaswrite(1, WAIT_STATE);\n\n\tid = pasread(INTERRUPT_MASK);\n\tif (id == 0xff || id == 0xfe) {\n\t\t/* sanity */\n\t\tDPRINTF((\"pas: bogus card id\\n\"));\n\t\treturn 0;\n\t}\n\t/*\n\t * We probably have a PAS-series board, now check for a\n\t * PAS2-series board by trying to change the board revision\n\t * bits.  PAS2-series hardware won't let you do this because\n\t * the bits are read-only.\n\t */\n\tt = id ^ 0xe0;\n\tpaswrite(t, INTERRUPT_MASK);\n\tt = inb(INTERRUPT_MASK);\n\tpaswrite(id, INTERRUPT_MASK);\n\n\tif (t != id) {\n\t\t/* Not a PAS2 */\n\t\tDPRINTF((\"pas: detected card but PAS2 test failed\\n\"));\n\t\treturn 0;\n\t}\n\t/*XXX*/\n\tt = pasread(OPERATION_MODE_1) & 0xf;\n\tsc->model = O_M_1_to_card[t];\n\tif (sc->model != 0) {\n\t\tsc->rev = pasread(BOARD_REV_ID);\n\t}\n\telse {\n\t\tDPRINTF((\"pas: bogus model id\\n\"));\n\t\treturn 0;\n\t}\n\n        if (sc->model >= 0) {\n                if (ia->ia_irq == IRQUNK) {\n                        DPRINTF((\"pas: sb emulation requires known irq\\n\"));\n                        return (0);\n                } \n                pasconf(sc->model, ia->ia_iobase, ia->ia_irq, 1);\n        } else {\n                DPRINTF((\"pas: could not probe pas\\n\"));\n                return (0);\n        }\n\n\t/* Now a SoundBlaster, so set up proper bus-space hooks\n         * appropriately\n         */\n\n\tsc->sc_sbdsp.sc_iobase = ia->ia_iobase;\n\tsc->sc_sbdsp.sc_iot = ia->ia_iot;\n\n\t/* Map i/o space [we map 24 ports which is the max of the sb and pro */\n\tif (bus_space_map(sc->sc_sbdsp.sc_iot, ia->ia_iobase, SBP_NPORT, 0,\n\t    &sc->sc_sbdsp.sc_ioh)) {\n\t\tDPRINTF((\"pas: can't map i/o space 0x%x/%d in probe\\n\",\n\t\t    ia->ia_iobase, SBP_NPORT));\n\t\treturn 0;\n\t}\n\n\tif (sbdsp_reset(&sc->sc_sbdsp) < 0) {\n\t\tDPRINTF((\"pas: couldn't reset card\\n\"));\n\t\tgoto unmap;\n\t}\n\n\t/*\n\t * Cannot auto-discover DMA channel.\n\t */\n\tif (!SB_DRQ_VALID(ia->ia_drq)) {\n\t\tDPRINTF((\"pas: configured dma chan %d invalid\\n\", ia->ia_drq));\n\t\tgoto unmap;\n\t}\n\tif (!SB_IRQ_VALID(ia->ia_irq)) {\n\t\tDPRINTF((\"pas: configured irq chan %d invalid\\n\", ia->ia_irq));\n\t\tgoto unmap;\n\t}\n\n\tsc->sc_sbdsp.sc_irq = ia->ia_irq;\n\tsc->sc_sbdsp.sc_drq8 = ia->ia_drq;\n\tsc->sc_sbdsp.sc_drq16 = -1; /* XXX */\n\t\n\tif (sbdsp_probe(&sc->sc_sbdsp) == 0) {\n\t\tDPRINTF((\"pas: sbdsp probe failed\\n\"));\n\t\tgoto unmap;\n\t}\n\n\tia->ia_iosize = SB_NPORT;\n\treturn 1;\n\n unmap:\n\tbus_space_unmap(sc->sc_sbdsp.sc_iot, sc->sc_sbdsp.sc_ioh, SBP_NPORT);\n\treturn 0;\n}"
  },
  {
    "function_name": "pasconf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pas.c",
    "lines": "163-241",
    "snippet": "void\npasconf(model, sbbase, sbirq, sbdrq)\n\tint model;\n\tint sbbase;\n\tint sbirq;\n\tint sbdrq;\n{\n\tpaswrite(0x00, INTERRUPT_MASK);\n\t/* Local timer control register */\n\tpaswrite(0x36, SAMPLE_COUNTER_CONTROL);\n\t/* Sample rate timer (16 bit) */\n\tpaswrite(0x36, SAMPLE_RATE_TIMER);\n\tpaswrite(0, SAMPLE_RATE_TIMER);\n\t/* Local timer control register */\n\tpaswrite(0x74, SAMPLE_COUNTER_CONTROL);\n\t/* Sample count register (16 bit) */\n\tpaswrite(0x74, SAMPLE_BUFFER_COUNTER);\n\tpaswrite(0, SAMPLE_BUFFER_COUNTER);\n\n\tpaswrite(P_C_PCM_MONO | P_C_PCM_DAC_MODE |\n\t\t  P_C_MIXER_CROSS_L_TO_L | P_C_MIXER_CROSS_R_TO_R,\n\t\t  PCM_CONTROL);\n\tpaswrite(S_M_PCM_RESET | S_M_FM_RESET |\n\t\t  S_M_SB_RESET | S_M_MIXER_RESET, SERIAL_MIXER);\n\n/*XXX*/\n\tpaswrite(I_C_1_BOOT_RESET_ENABLE|1, IO_CONFIGURATION_1);\n\n\tpaswrite(I_C_2_PCM_DMA_DISABLED, IO_CONFIGURATION_2);\n\tpaswrite(I_C_3_PCM_IRQ_DISABLED, IO_CONFIGURATION_3);\n\t\n#ifdef BROKEN_BUS_CLOCK \n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND |\n\t\t  S_C_1_FM_EMULATE_CLOCK, SYSTEM_CONFIGURATION_1);\n#else\n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND,\n\t\t  SYSTEM_CONFIGURATION_1);     \n#endif\n\n\t/*XXX*/\n\tpaswrite(0, SYSTEM_CONFIGURATION_2);\n\tpaswrite(0, SYSTEM_CONFIGURATION_3);\n\n\t/* Sets mute off and selects filter rate of 17.897 kHz */\n\tpaswrite(F_F_MIXER_UNMUTE | 0x01, FILTER_FREQUENCY);\n\n\tif (model == PAS_16 || model == PAS_16BASIC)\n\t\tpaswrite(8, PRESCALE_DIVIDER);\n\telse\n\t\tpaswrite(0, PRESCALE_DIVIDER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_PCM, PARALLEL_MIXER);\n\tpaswrite(5, PARALLEL_MIXER);\n\t\t\n\t/*\n\t * Setup SoundBlaster emulation.\n\t */\n\tpaswrite((sbbase >> 4) & 0xf, EMULATION_ADDRESS);\n\tpaswrite(E_C_SB_IRQ_translate[sbirq] | E_C_SB_DMA_translate[sbdrq],\n\t\t EMULATION_CONFIGURATION);\n\tpaswrite(C_E_SB_ENABLE, COMPATIBILITY_ENABLE);\n\n\t/*\n\t * Set mid-range levels.\n\t */\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MODE, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_LOUDNESS | P_M_MV508_ENHANCE_NONE, PARALLEL_MIXER);\t\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_A, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_B, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_SB, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_OUTPUTMIX | 30, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_MIC, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_INPUTMIX | 30, PARALLEL_MIXER);\n}",
    "includes": [
      "#include <dev/isa/pasreg.h>",
      "#include <dev/isa/sbreg.h>",
      "#include <dev/isa/sbdspvar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/midi_if.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpasconf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_INPUTMIX | 30",
            "PARALLEL_MIXER"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_MIC",
            "PARALLEL_MIXER"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_OUTPUTMIX | 30",
            "PARALLEL_MIXER"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_SB",
            "PARALLEL_MIXER"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "50",
            "PARALLEL_MIXER"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_ADDRESS | P_M_MV508_MASTER_B",
            "PARALLEL_MIXER"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "50",
            "PARALLEL_MIXER"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_ADDRESS | P_M_MV508_MASTER_A",
            "PARALLEL_MIXER"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_LOUDNESS | P_M_MV508_ENHANCE_NONE",
            "PARALLEL_MIXER"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_ADDRESS | P_M_MV508_MODE",
            "PARALLEL_MIXER"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "C_E_SB_ENABLE",
            "COMPATIBILITY_ENABLE"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "E_C_SB_IRQ_translate[sbirq] | E_C_SB_DMA_translate[sbdrq]",
            "EMULATION_CONFIGURATION"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "(sbbase >> 4) & 0xf",
            "EMULATION_ADDRESS"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "5",
            "PARALLEL_MIXER"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_M_MV508_ADDRESS | P_M_MV508_PCM",
            "PARALLEL_MIXER"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0",
            "PRESCALE_DIVIDER"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "8",
            "PRESCALE_DIVIDER"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "F_F_MIXER_UNMUTE | 0x01",
            "FILTER_FREQUENCY"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0",
            "SYSTEM_CONFIGURATION_3"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0",
            "SYSTEM_CONFIGURATION_2"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND",
            "SYSTEM_CONFIGURATION_1"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND |\n\t\t  S_C_1_FM_EMULATE_CLOCK",
            "SYSTEM_CONFIGURATION_1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "I_C_3_PCM_IRQ_DISABLED",
            "IO_CONFIGURATION_3"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "I_C_2_PCM_DMA_DISABLED",
            "IO_CONFIGURATION_2"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "I_C_1_BOOT_RESET_ENABLE|1",
            "IO_CONFIGURATION_1"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "S_M_PCM_RESET | S_M_FM_RESET |\n\t\t  S_M_SB_RESET | S_M_MIXER_RESET",
            "SERIAL_MIXER"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "P_C_PCM_MONO | P_C_PCM_DAC_MODE |\n\t\t  P_C_MIXER_CROSS_L_TO_L | P_C_MIXER_CROSS_R_TO_R",
            "PCM_CONTROL"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0",
            "SAMPLE_BUFFER_COUNTER"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0x74",
            "SAMPLE_BUFFER_COUNTER"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0x74",
            "SAMPLE_COUNTER_CONTROL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0",
            "SAMPLE_RATE_TIMER"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0x36",
            "SAMPLE_RATE_TIMER"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0x36",
            "SAMPLE_COUNTER_CONTROL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paswrite",
          "args": [
            "0x00",
            "INTERRUPT_MASK"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/pasreg.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/sbdspvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpasconf;\n\nvoid\npasconf(model, sbbase, sbirq, sbdrq)\n\tint model;\n\tint sbbase;\n\tint sbirq;\n\tint sbdrq;\n{\n\tpaswrite(0x00, INTERRUPT_MASK);\n\t/* Local timer control register */\n\tpaswrite(0x36, SAMPLE_COUNTER_CONTROL);\n\t/* Sample rate timer (16 bit) */\n\tpaswrite(0x36, SAMPLE_RATE_TIMER);\n\tpaswrite(0, SAMPLE_RATE_TIMER);\n\t/* Local timer control register */\n\tpaswrite(0x74, SAMPLE_COUNTER_CONTROL);\n\t/* Sample count register (16 bit) */\n\tpaswrite(0x74, SAMPLE_BUFFER_COUNTER);\n\tpaswrite(0, SAMPLE_BUFFER_COUNTER);\n\n\tpaswrite(P_C_PCM_MONO | P_C_PCM_DAC_MODE |\n\t\t  P_C_MIXER_CROSS_L_TO_L | P_C_MIXER_CROSS_R_TO_R,\n\t\t  PCM_CONTROL);\n\tpaswrite(S_M_PCM_RESET | S_M_FM_RESET |\n\t\t  S_M_SB_RESET | S_M_MIXER_RESET, SERIAL_MIXER);\n\n/*XXX*/\n\tpaswrite(I_C_1_BOOT_RESET_ENABLE|1, IO_CONFIGURATION_1);\n\n\tpaswrite(I_C_2_PCM_DMA_DISABLED, IO_CONFIGURATION_2);\n\tpaswrite(I_C_3_PCM_IRQ_DISABLED, IO_CONFIGURATION_3);\n\t\n#ifdef BROKEN_BUS_CLOCK \n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND |\n\t\t  S_C_1_FM_EMULATE_CLOCK, SYSTEM_CONFIGURATION_1);\n#else\n\tpaswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND,\n\t\t  SYSTEM_CONFIGURATION_1);     \n#endif\n\n\t/*XXX*/\n\tpaswrite(0, SYSTEM_CONFIGURATION_2);\n\tpaswrite(0, SYSTEM_CONFIGURATION_3);\n\n\t/* Sets mute off and selects filter rate of 17.897 kHz */\n\tpaswrite(F_F_MIXER_UNMUTE | 0x01, FILTER_FREQUENCY);\n\n\tif (model == PAS_16 || model == PAS_16BASIC)\n\t\tpaswrite(8, PRESCALE_DIVIDER);\n\telse\n\t\tpaswrite(0, PRESCALE_DIVIDER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_PCM, PARALLEL_MIXER);\n\tpaswrite(5, PARALLEL_MIXER);\n\t\t\n\t/*\n\t * Setup SoundBlaster emulation.\n\t */\n\tpaswrite((sbbase >> 4) & 0xf, EMULATION_ADDRESS);\n\tpaswrite(E_C_SB_IRQ_translate[sbirq] | E_C_SB_DMA_translate[sbdrq],\n\t\t EMULATION_CONFIGURATION);\n\tpaswrite(C_E_SB_ENABLE, COMPATIBILITY_ENABLE);\n\n\t/*\n\t * Set mid-range levels.\n\t */\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MODE, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_LOUDNESS | P_M_MV508_ENHANCE_NONE, PARALLEL_MIXER);\t\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_A, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_B, PARALLEL_MIXER);\n\tpaswrite(50, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_SB, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_OUTPUTMIX | 30, PARALLEL_MIXER);\n\n\tpaswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_MIC, PARALLEL_MIXER);\n\tpaswrite(P_M_MV508_INPUTMIX | 30, PARALLEL_MIXER);\n}"
  }
]