[
  {
    "function_name": "rf_ASMCheckStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "842-908",
    "snippet": "void \nrf_ASMCheckStatus(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * pda_p,\n    RF_AccessStripeMap_t * asm_p,\n    RF_RaidDisk_t ** disks,\n    int parity)\n{\n\tRF_DiskStatus_t dstatus;\n\tRF_RowCol_t frow, fcol;\n\n\tdstatus = disks[pda_p->row][pda_p->col].status;\n\n\tif (dstatus == rf_ds_spared) {\n\t\t/* if the disk has been spared, redirect access to the spare */\n\t\tfrow = pda_p->row;\n\t\tfcol = pda_p->col;\n\t\tpda_p->row = disks[frow][fcol].spareRow;\n\t\tpda_p->col = disks[frow][fcol].spareCol;\n\t} else\n\t\tif (dstatus == rf_ds_dist_spared) {\n\t\t\t/* ditto if disk has been spared to dist spare space */\n\t\t\tRF_RowCol_t or = pda_p->row, oc = pda_p->col;\n\t\t\tRF_SectorNum_t oo = pda_p->startSector;\n\n\t\t\tif (pda_p->type == RF_PDA_TYPE_DATA)\n\t\t\t\traidPtr->Layout.map->MapSector(raidPtr, pda_p->raidAddress, &pda_p->row, &pda_p->col, &pda_p->startSector, RF_REMAP);\n\t\t\telse\n\t\t\t\traidPtr->Layout.map->MapParity(raidPtr, pda_p->raidAddress, &pda_p->row, &pda_p->col, &pda_p->startSector, RF_REMAP);\n\n\t\t\tif (rf_mapDebug) {\n\t\t\t\tprintf(\"Redirected r %d c %d o %d -> r%d c %d o %d\\n\", or, oc, (int) oo,\n\t\t\t\t    pda_p->row, pda_p->col, (int) pda_p->startSector);\n\t\t\t}\n\t\t} else\n\t\t\tif (RF_DEAD_DISK(dstatus)) {\n\t\t\t\t/* if the disk is inaccessible, mark the\n\t\t\t\t * failure */\n\t\t\t\tif (parity)\n\t\t\t\t\tasm_p->numParityFailed++;\n\t\t\t\telse {\n\t\t\t\t\tasm_p->numDataFailed++;\n#if 0\n\t\t\t\t\t/* XXX Do we really want this spewing\n\t\t\t\t\t * out on the console? GO */\n\t\t\t\t\tprintf(\"DATA_FAILED!\\n\");\n#endif\n\t\t\t\t}\n\t\t\t\tasm_p->failedPDAs[asm_p->numFailedPDAs] = pda_p;\n\t\t\t\tasm_p->numFailedPDAs++;\n#if 0\n\t\t\t\tswitch (asm_p->numParityFailed + asm_p->numDataFailed) {\n\t\t\t\tcase 1:\n\t\t\t\t\tasm_p->failedPDAs[0] = pda_p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tasm_p->failedPDAs[1] = pda_p;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t/* the redirected access should never span a stripe unit boundary */\n\tRF_ASSERT(rf_RaidAddressToStripeUnitID(&raidPtr->Layout, pda_p->raidAddress) ==\n\t    rf_RaidAddressToStripeUnitID(&raidPtr->Layout, pda_p->raidAddress + pda_p->numSector - 1));\n\tRF_ASSERT(pda_p->col != -1);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
      "RF_RaidAddr_t raidAddress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pda_p->col != -1"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "rf_RaidAddressToStripeUnitID(&raidPtr->Layout, pda_p->raidAddress) ==\n\t    rf_RaidAddressToStripeUnitID(&raidPtr->Layout, pda_p->raidAddress + pda_p->numSector - 1)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&raidPtr->Layout",
            "pda_p->raidAddress + pda_p->numSector - 1"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&raidPtr->Layout",
            "pda_p->raidAddress"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DATA_FAILED!\\n\""
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "dstatus"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidPtr->Layout.map->MapParity",
          "args": [
            "raidPtr",
            "pda_p->raidAddress",
            "&pda_p->row",
            "&pda_p->col",
            "&pda_p->startSector",
            "RF_REMAP"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidPtr->Layout.map->MapSector",
          "args": [
            "raidPtr",
            "pda_p->raidAddress",
            "&pda_p->row",
            "&pda_p->col",
            "&pda_p->startSector",
            "RF_REMAP"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\n\nvoid \nrf_ASMCheckStatus(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * pda_p,\n    RF_AccessStripeMap_t * asm_p,\n    RF_RaidDisk_t ** disks,\n    int parity)\n{\n\tRF_DiskStatus_t dstatus;\n\tRF_RowCol_t frow, fcol;\n\n\tdstatus = disks[pda_p->row][pda_p->col].status;\n\n\tif (dstatus == rf_ds_spared) {\n\t\t/* if the disk has been spared, redirect access to the spare */\n\t\tfrow = pda_p->row;\n\t\tfcol = pda_p->col;\n\t\tpda_p->row = disks[frow][fcol].spareRow;\n\t\tpda_p->col = disks[frow][fcol].spareCol;\n\t} else\n\t\tif (dstatus == rf_ds_dist_spared) {\n\t\t\t/* ditto if disk has been spared to dist spare space */\n\t\t\tRF_RowCol_t or = pda_p->row, oc = pda_p->col;\n\t\t\tRF_SectorNum_t oo = pda_p->startSector;\n\n\t\t\tif (pda_p->type == RF_PDA_TYPE_DATA)\n\t\t\t\traidPtr->Layout.map->MapSector(raidPtr, pda_p->raidAddress, &pda_p->row, &pda_p->col, &pda_p->startSector, RF_REMAP);\n\t\t\telse\n\t\t\t\traidPtr->Layout.map->MapParity(raidPtr, pda_p->raidAddress, &pda_p->row, &pda_p->col, &pda_p->startSector, RF_REMAP);\n\n\t\t\tif (rf_mapDebug) {\n\t\t\t\tprintf(\"Redirected r %d c %d o %d -> r%d c %d o %d\\n\", or, oc, (int) oo,\n\t\t\t\t    pda_p->row, pda_p->col, (int) pda_p->startSector);\n\t\t\t}\n\t\t} else\n\t\t\tif (RF_DEAD_DISK(dstatus)) {\n\t\t\t\t/* if the disk is inaccessible, mark the\n\t\t\t\t * failure */\n\t\t\t\tif (parity)\n\t\t\t\t\tasm_p->numParityFailed++;\n\t\t\t\telse {\n\t\t\t\t\tasm_p->numDataFailed++;\n#if 0\n\t\t\t\t\t/* XXX Do we really want this spewing\n\t\t\t\t\t * out on the console? GO */\n\t\t\t\t\tprintf(\"DATA_FAILED!\\n\");\n#endif\n\t\t\t\t}\n\t\t\t\tasm_p->failedPDAs[asm_p->numFailedPDAs] = pda_p;\n\t\t\t\tasm_p->numFailedPDAs++;\n#if 0\n\t\t\t\tswitch (asm_p->numParityFailed + asm_p->numDataFailed) {\n\t\t\t\tcase 1:\n\t\t\t\t\tasm_p->failedPDAs[0] = pda_p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tasm_p->failedPDAs[1] = pda_p;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t/* the redirected access should never span a stripe unit boundary */\n\tRF_ASSERT(rf_RaidAddressToStripeUnitID(&raidPtr->Layout, pda_p->raidAddress) ==\n\t    rf_RaidAddressToStripeUnitID(&raidPtr->Layout, pda_p->raidAddress + pda_p->numSector - 1));\n\tRF_ASSERT(pda_p->col != -1);\n}"
  },
  {
    "function_name": "rf_ASMParityAdjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "783-835",
    "snippet": "void \nrf_ASMParityAdjust(\n    RF_PhysDiskAddr_t * toAdjust,\n    RF_StripeNum_t startAddrWithinStripe,\n    RF_SectorNum_t endAddress,\n    RF_RaidLayout_t * layoutPtr,\n    RF_AccessStripeMap_t * asm_p)\n{\n\tRF_PhysDiskAddr_t *new_pda;\n\n\t/* when we're accessing only a portion of one stripe unit, we want the\n\t * parity descriptor to identify only the chunk of parity associated\n\t * with the data.  When the access spans exactly one stripe unit\n\t * boundary and is less than a stripe unit in size, it uses two\n\t * disjoint regions of the parity unit.  When an access spans more\n\t * than one stripe unit boundary, it uses all of the parity unit.\n\t * \n\t * To better handle the case where stripe units are small, we may\n\t * eventually want to change the 2nd case so that if the SU size is\n\t * below some threshold, we just read/write the whole thing instead of\n\t * breaking it up into two accesses. */\n\tif (asm_p->numStripeUnitsAccessed == 1) {\n\t\tint     x = (startAddrWithinStripe % layoutPtr->sectorsPerStripeUnit);\n\t\ttoAdjust->startSector += x;\n\t\ttoAdjust->raidAddress += x;\n\t\ttoAdjust->numSector = asm_p->physInfo->numSector;\n\t\tRF_ASSERT(toAdjust->numSector != 0);\n\t} else\n\t\tif (asm_p->numStripeUnitsAccessed == 2 && asm_p->totalSectorsAccessed < layoutPtr->sectorsPerStripeUnit) {\n\t\t\tint     x = (startAddrWithinStripe % layoutPtr->sectorsPerStripeUnit);\n\n\t\t\t/* create a second pda and copy the parity map info\n\t\t\t * into it */\n\t\t\tRF_ASSERT(toAdjust->next == NULL);\n\t\t\tnew_pda = toAdjust->next = rf_AllocPhysDiskAddr();\n\t\t\t*new_pda = *toAdjust;\t/* structure assignment */\n\t\t\tnew_pda->next = NULL;\n\n\t\t\t/* adjust the start sector & number of blocks for the\n\t\t\t * first parity pda */\n\t\t\ttoAdjust->startSector += x;\n\t\t\ttoAdjust->raidAddress += x;\n\t\t\ttoAdjust->numSector = rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, startAddrWithinStripe) - startAddrWithinStripe;\n\t\t\tRF_ASSERT(toAdjust->numSector != 0);\n\n\t\t\t/* adjust the second pda */\n\t\t\tnew_pda->numSector = endAddress - rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, endAddress);\n\t\t\t/* new_pda->raidAddress =\n\t\t\t * rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr,\n\t\t\t * toAdjust->raidAddress); */\n\t\t\tRF_ASSERT(new_pda->numSector != 0);\n\t\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_RaidAddr_t raidAddress;",
      "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "new_pda->numSector != 0"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "endAddress"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "toAdjust->numSector != 0"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfNextStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "startAddrWithinStripe"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocPhysDiskAddr",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocPhysDiskAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "456-465",
          "snippet": "RF_PhysDiskAddr_t *\nrf_AllocPhysDiskAddr()\n{\n\tRF_PhysDiskAddr_t *p;\n\n\tRF_FREELIST_GET(rf_pda_freelist, p, next, (RF_PhysDiskAddr_t *));\n\tbzero((char *) p, sizeof(RF_PhysDiskAddr_t));\n\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_pda_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_pda_freelist;\n\nRF_PhysDiskAddr_t *\nrf_AllocPhysDiskAddr()\n{\n\tRF_PhysDiskAddr_t *p;\n\n\tRF_FREELIST_GET(rf_pda_freelist, p, next, (RF_PhysDiskAddr_t *));\n\tbzero((char *) p, sizeof(RF_PhysDiskAddr_t));\n\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "toAdjust->next == NULL"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "toAdjust->numSector != 0"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_RaidAddr_t raidAddress;\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\n\nvoid \nrf_ASMParityAdjust(\n    RF_PhysDiskAddr_t * toAdjust,\n    RF_StripeNum_t startAddrWithinStripe,\n    RF_SectorNum_t endAddress,\n    RF_RaidLayout_t * layoutPtr,\n    RF_AccessStripeMap_t * asm_p)\n{\n\tRF_PhysDiskAddr_t *new_pda;\n\n\t/* when we're accessing only a portion of one stripe unit, we want the\n\t * parity descriptor to identify only the chunk of parity associated\n\t * with the data.  When the access spans exactly one stripe unit\n\t * boundary and is less than a stripe unit in size, it uses two\n\t * disjoint regions of the parity unit.  When an access spans more\n\t * than one stripe unit boundary, it uses all of the parity unit.\n\t * \n\t * To better handle the case where stripe units are small, we may\n\t * eventually want to change the 2nd case so that if the SU size is\n\t * below some threshold, we just read/write the whole thing instead of\n\t * breaking it up into two accesses. */\n\tif (asm_p->numStripeUnitsAccessed == 1) {\n\t\tint     x = (startAddrWithinStripe % layoutPtr->sectorsPerStripeUnit);\n\t\ttoAdjust->startSector += x;\n\t\ttoAdjust->raidAddress += x;\n\t\ttoAdjust->numSector = asm_p->physInfo->numSector;\n\t\tRF_ASSERT(toAdjust->numSector != 0);\n\t} else\n\t\tif (asm_p->numStripeUnitsAccessed == 2 && asm_p->totalSectorsAccessed < layoutPtr->sectorsPerStripeUnit) {\n\t\t\tint     x = (startAddrWithinStripe % layoutPtr->sectorsPerStripeUnit);\n\n\t\t\t/* create a second pda and copy the parity map info\n\t\t\t * into it */\n\t\t\tRF_ASSERT(toAdjust->next == NULL);\n\t\t\tnew_pda = toAdjust->next = rf_AllocPhysDiskAddr();\n\t\t\t*new_pda = *toAdjust;\t/* structure assignment */\n\t\t\tnew_pda->next = NULL;\n\n\t\t\t/* adjust the start sector & number of blocks for the\n\t\t\t * first parity pda */\n\t\t\ttoAdjust->startSector += x;\n\t\t\ttoAdjust->raidAddress += x;\n\t\t\ttoAdjust->numSector = rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, startAddrWithinStripe) - startAddrWithinStripe;\n\t\t\tRF_ASSERT(toAdjust->numSector != 0);\n\n\t\t\t/* adjust the second pda */\n\t\t\tnew_pda->numSector = endAddress - rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, endAddress);\n\t\t\t/* new_pda->raidAddress =\n\t\t\t * rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr,\n\t\t\t * toAdjust->raidAddress); */\n\t\t\tRF_ASSERT(new_pda->numSector != 0);\n\t\t}\n}"
  },
  {
    "function_name": "rf_PrintRaidAddressInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "761-778",
    "snippet": "void \nrf_PrintRaidAddressInfo(raidPtr, raidAddr, numBlocks)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_SectorCount_t numBlocks;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RaidAddr_t ra, sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);\n\n\tprintf(\"Raid addrs of SU boundaries from start of stripe to end of access:\\n\\t\");\n\tfor (ra = sosAddr; ra <= raidAddr + numBlocks; ra += layoutPtr->sectorsPerStripeUnit) {\n\t\tprintf(\"%d (0x%x), \", (int) ra, (int) ra);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"Offset into stripe unit: %d (0x%x)\\n\",\n\t    (int) (raidAddr % layoutPtr->sectorsPerStripeUnit),\n\t    (int) (raidAddr % layoutPtr->sectorsPerStripeUnit));\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
      "RF_SectorCount_t numBlocks;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Offset into stripe unit: %d (0x%x)\\n\"",
            "(int) (raidAddr % layoutPtr->sectorsPerStripeUnit)",
            "(int) (raidAddr % layoutPtr->sectorsPerStripeUnit)"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "raidAddr"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_SectorCount_t numBlocks;\n\nvoid \nrf_PrintRaidAddressInfo(raidPtr, raidAddr, numBlocks)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_SectorCount_t numBlocks;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RaidAddr_t ra, sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);\n\n\tprintf(\"Raid addrs of SU boundaries from start of stripe to end of access:\\n\\t\");\n\tfor (ra = sosAddr; ra <= raidAddr + numBlocks; ra += layoutPtr->sectorsPerStripeUnit) {\n\t\tprintf(\"%d (0x%x), \", (int) ra, (int) ra);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"Offset into stripe unit: %d (0x%x)\\n\",\n\t    (int) (raidAddr % layoutPtr->sectorsPerStripeUnit),\n\t    (int) (raidAddr % layoutPtr->sectorsPerStripeUnit));\n}"
  },
  {
    "function_name": "rf_PrintFullAccessStripeMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "705-759",
    "snippet": "void \nrf_PrintFullAccessStripeMap(asm_h, prbuf)\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint     prbuf;\t\t/* flag to print buffer pointers */\n{\n\tint     i;\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_PhysDiskAddr_t *p;\n\tprintf(\"%d stripes total\\n\", (int) asm_h->numStripes);\n\tfor (; asmap; asmap = asmap->next) {\n\t\t/* printf(\"Num failures: %d\\n\",asmap->numDataFailed); */\n\t\t/* printf(\"Num sectors:\n\t\t * %d\\n\",(int)asmap->totalSectorsAccessed); */\n\t\tprintf(\"Stripe %d (%d sectors), failures: %d data, %d parity: \",\n\t\t    (int) asmap->stripeID,\n\t\t    (int) asmap->totalSectorsAccessed,\n\t\t    (int) asmap->numDataFailed,\n\t\t    (int) asmap->numParityFailed);\n\t\tif (asmap->parityInfo) {\n\t\t\tprintf(\"Parity [r%d c%d s%d-%d\", asmap->parityInfo->row, asmap->parityInfo->col,\n\t\t\t    (int) asmap->parityInfo->startSector,\n\t\t\t    (int) (asmap->parityInfo->startSector +\n\t\t\t\tasmap->parityInfo->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->bufPtr);\n\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\tprintf(\", r%d c%d s%d-%d\", asmap->parityInfo->next->row,\n\t\t\t\t    asmap->parityInfo->next->col,\n\t\t\t\t    (int) asmap->parityInfo->next->startSector,\n\t\t\t\t    (int) (asmap->parityInfo->next->startSector +\n\t\t\t\t\tasmap->parityInfo->next->numSector - 1));\n\t\t\t\tif (prbuf)\n\t\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->next->bufPtr);\n\t\t\t\tRF_ASSERT(asmap->parityInfo->next->next == NULL);\n\t\t\t}\n\t\t\tprintf(\"]\\n\\t\");\n\t\t}\n\t\tfor (i = 0, p = asmap->physInfo; p; p = p->next, i++) {\n\t\t\tprintf(\"SU r%d c%d s%d-%d \", p->row, p->col, (int) p->startSector,\n\t\t\t    (int) (p->startSector + p->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\"b0x%lx \", (unsigned long) p->bufPtr);\n\t\t\tif (i && !(i & 1))\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tp = asm_h->stripeMap->failedPDAs[0];\n\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 1)\n\t\t\tprintf(\"[multiple failures]\\n\");\n\t\telse\n\t\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 0)\n\t\t\t\tprintf(\"\\t[Failed PDA: r%d c%d s%d-%d]\\n\", p->row, p->col,\n\t\t\t\t    (int) p->startSector, (int) (p->startSector + p->numSector - 1));\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "caddr_t buffer;",
      "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\t[Failed PDA: r%d c%d s%d-%d]\\n\"",
            "p->row",
            "p->col",
            "(int) p->startSector",
            "(int) (p->startSector + p->numSector - 1)"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->parityInfo->next->next == NULL"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\ncaddr_t buffer;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nvoid \nrf_PrintFullAccessStripeMap(asm_h, prbuf)\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint     prbuf;\t\t/* flag to print buffer pointers */\n{\n\tint     i;\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_PhysDiskAddr_t *p;\n\tprintf(\"%d stripes total\\n\", (int) asm_h->numStripes);\n\tfor (; asmap; asmap = asmap->next) {\n\t\t/* printf(\"Num failures: %d\\n\",asmap->numDataFailed); */\n\t\t/* printf(\"Num sectors:\n\t\t * %d\\n\",(int)asmap->totalSectorsAccessed); */\n\t\tprintf(\"Stripe %d (%d sectors), failures: %d data, %d parity: \",\n\t\t    (int) asmap->stripeID,\n\t\t    (int) asmap->totalSectorsAccessed,\n\t\t    (int) asmap->numDataFailed,\n\t\t    (int) asmap->numParityFailed);\n\t\tif (asmap->parityInfo) {\n\t\t\tprintf(\"Parity [r%d c%d s%d-%d\", asmap->parityInfo->row, asmap->parityInfo->col,\n\t\t\t    (int) asmap->parityInfo->startSector,\n\t\t\t    (int) (asmap->parityInfo->startSector +\n\t\t\t\tasmap->parityInfo->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->bufPtr);\n\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\tprintf(\", r%d c%d s%d-%d\", asmap->parityInfo->next->row,\n\t\t\t\t    asmap->parityInfo->next->col,\n\t\t\t\t    (int) asmap->parityInfo->next->startSector,\n\t\t\t\t    (int) (asmap->parityInfo->next->startSector +\n\t\t\t\t\tasmap->parityInfo->next->numSector - 1));\n\t\t\t\tif (prbuf)\n\t\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->next->bufPtr);\n\t\t\t\tRF_ASSERT(asmap->parityInfo->next->next == NULL);\n\t\t\t}\n\t\t\tprintf(\"]\\n\\t\");\n\t\t}\n\t\tfor (i = 0, p = asmap->physInfo; p; p = p->next, i++) {\n\t\t\tprintf(\"SU r%d c%d s%d-%d \", p->row, p->col, (int) p->startSector,\n\t\t\t    (int) (p->startSector + p->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\"b0x%lx \", (unsigned long) p->bufPtr);\n\t\t\tif (i && !(i & 1))\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tp = asm_h->stripeMap->failedPDAs[0];\n\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 1)\n\t\t\tprintf(\"[multiple failures]\\n\");\n\t\telse\n\t\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 0)\n\t\t\t\tprintf(\"\\t[Failed PDA: r%d c%d s%d-%d]\\n\", p->row, p->col,\n\t\t\t\t    (int) p->startSector, (int) (p->startSector + p->numSector - 1));\n\t}\n}"
  },
  {
    "function_name": "rf_PrintAccessStripeMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "698-703",
    "snippet": "void \nrf_PrintAccessStripeMap(asm_h)\n\tRF_AccessStripeMapHeader_t *asm_h;\n{\n\trf_PrintFullAccessStripeMap(asm_h, 0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_PrintFullAccessStripeMap",
          "args": [
            "asm_h",
            "0"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintFullAccessStripeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "705-759",
          "snippet": "void \nrf_PrintFullAccessStripeMap(asm_h, prbuf)\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint     prbuf;\t\t/* flag to print buffer pointers */\n{\n\tint     i;\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_PhysDiskAddr_t *p;\n\tprintf(\"%d stripes total\\n\", (int) asm_h->numStripes);\n\tfor (; asmap; asmap = asmap->next) {\n\t\t/* printf(\"Num failures: %d\\n\",asmap->numDataFailed); */\n\t\t/* printf(\"Num sectors:\n\t\t * %d\\n\",(int)asmap->totalSectorsAccessed); */\n\t\tprintf(\"Stripe %d (%d sectors), failures: %d data, %d parity: \",\n\t\t    (int) asmap->stripeID,\n\t\t    (int) asmap->totalSectorsAccessed,\n\t\t    (int) asmap->numDataFailed,\n\t\t    (int) asmap->numParityFailed);\n\t\tif (asmap->parityInfo) {\n\t\t\tprintf(\"Parity [r%d c%d s%d-%d\", asmap->parityInfo->row, asmap->parityInfo->col,\n\t\t\t    (int) asmap->parityInfo->startSector,\n\t\t\t    (int) (asmap->parityInfo->startSector +\n\t\t\t\tasmap->parityInfo->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->bufPtr);\n\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\tprintf(\", r%d c%d s%d-%d\", asmap->parityInfo->next->row,\n\t\t\t\t    asmap->parityInfo->next->col,\n\t\t\t\t    (int) asmap->parityInfo->next->startSector,\n\t\t\t\t    (int) (asmap->parityInfo->next->startSector +\n\t\t\t\t\tasmap->parityInfo->next->numSector - 1));\n\t\t\t\tif (prbuf)\n\t\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->next->bufPtr);\n\t\t\t\tRF_ASSERT(asmap->parityInfo->next->next == NULL);\n\t\t\t}\n\t\t\tprintf(\"]\\n\\t\");\n\t\t}\n\t\tfor (i = 0, p = asmap->physInfo; p; p = p->next, i++) {\n\t\t\tprintf(\"SU r%d c%d s%d-%d \", p->row, p->col, (int) p->startSector,\n\t\t\t    (int) (p->startSector + p->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\"b0x%lx \", (unsigned long) p->bufPtr);\n\t\t\tif (i && !(i & 1))\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tp = asm_h->stripeMap->failedPDAs[0];\n\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 1)\n\t\t\tprintf(\"[multiple failures]\\n\");\n\t\telse\n\t\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 0)\n\t\t\t\tprintf(\"\\t[Failed PDA: r%d c%d s%d-%d]\\n\", p->row, p->col,\n\t\t\t\t    (int) p->startSector, (int) (p->startSector + p->numSector - 1));\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "caddr_t buffer;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\ncaddr_t buffer;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nvoid \nrf_PrintFullAccessStripeMap(asm_h, prbuf)\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tint     prbuf;\t\t/* flag to print buffer pointers */\n{\n\tint     i;\n\tRF_AccessStripeMap_t *asmap = asm_h->stripeMap;\n\tRF_PhysDiskAddr_t *p;\n\tprintf(\"%d stripes total\\n\", (int) asm_h->numStripes);\n\tfor (; asmap; asmap = asmap->next) {\n\t\t/* printf(\"Num failures: %d\\n\",asmap->numDataFailed); */\n\t\t/* printf(\"Num sectors:\n\t\t * %d\\n\",(int)asmap->totalSectorsAccessed); */\n\t\tprintf(\"Stripe %d (%d sectors), failures: %d data, %d parity: \",\n\t\t    (int) asmap->stripeID,\n\t\t    (int) asmap->totalSectorsAccessed,\n\t\t    (int) asmap->numDataFailed,\n\t\t    (int) asmap->numParityFailed);\n\t\tif (asmap->parityInfo) {\n\t\t\tprintf(\"Parity [r%d c%d s%d-%d\", asmap->parityInfo->row, asmap->parityInfo->col,\n\t\t\t    (int) asmap->parityInfo->startSector,\n\t\t\t    (int) (asmap->parityInfo->startSector +\n\t\t\t\tasmap->parityInfo->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->bufPtr);\n\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\tprintf(\", r%d c%d s%d-%d\", asmap->parityInfo->next->row,\n\t\t\t\t    asmap->parityInfo->next->col,\n\t\t\t\t    (int) asmap->parityInfo->next->startSector,\n\t\t\t\t    (int) (asmap->parityInfo->next->startSector +\n\t\t\t\t\tasmap->parityInfo->next->numSector - 1));\n\t\t\t\tif (prbuf)\n\t\t\t\t\tprintf(\" b0x%lx\", (unsigned long) asmap->parityInfo->next->bufPtr);\n\t\t\t\tRF_ASSERT(asmap->parityInfo->next->next == NULL);\n\t\t\t}\n\t\t\tprintf(\"]\\n\\t\");\n\t\t}\n\t\tfor (i = 0, p = asmap->physInfo; p; p = p->next, i++) {\n\t\t\tprintf(\"SU r%d c%d s%d-%d \", p->row, p->col, (int) p->startSector,\n\t\t\t    (int) (p->startSector + p->numSector - 1));\n\t\t\tif (prbuf)\n\t\t\t\tprintf(\"b0x%lx \", (unsigned long) p->bufPtr);\n\t\t\tif (i && !(i & 1))\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tp = asm_h->stripeMap->failedPDAs[0];\n\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 1)\n\t\t\tprintf(\"[multiple failures]\\n\");\n\t\telse\n\t\t\tif (asm_h->stripeMap->numDataFailed + asm_h->stripeMap->numParityFailed > 0)\n\t\t\t\tprintf(\"\\t[Failed PDA: r%d c%d s%d-%d]\\n\", p->row, p->col,\n\t\t\t\t    (int) p->startSector, (int) (p->startSector + p->numSector - 1));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_PrintAccessStripeMap(asm_h)\n\tRF_AccessStripeMapHeader_t *asm_h;\n{\n\trf_PrintFullAccessStripeMap(asm_h, 0);\n}"
  },
  {
    "function_name": "rf_NumFailedDataUnitsInStripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "660-689",
    "snippet": "int \nrf_NumFailedDataUnitsInStripe(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t trow, tcol, row, i;\n\tRF_SectorNum_t diskOffset;\n\tRF_RaidAddr_t sosAddr;\n\tint     numFailures;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\tnumFailures = 0;\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\tfor (i = 0; i < layoutPtr->numDataCol; i++) {\n\t\t(layoutPtr->map->MapSector) (raidPtr, sosAddr + i * layoutPtr->sectorsPerStripeUnit,\n\t\t    &trow, &tcol, &diskOffset, 0);\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[trow][tcol].status))\n\t\t\tnumFailures++;\n\t}\n\n\treturn numFailures;\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
      "RF_RaidAddr_t raidAddress;",
      "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[trow][tcol].status"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "sosAddr + i * layoutPtr->sectorsPerStripeUnit",
            "&trow",
            "&tcol",
            "&diskOffset",
            "0"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_NumFailedDataUnitsInStripe(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t trow, tcol, row, i;\n\tRF_SectorNum_t diskOffset;\n\tRF_RaidAddr_t sosAddr;\n\tint     numFailures;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\tnumFailures = 0;\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\tfor (i = 0; i < layoutPtr->numDataCol; i++) {\n\t\t(layoutPtr->map->MapSector) (raidPtr, sosAddr + i * layoutPtr->sectorsPerStripeUnit,\n\t\t    &trow, &tcol, &diskOffset, 0);\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[trow][tcol].status))\n\t\t\tnumFailures++;\n\t}\n\n\treturn numFailures;\n}"
  },
  {
    "function_name": "rf_CheckStripeForFailures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "608-655",
    "snippet": "int \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
      "RF_RaidAddr_t raidAddress;",
      "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CheckRUReconstructed",
          "args": [
            "raidPtr->reconControl[testrow]->reconMap",
            "diskOffset"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckRUReconstructed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "308-319",
          "snippet": "int \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\n\nint \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(trow == testrow) && (tcol == diskids[i])"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutPtr->map->MapSector",
          "args": [
            "raidPtr",
            "sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit",
            "&trow",
            "&tcol",
            "&diskOffset",
            "0"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->reconControl[testrow]->fcol == diskids[i]"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[testrow][diskids[i]].status"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "asmap->raidAddress",
            "&prow",
            "&pcol",
            "&poffset",
            "0"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "asmap->raidAddress",
            "&diskids",
            "&testrow"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_FreeAccessStripeMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "537-598",
    "snippet": "void \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
      "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
      "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;",
      "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
      "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeAccessStripeMapHeader",
          "args": [
            "hdr"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAccessStripeMapHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "449-454",
          "snippet": "void \nrf_FreeAccessStripeMapHeader(p)\n\tRF_AccessStripeMapHeader_t *p;\n{\n\tRF_FREELIST_FREE(rf_asmhdr_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_asmhdr_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_asmhdr_freelist;\n\nvoid \nrf_FreeAccessStripeMapHeader(p)\n\tRF_AccessStripeMapHeader_t *p;\n{\n\tRF_FREELIST_FREE(rf_asmhdr_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeASMList",
          "args": [
            "hdr->stripeMap",
            "pt",
            "asm_count"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeASMList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "529-535",
          "snippet": "static void \nrf_FreeASMList(l_start, l_end, count)\n\tRF_AccessStripeMap_t *l_start, *l_end;\n\tint     count;\n{\n\tRF_FREELIST_FREE_N(rf_asm_freelist, l_start, next, (RF_AccessStripeMap_t *), count);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
            "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
            "static RF_FreeList_t *rf_asm_freelist;",
            "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
            "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nstatic RF_FreeList_t *rf_asm_freelist;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nstatic void \nrf_FreeASMList(l_start, l_end, count)\n\tRF_AccessStripeMap_t *l_start, *l_end;\n\tint     count;\n{\n\tRF_FREELIST_FREE_N(rf_asm_freelist, l_start, next, (RF_AccessStripeMap_t *), count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreePDAList",
          "args": [
            "pdaList",
            "pdaEnd",
            "count"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreePDAList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "488-495",
          "snippet": "static void \nrf_FreePDAList(l_start, l_end, count)\n\tRF_PhysDiskAddr_t *l_start, *l_end;\t/* pointers to start and end\n\t\t\t\t\t\t * of list */\n\tint     count;\t\t/* number of elements in list */\n{\n\tRF_FREELIST_FREE_N(rf_pda_freelist, l_start, next, (RF_PhysDiskAddr_t *), count);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
            "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
            "static RF_FreeList_t *rf_pda_freelist;",
            "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
            "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nstatic RF_FreeList_t *rf_pda_freelist;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nstatic void \nrf_FreePDAList(l_start, l_end, count)\n\tRF_PhysDiskAddr_t *l_start, *l_end;\t/* pointers to start and end\n\t\t\t\t\t\t * of list */\n\tint     count;\t\t/* number of elements in list */\n{\n\tRF_FREELIST_FREE_N(rf_pda_freelist, l_start, next, (RF_PhysDiskAddr_t *), count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "t == count"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nvoid \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}"
  },
  {
    "function_name": "rf_FreeASMList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "529-535",
    "snippet": "static void \nrf_FreeASMList(l_start, l_end, count)\n\tRF_AccessStripeMap_t *l_start, *l_end;\n\tint     count;\n{\n\tRF_FREELIST_FREE_N(rf_asm_freelist, l_start, next, (RF_AccessStripeMap_t *), count);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
      "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
      "static RF_FreeList_t *rf_asm_freelist;",
      "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
      "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE_N",
          "args": [
            "rf_asm_freelist",
            "l_start",
            "next",
            "(RF_AccessStripeMap_t *), count"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nstatic RF_FreeList_t *rf_asm_freelist;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nstatic void \nrf_FreeASMList(l_start, l_end, count)\n\tRF_AccessStripeMap_t *l_start, *l_end;\n\tint     count;\n{\n\tRF_FREELIST_FREE_N(rf_asm_freelist, l_start, next, (RF_AccessStripeMap_t *), count);\n}"
  },
  {
    "function_name": "rf_FreeAccessStripeMapComponent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "522-527",
    "snippet": "void \nrf_FreeAccessStripeMapComponent(p)\n\tRF_AccessStripeMap_t *p;\n{\n\tRF_FREELIST_FREE(rf_asm_freelist, p, next);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_asm_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE",
          "args": [
            "rf_asm_freelist",
            "p",
            "next"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_asm_freelist;\n\nvoid \nrf_FreeAccessStripeMapComponent(p)\n\tRF_AccessStripeMap_t *p;\n{\n\tRF_FREELIST_FREE(rf_asm_freelist, p, next);\n}"
  },
  {
    "function_name": "rf_AllocAccessStripeMapComponent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "497-506",
    "snippet": "RF_AccessStripeMap_t *\nrf_AllocAccessStripeMapComponent()\n{\n\tRF_AccessStripeMap_t *p;\n\n\tRF_FREELIST_GET(rf_asm_freelist, p, next, (RF_AccessStripeMap_t *));\n\tbzero((char *) p, sizeof(RF_AccessStripeMap_t));\n\n\treturn (p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_asm_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) p",
            "sizeof(RF_AccessStripeMap_t)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_GET",
          "args": [
            "rf_asm_freelist",
            "p",
            "next",
            "(RF_AccessStripeMap_t *)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_asm_freelist;\n\nRF_AccessStripeMap_t *\nrf_AllocAccessStripeMapComponent()\n{\n\tRF_AccessStripeMap_t *p;\n\n\tRF_FREELIST_GET(rf_asm_freelist, p, next, (RF_AccessStripeMap_t *));\n\tbzero((char *) p, sizeof(RF_AccessStripeMap_t));\n\n\treturn (p);\n}"
  },
  {
    "function_name": "rf_FreePDAList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "488-495",
    "snippet": "static void \nrf_FreePDAList(l_start, l_end, count)\n\tRF_PhysDiskAddr_t *l_start, *l_end;\t/* pointers to start and end\n\t\t\t\t\t\t * of list */\n\tint     count;\t\t/* number of elements in list */\n{\n\tRF_FREELIST_FREE_N(rf_pda_freelist, l_start, next, (RF_PhysDiskAddr_t *), count);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
      "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
      "static RF_FreeList_t *rf_pda_freelist;",
      "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
      "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE_N",
          "args": [
            "rf_pda_freelist",
            "l_start",
            "next",
            "(RF_PhysDiskAddr_t *), count"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nstatic RF_FreeList_t *rf_pda_freelist;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nstatic void \nrf_FreePDAList(l_start, l_end, count)\n\tRF_PhysDiskAddr_t *l_start, *l_end;\t/* pointers to start and end\n\t\t\t\t\t\t * of list */\n\tint     count;\t\t/* number of elements in list */\n{\n\tRF_FREELIST_FREE_N(rf_pda_freelist, l_start, next, (RF_PhysDiskAddr_t *), count);\n}"
  },
  {
    "function_name": "rf_FreePhysDiskAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "481-486",
    "snippet": "void \nrf_FreePhysDiskAddr(p)\n\tRF_PhysDiskAddr_t *p;\n{\n\tRF_FREELIST_FREE(rf_pda_freelist, p, next);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_pda_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE",
          "args": [
            "rf_pda_freelist",
            "p",
            "next"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_pda_freelist;\n\nvoid \nrf_FreePhysDiskAddr(p)\n\tRF_PhysDiskAddr_t *p;\n{\n\tRF_FREELIST_FREE(rf_pda_freelist, p, next);\n}"
  },
  {
    "function_name": "rf_AllocPhysDiskAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "456-465",
    "snippet": "RF_PhysDiskAddr_t *\nrf_AllocPhysDiskAddr()\n{\n\tRF_PhysDiskAddr_t *p;\n\n\tRF_FREELIST_GET(rf_pda_freelist, p, next, (RF_PhysDiskAddr_t *));\n\tbzero((char *) p, sizeof(RF_PhysDiskAddr_t));\n\n\treturn (p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_pda_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) p",
            "sizeof(RF_PhysDiskAddr_t)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_GET",
          "args": [
            "rf_pda_freelist",
            "p",
            "next",
            "(RF_PhysDiskAddr_t *)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_pda_freelist;\n\nRF_PhysDiskAddr_t *\nrf_AllocPhysDiskAddr()\n{\n\tRF_PhysDiskAddr_t *p;\n\n\tRF_FREELIST_GET(rf_pda_freelist, p, next, (RF_PhysDiskAddr_t *));\n\tbzero((char *) p, sizeof(RF_PhysDiskAddr_t));\n\n\treturn (p);\n}"
  },
  {
    "function_name": "rf_FreeAccessStripeMapHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "449-454",
    "snippet": "void \nrf_FreeAccessStripeMapHeader(p)\n\tRF_AccessStripeMapHeader_t *p;\n{\n\tRF_FREELIST_FREE(rf_asmhdr_freelist, p, next);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_asmhdr_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE",
          "args": [
            "rf_asmhdr_freelist",
            "p",
            "next"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_asmhdr_freelist;\n\nvoid \nrf_FreeAccessStripeMapHeader(p)\n\tRF_AccessStripeMapHeader_t *p;\n{\n\tRF_FREELIST_FREE(rf_asmhdr_freelist, p, next);\n}"
  },
  {
    "function_name": "rf_AllocAccessStripeMapHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "437-446",
    "snippet": "RF_AccessStripeMapHeader_t *\nrf_AllocAccessStripeMapHeader()\n{\n\tRF_AccessStripeMapHeader_t *p;\n\n\tRF_FREELIST_GET(rf_asmhdr_freelist, p, next, (RF_AccessStripeMapHeader_t *));\n\tbzero((char *) p, sizeof(RF_AccessStripeMapHeader_t));\n\n\treturn (p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_asmhdr_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) p",
            "sizeof(RF_AccessStripeMapHeader_t)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_GET",
          "args": [
            "rf_asmhdr_freelist",
            "p",
            "next",
            "(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_asmhdr_freelist;\n\nRF_AccessStripeMapHeader_t *\nrf_AllocAccessStripeMapHeader()\n{\n\tRF_AccessStripeMapHeader_t *p;\n\n\tRF_FREELIST_GET(rf_asmhdr_freelist, p, next, (RF_AccessStripeMapHeader_t *));\n\tbzero((char *) p, sizeof(RF_AccessStripeMapHeader_t));\n\n\treturn (p);\n}"
  },
  {
    "function_name": "rf_ConfigureMapModule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "396-435",
    "snippet": "int \nrf_ConfigureMapModule(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_asmhdr_freelist, RF_MAX_FREE_ASMHDR,\n\t    RF_ASMHDR_INC, sizeof(RF_AccessStripeMapHeader_t));\n\tif (rf_asmhdr_freelist == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tRF_FREELIST_CREATE(rf_asm_freelist, RF_MAX_FREE_ASM,\n\t    RF_ASM_INC, sizeof(RF_AccessStripeMap_t));\n\tif (rf_asm_freelist == NULL) {\n\t\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\t\treturn (ENOMEM);\n\t}\n\tRF_FREELIST_CREATE(rf_pda_freelist, RF_MAX_FREE_PDA,\n\t    RF_PDA_INC, sizeof(RF_PhysDiskAddr_t));\n\tif (rf_pda_freelist == NULL) {\n\t\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\t\tRF_FREELIST_DESTROY(rf_pda_freelist, next, (RF_PhysDiskAddr_t *));\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownMapModule, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownMapModule(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME(rf_asmhdr_freelist, RF_ASMHDR_INITIAL, next,\n\t    (RF_AccessStripeMapHeader_t *));\n\tRF_FREELIST_PRIME(rf_asm_freelist, RF_ASM_INITIAL, next,\n\t    (RF_AccessStripeMap_t *));\n\tRF_FREELIST_PRIME(rf_pda_freelist, RF_PDA_INITIAL, next,\n\t    (RF_PhysDiskAddr_t *));\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define RF_PDA_INITIAL   64",
      "#define RF_PDA_INC       24",
      "#define RF_MAX_FREE_PDA 192",
      "#define RF_ASM_INITIAL   64",
      "#define RF_ASM_INC       24",
      "#define RF_MAX_FREE_ASM 192",
      "#define RF_ASMHDR_INITIAL   32",
      "#define RF_ASMHDR_INC       16",
      "#define RF_MAX_FREE_ASMHDR 128"
    ],
    "globals_used": [
      "static RF_FreeList_t *rf_asmhdr_freelist;",
      "static RF_FreeList_t *rf_asm_freelist;",
      "static RF_FreeList_t *rf_pda_freelist;",
      "static void rf_ShutdownMapModule(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME",
          "args": [
            "rf_pda_freelist",
            "RF_PDA_INITIAL",
            "next",
            "(RF_PhysDiskAddr_t *)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME",
          "args": [
            "rf_asm_freelist",
            "RF_ASM_INITIAL",
            "next",
            "(RF_AccessStripeMap_t *)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME",
          "args": [
            "rf_asmhdr_freelist",
            "RF_ASMHDR_INITIAL",
            "next",
            "(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownMapModule",
          "args": [
            "NULL"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownMapModule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "387-394",
          "snippet": "static void \nrf_ShutdownMapModule(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\tRF_FREELIST_DESTROY(rf_pda_freelist, next, (RF_PhysDiskAddr_t *));\n\tRF_FREELIST_DESTROY(rf_asm_freelist, next, (RF_AccessStripeMap_t *));\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_asmhdr_freelist;",
            "static RF_FreeList_t *rf_asm_freelist;",
            "static RF_FreeList_t *rf_pda_freelist;",
            "static void rf_ShutdownMapModule(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_asmhdr_freelist;\nstatic RF_FreeList_t *rf_asm_freelist;\nstatic RF_FreeList_t *rf_pda_freelist;\nstatic void rf_ShutdownMapModule(void *);\n\nstatic void \nrf_ShutdownMapModule(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\tRF_FREELIST_DESTROY(rf_pda_freelist, next, (RF_PhysDiskAddr_t *));\n\tRF_FREELIST_DESTROY(rf_asm_freelist, next, (RF_AccessStripeMap_t *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownMapModule",
            "NULL"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_pda_freelist",
            "next",
            "(RF_PhysDiskAddr_t *)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_asmhdr_freelist",
            "next",
            "(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_pda_freelist",
            "RF_MAX_FREE_PDA",
            "RF_PDA_INC",
            "sizeof(RF_PhysDiskAddr_t)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_asmhdr_freelist",
            "next",
            "(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_asm_freelist",
            "RF_MAX_FREE_ASM",
            "RF_ASM_INC",
            "sizeof(RF_AccessStripeMap_t)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_asmhdr_freelist",
            "RF_MAX_FREE_ASMHDR",
            "RF_ASMHDR_INC",
            "sizeof(RF_AccessStripeMapHeader_t)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define RF_PDA_INITIAL   64\n#define RF_PDA_INC       24\n#define RF_MAX_FREE_PDA 192\n#define RF_ASM_INITIAL   64\n#define RF_ASM_INC       24\n#define RF_MAX_FREE_ASM 192\n#define RF_ASMHDR_INITIAL   32\n#define RF_ASMHDR_INC       16\n#define RF_MAX_FREE_ASMHDR 128\n\nstatic RF_FreeList_t *rf_asmhdr_freelist;\nstatic RF_FreeList_t *rf_asm_freelist;\nstatic RF_FreeList_t *rf_pda_freelist;\nstatic void rf_ShutdownMapModule(void *);\n\nint \nrf_ConfigureMapModule(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_asmhdr_freelist, RF_MAX_FREE_ASMHDR,\n\t    RF_ASMHDR_INC, sizeof(RF_AccessStripeMapHeader_t));\n\tif (rf_asmhdr_freelist == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tRF_FREELIST_CREATE(rf_asm_freelist, RF_MAX_FREE_ASM,\n\t    RF_ASM_INC, sizeof(RF_AccessStripeMap_t));\n\tif (rf_asm_freelist == NULL) {\n\t\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\t\treturn (ENOMEM);\n\t}\n\tRF_FREELIST_CREATE(rf_pda_freelist, RF_MAX_FREE_PDA,\n\t    RF_PDA_INC, sizeof(RF_PhysDiskAddr_t));\n\tif (rf_pda_freelist == NULL) {\n\t\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\t\tRF_FREELIST_DESTROY(rf_pda_freelist, next, (RF_PhysDiskAddr_t *));\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownMapModule, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownMapModule(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME(rf_asmhdr_freelist, RF_ASMHDR_INITIAL, next,\n\t    (RF_AccessStripeMapHeader_t *));\n\tRF_FREELIST_PRIME(rf_asm_freelist, RF_ASM_INITIAL, next,\n\t    (RF_AccessStripeMap_t *));\n\tRF_FREELIST_PRIME(rf_pda_freelist, RF_PDA_INITIAL, next,\n\t    (RF_PhysDiskAddr_t *));\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownMapModule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "387-394",
    "snippet": "static void \nrf_ShutdownMapModule(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\tRF_FREELIST_DESTROY(rf_pda_freelist, next, (RF_PhysDiskAddr_t *));\n\tRF_FREELIST_DESTROY(rf_asm_freelist, next, (RF_AccessStripeMap_t *));\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_asmhdr_freelist;",
      "static RF_FreeList_t *rf_asm_freelist;",
      "static RF_FreeList_t *rf_pda_freelist;",
      "static void rf_ShutdownMapModule(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_asm_freelist",
            "next",
            "(RF_AccessStripeMap_t *)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_pda_freelist",
            "next",
            "(RF_PhysDiskAddr_t *)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_asmhdr_freelist",
            "next",
            "(RF_AccessStripeMapHeader_t *)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_asmhdr_freelist;\nstatic RF_FreeList_t *rf_asm_freelist;\nstatic RF_FreeList_t *rf_pda_freelist;\nstatic void rf_ShutdownMapModule(void *);\n\nstatic void \nrf_ShutdownMapModule(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_asmhdr_freelist, next, (RF_AccessStripeMapHeader_t *));\n\tRF_FREELIST_DESTROY(rf_pda_freelist, next, (RF_PhysDiskAddr_t *));\n\tRF_FREELIST_DESTROY(rf_asm_freelist, next, (RF_AccessStripeMap_t *));\n}"
  },
  {
    "function_name": "rf_MarkFailuresInASMList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
    "lines": "256-291",
    "snippet": "void \nrf_MarkFailuresInASMList(raidPtr, asm_h)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMapHeader_t *asm_h;\n{\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_PhysDiskAddr_t *pda;\n\n\tfor (asmap = asm_h->stripeMap; asmap; asmap = asmap->next) {\n\t\tasmap->numDataFailed = asmap->numParityFailed = asmap->numQFailed = 0;\n\t\tasmap->numFailedPDAs = 0;\n\t\tbzero((char *) asmap->failedPDAs,\n\t\t    RF_MAX_FAILED_PDA * sizeof(RF_PhysDiskAddr_t *));\n\t\tfor (pda = asmap->physInfo; pda; pda = pda->next) {\n\t\t\tif (RF_DEAD_DISK(disks[pda->row][pda->col].status)) {\n\t\t\t\tprintf(\"DEAD DISK BOGUSLY DETECTED!!\\n\");\n\t\t\t\tasmap->numDataFailed++;\n\t\t\t\tasmap->failedPDAs[asmap->numFailedPDAs] = pda;\n\t\t\t\tasmap->numFailedPDAs++;\n\t\t\t}\n\t\t}\n\t\tpda = asmap->parityInfo;\n\t\tif (pda && RF_DEAD_DISK(disks[pda->row][pda->col].status)) {\n\t\t\tasmap->numParityFailed++;\n\t\t\tasmap->failedPDAs[asmap->numFailedPDAs] = pda;\n\t\t\tasmap->numFailedPDAs++;\n\t\t}\n\t\tpda = asmap->qInfo;\n\t\tif (pda && RF_DEAD_DISK(disks[pda->row][pda->col].status)) {\n\t\t\tasmap->numQFailed++;\n\t\t\tasmap->failedPDAs[asmap->numFailedPDAs] = pda;\n\t\t\tasmap->numFailedPDAs++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
      "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;",
      "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "disks[pda->row][pda->col].status"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "disks[pda->row][pda->col].status"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DEAD DISK BOGUSLY DETECTED!!\\n\""
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "disks[pda->row][pda->col].status"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) asmap->failedPDAs",
            "RF_MAX_FAILED_PDA * sizeof(RF_PhysDiskAddr_t *)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\n\nvoid \nrf_MarkFailuresInASMList(raidPtr, asm_h)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMapHeader_t *asm_h;\n{\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_PhysDiskAddr_t *pda;\n\n\tfor (asmap = asm_h->stripeMap; asmap; asmap = asmap->next) {\n\t\tasmap->numDataFailed = asmap->numParityFailed = asmap->numQFailed = 0;\n\t\tasmap->numFailedPDAs = 0;\n\t\tbzero((char *) asmap->failedPDAs,\n\t\t    RF_MAX_FAILED_PDA * sizeof(RF_PhysDiskAddr_t *));\n\t\tfor (pda = asmap->physInfo; pda; pda = pda->next) {\n\t\t\tif (RF_DEAD_DISK(disks[pda->row][pda->col].status)) {\n\t\t\t\tprintf(\"DEAD DISK BOGUSLY DETECTED!!\\n\");\n\t\t\t\tasmap->numDataFailed++;\n\t\t\t\tasmap->failedPDAs[asmap->numFailedPDAs] = pda;\n\t\t\t\tasmap->numFailedPDAs++;\n\t\t\t}\n\t\t}\n\t\tpda = asmap->parityInfo;\n\t\tif (pda && RF_DEAD_DISK(disks[pda->row][pda->col].status)) {\n\t\t\tasmap->numParityFailed++;\n\t\t\tasmap->failedPDAs[asmap->numFailedPDAs] = pda;\n\t\t\tasmap->numFailedPDAs++;\n\t\t}\n\t\tpda = asmap->qInfo;\n\t\tif (pda && RF_DEAD_DISK(disks[pda->row][pda->col].status)) {\n\t\t\tasmap->numQFailed++;\n\t\t\tasmap->failedPDAs[asmap->numFailedPDAs] = pda;\n\t\t\tasmap->numFailedPDAs++;\n\t\t}\n\t}\n}"
  }
]