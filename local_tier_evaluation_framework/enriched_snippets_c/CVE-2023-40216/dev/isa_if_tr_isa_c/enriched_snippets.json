[
  {
    "function_name": "tr_isa_dumpaip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
    "lines": "241-255",
    "snippet": "void\ntr_isa_dumpaip(memt, mmioh)\n\tbus_space_tag_t memt;\n\tbus_space_handle_t mmioh;\n{\n\tunsigned int off, val;\n\tprintf(\"AIP contents:\");\n\tfor (off=0; off < 256; off++) {\n\t\tval = bus_space_read_1(memt, mmioh, TR_MAC_OFFSET + off);\n\t\tif ((off % 16) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%02x \", val);\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "mmioh",
            "TR_MAC_OFFSET + off"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ntr_isa_dumpaip(memt, mmioh)\n\tbus_space_tag_t memt;\n\tbus_space_handle_t mmioh;\n{\n\tunsigned int off, val;\n\tprintf(\"AIP contents:\");\n\tfor (off=0; off < 256; off++) {\n\t\tval = bus_space_read_1(memt, mmioh, TR_MAC_OFFSET + off);\n\t\tif ((off % 16) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%02x \", val);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "tr_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
    "lines": "185-235",
    "snippet": "void\ntr_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid\t*aux;\n{\n\tstruct tr_softc *sc = (void *) self;\n\tstruct isa_attach_args *ia = aux;\n\n\tsc->sc_piot = ia->ia_iot;\n\tsc->sc_memt = ia->ia_memt;\n\tif (tr_isa_map_io(ia, &sc->sc_pioh, &sc->sc_mmioh)) {\n\t\tprintf(\"tr_isa_attach: IO space vanished\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(sc->sc_memt, ia->ia_maddr, ia->ia_msize, 0,\n\t    &sc->sc_sramh)) {\n\t\tprintf(\"tr_isa_attach: shared ram space vanished\\n\");\n\t\treturn;\n\t}\n\t/* set ACA offset */\n\tsc->sc_aca = TR_ACA_OFFSET;\n\tsc->sc_memwinsz = ia->ia_msize;\n\tsc->sc_maddr = ia->ia_maddr;\n\t/*\n\t * Determine total RAM on adapter and decide how much to use.\n\t * XXX Since we don't use RAM paging, use sc_memwinsz for now.\n\t */\n\tsc->sc_memsize = sc->sc_memwinsz;\n\tsc->sc_memreserved = 0;\n\n\tif (tr_reset(sc) != 0)\n\t\treturn;\n\n\tif (ia->ia_aux != NULL) {\n\t\tsc->sc_mediastatus = trtcm_isa_mediastatus;\n\t\tsc->sc_mediachange = trtcm_isa_mediachange;\n\t}\n\telse {\n\t\tsc->sc_mediastatus = NULL;\n\t\tsc->sc_mediachange = NULL;\n\t}\n\n\tif (tr_attach(sc) != 0)\n\t\treturn;\n\n/*\n * XXX 3Com 619 can use LEVEL intr\n */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, tr_intr, sc, sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_isa_attach",
      "int\ttr_isa_map_io",
      "int\ttrtcm_isa_mediachange",
      "void\ttrtcm_isa_mediastatus",
      "int trtcm_setspeed(struct tr_softc *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "tr_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_attach",
          "args": [
            "sc"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "bktr_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6927-7073",
          "snippet": "static int\nbktr_attach( device_t dev )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tu_long\t\tval;\n\tunsigned int\trev;\n\tunsigned int\tunit;\n\tint\t\terror = 0;\n\tint\t\trid;\n#ifdef BROOKTREE_IRQ\n\tu_long\t\told_irq, new_irq;\n#endif \n\n        struct bktr_softc *bktr = device_get_softc(dev);\n\n\tunit = device_get_unit(dev);\n\n\t/*\n\t * Enable bus mastering and Memory Mapped device\n\t */\n\tval = pci_read_config(dev, PCIR_COMMAND, 4);\n\tval |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);\n\tpci_write_config(dev, PCIR_COMMAND, val, 4);\n\n\t/*\n\t * Map control/status registers.\n\t */\n\trid = PCI_MAP_REG_START;\n\tbktr->res_mem = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid,\n                                  0, ~0, 1, RF_ACTIVE);\n\n\tif (!bktr->res_mem) {\n\t\tdevice_printf(dev, \"could not map memory\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\tbktr->base = rman_get_virtual(bktr->res_mem); /* XXX use bus_space */\n\n\t/*\n\t * Disable the brooktree device\n\t */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\n#ifdef BROOKTREE_IRQ\t\t/* from the configuration file */\n\told_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tpci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);\n\tnew_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tprintf(\"bktr%d: attach: irq changed from %d to %d\\n\",\n\t\tunit, (old_irq & 0xff), (new_irq & 0xff));\n#endif \n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\trid = 0;\n\tbktr->res_irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid, 0, ~0, 1,\n                                 RF_SHAREABLE | RF_ACTIVE);\n\tif (bktr->res_irq == NULL) {\n\t\tdevice_printf(dev, \"could not map interrupt\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\n\terror = bus_setup_intr(dev, bktr->res_irq, INTR_TYPE_NET,\n                               bktr_intr, bktr, &bktr->res_ih);\n\tif (error) {\n\t\tdevice_printf(dev, \"could not setup irq\\n\");\n\t\tgoto fail;\n\n\t}\n\n\n\t/* Update the Device Control Register */\n\t/* on Bt878 and Bt879 cards           */\n\tfun = pci_read_config( dev, 0x40, 2);\n        fun = fun | 1;\t/* Enable writes to the sub-system vendor ID */\n\n#if defined( BKTR_430_FX_MODE )\n\tif (bootverbose) printf(\"Using 430 FX chipset compatibilty mode\\n\");\n        fun = fun | 2;\t/* Enable Intel 430 FX compatibility mode */\n#endif\n\n#if defined( BKTR_SIS_VIA_MODE )\n\tif (bootverbose) printf(\"Using SiS/VIA chipset compatibilty mode\\n\");\n        fun = fun | 4;\t/* Enable SiS/VIA compatibility mode (usefull for\n                           OPTi chipset motherboards too */\n#endif\n\tpci_write_config(dev, 0x40, fun, 2);\n\n\n\t/* XXX call bt848_i2c dependent attach() routine */\n#if (NSMBUS > 0)\n\tif (bt848_i2c_attach(unit, bktr->base, &bktr->i2c_sc))\n\t\tprintf(\"bktr%d: i2c_attach: can't attach\\n\", unit);\n#endif\n\n\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_read_config(dev, PCI_LATENCY_TIMER, 4);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_write_config(dev, PCI_LATENCY_TIMER, latency<<8, 4);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\t/* read the pci device id and revision id */\n\tfun = pci_get_devid(dev);\n        rev = pci_get_revid(dev);\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n\n#ifdef DEVFS\n\t/* XXX This just throw away the token, which should probably be fixed when\n\t   DEVFS is finally made really operational. */\n\tdevfs_add_devswf(&bktr_cdevsw, unit,    DV_CHR, 0, 0, 0444, \"bktr%d\",  unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+16, DV_CHR, 0, 0, 0444, \"tuner%d\", unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+32, DV_CHR, 0, 0, 0444, \"vbi%d\", unit);\n#endif /* DEVFS */\n\n\treturn 0;\n\nfail:\n\treturn error;\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
            "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
            "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
            "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
            "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0",
            "#define NSMBUS 0",
            "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))",
            "#define NSMBUS 0",
            "#define NSMBUS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define NSMBUS 0\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n#define NSMBUS 0\n#define NSMBUS 0\n\nstatic int\nbktr_attach( device_t dev )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tu_long\t\tval;\n\tunsigned int\trev;\n\tunsigned int\tunit;\n\tint\t\terror = 0;\n\tint\t\trid;\n#ifdef BROOKTREE_IRQ\n\tu_long\t\told_irq, new_irq;\n#endif \n\n        struct bktr_softc *bktr = device_get_softc(dev);\n\n\tunit = device_get_unit(dev);\n\n\t/*\n\t * Enable bus mastering and Memory Mapped device\n\t */\n\tval = pci_read_config(dev, PCIR_COMMAND, 4);\n\tval |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);\n\tpci_write_config(dev, PCIR_COMMAND, val, 4);\n\n\t/*\n\t * Map control/status registers.\n\t */\n\trid = PCI_MAP_REG_START;\n\tbktr->res_mem = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid,\n                                  0, ~0, 1, RF_ACTIVE);\n\n\tif (!bktr->res_mem) {\n\t\tdevice_printf(dev, \"could not map memory\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\tbktr->base = rman_get_virtual(bktr->res_mem); /* XXX use bus_space */\n\n\t/*\n\t * Disable the brooktree device\n\t */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\n#ifdef BROOKTREE_IRQ\t\t/* from the configuration file */\n\told_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tpci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);\n\tnew_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tprintf(\"bktr%d: attach: irq changed from %d to %d\\n\",\n\t\tunit, (old_irq & 0xff), (new_irq & 0xff));\n#endif \n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\trid = 0;\n\tbktr->res_irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid, 0, ~0, 1,\n                                 RF_SHAREABLE | RF_ACTIVE);\n\tif (bktr->res_irq == NULL) {\n\t\tdevice_printf(dev, \"could not map interrupt\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\n\terror = bus_setup_intr(dev, bktr->res_irq, INTR_TYPE_NET,\n                               bktr_intr, bktr, &bktr->res_ih);\n\tif (error) {\n\t\tdevice_printf(dev, \"could not setup irq\\n\");\n\t\tgoto fail;\n\n\t}\n\n\n\t/* Update the Device Control Register */\n\t/* on Bt878 and Bt879 cards           */\n\tfun = pci_read_config( dev, 0x40, 2);\n        fun = fun | 1;\t/* Enable writes to the sub-system vendor ID */\n\n#if defined( BKTR_430_FX_MODE )\n\tif (bootverbose) printf(\"Using 430 FX chipset compatibilty mode\\n\");\n        fun = fun | 2;\t/* Enable Intel 430 FX compatibility mode */\n#endif\n\n#if defined( BKTR_SIS_VIA_MODE )\n\tif (bootverbose) printf(\"Using SiS/VIA chipset compatibilty mode\\n\");\n        fun = fun | 4;\t/* Enable SiS/VIA compatibility mode (usefull for\n                           OPTi chipset motherboards too */\n#endif\n\tpci_write_config(dev, 0x40, fun, 2);\n\n\n\t/* XXX call bt848_i2c dependent attach() routine */\n#if (NSMBUS > 0)\n\tif (bt848_i2c_attach(unit, bktr->base, &bktr->i2c_sc))\n\t\tprintf(\"bktr%d: i2c_attach: can't attach\\n\", unit);\n#endif\n\n\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_read_config(dev, PCI_LATENCY_TIMER, 4);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_write_config(dev, PCI_LATENCY_TIMER, latency<<8, 4);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\t/* read the pci device id and revision id */\n\tfun = pci_get_devid(dev);\n        rev = pci_get_revid(dev);\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n\n#ifdef DEVFS\n\t/* XXX This just throw away the token, which should probably be fixed when\n\t   DEVFS is finally made really operational. */\n\tdevfs_add_devswf(&bktr_cdevsw, unit,    DV_CHR, 0, 0, 0444, \"bktr%d\",  unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+16, DV_CHR, 0, 0, 0444, \"tuner%d\", unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+32, DV_CHR, 0, 0, 0444, \"vbi%d\", unit);\n#endif /* DEVFS */\n\n\treturn 0;\n\nfail:\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_reset",
          "args": [
            "sc"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "tr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "504-565",
          "snippet": "int\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tr_isa_attach: shared ram space vanished\\n\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_memt",
            "ia->ia_maddr",
            "ia->ia_msize",
            "0",
            "&sc->sc_sramh"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_isa_map_io",
          "args": [
            "ia",
            "&sc->sc_pioh",
            "&sc->sc_mmioh"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "tr_isa_map_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
          "lines": "88-118",
          "snippet": "int\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ttr_isa_map_io"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttr_isa_map_io;\n\nint\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttr_isa_attach;\nint\ttr_isa_map_io;\nint\ttrtcm_isa_mediachange;\nvoid\ttrtcm_isa_mediastatus;\nint trtcm_setspeed(struct tr_softc *, int);\n\nvoid\ntr_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid\t*aux;\n{\n\tstruct tr_softc *sc = (void *) self;\n\tstruct isa_attach_args *ia = aux;\n\n\tsc->sc_piot = ia->ia_iot;\n\tsc->sc_memt = ia->ia_memt;\n\tif (tr_isa_map_io(ia, &sc->sc_pioh, &sc->sc_mmioh)) {\n\t\tprintf(\"tr_isa_attach: IO space vanished\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(sc->sc_memt, ia->ia_maddr, ia->ia_msize, 0,\n\t    &sc->sc_sramh)) {\n\t\tprintf(\"tr_isa_attach: shared ram space vanished\\n\");\n\t\treturn;\n\t}\n\t/* set ACA offset */\n\tsc->sc_aca = TR_ACA_OFFSET;\n\tsc->sc_memwinsz = ia->ia_msize;\n\tsc->sc_maddr = ia->ia_maddr;\n\t/*\n\t * Determine total RAM on adapter and decide how much to use.\n\t * XXX Since we don't use RAM paging, use sc_memwinsz for now.\n\t */\n\tsc->sc_memsize = sc->sc_memwinsz;\n\tsc->sc_memreserved = 0;\n\n\tif (tr_reset(sc) != 0)\n\t\treturn;\n\n\tif (ia->ia_aux != NULL) {\n\t\tsc->sc_mediastatus = trtcm_isa_mediastatus;\n\t\tsc->sc_mediachange = trtcm_isa_mediachange;\n\t}\n\telse {\n\t\tsc->sc_mediastatus = NULL;\n\t\tsc->sc_mediachange = NULL;\n\t}\n\n\tif (tr_attach(sc) != 0)\n\t\treturn;\n\n/*\n * XXX 3Com 619 can use LEVEL intr\n */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, tr_intr, sc, sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "tr_isa_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
    "lines": "137-181",
    "snippet": "int\ntr_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tint\ti;\n\tbus_size_t\ttr_id;\n\tbus_space_handle_t sramh, pioh, mmioh;\n\tint probecode;\n\tint matched = 0;\n\n\tfor (i = 0; tr_isa_probe_list[i] != 0; i++) {\n\t\tprobecode = tr_isa_probe_list[i](parent, match, aux);\n\t\tif (probecode < 0)\n\t\t\treturn 0;\t/* Fail instantly. */\n\t\tif (probecode > 0)\n\t\t\tbreak;\t\t/* We have a match. */\n\t}\n\tif (tr_isa_probe_list[i] == 0)\n\t\treturn 0;\t\t/* Nothing matched. */\n\tif (tr_isa_map_io(ia, &pioh, &mmioh))\n\t\treturn 0;\n\ttr_id = TR_ID_OFFSET;\n\tmatched = 1;\n\tfor (i = 0; i < sizeof(tr_isa_id); i++) {\n\t\tif (bus_space_read_1(ia->ia_memt, mmioh, tr_id) !=\n\t\t    tr_isa_id[i])\n\t\t\tmatched = 0;\n\t\ttr_id += 2;\n\t}\n#ifdef TRISADEBUG\n\ttr_isa_dumpaip(ia->ia_memt, mmioh);\n#endif\n\ttr_isa_unmap_io(ia, pioh, mmioh);\n\tif (!matched) {\n\t\treturn 0;\n\t}\n\tif (bus_space_map(ia->ia_memt, ia->ia_maddr, ia->ia_msize, 0, &sramh)) {\n\t\tprintf(\"tr_isa_probe: can't map shared ram\\n\");\n\t\treturn 0;\n\t}\n\tbus_space_unmap(ia->ia_memt, sramh, ia->ia_msize);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttr_isa_probe",
      "int\ttr_isa_map_io",
      "void\ttr_isa_unmap_io",
      "int\t(*tr_isa_probe_list[])(struct device *, void *, void *) = {\n\t\ttrtcm_isa_probe,\n\t\ttribm_isa_probe,\n\t\t0\n\t};",
      "static u_char tr_isa_id[] = {\n\t5, 0, 4, 9, 4, 3, 4, 15, 3, 6, 3, 1, 3, 1, 3, 0, 3, 9, 3, 9, 3, 0, 2, 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "ia->ia_memt",
            "sramh",
            "ia->ia_msize"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tr_isa_probe: can't map shared ram\\n\""
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "ia->ia_memt",
            "ia->ia_maddr",
            "ia->ia_msize",
            "0",
            "&sramh"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_isa_unmap_io",
          "args": [
            "ia",
            "pioh",
            "mmioh"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "tr_isa_unmap_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
          "lines": "120-127",
          "snippet": "void\ntr_isa_unmap_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t pioh, mmioh;\n{\n\tbus_space_unmap(ia->ia_memt, mmioh, TR_MMIO_SIZE);\n\tbus_space_unmap(ia->ia_iot, pioh, ia->ia_iosize);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_isa_unmap_io"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttr_isa_unmap_io;\n\nvoid\ntr_isa_unmap_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t pioh, mmioh;\n{\n\tbus_space_unmap(ia->ia_memt, mmioh, TR_MMIO_SIZE);\n\tbus_space_unmap(ia->ia_iot, pioh, ia->ia_iosize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_isa_dumpaip",
          "args": [
            "ia->ia_memt",
            "mmioh"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "tr_isa_dumpaip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
          "lines": "241-255",
          "snippet": "void\ntr_isa_dumpaip(memt, mmioh)\n\tbus_space_tag_t memt;\n\tbus_space_handle_t mmioh;\n{\n\tunsigned int off, val;\n\tprintf(\"AIP contents:\");\n\tfor (off=0; off < 256; off++) {\n\t\tval = bus_space_read_1(memt, mmioh, TR_MAC_OFFSET + off);\n\t\tif ((off % 16) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%02x \", val);\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ntr_isa_dumpaip(memt, mmioh)\n\tbus_space_tag_t memt;\n\tbus_space_handle_t mmioh;\n{\n\tunsigned int off, val;\n\tprintf(\"AIP contents:\");\n\tfor (off=0; off < 256; off++) {\n\t\tval = bus_space_read_1(memt, mmioh, TR_MAC_OFFSET + off);\n\t\tif ((off % 16) == 0)\n\t\t\tprintf(\"\\n\");\n\t\tprintf(\"%02x \", val);\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "ia->ia_memt",
            "mmioh",
            "tr_id"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_isa_map_io",
          "args": [
            "ia",
            "&pioh",
            "&mmioh"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "tr_isa_map_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
          "lines": "88-118",
          "snippet": "int\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ttr_isa_map_io"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttr_isa_map_io;\n\nint\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_isa_probe_list[i]",
          "args": [
            "parent",
            "match",
            "aux"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttr_isa_probe;\nint\ttr_isa_map_io;\nvoid\ttr_isa_unmap_io;\nint\t(*tr_isa_probe_list[])(struct device *, void *, void *) = {\n\t\ttrtcm_isa_probe,\n\t\ttribm_isa_probe,\n\t\t0\n\t};\nstatic u_char tr_isa_id[] = {\n\t5, 0, 4, 9, 4, 3, 4, 15, 3, 6, 3, 1, 3, 1, 3, 0, 3, 9, 3, 9, 3, 0, 2, 0\n};\n\nint\ntr_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tint\ti;\n\tbus_size_t\ttr_id;\n\tbus_space_handle_t sramh, pioh, mmioh;\n\tint probecode;\n\tint matched = 0;\n\n\tfor (i = 0; tr_isa_probe_list[i] != 0; i++) {\n\t\tprobecode = tr_isa_probe_list[i](parent, match, aux);\n\t\tif (probecode < 0)\n\t\t\treturn 0;\t/* Fail instantly. */\n\t\tif (probecode > 0)\n\t\t\tbreak;\t\t/* We have a match. */\n\t}\n\tif (tr_isa_probe_list[i] == 0)\n\t\treturn 0;\t\t/* Nothing matched. */\n\tif (tr_isa_map_io(ia, &pioh, &mmioh))\n\t\treturn 0;\n\ttr_id = TR_ID_OFFSET;\n\tmatched = 1;\n\tfor (i = 0; i < sizeof(tr_isa_id); i++) {\n\t\tif (bus_space_read_1(ia->ia_memt, mmioh, tr_id) !=\n\t\t    tr_isa_id[i])\n\t\t\tmatched = 0;\n\t\ttr_id += 2;\n\t}\n#ifdef TRISADEBUG\n\ttr_isa_dumpaip(ia->ia_memt, mmioh);\n#endif\n\ttr_isa_unmap_io(ia, pioh, mmioh);\n\tif (!matched) {\n\t\treturn 0;\n\t}\n\tif (bus_space_map(ia->ia_memt, ia->ia_maddr, ia->ia_msize, 0, &sramh)) {\n\t\tprintf(\"tr_isa_probe: can't map shared ram\\n\");\n\t\treturn 0;\n\t}\n\tbus_space_unmap(ia->ia_memt, sramh, ia->ia_msize);\n\treturn 1;\n}"
  },
  {
    "function_name": "tr_isa_unmap_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
    "lines": "120-127",
    "snippet": "void\ntr_isa_unmap_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t pioh, mmioh;\n{\n\tbus_space_unmap(ia->ia_memt, mmioh, TR_MMIO_SIZE);\n\tbus_space_unmap(ia->ia_iot, pioh, ia->ia_iosize);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_isa_unmap_io"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "ia->ia_iot",
            "pioh",
            "ia->ia_iosize"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "ia->ia_memt",
            "mmioh",
            "TR_MMIO_SIZE"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttr_isa_unmap_io;\n\nvoid\ntr_isa_unmap_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t pioh, mmioh;\n{\n\tbus_space_unmap(ia->ia_memt, mmioh, TR_MMIO_SIZE);\n\tbus_space_unmap(ia->ia_iot, pioh, ia->ia_iosize);\n}"
  },
  {
    "function_name": "tr_isa_map_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_tr_isa.c",
    "lines": "88-118",
    "snippet": "int\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttr_isa_map_io"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "ia->ia_iot",
            "*pioh",
            "ia->ia_iosize"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\"",
            "mmio",
            "TR_MMIO_SIZE"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "ia->ia_memt",
            "mmio",
            "TR_MMIO_SIZE",
            "0",
            "mmioh"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "ia->ia_iot",
            "*pioh",
            "ia->ia_iosize"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "ia->ia_iot",
            "*pioh",
            "TR_SWITCH"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "ia->ia_iot",
            "ia->ia_iobase",
            "ia->ia_iosize",
            "0",
            "pioh"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttr_isa_map_io;\n\nint\ntr_isa_map_io(ia, pioh, mmioh)\nstruct isa_attach_args *ia;\nbus_space_handle_t *pioh, *mmioh;\n{\n\tbus_size_t mmio;\n\tu_int8_t s;\n\n\tif (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0, pioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map PIO ports\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Read adapter switches and calculate addresses of MMIO. */\n\ts = bus_space_read_1(ia->ia_iot, *pioh, TR_SWITCH);\n\n\tif ((s & 0xfc) < ((TR_MMIO_MINADDR - TR_MMIO_OFFSET) >> 11) ||\n\t    (s & 0xfc) > ((TR_MMIO_MAXADDR - TR_MMIO_OFFSET) >> 11)) {\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\n\tmmio = ((s & 0xfc) << 11) + TR_MMIO_OFFSET;\n\tif (bus_space_map(ia->ia_memt, mmio, TR_MMIO_SIZE, 0, mmioh)) {\n\t\tprintf(\"tr_isa_map_io: can't map MMIO region 0x%05lx/%d\\n\",\n\t\t\tmmio, TR_MMIO_SIZE);\n\t\tbus_space_unmap(ia->ia_iot, *pioh, ia->ia_iosize);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  }
]