[
  {
    "function_name": "wss_isapnp_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isapnp.c",
    "lines": "91-127",
    "snippet": "void\nwss_isapnp_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isapnp_softc *pnp = (struct isapnp_softc *)parent;\n\tstruct wss_softc *sc = (struct wss_softc *)self;\n\tstruct ad1848_softc *ac = &sc->sc_ad1848;\n\tstruct isa_attach_args *ipa = aux;\n\n\t/* probably broken */\n\tisapnp_write_reg(pnp, ISAPNP_CONFIG_CONTROL, 0x02);\n\n\tsc->sc_iot = ipa->ia_iot;\n\tsc->sc_ioh = ipa->ipa_io[0].h;\n\tsc->mad_chip_type = MAD_NONE;\n\n/* Set up AD1848 I/O handle. */ \n\tac->sc_iot = sc->sc_iot;\n\tac->sc_isa = parent->dv_parent; \n\tac->sc_ioh = sc->sc_ioh;\n\tac->mode = 2;\n\tac->sc_iooffs = 0;\n\n\tsc->sc_ic  = ipa->ia_ic;\n\tsc->wss_irq = ipa->ipa_irq[0].num;\n\tsc->wss_drq = ipa->ipa_drq[0].num;\n\tsc->wss_recdrq = ipa->ipa_ndrq > 1 ? ipa->ipa_drq[1].num :\n\t    ipa->ipa_drq[0].num;\n\n\tif (ad1848_probe(&sc->sc_ad1848)==0) {\n\t\tprintf(\"%s: probe failed\\n\", ac->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\twssattach(sc);\n}",
    "includes": [
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/madreg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isapnpreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\twss_isapnp_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wssattach",
          "args": [
            "sc"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "wssattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss.c",
          "lines": "120-156",
          "snippet": "void\nwssattach(sc)\n    struct wss_softc *sc;\n{\n    int version;\n    \n    madattach(sc);\n\n    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq, IST_EDGE, IPL_AUDIO,\n        ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n    ad1848_attach(&sc->sc_ad1848);\n    \n    version = bus_space_read_1(sc->sc_iot, sc->sc_ioh, WSS_STATUS) & WSS_VERSMASK;\n    printf(\" (vers %d)\", version);\n    switch(sc->mad_chip_type) {\n    case MAD_82C928:\n\tprintf(\", 82C928\");\n\tbreak;\n    case MAD_OTI601D:\n\tprintf(\", OTI-601D\");\n\tbreak;\n    case MAD_82C929:\n\tprintf(\", 82C929\");\n\tbreak;\n    case MAD_82C931:\n\tprintf(\", 82C931\");\n\tbreak;\n    default:\n\tbreak;\n    }\n    printf(\"\\n\");\n\n    sc->sc_ad1848.parent = sc;\n\n    audio_attach_mi(&wss_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}",
          "includes": [
            "#include <dev/isa/madreg.h>",
            "#include <dev/isa/wssvar.h>",
            "#include <dev/isa/wssreg.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct audio_hw_if wss_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\twss_getdev,\n\tNULL,\n\twss_mixer_set_port,\n\twss_mixer_get_port,\n\twss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/madreg.h>\n#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_hw_if wss_hw_if = {\n\tad1848_open,\n\tad1848_close,\n\tNULL,\n\tad1848_query_encoding,\n\tad1848_set_params,\n\tad1848_round_blocksize,\n\tad1848_commit_settings,\n\tad1848_dma_init_output,\n\tad1848_dma_init_input,\n\tad1848_dma_output,\n\tad1848_dma_input,\n\tad1848_halt_out_dma,\n\tad1848_halt_in_dma,\n\tNULL,\n\twss_getdev,\n\tNULL,\n\twss_mixer_set_port,\n\twss_mixer_get_port,\n\twss_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tad1848_get_props,\n\tNULL,\n\tNULL\n};\n\nvoid\nwssattach(sc)\n    struct wss_softc *sc;\n{\n    int version;\n    \n    madattach(sc);\n\n    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq, IST_EDGE, IPL_AUDIO,\n        ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);\n\n    ad1848_attach(&sc->sc_ad1848);\n    \n    version = bus_space_read_1(sc->sc_iot, sc->sc_ioh, WSS_STATUS) & WSS_VERSMASK;\n    printf(\" (vers %d)\", version);\n    switch(sc->mad_chip_type) {\n    case MAD_82C928:\n\tprintf(\", 82C928\");\n\tbreak;\n    case MAD_OTI601D:\n\tprintf(\", OTI-601D\");\n\tbreak;\n    case MAD_82C929:\n\tprintf(\", 82C929\");\n\tbreak;\n    case MAD_82C931:\n\tprintf(\", 82C931\");\n\tbreak;\n    default:\n\tbreak;\n    }\n    printf(\"\\n\");\n\n    sc->sc_ad1848.parent = sc;\n\n    audio_attach_mi(&wss_hw_if, &sc->sc_ad1848, &sc->sc_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: probe failed\\n\"",
            "ac->sc_dev.dv_xname"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_probe",
          "args": [
            "&sc->sc_ad1848"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "303-488",
          "snippet": "int\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isapnp_write_reg",
          "args": [
            "pnp",
            "ISAPNP_CONFIG_CONTROL",
            "0x02"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "isapnp_write_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isavar.h",
          "lines": "423-431",
          "snippet": "static __inline void\nisapnp_write_reg(sc, r, v)\n\tstruct isapnp_softc *sc;\n\tint r;\n\tu_char v;\n{\n\tISAPNP_WRITE_ADDR(sc, r);\n\tISAPNP_WRITE_DATA(sc, v);\n}",
          "includes": [
            "#include <alpha/isa/isapnp_machdep.h>",
            "#include <i386/isa/isapnp_machdep.h>",
            "#include \"isapnp.h\"",
            "#include <hppa/isa/isa_machdep.h>",
            "#include <powerpc/isa/isa_machdep.h>",
            "#include <wgrisc/isa/isa_machdep.h>",
            "#include <arc/isa/isa_machdep.h>",
            "#include <i386/isa/isa_machdep.h>",
            "#include <amiga/isa/isa_machdep.h>",
            "#include <alpha/isa/isa_machdep.h>",
            "#include \"isadma.h\"",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <alpha/isa/isapnp_machdep.h>\n#include <i386/isa/isapnp_machdep.h>\n#include \"isapnp.h\"\n#include <hppa/isa/isa_machdep.h>\n#include <powerpc/isa/isa_machdep.h>\n#include <wgrisc/isa/isa_machdep.h>\n#include <arc/isa/isa_machdep.h>\n#include <i386/isa/isa_machdep.h>\n#include <amiga/isa/isa_machdep.h>\n#include <alpha/isa/isa_machdep.h>\n#include \"isadma.h\"\n#include <machine/bus.h>\n#include <sys/queue.h>\n\nstatic __inline void\nisapnp_write_reg(sc, r, v)\n\tstruct isapnp_softc *sc;\n\tint r;\n\tu_char v;\n{\n\tISAPNP_WRITE_ADDR(sc, r);\n\tISAPNP_WRITE_DATA(sc, v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/madreg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isapnpreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\twss_isapnp_attach;\n\nvoid\nwss_isapnp_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isapnp_softc *pnp = (struct isapnp_softc *)parent;\n\tstruct wss_softc *sc = (struct wss_softc *)self;\n\tstruct ad1848_softc *ac = &sc->sc_ad1848;\n\tstruct isa_attach_args *ipa = aux;\n\n\t/* probably broken */\n\tisapnp_write_reg(pnp, ISAPNP_CONFIG_CONTROL, 0x02);\n\n\tsc->sc_iot = ipa->ia_iot;\n\tsc->sc_ioh = ipa->ipa_io[0].h;\n\tsc->mad_chip_type = MAD_NONE;\n\n/* Set up AD1848 I/O handle. */ \n\tac->sc_iot = sc->sc_iot;\n\tac->sc_isa = parent->dv_parent; \n\tac->sc_ioh = sc->sc_ioh;\n\tac->mode = 2;\n\tac->sc_iooffs = 0;\n\n\tsc->sc_ic  = ipa->ia_ic;\n\tsc->wss_irq = ipa->ipa_irq[0].num;\n\tsc->wss_drq = ipa->ipa_drq[0].num;\n\tsc->wss_recdrq = ipa->ipa_ndrq > 1 ? ipa->ipa_drq[1].num :\n\t    ipa->ipa_drq[0].num;\n\n\tif (ad1848_probe(&sc->sc_ad1848)==0) {\n\t\tprintf(\"%s: probe failed\\n\", ac->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\twssattach(sc);\n}"
  },
  {
    "function_name": "wss_isapnp_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wss_isapnp.c",
    "lines": "79-85",
    "snippet": "int\nwss_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wssvar.h>",
      "#include <dev/isa/wssreg.h>",
      "#include <dev/isa/madreg.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/isapnpreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twss_isapnp_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/wssvar.h>\n#include <dev/isa/wssreg.h>\n#include <dev/isa/madreg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/isapnpreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\twss_isapnp_match;\n\nint\nwss_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}"
  }
]