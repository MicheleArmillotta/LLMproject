[
  {
    "function_name": "cy_probe_pci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/cy_pci.c",
    "lines": "70-141",
    "snippet": "int\ncy_probe_pci(parent, match, aux)\n     struct device *parent;\n     void *match, *aux;\n{\n  int card = ((struct device *)match)->dv_unit;\n  struct pci_attach_args *pa = aux;\n  bus_space_tag_t memt;\n  bus_space_handle_t memh;\n  bus_addr_t memaddr;\n  bus_size_t memsize;\n  bus_space_tag_t iot;\n  bus_space_handle_t ioh;\n  bus_addr_t iobase;\n  bus_size_t iosize;\n  int cacheable;\n\n  if(!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CYCLADES &&\n       (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_1 ||\n\tPCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_2)))\n    return 0;\n\n#ifdef CY_DEBUG\n  printf(\"cy: Found Cyclades PCI device, id = 0x%x\\n\", pa->pa_id);\n#endif\n\n  memt = pa->pa_memt;\n  iot = pa->pa_iot;\n\n  if(pci_mem_find(pa->pa_pc, pa->pa_tag, 0x18,\n\t\t  &memaddr, &memsize, &cacheable) != 0) {\n    printf(\"cy%d: can't find PCI card memory\", card);\n    return 0;\n  }\n\n  /* map the memory (non-cacheable) */\n  if(bus_space_map(memt, memaddr, memsize, 0, &memh) != 0) {\n    printf(\"cy%d: couldn't map PCI memory region\\n\", card);\n    return 0;\n  }\n\n  /* the PCI Cyclom IO space is only used for enabling interrupts */\n  if(pci_io_find(pa->pa_pc, pa->pa_tag, 0x14, &iobase, &iosize) != 0) {\n    bus_space_unmap(memt, memh, memsize);\n    printf(\"cy%d: couldn't find PCI io region\\n\", card);\n    return 0;\n  }\n\n  if(bus_space_map(iot, iobase, iosize, 0, &ioh) != 0) {\n    bus_space_unmap(memt, memh, memsize);\n    printf(\"cy%d: couldn't map PCI io region\\n\", card);\n    return 0; \n  }\n\n#ifdef CY_DEBUG\n  printf(\"cy%d: pci mapped mem 0x%lx (size %d), io 0x%x (size %d)\\n\",\n\t card, memaddr, memsize, iobase, iosize);\n#endif\n\n  if(cy_probe_common(card, memt, memh, CY_BUSTYPE_PCI) == 0) {\n    bus_space_unmap(memt, memh, memsize);\n    bus_space_unmap(iot, ioh, iosize);\n    printf(\"cy%d: PCI Cyclom card with no CD1400s!?\\n\", card);\n    return 0;\n  }\n\n  /* Enable PCI card interrupts */\n  bus_space_write_2(iot, ioh, CY_PCI_INTENA,\n      bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);\n\n  return 1;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int cy_probe_pci",
      "int cy_probe_common"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "CY_PCI_INTENA",
            "bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "CY_PCI_INTENA"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d: PCI Cyclom card with no CD1400s!?\\n\"",
            "card"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "iosize"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "memsize"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_probe_common",
          "args": [
            "card",
            "memt",
            "memh",
            "CY_BUSTYPE_PCI"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "cy_probe_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "94-194",
          "snippet": "int\ncy_probe_common(card, memt, memh, bustype)\n     int card, bustype;\n     bus_space_tag_t memt;\n     bus_space_handle_t memh;\n{\n  int cy_chip, chip_offs;\n  u_char firmware_ver;\n\n  /* Cyclom card hardware reset */\n  bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);\n  DELAY(500); /* wait for reset to complete */\n  bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);\n\n#ifdef CY_DEBUG\n  printf(\"cy: card reset done\\n\");\n#endif\n\n  cy_nr_cd1400s[card] = 0;\n\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < CY_MAX_CD1400s;\n      cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {\n    int i;\n\n    /* the last 4 cd1400s are 'interleaved'\n       with the first 4 on 32-port boards */\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<bustype);\n\n#ifdef CY_DEBUG\n    printf(\"cy%d probe chip %d offset 0x%lx ... \",\n\t   card, cy_chip, chip_offs);\n#endif\n\n    /* wait until the chip is ready for command */\n    DELAY(1000);\n    if(bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_CCR<<1) << bustype)) != 0) {\n#ifdef CY_DEBUG\n      printf(\"not ready for command\\n\");\n#endif\n      break;\n    }\n\n    /* clear the firmware version reg. */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_GFRCR<<1) << bustype), 0);\n\n    /*\n     * On Cyclom-16 references to non-existent chip 4\n     * actually access chip 0 (address line 9 not decoded).\n     * Here we check if the clearing of chip 4 GFRCR actually\n     * cleared chip 0 GFRCR. In that case we have a 16 port card.\n     */\n    if(cy_chip == 4 &&\n       bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_GFRCR<<1) << bustype)) ==0)\n      break;\n\n    /* reset the chip */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_CCR<<1) << bustype),\n\t\t    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);\n\n    /* wait for the chip to initialize itself */\n    for(i = 0; i < 200; i++) {\n      DELAY(50);\n      firmware_ver =\n\tbus_space_read_1(memt, memh, chip_offs +\n\t\t       ((CD1400_GFRCR<<1) << bustype));\n      if((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */\n\tbreak;\n    }\n#ifdef CY_DEBUG\n    printf(\"firmware version 0x%x\\n\", firmware_ver);\n#endif      \n\n    if((firmware_ver & 0xf0) != 0x40)\n      break;\n\n    /* firmware version OK, CD1400 found */\n    cy_nr_cd1400s[card]++;\n  }\n\n  if(cy_nr_cd1400s[card] == 0) {\n#ifdef CY_DEBUG\n    printf(\"no CD1400s found\\n\");\n#endif\n    return 0;\n  }\n\n#ifdef CY_DEBUG\n  printf(\"found %d CD1400s\\n\", cy_nr_cd1400s[card]);\n#endif\n\n  cy_card_memh[card] = memh;\n  cy_bus_types[card] = bustype;\n\n  return 1;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_probe_common(card, memt, memh, bustype)\n     int card, bustype;\n     bus_space_tag_t memt;\n     bus_space_handle_t memh;\n{\n  int cy_chip, chip_offs;\n  u_char firmware_ver;\n\n  /* Cyclom card hardware reset */\n  bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);\n  DELAY(500); /* wait for reset to complete */\n  bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);\n\n#ifdef CY_DEBUG\n  printf(\"cy: card reset done\\n\");\n#endif\n\n  cy_nr_cd1400s[card] = 0;\n\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < CY_MAX_CD1400s;\n      cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {\n    int i;\n\n    /* the last 4 cd1400s are 'interleaved'\n       with the first 4 on 32-port boards */\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<bustype);\n\n#ifdef CY_DEBUG\n    printf(\"cy%d probe chip %d offset 0x%lx ... \",\n\t   card, cy_chip, chip_offs);\n#endif\n\n    /* wait until the chip is ready for command */\n    DELAY(1000);\n    if(bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_CCR<<1) << bustype)) != 0) {\n#ifdef CY_DEBUG\n      printf(\"not ready for command\\n\");\n#endif\n      break;\n    }\n\n    /* clear the firmware version reg. */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_GFRCR<<1) << bustype), 0);\n\n    /*\n     * On Cyclom-16 references to non-existent chip 4\n     * actually access chip 0 (address line 9 not decoded).\n     * Here we check if the clearing of chip 4 GFRCR actually\n     * cleared chip 0 GFRCR. In that case we have a 16 port card.\n     */\n    if(cy_chip == 4 &&\n       bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_GFRCR<<1) << bustype)) ==0)\n      break;\n\n    /* reset the chip */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_CCR<<1) << bustype),\n\t\t    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);\n\n    /* wait for the chip to initialize itself */\n    for(i = 0; i < 200; i++) {\n      DELAY(50);\n      firmware_ver =\n\tbus_space_read_1(memt, memh, chip_offs +\n\t\t       ((CD1400_GFRCR<<1) << bustype));\n      if((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */\n\tbreak;\n    }\n#ifdef CY_DEBUG\n    printf(\"firmware version 0x%x\\n\", firmware_ver);\n#endif      \n\n    if((firmware_ver & 0xf0) != 0x40)\n      break;\n\n    /* firmware version OK, CD1400 found */\n    cy_nr_cd1400s[card]++;\n  }\n\n  if(cy_nr_cd1400s[card] == 0) {\n#ifdef CY_DEBUG\n    printf(\"no CD1400s found\\n\");\n#endif\n    return 0;\n  }\n\n#ifdef CY_DEBUG\n  printf(\"found %d CD1400s\\n\", cy_nr_cd1400s[card]);\n#endif\n\n  cy_card_memh[card] = memh;\n  cy_bus_types[card] = bustype;\n\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "memsize"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "iobase",
            "iosize",
            "0",
            "&ioh"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "memsize"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "0x14",
            "&iobase",
            "&iosize"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "memaddr",
            "memsize",
            "0",
            "&memh"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "0x18",
            "&memaddr",
            "&memsize",
            "&cacheable"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint cy_probe_pci;\nint cy_probe_common;\n\nint\ncy_probe_pci(parent, match, aux)\n     struct device *parent;\n     void *match, *aux;\n{\n  int card = ((struct device *)match)->dv_unit;\n  struct pci_attach_args *pa = aux;\n  bus_space_tag_t memt;\n  bus_space_handle_t memh;\n  bus_addr_t memaddr;\n  bus_size_t memsize;\n  bus_space_tag_t iot;\n  bus_space_handle_t ioh;\n  bus_addr_t iobase;\n  bus_size_t iosize;\n  int cacheable;\n\n  if(!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CYCLADES &&\n       (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_1 ||\n\tPCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_2)))\n    return 0;\n\n#ifdef CY_DEBUG\n  printf(\"cy: Found Cyclades PCI device, id = 0x%x\\n\", pa->pa_id);\n#endif\n\n  memt = pa->pa_memt;\n  iot = pa->pa_iot;\n\n  if(pci_mem_find(pa->pa_pc, pa->pa_tag, 0x18,\n\t\t  &memaddr, &memsize, &cacheable) != 0) {\n    printf(\"cy%d: can't find PCI card memory\", card);\n    return 0;\n  }\n\n  /* map the memory (non-cacheable) */\n  if(bus_space_map(memt, memaddr, memsize, 0, &memh) != 0) {\n    printf(\"cy%d: couldn't map PCI memory region\\n\", card);\n    return 0;\n  }\n\n  /* the PCI Cyclom IO space is only used for enabling interrupts */\n  if(pci_io_find(pa->pa_pc, pa->pa_tag, 0x14, &iobase, &iosize) != 0) {\n    bus_space_unmap(memt, memh, memsize);\n    printf(\"cy%d: couldn't find PCI io region\\n\", card);\n    return 0;\n  }\n\n  if(bus_space_map(iot, iobase, iosize, 0, &ioh) != 0) {\n    bus_space_unmap(memt, memh, memsize);\n    printf(\"cy%d: couldn't map PCI io region\\n\", card);\n    return 0; \n  }\n\n#ifdef CY_DEBUG\n  printf(\"cy%d: pci mapped mem 0x%lx (size %d), io 0x%x (size %d)\\n\",\n\t card, memaddr, memsize, iobase, iosize);\n#endif\n\n  if(cy_probe_common(card, memt, memh, CY_BUSTYPE_PCI) == 0) {\n    bus_space_unmap(memt, memh, memsize);\n    bus_space_unmap(iot, ioh, iosize);\n    printf(\"cy%d: PCI Cyclom card with no CD1400s!?\\n\", card);\n    return 0;\n  }\n\n  /* Enable PCI card interrupts */\n  bus_space_write_2(iot, ioh, CY_PCI_INTENA,\n      bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);\n\n  return 1;\n}"
  }
]