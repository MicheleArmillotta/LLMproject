[
  {
    "function_name": "tlphy_acomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
    "lines": "371-394",
    "snippet": "void\ntlphy_acomp(sc)\n\tstruct tlphy_softc *sc;\n{\n\tint aner, anlpar;\n\n\tsc->sc_need_acomp = 0;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't self-configure\n\t * after autonegotiation.  We have to do it ourselves\n\t * based on the link partner status.\n\t */\n\n\taner = PHY_READ(&sc->sc_mii, MII_ANER);\n\tif (aner & ANER_LPAN) {\n\t\tanlpar = PHY_READ(&sc->sc_mii, MII_ANLPAR) &\n\t\t    PHY_READ(&sc->sc_mii, MII_ANAR);\n\t\tif (anlpar & ANAR_10_FD) {\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, BMCR_FDX);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/pci/if_tlvar.h>",
      "#include <dev/mii/tlphyvar.h>",
      "#include <dev/mii/tlphyreg.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttlphy_acomp"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PHY_WRITE",
          "args": [
            "&sc->sc_mii",
            "MII_BMCR",
            "BMCR_FDX"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_ANAR"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_ANLPAR"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_ANER"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttlphy_acomp;\n\nvoid\ntlphy_acomp(sc)\n\tstruct tlphy_softc *sc;\n{\n\tint aner, anlpar;\n\n\tsc->sc_need_acomp = 0;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't self-configure\n\t * after autonegotiation.  We have to do it ourselves\n\t * based on the link partner status.\n\t */\n\n\taner = PHY_READ(&sc->sc_mii, MII_ANER);\n\tif (aner & ANER_LPAN) {\n\t\tanlpar = PHY_READ(&sc->sc_mii, MII_ANLPAR) &\n\t\t    PHY_READ(&sc->sc_mii, MII_ANAR);\n\t\tif (anlpar & ANAR_10_FD) {\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, BMCR_FDX);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "tlphy_auto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
    "lines": "343-369",
    "snippet": "int\ntlphy_auto(sc, waitfor)\n\tstruct tlphy_softc *sc;\n\tint waitfor;\n{\n\tint error;\n\n\tswitch ((error = mii_phy_auto(&sc->sc_mii, waitfor))) {\n\tcase EIO:\n\t\t/*\n\t\t * Just assume we're not in full-duplex mode.\n\t\t * XXX Check link and try AUI/BNC?\n\t\t */\n\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, 0);\n\t\tbreak;\n\n\tcase EJUSTRETURN:\n\t\t/* Flag that we need to program when it completes. */\n\t\tsc->sc_need_acomp = 1;\n\t\tbreak;\n\n\tdefault:\n\t\ttlphy_acomp(sc);\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/pci/if_tlvar.h>",
      "#include <dev/mii/tlphyvar.h>",
      "#include <dev/mii/tlphyreg.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttlphy_auto",
      "void\ttlphy_acomp"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlphy_acomp",
          "args": [
            "sc"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "tlphy_acomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
          "lines": "371-394",
          "snippet": "void\ntlphy_acomp(sc)\n\tstruct tlphy_softc *sc;\n{\n\tint aner, anlpar;\n\n\tsc->sc_need_acomp = 0;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't self-configure\n\t * after autonegotiation.  We have to do it ourselves\n\t * based on the link partner status.\n\t */\n\n\taner = PHY_READ(&sc->sc_mii, MII_ANER);\n\tif (aner & ANER_LPAN) {\n\t\tanlpar = PHY_READ(&sc->sc_mii, MII_ANLPAR) &\n\t\t    PHY_READ(&sc->sc_mii, MII_ANAR);\n\t\tif (anlpar & ANAR_10_FD) {\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, BMCR_FDX);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_tlvar.h>",
            "#include <dev/mii/tlphyvar.h>",
            "#include <dev/mii/tlphyreg.h>",
            "#include <dev/mii/miidevs.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttlphy_acomp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttlphy_acomp;\n\nvoid\ntlphy_acomp(sc)\n\tstruct tlphy_softc *sc;\n{\n\tint aner, anlpar;\n\n\tsc->sc_need_acomp = 0;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't self-configure\n\t * after autonegotiation.  We have to do it ourselves\n\t * based on the link partner status.\n\t */\n\n\taner = PHY_READ(&sc->sc_mii, MII_ANER);\n\tif (aner & ANER_LPAN) {\n\t\tanlpar = PHY_READ(&sc->sc_mii, MII_ANLPAR) &\n\t\t    PHY_READ(&sc->sc_mii, MII_ANAR);\n\t\tif (anlpar & ANAR_10_FD) {\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, BMCR_FDX);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_WRITE",
          "args": [
            "&sc->sc_mii",
            "MII_BMCR",
            "0"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_auto",
          "args": [
            "&sc->sc_mii",
            "waitfor"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_auto_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "144-158",
          "snippet": "void\nmii_phy_auto_timeout(arg)\n\tvoid *arg;\n{\n\tstruct mii_softc *mii = arg;\n\tint s, bmsr;\n\n\ts = splnet();\n\tmii->mii_flags &= ~MIIF_DOINGAUTO;\n\tbmsr = PHY_READ(mii, MII_BMSR);\n\n\t/* Update the media status. */\n\t(void) (*mii->mii_service)(mii, mii->mii_pdata, MII_POLLSTAT);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tmii_phy_auto_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\tmii_phy_auto_timeout;\n\nvoid\nmii_phy_auto_timeout(arg)\n\tvoid *arg;\n{\n\tstruct mii_softc *mii = arg;\n\tint s, bmsr;\n\n\ts = splnet();\n\tmii->mii_flags &= ~MIIF_DOINGAUTO;\n\tbmsr = PHY_READ(mii, MII_BMSR);\n\n\t/* Update the media status. */\n\t(void) (*mii->mii_service)(mii, mii->mii_pdata, MII_POLLSTAT);\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttlphy_auto;\nvoid\ttlphy_acomp;\n\nint\ntlphy_auto(sc, waitfor)\n\tstruct tlphy_softc *sc;\n\tint waitfor;\n{\n\tint error;\n\n\tswitch ((error = mii_phy_auto(&sc->sc_mii, waitfor))) {\n\tcase EIO:\n\t\t/*\n\t\t * Just assume we're not in full-duplex mode.\n\t\t * XXX Check link and try AUI/BNC?\n\t\t */\n\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, 0);\n\t\tbreak;\n\n\tcase EJUSTRETURN:\n\t\t/* Flag that we need to program when it completes. */\n\t\tsc->sc_need_acomp = 1;\n\t\tbreak;\n\n\tdefault:\n\t\ttlphy_acomp(sc);\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "tlphy_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
    "lines": "292-341",
    "snippet": "void\ntlphy_status(sc)\n\tstruct tlphy_softc *sc;\n{\n\tstruct mii_data *mii = sc->sc_mii.mii_pdata;\n\tstruct tl_softc *tlsc = (struct tl_softc *)sc->sc_mii.mii_dev.dv_parent;\n\tint bmsr, bmcr, tlctrl;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\tbmcr = PHY_READ(&sc->sc_mii, MII_BMCR);\n\tif (bmcr & BMCR_ISO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\tmii->mii_media_status = 0;  \n\t\treturn;\n\t}\n\n\ttlctrl = PHY_READ(&sc->sc_mii, MII_TLPHY_CTRL);\n\tif (tlctrl & CTRL_AUISEL) {\n\t\tif (sc->sc_tlphycap & TLPHY_MEDIA_10_2)\n\t\t\tmii->mii_media_active |= IFM_10_2;\n\t\telse if (sc->sc_tlphycap & TLPHY_MEDIA_10_5)\n\t\t\tmii->mii_media_active |= IFM_10_5;\n\t\telse\n\t\t\tprintf(\"%s: AUI selected with no matching media !\\n\",\n\t\t\t    sc->sc_mii.mii_dev.dv_xname);\n\t\tif (tlsc->tl_flags & TL_IFACT)\n\t\t\tmii->mii_media_status |= IFM_ACTIVE;\n\t\treturn;\n\t}\n\n\tbmsr = PHY_READ(&sc->sc_mii, MII_BMSR) |\n\t    PHY_READ(&sc->sc_mii, MII_BMSR);\n\tif (bmsr & BMSR_LINK)   \n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (bmcr & BMCR_LOOP)\n\t\tmii->mii_media_active |= IFM_LOOP;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't have any way to\n\t * tell which media is actually active.  (Note it also\n\t * doesn't self-configure after autonegotiation.)  We\n\t * just have to report what's in the BMCR.\n\t */\n\tif (bmcr & BMCR_FDX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\tmii->mii_media_active |= IFM_10_T;\n}",
    "includes": [
      "#include <dev/pci/if_tlvar.h>",
      "#include <dev/mii/tlphyvar.h>",
      "#include <dev/mii/tlphyreg.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttlphy_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_BMSR"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_BMSR"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: AUI selected with no matching media !\\n\"",
            "sc->sc_mii.mii_dev.dv_xname"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_TLPHY_CTRL"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_BMCR"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttlphy_status;\n\nvoid\ntlphy_status(sc)\n\tstruct tlphy_softc *sc;\n{\n\tstruct mii_data *mii = sc->sc_mii.mii_pdata;\n\tstruct tl_softc *tlsc = (struct tl_softc *)sc->sc_mii.mii_dev.dv_parent;\n\tint bmsr, bmcr, tlctrl;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\tbmcr = PHY_READ(&sc->sc_mii, MII_BMCR);\n\tif (bmcr & BMCR_ISO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\tmii->mii_media_status = 0;  \n\t\treturn;\n\t}\n\n\ttlctrl = PHY_READ(&sc->sc_mii, MII_TLPHY_CTRL);\n\tif (tlctrl & CTRL_AUISEL) {\n\t\tif (sc->sc_tlphycap & TLPHY_MEDIA_10_2)\n\t\t\tmii->mii_media_active |= IFM_10_2;\n\t\telse if (sc->sc_tlphycap & TLPHY_MEDIA_10_5)\n\t\t\tmii->mii_media_active |= IFM_10_5;\n\t\telse\n\t\t\tprintf(\"%s: AUI selected with no matching media !\\n\",\n\t\t\t    sc->sc_mii.mii_dev.dv_xname);\n\t\tif (tlsc->tl_flags & TL_IFACT)\n\t\t\tmii->mii_media_status |= IFM_ACTIVE;\n\t\treturn;\n\t}\n\n\tbmsr = PHY_READ(&sc->sc_mii, MII_BMSR) |\n\t    PHY_READ(&sc->sc_mii, MII_BMSR);\n\tif (bmsr & BMSR_LINK)   \n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (bmcr & BMCR_LOOP)\n\t\tmii->mii_media_active |= IFM_LOOP;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't have any way to\n\t * tell which media is actually active.  (Note it also\n\t * doesn't self-configure after autonegotiation.)  We\n\t * just have to report what's in the BMCR.\n\t */\n\tif (bmcr & BMCR_FDX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\tmii->mii_media_active |= IFM_10_T;\n}"
  },
  {
    "function_name": "tlphy_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
    "lines": "171-290",
    "snippet": "int\ntlphy_service(self, mii, cmd)\n\tstruct mii_softc *self;\n\tstruct mii_data *mii;\n\tint cmd;\n{\n\tstruct tlphy_softc *sc = (struct tlphy_softc *)self;\n\tstruct ifmedia_entry *ife = mii->mii_media.ifm_cur;\n\tint reg;\n\n\tif ((sc->sc_mii.mii_flags & MIIF_DOINGAUTO) == 0 && sc->sc_need_acomp)\n\t\ttlphy_acomp(sc);\n\n\tswitch (cmd) {\n\tcase MII_POLLSTAT:\n\t\t/*\n\t\t * If we're not polling our PHY instance, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->sc_mii.mii_inst)\n\t\t\treturn (0);\n\t\tbreak;\n\n\tcase MII_MEDIACHG:\n\t\t/*\n\t\t * If the media indicates a different PHY instance,\n\t\t * isolate ourselves.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->sc_mii.mii_inst) {\n\t\t\treg = PHY_READ(&sc->sc_mii, MII_BMCR);\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, reg | BMCR_ISO);\n\t\t\treturn (0);\n\t\t}\n\t\t\n\t\t/*\n\t\t * If the interface is not up, don't do anything.\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\tbreak;\n\n\t\tswitch (IFM_SUBTYPE(ife->ifm_media)) {\n\t\tcase IFM_AUTO:\n\t\t\t/*\n\t\t\t * The ThunderLAN PHY doesn't self-configure after\n\t\t\t * an autonegotiation cycle, so there's no such\n\t\t\t * thing as \"already in auto mode\".\n\t\t\t */\n\t\t\t(void) tlphy_auto(sc, 1);\n\t\t\tbreak;\n\t\tcase IFM_10_2:\n\t\tcase IFM_10_5:\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, 0);\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_TLPHY_CTRL, CTRL_AUISEL);\n\t\t\tdelay(100000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_TLPHY_CTRL, 0);\n\t\t\tdelay(100000);\n\t\t\tmii_phy_setmedia(&sc->sc_mii);\n\t\t}\n\t\tbreak;\n\n\tcase MII_TICK:\n\t\t/*\n\t\t * If we're not currently selected, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->sc_mii.mii_inst)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Only used for autonegotiation.\n\t\t */\n\t\tif (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Is the interface even up?\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Check to see if we have link.  If we do, we don't\n\t\t * need to restart the autonegotiation process.  Read\n\t\t * the BMSR twice in case it's latched.\n\t\t *\n\t\t * XXX WHAT ABOUT CHECKING LINK ON THE BNC/AUI?!\n\t\t */\n\t\treg = PHY_READ(&sc->sc_mii, MII_BMSR) |\n\t\t    PHY_READ(&sc->sc_mii, MII_BMSR);\n\t\tif (reg & BMSR_LINK)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Only retry autonegotiation every 5 seconds.\n\t\t */\n\t\tif (++sc->sc_mii.mii_ticks != 5)\n\t\t\treturn (0);\n\n\t\tsc->sc_mii.mii_ticks = 0;\n\t\tmii_phy_reset(&sc->sc_mii);\n\t\tif (tlphy_auto(sc, 0) == EJUSTRETURN)\n\t\t\treturn (0);\n\t\tbreak;\n\n\tcase MII_DOWN:\n\t\tmii_phy_down(sc);\n\t\treturn (0);\n\t}\n\n\t/* Update the media status. */\n\ttlphy_status(sc);\n\n\t/* Callback if something changed. */\n\tif (sc->sc_mii.mii_active != mii->mii_media_active ||\n\t    cmd == MII_MEDIACHG) {\n\t\t(*mii->mii_statchg)(sc->sc_mii.mii_dev.dv_parent);\n\t\tsc->sc_mii.mii_active = mii->mii_media_active;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/if_tlvar.h>",
      "#include <dev/mii/tlphyvar.h>",
      "#include <dev/mii/tlphyreg.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttlphy_service",
      "int\ttlphy_auto",
      "void\ttlphy_acomp",
      "void\ttlphy_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_mii.mii_dev.dv_parent"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlphy_status",
          "args": [
            "sc"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "tlphy_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
          "lines": "292-341",
          "snippet": "void\ntlphy_status(sc)\n\tstruct tlphy_softc *sc;\n{\n\tstruct mii_data *mii = sc->sc_mii.mii_pdata;\n\tstruct tl_softc *tlsc = (struct tl_softc *)sc->sc_mii.mii_dev.dv_parent;\n\tint bmsr, bmcr, tlctrl;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\tbmcr = PHY_READ(&sc->sc_mii, MII_BMCR);\n\tif (bmcr & BMCR_ISO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\tmii->mii_media_status = 0;  \n\t\treturn;\n\t}\n\n\ttlctrl = PHY_READ(&sc->sc_mii, MII_TLPHY_CTRL);\n\tif (tlctrl & CTRL_AUISEL) {\n\t\tif (sc->sc_tlphycap & TLPHY_MEDIA_10_2)\n\t\t\tmii->mii_media_active |= IFM_10_2;\n\t\telse if (sc->sc_tlphycap & TLPHY_MEDIA_10_5)\n\t\t\tmii->mii_media_active |= IFM_10_5;\n\t\telse\n\t\t\tprintf(\"%s: AUI selected with no matching media !\\n\",\n\t\t\t    sc->sc_mii.mii_dev.dv_xname);\n\t\tif (tlsc->tl_flags & TL_IFACT)\n\t\t\tmii->mii_media_status |= IFM_ACTIVE;\n\t\treturn;\n\t}\n\n\tbmsr = PHY_READ(&sc->sc_mii, MII_BMSR) |\n\t    PHY_READ(&sc->sc_mii, MII_BMSR);\n\tif (bmsr & BMSR_LINK)   \n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (bmcr & BMCR_LOOP)\n\t\tmii->mii_media_active |= IFM_LOOP;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't have any way to\n\t * tell which media is actually active.  (Note it also\n\t * doesn't self-configure after autonegotiation.)  We\n\t * just have to report what's in the BMCR.\n\t */\n\tif (bmcr & BMCR_FDX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\tmii->mii_media_active |= IFM_10_T;\n}",
          "includes": [
            "#include <dev/pci/if_tlvar.h>",
            "#include <dev/mii/tlphyvar.h>",
            "#include <dev/mii/tlphyreg.h>",
            "#include <dev/mii/miidevs.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttlphy_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttlphy_status;\n\nvoid\ntlphy_status(sc)\n\tstruct tlphy_softc *sc;\n{\n\tstruct mii_data *mii = sc->sc_mii.mii_pdata;\n\tstruct tl_softc *tlsc = (struct tl_softc *)sc->sc_mii.mii_dev.dv_parent;\n\tint bmsr, bmcr, tlctrl;\n\n\tmii->mii_media_status = IFM_AVALID;\n\tmii->mii_media_active = IFM_ETHER;\n\n\tbmcr = PHY_READ(&sc->sc_mii, MII_BMCR);\n\tif (bmcr & BMCR_ISO) {\n\t\tmii->mii_media_active |= IFM_NONE;\n\t\tmii->mii_media_status = 0;  \n\t\treturn;\n\t}\n\n\ttlctrl = PHY_READ(&sc->sc_mii, MII_TLPHY_CTRL);\n\tif (tlctrl & CTRL_AUISEL) {\n\t\tif (sc->sc_tlphycap & TLPHY_MEDIA_10_2)\n\t\t\tmii->mii_media_active |= IFM_10_2;\n\t\telse if (sc->sc_tlphycap & TLPHY_MEDIA_10_5)\n\t\t\tmii->mii_media_active |= IFM_10_5;\n\t\telse\n\t\t\tprintf(\"%s: AUI selected with no matching media !\\n\",\n\t\t\t    sc->sc_mii.mii_dev.dv_xname);\n\t\tif (tlsc->tl_flags & TL_IFACT)\n\t\t\tmii->mii_media_status |= IFM_ACTIVE;\n\t\treturn;\n\t}\n\n\tbmsr = PHY_READ(&sc->sc_mii, MII_BMSR) |\n\t    PHY_READ(&sc->sc_mii, MII_BMSR);\n\tif (bmsr & BMSR_LINK)   \n\t\tmii->mii_media_status |= IFM_ACTIVE;\n\n\tif (bmcr & BMCR_LOOP)\n\t\tmii->mii_media_active |= IFM_LOOP;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't have any way to\n\t * tell which media is actually active.  (Note it also\n\t * doesn't self-configure after autonegotiation.)  We\n\t * just have to report what's in the BMCR.\n\t */\n\tif (bmcr & BMCR_FDX)\n\t\tmii->mii_media_active |= IFM_FDX;\n\tmii->mii_media_active |= IFM_10_T;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_phy_down",
          "args": [
            "sc"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "183-191",
          "snippet": "void\nmii_phy_down(sc)\n\tstruct mii_softc *sc;\n{\n\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\tsc->mii_flags &= ~MIIF_DOINGAUTO;\n\t\tuntimeout(mii_phy_auto_timeout, sc);\n\t}\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tmii_phy_auto_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\tmii_phy_auto_timeout;\n\nvoid\nmii_phy_down(sc)\n\tstruct mii_softc *sc;\n{\n\tif (sc->mii_flags & MIIF_DOINGAUTO) {\n\t\tsc->mii_flags &= ~MIIF_DOINGAUTO;\n\t\tuntimeout(mii_phy_auto_timeout, sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlphy_auto",
          "args": [
            "sc",
            "0"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "tlphy_auto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
          "lines": "343-369",
          "snippet": "int\ntlphy_auto(sc, waitfor)\n\tstruct tlphy_softc *sc;\n\tint waitfor;\n{\n\tint error;\n\n\tswitch ((error = mii_phy_auto(&sc->sc_mii, waitfor))) {\n\tcase EIO:\n\t\t/*\n\t\t * Just assume we're not in full-duplex mode.\n\t\t * XXX Check link and try AUI/BNC?\n\t\t */\n\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, 0);\n\t\tbreak;\n\n\tcase EJUSTRETURN:\n\t\t/* Flag that we need to program when it completes. */\n\t\tsc->sc_need_acomp = 1;\n\t\tbreak;\n\n\tdefault:\n\t\ttlphy_acomp(sc);\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/pci/if_tlvar.h>",
            "#include <dev/mii/tlphyvar.h>",
            "#include <dev/mii/tlphyreg.h>",
            "#include <dev/mii/miidevs.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ttlphy_auto",
            "void\ttlphy_acomp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttlphy_auto;\nvoid\ttlphy_acomp;\n\nint\ntlphy_auto(sc, waitfor)\n\tstruct tlphy_softc *sc;\n\tint waitfor;\n{\n\tint error;\n\n\tswitch ((error = mii_phy_auto(&sc->sc_mii, waitfor))) {\n\tcase EIO:\n\t\t/*\n\t\t * Just assume we're not in full-duplex mode.\n\t\t * XXX Check link and try AUI/BNC?\n\t\t */\n\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, 0);\n\t\tbreak;\n\n\tcase EJUSTRETURN:\n\t\t/* Flag that we need to program when it completes. */\n\t\tsc->sc_need_acomp = 1;\n\t\tbreak;\n\n\tdefault:\n\t\ttlphy_acomp(sc);\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_phy_reset",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "160-182",
          "snippet": "void\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_BMSR"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_BMSR"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ife->ifm_media"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_INST",
          "args": [
            "ife->ifm_media"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_setmedia",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_setmedia",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "72-97",
          "snippet": "void\nmii_phy_setmedia(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data*mii = sc->mii_pdata;\n\tstruct ifmedia_entry *ife = mii->mii_media.ifm_cur;\n\tint bmcr, anar;\n\n\t/*\n\t * Table index is stored in the media entry.\n\t */\n\n#ifdef DIAGNOSTIC\n\tif (ife->ifm_data < 0 || ife->ifm_data >= MII_NMEDIA)\n\t\tpanic(\"mii_phy_setmedia\");\n#endif\n\n\tanar = mii_media_table[ife->ifm_data].mm_anar;\n\tbmcr = mii_media_table[ife->ifm_data].mm_bmcr;\n\n\tif (ife->ifm_media & IFM_LOOP)\n\t\tbmcr |= BMCR_LOOP;\n\n\tPHY_WRITE(sc, MII_ANAR, anar);\n\tPHY_WRITE(sc, MII_BMCR, bmcr);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct mii_media mii_media_table[] = {\n\t{ BMCR_ISO,\t\tANAR_CSMA },\t\t/* None */\n\t{ 0,\t\t\tANAR_CSMA|ANAR_10 },\t/* 10baseT */\n\t{ BMCR_FDX,\t\tANAR_CSMA|ANAR_10_FD },\t/* 10baseT-FDX */\n\t{ BMCR_S100,\t\tANAR_CSMA|ANAR_T4 },\t/* 100baseT4 */\n\t{ BMCR_S100,\t\tANAR_CSMA|ANAR_TX },\t/* 100baseTX */\n\t{ BMCR_S100|BMCR_FDX,\tANAR_CSMA|ANAR_TX_FD }, /* 100baseTX-FDX */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nconst struct mii_media mii_media_table[] = {\n\t{ BMCR_ISO,\t\tANAR_CSMA },\t\t/* None */\n\t{ 0,\t\t\tANAR_CSMA|ANAR_10 },\t/* 10baseT */\n\t{ BMCR_FDX,\t\tANAR_CSMA|ANAR_10_FD },\t/* 10baseT-FDX */\n\t{ BMCR_S100,\t\tANAR_CSMA|ANAR_T4 },\t/* 100baseT4 */\n\t{ BMCR_S100,\t\tANAR_CSMA|ANAR_TX },\t/* 100baseTX */\n\t{ BMCR_S100|BMCR_FDX,\tANAR_CSMA|ANAR_TX_FD }, /* 100baseTX-FDX */\n};\n\nvoid\nmii_phy_setmedia(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data*mii = sc->mii_pdata;\n\tstruct ifmedia_entry *ife = mii->mii_media.ifm_cur;\n\tint bmcr, anar;\n\n\t/*\n\t * Table index is stored in the media entry.\n\t */\n\n#ifdef DIAGNOSTIC\n\tif (ife->ifm_data < 0 || ife->ifm_data >= MII_NMEDIA)\n\t\tpanic(\"mii_phy_setmedia\");\n#endif\n\n\tanar = mii_media_table[ife->ifm_data].mm_anar;\n\tbmcr = mii_media_table[ife->ifm_data].mm_bmcr;\n\n\tif (ife->ifm_media & IFM_LOOP)\n\t\tbmcr |= BMCR_LOOP;\n\n\tPHY_WRITE(sc, MII_ANAR, anar);\n\tPHY_WRITE(sc, MII_BMCR, bmcr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100000"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_WRITE",
          "args": [
            "&sc->sc_mii",
            "MII_TLPHY_CTRL",
            "0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_WRITE",
          "args": [
            "&sc->sc_mii",
            "MII_TLPHY_CTRL",
            "CTRL_AUISEL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_WRITE",
          "args": [
            "&sc->sc_mii",
            "MII_BMCR",
            "0"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ife->ifm_media"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_WRITE",
          "args": [
            "&sc->sc_mii",
            "MII_BMCR",
            "reg | BMCR_ISO"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_BMCR"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_INST",
          "args": [
            "ife->ifm_media"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_INST",
          "args": [
            "ife->ifm_media"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlphy_acomp",
          "args": [
            "sc"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "tlphy_acomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
          "lines": "371-394",
          "snippet": "void\ntlphy_acomp(sc)\n\tstruct tlphy_softc *sc;\n{\n\tint aner, anlpar;\n\n\tsc->sc_need_acomp = 0;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't self-configure\n\t * after autonegotiation.  We have to do it ourselves\n\t * based on the link partner status.\n\t */\n\n\taner = PHY_READ(&sc->sc_mii, MII_ANER);\n\tif (aner & ANER_LPAN) {\n\t\tanlpar = PHY_READ(&sc->sc_mii, MII_ANLPAR) &\n\t\t    PHY_READ(&sc->sc_mii, MII_ANAR);\n\t\tif (anlpar & ANAR_10_FD) {\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, BMCR_FDX);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_tlvar.h>",
            "#include <dev/mii/tlphyvar.h>",
            "#include <dev/mii/tlphyreg.h>",
            "#include <dev/mii/miidevs.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttlphy_acomp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttlphy_acomp;\n\nvoid\ntlphy_acomp(sc)\n\tstruct tlphy_softc *sc;\n{\n\tint aner, anlpar;\n\n\tsc->sc_need_acomp = 0;\n\n\t/*\n\t * Grr, braindead ThunderLAN PHY doesn't self-configure\n\t * after autonegotiation.  We have to do it ourselves\n\t * based on the link partner status.\n\t */\n\n\taner = PHY_READ(&sc->sc_mii, MII_ANER);\n\tif (aner & ANER_LPAN) {\n\t\tanlpar = PHY_READ(&sc->sc_mii, MII_ANLPAR) &\n\t\t    PHY_READ(&sc->sc_mii, MII_ANAR);\n\t\tif (anlpar & ANAR_10_FD) {\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, BMCR_FDX);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttlphy_service;\nint\ttlphy_auto;\nvoid\ttlphy_acomp;\nvoid\ttlphy_status;\n\nint\ntlphy_service(self, mii, cmd)\n\tstruct mii_softc *self;\n\tstruct mii_data *mii;\n\tint cmd;\n{\n\tstruct tlphy_softc *sc = (struct tlphy_softc *)self;\n\tstruct ifmedia_entry *ife = mii->mii_media.ifm_cur;\n\tint reg;\n\n\tif ((sc->sc_mii.mii_flags & MIIF_DOINGAUTO) == 0 && sc->sc_need_acomp)\n\t\ttlphy_acomp(sc);\n\n\tswitch (cmd) {\n\tcase MII_POLLSTAT:\n\t\t/*\n\t\t * If we're not polling our PHY instance, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->sc_mii.mii_inst)\n\t\t\treturn (0);\n\t\tbreak;\n\n\tcase MII_MEDIACHG:\n\t\t/*\n\t\t * If the media indicates a different PHY instance,\n\t\t * isolate ourselves.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->sc_mii.mii_inst) {\n\t\t\treg = PHY_READ(&sc->sc_mii, MII_BMCR);\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, reg | BMCR_ISO);\n\t\t\treturn (0);\n\t\t}\n\t\t\n\t\t/*\n\t\t * If the interface is not up, don't do anything.\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\tbreak;\n\n\t\tswitch (IFM_SUBTYPE(ife->ifm_media)) {\n\t\tcase IFM_AUTO:\n\t\t\t/*\n\t\t\t * The ThunderLAN PHY doesn't self-configure after\n\t\t\t * an autonegotiation cycle, so there's no such\n\t\t\t * thing as \"already in auto mode\".\n\t\t\t */\n\t\t\t(void) tlphy_auto(sc, 1);\n\t\t\tbreak;\n\t\tcase IFM_10_2:\n\t\tcase IFM_10_5:\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_BMCR, 0);\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_TLPHY_CTRL, CTRL_AUISEL);\n\t\t\tdelay(100000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPHY_WRITE(&sc->sc_mii, MII_TLPHY_CTRL, 0);\n\t\t\tdelay(100000);\n\t\t\tmii_phy_setmedia(&sc->sc_mii);\n\t\t}\n\t\tbreak;\n\n\tcase MII_TICK:\n\t\t/*\n\t\t * If we're not currently selected, just return.\n\t\t */\n\t\tif (IFM_INST(ife->ifm_media) != sc->sc_mii.mii_inst)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Only used for autonegotiation.\n\t\t */\n\t\tif (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Is the interface even up?\n\t\t */\n\t\tif ((mii->mii_ifp->if_flags & IFF_UP) == 0)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Check to see if we have link.  If we do, we don't\n\t\t * need to restart the autonegotiation process.  Read\n\t\t * the BMSR twice in case it's latched.\n\t\t *\n\t\t * XXX WHAT ABOUT CHECKING LINK ON THE BNC/AUI?!\n\t\t */\n\t\treg = PHY_READ(&sc->sc_mii, MII_BMSR) |\n\t\t    PHY_READ(&sc->sc_mii, MII_BMSR);\n\t\tif (reg & BMSR_LINK)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Only retry autonegotiation every 5 seconds.\n\t\t */\n\t\tif (++sc->sc_mii.mii_ticks != 5)\n\t\t\treturn (0);\n\n\t\tsc->sc_mii.mii_ticks = 0;\n\t\tmii_phy_reset(&sc->sc_mii);\n\t\tif (tlphy_auto(sc, 0) == EJUSTRETURN)\n\t\t\treturn (0);\n\t\tbreak;\n\n\tcase MII_DOWN:\n\t\tmii_phy_down(sc);\n\t\treturn (0);\n\t}\n\n\t/* Update the media status. */\n\ttlphy_status(sc);\n\n\t/* Callback if something changed. */\n\tif (sc->sc_mii.mii_active != mii->mii_media_active ||\n\t    cmd == MII_MEDIACHG) {\n\t\t(*mii->mii_statchg)(sc->sc_mii.mii_dev.dv_parent);\n\t\tsc->sc_mii.mii_active = mii->mii_media_active;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "tlphyattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
    "lines": "131-169",
    "snippet": "void\ntlphyattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct tlphy_softc *sc = (struct tlphy_softc *)self;\n\tstruct tl_softc *tlsc = (struct tl_softc *)self->dv_parent;\n\tstruct mii_attach_args *ma = aux;\n\tstruct mii_data *mii = ma->mii_data;\n\n\tprintf(\": %s, rev. %d\\n\", MII_STR_xxTI_TLAN10T,\n\t    MII_REV(ma->mii_id2));\n\n\tsc->sc_mii.mii_inst = mii->mii_instance;\n\tsc->sc_mii.mii_phy = ma->mii_phyno;\n\tsc->sc_mii.mii_service = tlphy_service;\n\tsc->sc_mii.mii_pdata = mii;\n\n\tmii_phy_reset(&sc->sc_mii);\n\n\t/*\n\t * Note that if we're on a device that also supports 100baseTX,\n\t * we are not going to want to use the built-in 10baseT port,\n\t * since there will be another PHY on the MII wired up to the\n\t * UTP connector.  The parent indicates this to us by specifying\n\t * the TLPHY_MEDIA_NO_10_T bit.\n\t */\n\tsc->sc_tlphycap = tlsc->tl_product->tp_tlphymedia;\n\tif ((sc->sc_tlphycap & TLPHY_MEDIA_NO_10_T) == 0)\n\t\tsc->sc_mii.mii_capabilities =\n\t\t    PHY_READ(&sc->sc_mii, MII_BMSR) & ma->mii_capmask;\n\telse\n\t\tsc->sc_mii.mii_capabilities = 0;\n\n\tif (sc->sc_mii.mii_capabilities & BMSR_MEDIAMASK) {\n\t\tmii_add_media(mii, sc->sc_mii.mii_capabilities,\n\t\t    sc->sc_mii.mii_inst);\n\t}\n}",
    "includes": [
      "#include <dev/pci/if_tlvar.h>",
      "#include <dev/mii/tlphyvar.h>",
      "#include <dev/mii/tlphyreg.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttlphyattach",
      "int\ttlphy_service"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_add_media",
          "args": [
            "mii",
            "sc->sc_mii.mii_capabilities",
            "sc->sc_mii.mii_inst"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "mii_add_media",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "198-248",
          "snippet": "void\nmii_add_media(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\n#define\tADD(m, c)\tifmedia_add(&mii->mii_media, (m), (c), NULL)\n\n\tif ((sc->mii_flags & MIIF_NOISOLATE) == 0)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),\n\t\t    MII_MEDIA_NONE);\n\n\tif (sc->mii_capabilities & BMSR_10THDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),\n\t\t    MII_MEDIA_10_T);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_10_T);\n#endif\n\t}\n\n\tif (sc->mii_capabilities & BMSR_10TFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_10_T_FDX);\n\tif (sc->mii_capabilities & BMSR_100TXHDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_100TXFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX_FDX);\n\tif (sc->mii_capabilities & BMSR_100T4) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_T4);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_ANEG)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst),\n\t\t    MII_NMEDIA);\t/* intentionally invalid index */\n#undef ADD\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_add_media(sc)\n\tstruct mii_softc *sc;\n{\n\tstruct mii_data *mii = sc->mii_pdata;\n\n#define\tADD(m, c)\tifmedia_add(&mii->mii_media, (m), (c), NULL)\n\n\tif ((sc->mii_flags & MIIF_NOISOLATE) == 0)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),\n\t\t    MII_MEDIA_NONE);\n\n\tif (sc->mii_capabilities & BMSR_10THDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),\n\t\t    MII_MEDIA_10_T);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_10_T);\n#endif\n\t}\n\n\tif (sc->mii_capabilities & BMSR_10TFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_10_T_FDX);\n\tif (sc->mii_capabilities & BMSR_100TXHDX) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_100TXFDX)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),\n\t\t    MII_MEDIA_100_TX_FDX);\n\tif (sc->mii_capabilities & BMSR_100T4) {\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, 0, sc->mii_inst),\n\t\t    MII_MEDIA_100_T4);\n#if 0\n\t\tif ((sc->mii_flags & MIIF_NOLOOP) == 0)\n\t\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,\n\t\t\t    sc->mii_inst), MII_MEDIA_100_T4);\n#endif\n\t}\n\tif (sc->mii_capabilities & BMSR_ANEG)\n\t\tADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst),\n\t\t    MII_NMEDIA);\t/* intentionally invalid index */\n#undef ADD\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHY_READ",
          "args": [
            "&sc->sc_mii",
            "MII_BMSR"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_reset",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "160-182",
          "snippet": "void\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": %s, rev. %d\\n\"",
            "MII_STR_xxTI_TLAN10T",
            "MII_REV(ma->mii_id2)"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MII_REV",
          "args": [
            "ma->mii_id2"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ttlphyattach;\nint\ttlphy_service;\n\nvoid\ntlphyattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct tlphy_softc *sc = (struct tlphy_softc *)self;\n\tstruct tl_softc *tlsc = (struct tl_softc *)self->dv_parent;\n\tstruct mii_attach_args *ma = aux;\n\tstruct mii_data *mii = ma->mii_data;\n\n\tprintf(\": %s, rev. %d\\n\", MII_STR_xxTI_TLAN10T,\n\t    MII_REV(ma->mii_id2));\n\n\tsc->sc_mii.mii_inst = mii->mii_instance;\n\tsc->sc_mii.mii_phy = ma->mii_phyno;\n\tsc->sc_mii.mii_service = tlphy_service;\n\tsc->sc_mii.mii_pdata = mii;\n\n\tmii_phy_reset(&sc->sc_mii);\n\n\t/*\n\t * Note that if we're on a device that also supports 100baseTX,\n\t * we are not going to want to use the built-in 10baseT port,\n\t * since there will be another PHY on the MII wired up to the\n\t * UTP connector.  The parent indicates this to us by specifying\n\t * the TLPHY_MEDIA_NO_10_T bit.\n\t */\n\tsc->sc_tlphycap = tlsc->tl_product->tp_tlphymedia;\n\tif ((sc->sc_tlphycap & TLPHY_MEDIA_NO_10_T) == 0)\n\t\tsc->sc_mii.mii_capabilities =\n\t\t    PHY_READ(&sc->sc_mii, MII_BMSR) & ma->mii_capmask;\n\telse\n\t\tsc->sc_mii.mii_capabilities = 0;\n\n\tif (sc->sc_mii.mii_capabilities & BMSR_MEDIAMASK) {\n\t\tmii_add_media(mii, sc->sc_mii.mii_capabilities,\n\t\t    sc->sc_mii.mii_inst);\n\t}\n}"
  },
  {
    "function_name": "tlphymatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/tlphy.c",
    "lines": "116-129",
    "snippet": "int\ntlphymatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct mii_attach_args *ma = aux;       \n\n\tif (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxTI &&\n\t    MII_MODEL(ma->mii_id2) == MII_MODEL_xxTI_TLAN10T)\n\t\treturn (10);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/if_tlvar.h>",
      "#include <dev/mii/tlphyvar.h>",
      "#include <dev/mii/tlphyreg.h>",
      "#include <dev/mii/miidevs.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttlphymatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MII_MODEL",
          "args": [
            "ma->mii_id2"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_OUI",
          "args": [
            "ma->mii_id1",
            "ma->mii_id2"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_tlvar.h>\n#include <dev/mii/tlphyvar.h>\n#include <dev/mii/tlphyreg.h>\n#include <dev/mii/miidevs.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ttlphymatch;\n\nint\ntlphymatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct mii_attach_args *ma = aux;       \n\n\tif (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxTI &&\n\t    MII_MODEL(ma->mii_id2) == MII_MODEL_xxTI_TLAN10T)\n\t\treturn (10);\n\n\treturn (0);\n}"
  }
]