[
  {
    "function_name": "bah_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "1220-1228",
    "snippet": "void\nbah_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc = ifp->if_softc;\n\n\tsc->sc_base->command = ARC_TXDIS;\n\treturn;\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tbah_watchdog"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_watchdog;\n\nvoid\nbah_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc = ifp->if_softc;\n\n\tsc->sc_base->command = ARC_TXDIS;\n\treturn;\n}"
  },
  {
    "function_name": "bah_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "1143-1204",
    "snippet": "int\nbah_ioctl(ifp, command, data)\n\tregister struct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct bah_softc *sc;\n\tregister struct ifaddr *ifa;\n\tint s, error;\n\n\terror = 0;\n\tsc = ifp->if_softc;\n\tifa = (struct ifaddr *)data;\n\ts = splnet();\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 2) \n\tprintf(\"%s: ioctl() called, cmd = 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, command);\n#endif\n\n\tswitch (command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tbah_init(sc);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbah_init(sc);\n\t\t\tbreak;\n\t\t}\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, \n\t\t\t * then stop it.\n\t\t\t */\n\t\t\tbah_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tbah_init(sc);\n\t\t} \n\t\tbreak;\n\n\t\t/* Multicast not supported */\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tbah_init",
      "void\tbah_stop",
      "int\tbah_ioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bah_init",
          "args": [
            "sc"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "bah_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "311-327",
          "snippet": "void\nbah_init(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint s;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\ts = splnet();\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tbah_reset(sc);\n\t\tbah_start(ifp);\n\t\tsplx(s);\n\t}\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tbah_init",
            "void\tbah_reset",
            "void\tbah_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_init;\nvoid\tbah_reset;\nvoid\tbah_start;\n\nvoid\nbah_init(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint s;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\ts = splnet();\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tbah_reset(sc);\n\t\tbah_start(ifp);\n\t\tsplx(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bah_stop",
          "args": [
            "sc"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "bah_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "425-459",
          "snippet": "void\nbah_stop(sc)\n\tstruct bah_softc *sc;\n{\n\t/* Stop the interrupts */\n\tsc->sc_base->status = 0;\n\n\t/* Stop the interface */\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\n\t/* Stop watchdog timer */\n\tsc->sc_arccom.ac_if.if_timer = 0;\n\n#ifdef BAHTIMINGS\n\tlog(LOG_DEBUG,\"%s: to board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyout, sc->sc_stats.maxcopyout);\n\n\tlog(LOG_DEBUG,\"%s: from board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyin, sc->sc_stats.maxcopyin);\n\t\n\tlog(LOG_DEBUG,\"%s: send time: %6lu .. %6lu mics/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.minsend, sc->sc_stats.maxsend);\n\n\tsc->sc_stats.minsend = \n\t    sc->sc_stats.mincopyout = \n\t    sc->sc_stats.mincopyin = ULONG_MAX;\n\tsc->sc_stats.maxsend = \n\t    sc->sc_stats.maxcopyout = \n\t    sc->sc_stats.maxcopyin = 0;\n#endif\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tbah_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_stop;\n\nvoid\nbah_stop(sc)\n\tstruct bah_softc *sc;\n{\n\t/* Stop the interrupts */\n\tsc->sc_base->status = 0;\n\n\t/* Stop the interface */\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\n\t/* Stop watchdog timer */\n\tsc->sc_arccom.ac_if.if_timer = 0;\n\n#ifdef BAHTIMINGS\n\tlog(LOG_DEBUG,\"%s: to board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyout, sc->sc_stats.maxcopyout);\n\n\tlog(LOG_DEBUG,\"%s: from board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyin, sc->sc_stats.maxcopyin);\n\t\n\tlog(LOG_DEBUG,\"%s: send time: %6lu .. %6lu mics/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.minsend, sc->sc_stats.maxsend);\n\n\tsc->sc_stats.minsend = \n\t    sc->sc_stats.mincopyout = \n\t    sc->sc_stats.mincopyin = ULONG_MAX;\n\tsc->sc_stats.maxsend = \n\t    sc->sc_stats.maxcopyout = \n\t    sc->sc_stats.maxcopyin = 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ioctl() called, cmd = 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "command"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_init;\nvoid\tbah_stop;\nint\tbah_ioctl;\n\nint\nbah_ioctl(ifp, command, data)\n\tregister struct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct bah_softc *sc;\n\tregister struct ifaddr *ifa;\n\tint s, error;\n\n\terror = 0;\n\tsc = ifp->if_softc;\n\tifa = (struct ifaddr *)data;\n\ts = splnet();\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 2) \n\tprintf(\"%s: ioctl() called, cmd = 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, command);\n#endif\n\n\tswitch (command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tbah_init(sc);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbah_init(sc);\n\t\t\tbreak;\n\t\t}\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, \n\t\t\t * then stop it.\n\t\t\t */\n\t\t\tbah_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tbah_init(sc);\n\t\t} \n\t\tbreak;\n\n\t\t/* Multicast not supported */\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "bahintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "1018-1137",
    "snippet": "int\nbahintr(sc)\n\tstruct bah_softc *sc;\n{\n\tu_char isr, maskedisr;\n\tint buffer;\n\tu_long newsec;\n\n\tisr = sc->sc_base->status;\n\tmaskedisr = isr & sc->sc_intmask;\n\tif (!maskedisr) \n\t\treturn (0);\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG>1)\n\tprintf(\"%s: intr: status 0x%02x, intmask 0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, isr, sc->sc_intmask);\n#endif\n\n\tif (maskedisr & ARC_POR) {\n\t\tsc->sc_arccom.ac_anaddr = sc->sc_base->dipswitches;\n\t\tsc->sc_base->command = ARC_CLR(CLR_POR);\n\t\tlog(LOG_WARNING, \"%s: intr: got spurious power on reset int\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n\n\tif (maskedisr & ARC_RECON) {\n\t\t/*\n\t\t * we dont need to:\n\t\t * sc->sc_base->command = ARC_CONF(CONF_LONG);\n\t\t */\n\t\tsc->sc_base->command = ARC_CLR(CLR_RECONFIG);\n\t\tsc->sc_arccom.ac_if.if_collisions++;\n\n\t\t/*\n\t\t * If more than 2 seconds per reconfig:\n\t\t *\tReset time and counter.\n\t\t * else:\n\t\t *\tIf more than ARC_EXCESSIVE_RECONFIGS reconfigs\n\t\t *\tsince last burst, complain and set treshold for\n\t\t *\twarnings to ARC_EXCESSIVE_RECONS_REWARN.\n\t\t *\n\t\t * This allows for, e.g., new stations on the cable, or\n\t\t * cable switching as long as it is over after (normally)\n\t\t * 16 seconds.\n\t\t *\n\t\t * XXX TODO: check timeout bits in status word and double\n\t\t * time if necessary.\n\t\t */\n\n\t\tnewsec = time.tv_sec;\n\t\tif (newsec - sc->sc_recontime > 2 * sc->sc_reconcount) {\n\t\t\tsc->sc_recontime = newsec;\n\t\t\tsc->sc_reconcount = 0;\n\t\t\tsc->sc_reconcount_excessive = ARC_EXCESSIVE_RECONS;\n\t\t} else if (++sc->sc_reconcount > sc->sc_reconcount_excessive) {\n\t\t\tsc->sc_reconcount_excessive = \n\t\t\t    ARC_EXCESSIVE_RECONS_REWARN;\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: excessive token losses, cable problem?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_recontime = newsec;\n\t\t\tsc->sc_reconcount = 0;\n\t\t}\n\t}\n\n\tif (maskedisr & ARC_RI) {\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 1)\n\t\tprintf(\"%s: intr: hard rint, act %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_rx_act);\n#endif\n\t\n\t\tbuffer = sc->sc_rx_act;\n\t\t/* look if buffer is marked invalid: */\n\t\tif (sc->sc_base->buffers[buffer*512*2] == 0) {\n\t/* invalid marked buffer (or illegally configured sender) */\n\t\t\tlog(LOG_WARNING, \n\t\t\t    \"%s: spurious RX interrupt or sender 0 (ignored)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/*\n\t\t\t * restart receiver on same buffer.\n\t\t\t */\n\t\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\n\t\t} else if (++sc->sc_rx_fillcount > 1) {\n\t\t\tsc->sc_intmask &= ~ARC_RI;\n\t\t\tsc->sc_base->status = sc->sc_intmask;\n\t\t} else {\n\n\t\t\tbuffer ^= 1;\n\t\t\tsc->sc_rx_act = buffer;\n\n\t\t\t/*\n\t\t\t * Start receiver on other receive buffer.\n\t\t\t * This also clears the RI interupt flag.\n\t\t\t */\n\t\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\t\t\t/* we are in the RX intr, so mask is ok for RX */\n\n#ifdef BAH_DEBUG\n\t\t\tprintf(\"%s: started rx for buffer %ld, status 0x%02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_rx_act,\n\t\t\t    sc->sc_base->status);\n#endif\n\t\t}\n\n#ifdef BAHSOFTCOPY\n\t\t/* this one starts a soft int to copy out of the hw */\n\t\tadd_sicallback((sifunc_t)bah_srint, sc,NULL);\n#else\n\t\t/* this one does the copy here */\n\t\tbah_srint(sc,NULL);\n#endif\n\t}\n\n\tif (maskedisr & ARC_TA) \n\t\tbah_tint(sc, isr);\n\n\treturn (1);\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ARC_EXCESSIVE_RECONS_REWARN 400",
      "#define ARC_EXCESSIVE_RECONS 20",
      "#define BAHSOFTCOPY /**/"
    ],
    "globals_used": [
      "int\tbahintr",
      "void\tbah_srint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bah_tint",
          "args": [
            "sc",
            "isr"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "bah_tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "914-1013",
          "snippet": "__inline static void\nbah_tint(sc, isr)\n\tstruct bah_softc *sc;\n\tint isr;\n{\n\tstruct ifnet *ifp;\n\n\tint buffer;\n#ifdef BAHTIMINGS\n\tint clknow;\n#endif\n\n\tifp = &(sc->sc_arccom.ac_if);\n\tbuffer = sc->sc_tx_act;\n\n\t/*\n\t * retransmit code:  \n\t * Normal situtations first for fast path:\n\t * If acknowledgement received ok or broadcast, we're ok.\n\t * else if \n\t */ \n\n\tif (isr & ARC_TMA || sc->sc_broadcast[buffer])\n\t\tsc->sc_arccom.ac_if.if_opackets++;\n#ifdef BAHRETRANSMIT\n\telse if (ifp->if_flags & IFF_LINK2 && ifp->if_timer > 0 \n\t    && --sc->sc_retransmits[buffer] > 0) {\n\t\t/* retransmit same buffer */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\treturn;\n\t}\n#endif\n\telse\n\t\tifp->if_oerrors++;\n\t\t\n\t\t\n#ifdef BAHTIMINGS\n\tclknow = clkread();\n\n\tsc->sc_stats.minsend = ulmin(sc->sc_stats.minsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n\n\tsc->sc_stats.maxsend = ulmax(sc->sc_stats.maxsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n#endif\n\n\t/* We know we can accept another buffer at this point. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (--sc->sc_tx_fillcount > 0) {\n\n\t\t/* \n\t\t * start tx on other buffer.\n\t\t * This also clears the int flag\n\t\t */\n\t\tbuffer ^= 1;\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * already given:\n\t\t * sc->sc_intmask |= ARC_TA; \n\t\t * sc->sc_base->status = sc->sc_intmask;\n\t\t */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\t/* init watchdog timer */\n\t\tifp->if_timer = ARCTIMEOUT;\n\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n \n#if defined(BAH_DEBUG) && (BAH_DEBUG > 1)\n\t\tprintf(\"%s: tint: starting tx on buffer %d, status 0x%02x\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer, sc->sc_base->status);\n#endif\n\t} else {\n\t\t/* have to disable TX interrupt */\n\t\tsc->sc_intmask &= ~ARC_TA;\n\t\tsc->sc_base->status = sc->sc_intmask;\n\t\t/* ... and watchdog timer */\n\t\tifp->if_timer = 0;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: tint: no more buffers to send, status 0x%02x\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\t}\n\n#ifdef BAHSOFTCOPY\n\t/* schedule soft int to fill a new buffer for us */\n\tadd_sicallback((sifunc_t)callstart, sc, NULL);\n#else\n\t/* call it directly */\n\tcallstart(sc, NULL);\n#endif\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ARCTIMEOUT (5*IFNET_SLOWHZ)",
            "#define BAHRETRANSMIT /**/",
            "#define BAHSOFTCOPY /**/"
          ],
          "globals_used": [
            "void\tcallstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARCTIMEOUT (5*IFNET_SLOWHZ)\n#define BAHRETRANSMIT /**/\n#define BAHSOFTCOPY /**/\n\nvoid\tcallstart;\n\n__inline static void\nbah_tint(sc, isr)\n\tstruct bah_softc *sc;\n\tint isr;\n{\n\tstruct ifnet *ifp;\n\n\tint buffer;\n#ifdef BAHTIMINGS\n\tint clknow;\n#endif\n\n\tifp = &(sc->sc_arccom.ac_if);\n\tbuffer = sc->sc_tx_act;\n\n\t/*\n\t * retransmit code:  \n\t * Normal situtations first for fast path:\n\t * If acknowledgement received ok or broadcast, we're ok.\n\t * else if \n\t */ \n\n\tif (isr & ARC_TMA || sc->sc_broadcast[buffer])\n\t\tsc->sc_arccom.ac_if.if_opackets++;\n#ifdef BAHRETRANSMIT\n\telse if (ifp->if_flags & IFF_LINK2 && ifp->if_timer > 0 \n\t    && --sc->sc_retransmits[buffer] > 0) {\n\t\t/* retransmit same buffer */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\treturn;\n\t}\n#endif\n\telse\n\t\tifp->if_oerrors++;\n\t\t\n\t\t\n#ifdef BAHTIMINGS\n\tclknow = clkread();\n\n\tsc->sc_stats.minsend = ulmin(sc->sc_stats.minsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n\n\tsc->sc_stats.maxsend = ulmax(sc->sc_stats.maxsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n#endif\n\n\t/* We know we can accept another buffer at this point. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (--sc->sc_tx_fillcount > 0) {\n\n\t\t/* \n\t\t * start tx on other buffer.\n\t\t * This also clears the int flag\n\t\t */\n\t\tbuffer ^= 1;\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * already given:\n\t\t * sc->sc_intmask |= ARC_TA; \n\t\t * sc->sc_base->status = sc->sc_intmask;\n\t\t */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\t/* init watchdog timer */\n\t\tifp->if_timer = ARCTIMEOUT;\n\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n \n#if defined(BAH_DEBUG) && (BAH_DEBUG > 1)\n\t\tprintf(\"%s: tint: starting tx on buffer %d, status 0x%02x\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer, sc->sc_base->status);\n#endif\n\t} else {\n\t\t/* have to disable TX interrupt */\n\t\tsc->sc_intmask &= ~ARC_TA;\n\t\tsc->sc_base->status = sc->sc_intmask;\n\t\t/* ... and watchdog timer */\n\t\tifp->if_timer = 0;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: tint: no more buffers to send, status 0x%02x\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\t}\n\n#ifdef BAHSOFTCOPY\n\t/* schedule soft int to fill a new buffer for us */\n\tadd_sicallback((sifunc_t)callstart, sc, NULL);\n#else\n\t/* call it directly */\n\tcallstart(sc, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bah_srint",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "bah_srint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "765-912",
          "snippet": "void\nbah_srint(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\tint buffer, len, len1, amount, offset, s, i, type;\n\tu_char __volatile *bah_ram_ptr;\n\tstruct mbuf *m, *dst, *head;\n\tstruct arc_header *ah;\n\tstruct ifnet *ifp;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\tsc = (struct bah_softc *)vsc;\n\tifp = &sc->sc_arccom.ac_if;\n\thead = 0;\n\n\ts = splnet();\n\tbuffer = sc->sc_rx_act ^ 1;\n\tsplx(s);\n\n\t/* Allocate header mbuf */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\n\tif (m == 0) {\n\t\t/* \n\t \t * in case s.th. goes wrong with mem, drop it\n\t \t * to make sure the receiver can be started again\n\t\t * count it as input error (we dont have any other\n\t\t * detectable)\n\t \t */\n\t\tifp->if_ierrors++;\n\t\tgoto cleanup;\n\t}\n\t\t\t\n\tm->m_pkthdr.rcvif = ifp;\n\n\t/*\n\t * Align so that IP packet will be longword aligned. Here we\n\t * assume that m_data of new packet is longword aligned.\n\t * When implementing PHDS, we might have to change it to 2,\n\t * (2*sizeof(ulong) - ARC_HDRNEWLEN)), packet type dependent.\n\t */\n\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\toffset = bah_ram_ptr[2*2];\n\tif (offset)\n\t\tlen = 256 - offset;\n\telse {\n\t\toffset = bah_ram_ptr[3*2];\n\t\tlen = 512 - offset;\n\t}\n\ttype = bah_ram_ptr[offset*2];\n\tm->m_data += 1 + arc_isphds(type);\n\n\thead = m;\n\tah = mtod(head, struct arc_header *);\n\t\t\n\tah->arc_shost = bah_ram_ptr[0*2];\n\tah->arc_dhost = bah_ram_ptr[1*2];\n\n\tm->m_pkthdr.len = len+2; /* whole packet length */\n\tm->m_len = 2;\t\t /* mbuf filled with ARCnet addresses */\n\tbah_ram_ptr += offset*2; /* ram buffer continues there */\n\n\twhile (len > 0) {\n\t\n\t\tlen1 = len;\n\t\tamount = M_TRAILINGSPACE(m);\n\n\t\tif (amount == 0) {\n\t\t\tdst = m;\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\n\t\t\tif (m == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\n\t\t\tif (len1 >= MINCLSIZE)\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\n\t\t\tm->m_len = 0;\n\t\t\tdst->m_next = m;\n\t\t\tamount = M_TRAILINGSPACE(m);\n\t\t}\n\n\t\tif (amount < len1)\n\t\t\tlen1 = amount;\n\n#ifdef BAHTIMINGS\n\t\tlencopy = len;\n\t\tcopystart = clkread();\n#endif\n\n\t\tmovepin(bah_ram_ptr, mtod(m, u_char *) + m->m_len, len1);\n\n#ifdef BAHTIMINGS\n\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\tsc->sc_stats.mincopyin =\n\t\t    ulmin(sc->sc_stats.mincopyin, perbyte);\n\t\tsc->sc_stats.maxcopyin =\n\t\t    ulmax(sc->sc_stats.maxcopyin, perbyte);\n#endif\n\n\t\tm->m_len += len1;\n\t\tbah_ram_ptr += len1*2;\n\t\tlen -= len1;\n\t}\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, head);\n#endif\n\n\tarc_input(&sc->sc_arccom.ac_if, head);\n\n\t/* arc_input has freed it, we dont need to... */\n\n\thead = NULL;\n\tifp->if_ipackets++;\n\t\ncleanup:\n\n\tif (head != NULL)\n\t\tm_freem(head);\n\n\t/* mark buffer as invalid by source id 0 */\n\tsc->sc_base->buffers[buffer*512*2] = 0;\n\ts = splnet();\n\n\tif (--sc->sc_rx_fillcount == 2 - 1) {\n\n\t\t/* was off, restart it on buffer just emptied */\n\t\tsc->sc_rx_act = buffer;\n\t\tsc->sc_intmask |= ARC_RI;\n\n\t\t/* this also clears the RI flag interupt: */\n\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\t\tsc->sc_base->status = sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: srint: restarted rx on buf %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tmovepin",
            "__P((u_char __volatile *from, u_char *to, int len));",
            "void\tbah_srint"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tmovepin;\n__P((u_char __volatile *from, u_char *to, int len));\nvoid\tbah_srint;\n\nvoid\nbah_srint(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\tint buffer, len, len1, amount, offset, s, i, type;\n\tu_char __volatile *bah_ram_ptr;\n\tstruct mbuf *m, *dst, *head;\n\tstruct arc_header *ah;\n\tstruct ifnet *ifp;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\tsc = (struct bah_softc *)vsc;\n\tifp = &sc->sc_arccom.ac_if;\n\thead = 0;\n\n\ts = splnet();\n\tbuffer = sc->sc_rx_act ^ 1;\n\tsplx(s);\n\n\t/* Allocate header mbuf */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\n\tif (m == 0) {\n\t\t/* \n\t \t * in case s.th. goes wrong with mem, drop it\n\t \t * to make sure the receiver can be started again\n\t\t * count it as input error (we dont have any other\n\t\t * detectable)\n\t \t */\n\t\tifp->if_ierrors++;\n\t\tgoto cleanup;\n\t}\n\t\t\t\n\tm->m_pkthdr.rcvif = ifp;\n\n\t/*\n\t * Align so that IP packet will be longword aligned. Here we\n\t * assume that m_data of new packet is longword aligned.\n\t * When implementing PHDS, we might have to change it to 2,\n\t * (2*sizeof(ulong) - ARC_HDRNEWLEN)), packet type dependent.\n\t */\n\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\toffset = bah_ram_ptr[2*2];\n\tif (offset)\n\t\tlen = 256 - offset;\n\telse {\n\t\toffset = bah_ram_ptr[3*2];\n\t\tlen = 512 - offset;\n\t}\n\ttype = bah_ram_ptr[offset*2];\n\tm->m_data += 1 + arc_isphds(type);\n\n\thead = m;\n\tah = mtod(head, struct arc_header *);\n\t\t\n\tah->arc_shost = bah_ram_ptr[0*2];\n\tah->arc_dhost = bah_ram_ptr[1*2];\n\n\tm->m_pkthdr.len = len+2; /* whole packet length */\n\tm->m_len = 2;\t\t /* mbuf filled with ARCnet addresses */\n\tbah_ram_ptr += offset*2; /* ram buffer continues there */\n\n\twhile (len > 0) {\n\t\n\t\tlen1 = len;\n\t\tamount = M_TRAILINGSPACE(m);\n\n\t\tif (amount == 0) {\n\t\t\tdst = m;\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\n\t\t\tif (m == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\n\t\t\tif (len1 >= MINCLSIZE)\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\n\t\t\tm->m_len = 0;\n\t\t\tdst->m_next = m;\n\t\t\tamount = M_TRAILINGSPACE(m);\n\t\t}\n\n\t\tif (amount < len1)\n\t\t\tlen1 = amount;\n\n#ifdef BAHTIMINGS\n\t\tlencopy = len;\n\t\tcopystart = clkread();\n#endif\n\n\t\tmovepin(bah_ram_ptr, mtod(m, u_char *) + m->m_len, len1);\n\n#ifdef BAHTIMINGS\n\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\tsc->sc_stats.mincopyin =\n\t\t    ulmin(sc->sc_stats.mincopyin, perbyte);\n\t\tsc->sc_stats.maxcopyin =\n\t\t    ulmax(sc->sc_stats.maxcopyin, perbyte);\n#endif\n\n\t\tm->m_len += len1;\n\t\tbah_ram_ptr += len1*2;\n\t\tlen -= len1;\n\t}\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, head);\n#endif\n\n\tarc_input(&sc->sc_arccom.ac_if, head);\n\n\t/* arc_input has freed it, we dont need to... */\n\n\thead = NULL;\n\tifp->if_ipackets++;\n\t\ncleanup:\n\n\tif (head != NULL)\n\t\tm_freem(head);\n\n\t/* mark buffer as invalid by source id 0 */\n\tsc->sc_base->buffers[buffer*512*2] = 0;\n\ts = splnet();\n\n\tif (--sc->sc_rx_fillcount == 2 - 1) {\n\n\t\t/* was off, restart it on buffer just emptied */\n\t\tsc->sc_rx_act = buffer;\n\t\tsc->sc_intmask |= ARC_RI;\n\n\t\t/* this also clears the RI flag interupt: */\n\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\t\tsc->sc_base->status = sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: srint: restarted rx on buf %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_sicallback",
          "args": [
            "(sifunc_t)bah_srint",
            "sc",
            "NULL"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: started rx for buffer %ld, status 0x%02x\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_rx_act",
            "sc->sc_base->status"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARC_RXBC",
          "args": [
            "buffer"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARC_RXBC",
          "args": [
            "buffer"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: spurious RX interrupt or sender 0 (ignored)\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARC_CLR",
          "args": [
            "CLR_RECONFIG"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARC_CLR",
          "args": [
            "CLR_POR"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARC_EXCESSIVE_RECONS_REWARN 400\n#define ARC_EXCESSIVE_RECONS 20\n#define BAHSOFTCOPY /**/\n\nint\tbahintr;\nvoid\tbah_srint;\n\nint\nbahintr(sc)\n\tstruct bah_softc *sc;\n{\n\tu_char isr, maskedisr;\n\tint buffer;\n\tu_long newsec;\n\n\tisr = sc->sc_base->status;\n\tmaskedisr = isr & sc->sc_intmask;\n\tif (!maskedisr) \n\t\treturn (0);\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG>1)\n\tprintf(\"%s: intr: status 0x%02x, intmask 0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, isr, sc->sc_intmask);\n#endif\n\n\tif (maskedisr & ARC_POR) {\n\t\tsc->sc_arccom.ac_anaddr = sc->sc_base->dipswitches;\n\t\tsc->sc_base->command = ARC_CLR(CLR_POR);\n\t\tlog(LOG_WARNING, \"%s: intr: got spurious power on reset int\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n\n\tif (maskedisr & ARC_RECON) {\n\t\t/*\n\t\t * we dont need to:\n\t\t * sc->sc_base->command = ARC_CONF(CONF_LONG);\n\t\t */\n\t\tsc->sc_base->command = ARC_CLR(CLR_RECONFIG);\n\t\tsc->sc_arccom.ac_if.if_collisions++;\n\n\t\t/*\n\t\t * If more than 2 seconds per reconfig:\n\t\t *\tReset time and counter.\n\t\t * else:\n\t\t *\tIf more than ARC_EXCESSIVE_RECONFIGS reconfigs\n\t\t *\tsince last burst, complain and set treshold for\n\t\t *\twarnings to ARC_EXCESSIVE_RECONS_REWARN.\n\t\t *\n\t\t * This allows for, e.g., new stations on the cable, or\n\t\t * cable switching as long as it is over after (normally)\n\t\t * 16 seconds.\n\t\t *\n\t\t * XXX TODO: check timeout bits in status word and double\n\t\t * time if necessary.\n\t\t */\n\n\t\tnewsec = time.tv_sec;\n\t\tif (newsec - sc->sc_recontime > 2 * sc->sc_reconcount) {\n\t\t\tsc->sc_recontime = newsec;\n\t\t\tsc->sc_reconcount = 0;\n\t\t\tsc->sc_reconcount_excessive = ARC_EXCESSIVE_RECONS;\n\t\t} else if (++sc->sc_reconcount > sc->sc_reconcount_excessive) {\n\t\t\tsc->sc_reconcount_excessive = \n\t\t\t    ARC_EXCESSIVE_RECONS_REWARN;\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: excessive token losses, cable problem?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_recontime = newsec;\n\t\t\tsc->sc_reconcount = 0;\n\t\t}\n\t}\n\n\tif (maskedisr & ARC_RI) {\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 1)\n\t\tprintf(\"%s: intr: hard rint, act %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_rx_act);\n#endif\n\t\n\t\tbuffer = sc->sc_rx_act;\n\t\t/* look if buffer is marked invalid: */\n\t\tif (sc->sc_base->buffers[buffer*512*2] == 0) {\n\t/* invalid marked buffer (or illegally configured sender) */\n\t\t\tlog(LOG_WARNING, \n\t\t\t    \"%s: spurious RX interrupt or sender 0 (ignored)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/*\n\t\t\t * restart receiver on same buffer.\n\t\t\t */\n\t\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\n\t\t} else if (++sc->sc_rx_fillcount > 1) {\n\t\t\tsc->sc_intmask &= ~ARC_RI;\n\t\t\tsc->sc_base->status = sc->sc_intmask;\n\t\t} else {\n\n\t\t\tbuffer ^= 1;\n\t\t\tsc->sc_rx_act = buffer;\n\n\t\t\t/*\n\t\t\t * Start receiver on other receive buffer.\n\t\t\t * This also clears the RI interupt flag.\n\t\t\t */\n\t\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\t\t\t/* we are in the RX intr, so mask is ok for RX */\n\n#ifdef BAH_DEBUG\n\t\t\tprintf(\"%s: started rx for buffer %ld, status 0x%02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_rx_act,\n\t\t\t    sc->sc_base->status);\n#endif\n\t\t}\n\n#ifdef BAHSOFTCOPY\n\t\t/* this one starts a soft int to copy out of the hw */\n\t\tadd_sicallback((sifunc_t)bah_srint, sc,NULL);\n#else\n\t\t/* this one does the copy here */\n\t\tbah_srint(sc,NULL);\n#endif\n\t}\n\n\tif (maskedisr & ARC_TA) \n\t\tbah_tint(sc, isr);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "bah_tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "914-1013",
    "snippet": "__inline static void\nbah_tint(sc, isr)\n\tstruct bah_softc *sc;\n\tint isr;\n{\n\tstruct ifnet *ifp;\n\n\tint buffer;\n#ifdef BAHTIMINGS\n\tint clknow;\n#endif\n\n\tifp = &(sc->sc_arccom.ac_if);\n\tbuffer = sc->sc_tx_act;\n\n\t/*\n\t * retransmit code:  \n\t * Normal situtations first for fast path:\n\t * If acknowledgement received ok or broadcast, we're ok.\n\t * else if \n\t */ \n\n\tif (isr & ARC_TMA || sc->sc_broadcast[buffer])\n\t\tsc->sc_arccom.ac_if.if_opackets++;\n#ifdef BAHRETRANSMIT\n\telse if (ifp->if_flags & IFF_LINK2 && ifp->if_timer > 0 \n\t    && --sc->sc_retransmits[buffer] > 0) {\n\t\t/* retransmit same buffer */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\treturn;\n\t}\n#endif\n\telse\n\t\tifp->if_oerrors++;\n\t\t\n\t\t\n#ifdef BAHTIMINGS\n\tclknow = clkread();\n\n\tsc->sc_stats.minsend = ulmin(sc->sc_stats.minsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n\n\tsc->sc_stats.maxsend = ulmax(sc->sc_stats.maxsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n#endif\n\n\t/* We know we can accept another buffer at this point. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (--sc->sc_tx_fillcount > 0) {\n\n\t\t/* \n\t\t * start tx on other buffer.\n\t\t * This also clears the int flag\n\t\t */\n\t\tbuffer ^= 1;\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * already given:\n\t\t * sc->sc_intmask |= ARC_TA; \n\t\t * sc->sc_base->status = sc->sc_intmask;\n\t\t */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\t/* init watchdog timer */\n\t\tifp->if_timer = ARCTIMEOUT;\n\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n \n#if defined(BAH_DEBUG) && (BAH_DEBUG > 1)\n\t\tprintf(\"%s: tint: starting tx on buffer %d, status 0x%02x\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer, sc->sc_base->status);\n#endif\n\t} else {\n\t\t/* have to disable TX interrupt */\n\t\tsc->sc_intmask &= ~ARC_TA;\n\t\tsc->sc_base->status = sc->sc_intmask;\n\t\t/* ... and watchdog timer */\n\t\tifp->if_timer = 0;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: tint: no more buffers to send, status 0x%02x\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\t}\n\n#ifdef BAHSOFTCOPY\n\t/* schedule soft int to fill a new buffer for us */\n\tadd_sicallback((sifunc_t)callstart, sc, NULL);\n#else\n\t/* call it directly */\n\tcallstart(sc, NULL);\n#endif\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ARCTIMEOUT (5*IFNET_SLOWHZ)",
      "#define BAHRETRANSMIT /**/",
      "#define BAHSOFTCOPY /**/"
    ],
    "globals_used": [
      "void\tcallstart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callstart",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "callstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "690-698",
          "snippet": "void \ncallstart(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\n\tsc = (struct bah_softc *)vsc;\n\tbah_start(&sc->sc_arccom.ac_if);\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tbah_start",
            "void\tcallstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_start;\nvoid\tcallstart;\n\nvoid \ncallstart(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\n\tsc = (struct bah_softc *)vsc;\n\tbah_start(&sc->sc_arccom.ac_if);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_sicallback",
          "args": [
            "(sifunc_t)callstart",
            "sc",
            "NULL"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: tint: no more buffers to send, status 0x%02x\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_base->status"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clkread",
          "args": [],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t)&time",
            "(caddr_t)&(sc->sc_stats.lasttxstart_tv)",
            "sizeof(struct timeval)"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARC_TX",
          "args": [
            "buffer"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulmax",
          "args": [
            "sc->sc_stats.maxsend",
            "clknow - sc->sc_stats.lasttxstart_mics"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulmin",
          "args": [
            "sc->sc_stats.minsend",
            "clknow - sc->sc_stats.lasttxstart_mics"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clkread",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARC_TX",
          "args": [
            "buffer"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARCTIMEOUT (5*IFNET_SLOWHZ)\n#define BAHRETRANSMIT /**/\n#define BAHSOFTCOPY /**/\n\nvoid\tcallstart;\n\n__inline static void\nbah_tint(sc, isr)\n\tstruct bah_softc *sc;\n\tint isr;\n{\n\tstruct ifnet *ifp;\n\n\tint buffer;\n#ifdef BAHTIMINGS\n\tint clknow;\n#endif\n\n\tifp = &(sc->sc_arccom.ac_if);\n\tbuffer = sc->sc_tx_act;\n\n\t/*\n\t * retransmit code:  \n\t * Normal situtations first for fast path:\n\t * If acknowledgement received ok or broadcast, we're ok.\n\t * else if \n\t */ \n\n\tif (isr & ARC_TMA || sc->sc_broadcast[buffer])\n\t\tsc->sc_arccom.ac_if.if_opackets++;\n#ifdef BAHRETRANSMIT\n\telse if (ifp->if_flags & IFF_LINK2 && ifp->if_timer > 0 \n\t    && --sc->sc_retransmits[buffer] > 0) {\n\t\t/* retransmit same buffer */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\treturn;\n\t}\n#endif\n\telse\n\t\tifp->if_oerrors++;\n\t\t\n\t\t\n#ifdef BAHTIMINGS\n\tclknow = clkread();\n\n\tsc->sc_stats.minsend = ulmin(sc->sc_stats.minsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n\n\tsc->sc_stats.maxsend = ulmax(sc->sc_stats.maxsend,\n\t    clknow - sc->sc_stats.lasttxstart_mics);\n#endif\n\n\t/* We know we can accept another buffer at this point. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (--sc->sc_tx_fillcount > 0) {\n\n\t\t/* \n\t\t * start tx on other buffer.\n\t\t * This also clears the int flag\n\t\t */\n\t\tbuffer ^= 1;\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * already given:\n\t\t * sc->sc_intmask |= ARC_TA; \n\t\t * sc->sc_base->status = sc->sc_intmask;\n\t\t */\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\t/* init watchdog timer */\n\t\tifp->if_timer = ARCTIMEOUT;\n\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n \n#if defined(BAH_DEBUG) && (BAH_DEBUG > 1)\n\t\tprintf(\"%s: tint: starting tx on buffer %d, status 0x%02x\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer, sc->sc_base->status);\n#endif\n\t} else {\n\t\t/* have to disable TX interrupt */\n\t\tsc->sc_intmask &= ~ARC_TA;\n\t\tsc->sc_base->status = sc->sc_intmask;\n\t\t/* ... and watchdog timer */\n\t\tifp->if_timer = 0;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: tint: no more buffers to send, status 0x%02x\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\t}\n\n#ifdef BAHSOFTCOPY\n\t/* schedule soft int to fill a new buffer for us */\n\tadd_sicallback((sifunc_t)callstart, sc, NULL);\n#else\n\t/* call it directly */\n\tcallstart(sc, NULL);\n#endif\n}"
  },
  {
    "function_name": "bah_srint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "765-912",
    "snippet": "void\nbah_srint(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\tint buffer, len, len1, amount, offset, s, i, type;\n\tu_char __volatile *bah_ram_ptr;\n\tstruct mbuf *m, *dst, *head;\n\tstruct arc_header *ah;\n\tstruct ifnet *ifp;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\tsc = (struct bah_softc *)vsc;\n\tifp = &sc->sc_arccom.ac_if;\n\thead = 0;\n\n\ts = splnet();\n\tbuffer = sc->sc_rx_act ^ 1;\n\tsplx(s);\n\n\t/* Allocate header mbuf */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\n\tif (m == 0) {\n\t\t/* \n\t \t * in case s.th. goes wrong with mem, drop it\n\t \t * to make sure the receiver can be started again\n\t\t * count it as input error (we dont have any other\n\t\t * detectable)\n\t \t */\n\t\tifp->if_ierrors++;\n\t\tgoto cleanup;\n\t}\n\t\t\t\n\tm->m_pkthdr.rcvif = ifp;\n\n\t/*\n\t * Align so that IP packet will be longword aligned. Here we\n\t * assume that m_data of new packet is longword aligned.\n\t * When implementing PHDS, we might have to change it to 2,\n\t * (2*sizeof(ulong) - ARC_HDRNEWLEN)), packet type dependent.\n\t */\n\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\toffset = bah_ram_ptr[2*2];\n\tif (offset)\n\t\tlen = 256 - offset;\n\telse {\n\t\toffset = bah_ram_ptr[3*2];\n\t\tlen = 512 - offset;\n\t}\n\ttype = bah_ram_ptr[offset*2];\n\tm->m_data += 1 + arc_isphds(type);\n\n\thead = m;\n\tah = mtod(head, struct arc_header *);\n\t\t\n\tah->arc_shost = bah_ram_ptr[0*2];\n\tah->arc_dhost = bah_ram_ptr[1*2];\n\n\tm->m_pkthdr.len = len+2; /* whole packet length */\n\tm->m_len = 2;\t\t /* mbuf filled with ARCnet addresses */\n\tbah_ram_ptr += offset*2; /* ram buffer continues there */\n\n\twhile (len > 0) {\n\t\n\t\tlen1 = len;\n\t\tamount = M_TRAILINGSPACE(m);\n\n\t\tif (amount == 0) {\n\t\t\tdst = m;\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\n\t\t\tif (m == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\n\t\t\tif (len1 >= MINCLSIZE)\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\n\t\t\tm->m_len = 0;\n\t\t\tdst->m_next = m;\n\t\t\tamount = M_TRAILINGSPACE(m);\n\t\t}\n\n\t\tif (amount < len1)\n\t\t\tlen1 = amount;\n\n#ifdef BAHTIMINGS\n\t\tlencopy = len;\n\t\tcopystart = clkread();\n#endif\n\n\t\tmovepin(bah_ram_ptr, mtod(m, u_char *) + m->m_len, len1);\n\n#ifdef BAHTIMINGS\n\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\tsc->sc_stats.mincopyin =\n\t\t    ulmin(sc->sc_stats.mincopyin, perbyte);\n\t\tsc->sc_stats.maxcopyin =\n\t\t    ulmax(sc->sc_stats.maxcopyin, perbyte);\n#endif\n\n\t\tm->m_len += len1;\n\t\tbah_ram_ptr += len1*2;\n\t\tlen -= len1;\n\t}\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, head);\n#endif\n\n\tarc_input(&sc->sc_arccom.ac_if, head);\n\n\t/* arc_input has freed it, we dont need to... */\n\n\thead = NULL;\n\tifp->if_ipackets++;\n\t\ncleanup:\n\n\tif (head != NULL)\n\t\tm_freem(head);\n\n\t/* mark buffer as invalid by source id 0 */\n\tsc->sc_base->buffers[buffer*512*2] = 0;\n\ts = splnet();\n\n\tif (--sc->sc_rx_fillcount == 2 - 1) {\n\n\t\t/* was off, restart it on buffer just emptied */\n\t\tsc->sc_rx_act = buffer;\n\t\tsc->sc_intmask |= ARC_RI;\n\n\t\t/* this also clears the RI flag interupt: */\n\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\t\tsc->sc_base->status = sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: srint: restarted rx on buf %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tmovepin",
      "__P((u_char __volatile *from, u_char *to, int len));",
      "void\tbah_srint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: srint: restarted rx on buf %ld\\n\"",
            "sc->sc_dev.dv_xname",
            "buffer"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARC_RXBC",
          "args": [
            "buffer"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "head"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc_input",
          "args": [
            "&sc->sc_arccom.ac_if",
            "head"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "head"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulmax",
          "args": [
            "sc->sc_stats.maxcopyin",
            "perbyte"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulmin",
          "args": [
            "sc->sc_stats.mincopyin",
            "perbyte"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clkread",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "movepin",
          "args": [
            "bah_ram_ptr",
            "mtod(m, u_char *) + m->m_len",
            "len1"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "movepin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "700-759",
          "snippet": "__inline void\nmovepin(from, to, len)\n\t__volatile u_char *from;\n\tu_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tunsigned long\tlongd, longd1, longd2, longd3, longd4;\n\tushort\t\tshortd;\n\n\tif ((len > 3) && (((long)to) & 3)) {\n\t\tswitch (((long)to) & 3) {\n\t\tcase 3: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\t\tbreak;\n\t\tcase 1: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\tcase 2:\tasm (\"movepw %1@(0),%0\": \"=d\" (shortd) : \"a\" (from));\n\t\t\t*((ushort *)to)++ = shortd;\n\t\t\tfrom += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tasm(\"movepl %1@(0),%0\"  : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(8),%0\"  : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(16),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(24),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tasm(\"movepl %1@(32),%0\" : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(40),%0\" : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(48),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(56),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tfrom += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tasm(\"movepl %1@(0),%0\" : \"=d\"(longd) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd;\n\t\t\tfrom += 8; len -= 4;\n\t\t}\n\n\t}\n#endif /* BAHASMCOPY */\n\twhile (len > 0) {\n\t\t*to++ = *from;\n\t\tfrom += 2;\n\t\t--len;\n\t}\n\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define BAHASMCOPY /**/"
          ],
          "globals_used": [
            "void\tmovepin",
            "__P((u_char __volatile *from, u_char *to, int len));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define BAHASMCOPY /**/\n\nvoid\tmovepin;\n__P((u_char __volatile *from, u_char *to, int len));\n\n__inline void\nmovepin(from, to, len)\n\t__volatile u_char *from;\n\tu_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tunsigned long\tlongd, longd1, longd2, longd3, longd4;\n\tushort\t\tshortd;\n\n\tif ((len > 3) && (((long)to) & 3)) {\n\t\tswitch (((long)to) & 3) {\n\t\tcase 3: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\t\tbreak;\n\t\tcase 1: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\tcase 2:\tasm (\"movepw %1@(0),%0\": \"=d\" (shortd) : \"a\" (from));\n\t\t\t*((ushort *)to)++ = shortd;\n\t\t\tfrom += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tasm(\"movepl %1@(0),%0\"  : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(8),%0\"  : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(16),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(24),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tasm(\"movepl %1@(32),%0\" : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(40),%0\" : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(48),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(56),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tfrom += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tasm(\"movepl %1@(0),%0\" : \"=d\"(longd) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd;\n\t\t\tfrom += 8; len -= 4;\n\t\t}\n\n\t}\n#endif /* BAHASMCOPY */\n\twhile (len > 0) {\n\t\t*to++ = *from;\n\t\tfrom += 2;\n\t\t--len;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clkread",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_TRAILINGSPACE",
          "args": [
            "m"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_TRAILINGSPACE",
          "args": [
            "m"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "head",
            "structarc_header*"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc_isphds",
          "args": [
            "type"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tmovepin;\n__P((u_char __volatile *from, u_char *to, int len));\nvoid\tbah_srint;\n\nvoid\nbah_srint(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\tint buffer, len, len1, amount, offset, s, i, type;\n\tu_char __volatile *bah_ram_ptr;\n\tstruct mbuf *m, *dst, *head;\n\tstruct arc_header *ah;\n\tstruct ifnet *ifp;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\tsc = (struct bah_softc *)vsc;\n\tifp = &sc->sc_arccom.ac_if;\n\thead = 0;\n\n\ts = splnet();\n\tbuffer = sc->sc_rx_act ^ 1;\n\tsplx(s);\n\n\t/* Allocate header mbuf */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\n\tif (m == 0) {\n\t\t/* \n\t \t * in case s.th. goes wrong with mem, drop it\n\t \t * to make sure the receiver can be started again\n\t\t * count it as input error (we dont have any other\n\t\t * detectable)\n\t \t */\n\t\tifp->if_ierrors++;\n\t\tgoto cleanup;\n\t}\n\t\t\t\n\tm->m_pkthdr.rcvif = ifp;\n\n\t/*\n\t * Align so that IP packet will be longword aligned. Here we\n\t * assume that m_data of new packet is longword aligned.\n\t * When implementing PHDS, we might have to change it to 2,\n\t * (2*sizeof(ulong) - ARC_HDRNEWLEN)), packet type dependent.\n\t */\n\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\toffset = bah_ram_ptr[2*2];\n\tif (offset)\n\t\tlen = 256 - offset;\n\telse {\n\t\toffset = bah_ram_ptr[3*2];\n\t\tlen = 512 - offset;\n\t}\n\ttype = bah_ram_ptr[offset*2];\n\tm->m_data += 1 + arc_isphds(type);\n\n\thead = m;\n\tah = mtod(head, struct arc_header *);\n\t\t\n\tah->arc_shost = bah_ram_ptr[0*2];\n\tah->arc_dhost = bah_ram_ptr[1*2];\n\n\tm->m_pkthdr.len = len+2; /* whole packet length */\n\tm->m_len = 2;\t\t /* mbuf filled with ARCnet addresses */\n\tbah_ram_ptr += offset*2; /* ram buffer continues there */\n\n\twhile (len > 0) {\n\t\n\t\tlen1 = len;\n\t\tamount = M_TRAILINGSPACE(m);\n\n\t\tif (amount == 0) {\n\t\t\tdst = m;\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\n\t\t\tif (m == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\n\t\t\tif (len1 >= MINCLSIZE)\n\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\n\t\t\tm->m_len = 0;\n\t\t\tdst->m_next = m;\n\t\t\tamount = M_TRAILINGSPACE(m);\n\t\t}\n\n\t\tif (amount < len1)\n\t\t\tlen1 = amount;\n\n#ifdef BAHTIMINGS\n\t\tlencopy = len;\n\t\tcopystart = clkread();\n#endif\n\n\t\tmovepin(bah_ram_ptr, mtod(m, u_char *) + m->m_len, len1);\n\n#ifdef BAHTIMINGS\n\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\tsc->sc_stats.mincopyin =\n\t\t    ulmin(sc->sc_stats.mincopyin, perbyte);\n\t\tsc->sc_stats.maxcopyin =\n\t\t    ulmax(sc->sc_stats.maxcopyin, perbyte);\n#endif\n\n\t\tm->m_len += len1;\n\t\tbah_ram_ptr += len1*2;\n\t\tlen -= len1;\n\t}\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, head);\n#endif\n\n\tarc_input(&sc->sc_arccom.ac_if, head);\n\n\t/* arc_input has freed it, we dont need to... */\n\n\thead = NULL;\n\tifp->if_ipackets++;\n\t\ncleanup:\n\n\tif (head != NULL)\n\t\tm_freem(head);\n\n\t/* mark buffer as invalid by source id 0 */\n\tsc->sc_base->buffers[buffer*512*2] = 0;\n\ts = splnet();\n\n\tif (--sc->sc_rx_fillcount == 2 - 1) {\n\n\t\t/* was off, restart it on buffer just emptied */\n\t\tsc->sc_rx_act = buffer;\n\t\tsc->sc_intmask |= ARC_RI;\n\n\t\t/* this also clears the RI flag interupt: */\n\t\tsc->sc_base->command = ARC_RXBC(buffer);\n\t\tsc->sc_base->status = sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: srint: restarted rx on buf %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "movepin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "700-759",
    "snippet": "__inline void\nmovepin(from, to, len)\n\t__volatile u_char *from;\n\tu_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tunsigned long\tlongd, longd1, longd2, longd3, longd4;\n\tushort\t\tshortd;\n\n\tif ((len > 3) && (((long)to) & 3)) {\n\t\tswitch (((long)to) & 3) {\n\t\tcase 3: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\t\tbreak;\n\t\tcase 1: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\tcase 2:\tasm (\"movepw %1@(0),%0\": \"=d\" (shortd) : \"a\" (from));\n\t\t\t*((ushort *)to)++ = shortd;\n\t\t\tfrom += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tasm(\"movepl %1@(0),%0\"  : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(8),%0\"  : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(16),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(24),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tasm(\"movepl %1@(32),%0\" : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(40),%0\" : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(48),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(56),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tfrom += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tasm(\"movepl %1@(0),%0\" : \"=d\"(longd) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd;\n\t\t\tfrom += 8; len -= 4;\n\t\t}\n\n\t}\n#endif /* BAHASMCOPY */\n\twhile (len > 0) {\n\t\t*to++ = *from;\n\t\tfrom += 2;\n\t\t--len;\n\t}\n\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define BAHASMCOPY /**/"
    ],
    "globals_used": [
      "void\tmovepin",
      "__P((u_char __volatile *from, u_char *to, int len));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define BAHASMCOPY /**/\n\nvoid\tmovepin;\n__P((u_char __volatile *from, u_char *to, int len));\n\n__inline void\nmovepin(from, to, len)\n\t__volatile u_char *from;\n\tu_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tunsigned long\tlongd, longd1, longd2, longd3, longd4;\n\tushort\t\tshortd;\n\n\tif ((len > 3) && (((long)to) & 3)) {\n\t\tswitch (((long)to) & 3) {\n\t\tcase 3: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\t\tbreak;\n\t\tcase 1: *to++ = *from;\n\t\t\tfrom += 2; --len;\n\t\tcase 2:\tasm (\"movepw %1@(0),%0\": \"=d\" (shortd) : \"a\" (from));\n\t\t\t*((ushort *)to)++ = shortd;\n\t\t\tfrom += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tasm(\"movepl %1@(0),%0\"  : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(8),%0\"  : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(16),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(24),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tasm(\"movepl %1@(32),%0\" : \"=d\"(longd1) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(40),%0\" : \"=d\"(longd2) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(48),%0\" : \"=d\"(longd3) : \"a\" (from));\n\t\t\tasm(\"movepl %1@(56),%0\" : \"=d\"(longd4) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd1;\n\t\t\t*((unsigned long *)to)++ = longd2;\n\t\t\t*((unsigned long *)to)++ = longd3;\n\t\t\t*((unsigned long *)to)++ = longd4;\n\n\t\t\tfrom += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tasm(\"movepl %1@(0),%0\" : \"=d\"(longd) : \"a\" (from));\n\t\t\t*((unsigned long *)to)++ = longd;\n\t\t\tfrom += 8; len -= 4;\n\t\t}\n\n\t}\n#endif /* BAHASMCOPY */\n\twhile (len > 0) {\n\t\t*to++ = *from;\n\t\tfrom += 2;\n\t\t--len;\n\t}\n\n}"
  },
  {
    "function_name": "callstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "690-698",
    "snippet": "void \ncallstart(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\n\tsc = (struct bah_softc *)vsc;\n\tbah_start(&sc->sc_arccom.ac_if);\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tbah_start",
      "void\tcallstart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bah_start",
          "args": [
            "&sc->sc_arccom.ac_if"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "bah_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "532-688",
          "snippet": "void\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ARCTIMEOUT (5*IFNET_SLOWHZ)",
            "#define ARC_MAX_LEN 508",
            "#define ARC_MAX_FORBID_LEN 256",
            "#define ARC_MIN_FORBID_LEN 254"
          ],
          "globals_used": [
            "void\tbah_start",
            "void\tmovepout",
            "__P((u_char __volatile *from, u_char *to, int len));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARCTIMEOUT (5*IFNET_SLOWHZ)\n#define ARC_MAX_LEN 508\n#define ARC_MAX_FORBID_LEN 256\n#define ARC_MIN_FORBID_LEN 254\n\nvoid\tbah_start;\nvoid\tmovepout;\n__P((u_char __volatile *from, u_char *to, int len));\n\nvoid\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_start;\nvoid\tcallstart;\n\nvoid \ncallstart(vsc, dummy)\n\tvoid *vsc, *dummy;\n{\n\tstruct bah_softc *sc;\n\n\tsc = (struct bah_softc *)vsc;\n\tbah_start(&sc->sc_arccom.ac_if);\n}"
  },
  {
    "function_name": "bah_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "532-688",
    "snippet": "void\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ARCTIMEOUT (5*IFNET_SLOWHZ)",
      "#define ARC_MAX_LEN 508",
      "#define ARC_MAX_FORBID_LEN 256",
      "#define ARC_MIN_FORBID_LEN 254"
    ],
    "globals_used": [
      "void\tbah_start",
      "void\tmovepout",
      "__P((u_char __volatile *from, u_char *to, int len));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clkread",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t)&time",
            "(caddr_t)&(sc->sc_stats.lasttxstart_tv)",
            "sizeof(struct timeval)"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARC_TX",
          "args": [
            "buffer"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: start: starting transmitter on buffer %d\\n\"",
            "sc->sc_dev.dv_xname",
            "buffer"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulmax",
          "args": [
            "sc->sc_stats.maxcopyout",
            "perbyte"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulmin",
          "args": [
            "sc->sc_stats.mincopyout",
            "perbyte"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clkread",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "movepout",
          "args": [
            "mtod(mp, caddr_t)",
            "bah_ram_ptr",
            "len"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "movepout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "461-521",
          "snippet": "__inline void \nmovepout(from, to, len)\n\tu_char *from;\n\t__volatile u_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tu_short shortd;\n\tu_long longd, longd1, longd2, longd3, longd4;\n\n\tif ((len > 3) && ((long)from) & 3) {\n\t\tswitch (((long)from) & 3) {\n\t\tcase 3:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\tcase 2:\n\t\t\tshortd = *((u_short *)from)++;\n\t\t\tasm(\"movepw %0,%1@(0)\" : : \"d\"(shortd), \"a\"(to));\n\t\t\tto += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\"  : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(8)\"  : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(16)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(24)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(32)\" : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(40)\" : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(48)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(56)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tto += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tlongd = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\" : : \"d\"(longd), \"a\"(to));\n\t\t\tto += 8; len -= 4;\n\t\t}\n\t}\n#endif\n\twhile (len > 0) {\n\t\t*to = *from++;\n\t\tto += 2;\n\t\t--len;\n\t}\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define BAHASMCOPY /**/"
          ],
          "globals_used": [
            "void\tmovepout",
            "__P((u_char __volatile *from, u_char *to, int len));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define BAHASMCOPY /**/\n\nvoid\tmovepout;\n__P((u_char __volatile *from, u_char *to, int len));\n\n__inline void \nmovepout(from, to, len)\n\tu_char *from;\n\t__volatile u_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tu_short shortd;\n\tu_long longd, longd1, longd2, longd3, longd4;\n\n\tif ((len > 3) && ((long)from) & 3) {\n\t\tswitch (((long)from) & 3) {\n\t\tcase 3:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\tcase 2:\n\t\t\tshortd = *((u_short *)from)++;\n\t\t\tasm(\"movepw %0,%1@(0)\" : : \"d\"(shortd), \"a\"(to));\n\t\t\tto += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\"  : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(8)\"  : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(16)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(24)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(32)\" : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(40)\" : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(48)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(56)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tto += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tlongd = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\" : : \"d\"(longd), \"a\"(to));\n\t\t\tto += 8; len -= 4;\n\t\t}\n\t}\n#endif\n\twhile (len > 0) {\n\t\t*to = *from++;\n\t\tto += 2;\n\t\t--len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "mp",
            "caddr_t"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clkread",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "2"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_pullup",
          "args": [
            "m",
            "2"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_pullup",
          "args": [
            "m",
            "3"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARCTIMEOUT (5*IFNET_SLOWHZ)\n#define ARC_MAX_LEN 508\n#define ARC_MAX_FORBID_LEN 256\n#define ARC_MIN_FORBID_LEN 254\n\nvoid\tbah_start;\nvoid\tmovepout;\n__P((u_char __volatile *from, u_char *to, int len));\n\nvoid\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}"
  },
  {
    "function_name": "movepout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "461-521",
    "snippet": "__inline void \nmovepout(from, to, len)\n\tu_char *from;\n\t__volatile u_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tu_short shortd;\n\tu_long longd, longd1, longd2, longd3, longd4;\n\n\tif ((len > 3) && ((long)from) & 3) {\n\t\tswitch (((long)from) & 3) {\n\t\tcase 3:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\tcase 2:\n\t\t\tshortd = *((u_short *)from)++;\n\t\t\tasm(\"movepw %0,%1@(0)\" : : \"d\"(shortd), \"a\"(to));\n\t\t\tto += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\"  : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(8)\"  : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(16)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(24)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(32)\" : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(40)\" : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(48)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(56)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tto += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tlongd = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\" : : \"d\"(longd), \"a\"(to));\n\t\t\tto += 8; len -= 4;\n\t\t}\n\t}\n#endif\n\twhile (len > 0) {\n\t\t*to = *from++;\n\t\tto += 2;\n\t\t--len;\n\t}\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define BAHASMCOPY /**/"
    ],
    "globals_used": [
      "void\tmovepout",
      "__P((u_char __volatile *from, u_char *to, int len));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define BAHASMCOPY /**/\n\nvoid\tmovepout;\n__P((u_char __volatile *from, u_char *to, int len));\n\n__inline void \nmovepout(from, to, len)\n\tu_char *from;\n\t__volatile u_char *to;\n\tint len;\n{\n#ifdef BAHASMCOPY\n\tu_short shortd;\n\tu_long longd, longd1, longd2, longd3, longd4;\n\n\tif ((len > 3) && ((long)from) & 3) {\n\t\tswitch (((long)from) & 3) {\n\t\tcase 3:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*to = *from++;\n\t\t\tto += 2; --len;\n\t\tcase 2:\n\t\t\tshortd = *((u_short *)from)++;\n\t\t\tasm(\"movepw %0,%1@(0)\" : : \"d\"(shortd), \"a\"(to));\n\t\t\tto += 4; len -= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\n\t\twhile (len >= 32) {\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\"  : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(8)\"  : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(16)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(24)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tlongd1 = *((u_long *)from)++;\n\t\t\tlongd2 = *((u_long *)from)++;\n\t\t\tlongd3 = *((u_long *)from)++;\n\t\t\tlongd4 = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(32)\" : : \"d\"(longd1), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(40)\" : : \"d\"(longd2), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(48)\" : : \"d\"(longd3), \"a\"(to));\n\t\t\tasm(\"movepl %0,%1@(56)\" : : \"d\"(longd4), \"a\"(to));\n\n\t\t\tto += 64; len -= 32;\n\t\t}\n\t\twhile (len > 0) {\n\t\t\tlongd = *((u_long *)from)++;\n\t\t\tasm(\"movepl %0,%1@(0)\" : : \"d\"(longd), \"a\"(to));\n\t\t\tto += 8; len -= 4;\n\t\t}\n\t}\n#endif\n\twhile (len > 0) {\n\t\t*to = *from++;\n\t\tto += 2;\n\t\t--len;\n\t}\n}"
  },
  {
    "function_name": "bah_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "425-459",
    "snippet": "void\nbah_stop(sc)\n\tstruct bah_softc *sc;\n{\n\t/* Stop the interrupts */\n\tsc->sc_base->status = 0;\n\n\t/* Stop the interface */\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\n\t/* Stop watchdog timer */\n\tsc->sc_arccom.ac_if.if_timer = 0;\n\n#ifdef BAHTIMINGS\n\tlog(LOG_DEBUG,\"%s: to board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyout, sc->sc_stats.maxcopyout);\n\n\tlog(LOG_DEBUG,\"%s: from board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyin, sc->sc_stats.maxcopyin);\n\t\n\tlog(LOG_DEBUG,\"%s: send time: %6lu .. %6lu mics/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.minsend, sc->sc_stats.maxsend);\n\n\tsc->sc_stats.minsend = \n\t    sc->sc_stats.mincopyout = \n\t    sc->sc_stats.mincopyin = ULONG_MAX;\n\tsc->sc_stats.maxsend = \n\t    sc->sc_stats.maxcopyout = \n\t    sc->sc_stats.maxcopyin = 0;\n#endif\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tbah_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_DEBUG",
            "\"%s: send time: %6lu .. %6lu mics/byte\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_stats.minsend",
            "sc->sc_stats.maxsend"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_stop;\n\nvoid\nbah_stop(sc)\n\tstruct bah_softc *sc;\n{\n\t/* Stop the interrupts */\n\tsc->sc_base->status = 0;\n\n\t/* Stop the interface */\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\n\t/* Stop watchdog timer */\n\tsc->sc_arccom.ac_if.if_timer = 0;\n\n#ifdef BAHTIMINGS\n\tlog(LOG_DEBUG,\"%s: to board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyout, sc->sc_stats.maxcopyout);\n\n\tlog(LOG_DEBUG,\"%s: from board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyin, sc->sc_stats.maxcopyin);\n\t\n\tlog(LOG_DEBUG,\"%s: send time: %6lu .. %6lu mics/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.minsend, sc->sc_stats.maxsend);\n\n\tsc->sc_stats.minsend = \n\t    sc->sc_stats.mincopyout = \n\t    sc->sc_stats.mincopyin = ULONG_MAX;\n\tsc->sc_stats.maxsend = \n\t    sc->sc_stats.maxcopyout = \n\t    sc->sc_stats.maxcopyin = 0;\n#endif\n}"
  },
  {
    "function_name": "bah_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "335-420",
    "snippet": "void\nbah_reset(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint linkaddress;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\t/* stop hardware in case it still runs */\n\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\tDELAY(200);\n\n\t/* and restart it */\n\tsc->sc_base->kick1 = 0xFF;\n\tsc->sc_base->kick2 = 0xFF;\n\n\tdo {\n\t\tDELAY(200);\n\t} while (!(sc->sc_base->status & ARC_POR)); \n\n\tlinkaddress = sc->sc_base->dipswitches;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 2)\n\tprintf(\"%s: reset: card reset, link addr = 0x%02x (%ld)\\n\",\n\t    sc->sc_dev.dv_xname, linkaddress, linkaddress);\n#endif\n\tsc->sc_arccom.ac_anaddr = linkaddress;\n\n\t/* tell the routing level about the (possibly changed) link address */\n\tarc_ifattach(ifp);\n\n\t/* POR is NMI, but we need it below: */\n\tsc->sc_intmask = ARC_RECON|ARC_POR;\n\tsc->sc_base->status\t= sc->sc_intmask;\n\tsc->sc_base->command = ARC_CONF(CONF_LONG);\n\t\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: chip configured, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_base->command = ARC_CLR(CLR_POR|CLR_RECONFIG);\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: bits cleared, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_reconcount_excessive = ARC_EXCESSIVE_RECONS;\n\n\t/* start receiver */\n\n\tsc->sc_intmask  |= ARC_RI;\n\tsc->sc_rx_fillcount = 0;\n\tsc->sc_rx_act = 2;\n\n\tsc->sc_base->command = ARC_RXBC(2);\n\tsc->sc_base->status\t= sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: started receiver, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\t/* and init transmitter status */\n\tsc->sc_tx_act = 0;\n\tsc->sc_tx_fillcount = 0;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef BAHTIMINGS\n\tbzero((caddr_t)&(sc->sc_stats), sizeof(sc->sc_stats));\n\tsc->sc_stats.mincopyin =\n\t    sc->sc_stats.mincopyout =\n\t    sc->sc_stats.minsend = ULONG_MAX;\n#endif\n\n\tbah_start(ifp);\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ARC_EXCESSIVE_RECONS 20"
    ],
    "globals_used": [
      "void\tbah_reset",
      "void\tbah_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bah_start",
          "args": [
            "ifp"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "bah_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "532-688",
          "snippet": "void\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ARCTIMEOUT (5*IFNET_SLOWHZ)",
            "#define ARC_MAX_LEN 508",
            "#define ARC_MAX_FORBID_LEN 256",
            "#define ARC_MIN_FORBID_LEN 254"
          ],
          "globals_used": [
            "void\tbah_start",
            "void\tmovepout",
            "__P((u_char __volatile *from, u_char *to, int len));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARCTIMEOUT (5*IFNET_SLOWHZ)\n#define ARC_MAX_LEN 508\n#define ARC_MAX_FORBID_LEN 256\n#define ARC_MIN_FORBID_LEN 254\n\nvoid\tbah_start;\nvoid\tmovepout;\n__P((u_char __volatile *from, u_char *to, int len));\n\nvoid\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t)&(sc->sc_stats)",
            "sizeof(sc->sc_stats)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset: started receiver, status=0x%02x\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_base->status"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARC_RXBC",
          "args": [
            "2"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARC_CLR",
          "args": [
            "CLR_POR|CLR_RECONFIG"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARC_CONF",
          "args": [
            "CONF_LONG"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc_ifattach",
          "args": [
            "ifp"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARC_EXCESSIVE_RECONS 20\n\nvoid\tbah_reset;\nvoid\tbah_start;\n\nvoid\nbah_reset(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint linkaddress;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\t/* stop hardware in case it still runs */\n\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\tDELAY(200);\n\n\t/* and restart it */\n\tsc->sc_base->kick1 = 0xFF;\n\tsc->sc_base->kick2 = 0xFF;\n\n\tdo {\n\t\tDELAY(200);\n\t} while (!(sc->sc_base->status & ARC_POR)); \n\n\tlinkaddress = sc->sc_base->dipswitches;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 2)\n\tprintf(\"%s: reset: card reset, link addr = 0x%02x (%ld)\\n\",\n\t    sc->sc_dev.dv_xname, linkaddress, linkaddress);\n#endif\n\tsc->sc_arccom.ac_anaddr = linkaddress;\n\n\t/* tell the routing level about the (possibly changed) link address */\n\tarc_ifattach(ifp);\n\n\t/* POR is NMI, but we need it below: */\n\tsc->sc_intmask = ARC_RECON|ARC_POR;\n\tsc->sc_base->status\t= sc->sc_intmask;\n\tsc->sc_base->command = ARC_CONF(CONF_LONG);\n\t\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: chip configured, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_base->command = ARC_CLR(CLR_POR|CLR_RECONFIG);\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: bits cleared, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_reconcount_excessive = ARC_EXCESSIVE_RECONS;\n\n\t/* start receiver */\n\n\tsc->sc_intmask  |= ARC_RI;\n\tsc->sc_rx_fillcount = 0;\n\tsc->sc_rx_act = 2;\n\n\tsc->sc_base->command = ARC_RXBC(2);\n\tsc->sc_base->status\t= sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: started receiver, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\t/* and init transmitter status */\n\tsc->sc_tx_act = 0;\n\tsc->sc_tx_fillcount = 0;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef BAHTIMINGS\n\tbzero((caddr_t)&(sc->sc_stats), sizeof(sc->sc_stats));\n\tsc->sc_stats.mincopyin =\n\t    sc->sc_stats.mincopyout =\n\t    sc->sc_stats.minsend = ULONG_MAX;\n#endif\n\n\tbah_start(ifp);\n}"
  },
  {
    "function_name": "bah_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "311-327",
    "snippet": "void\nbah_init(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint s;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\ts = splnet();\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tbah_reset(sc);\n\t\tbah_start(ifp);\n\t\tsplx(s);\n\t}\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tbah_init",
      "void\tbah_reset",
      "void\tbah_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bah_start",
          "args": [
            "ifp"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "bah_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "532-688",
          "snippet": "void\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ARCTIMEOUT (5*IFNET_SLOWHZ)",
            "#define ARC_MAX_LEN 508",
            "#define ARC_MAX_FORBID_LEN 256",
            "#define ARC_MIN_FORBID_LEN 254"
          ],
          "globals_used": [
            "void\tbah_start",
            "void\tmovepout",
            "__P((u_char __volatile *from, u_char *to, int len));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARCTIMEOUT (5*IFNET_SLOWHZ)\n#define ARC_MAX_LEN 508\n#define ARC_MAX_FORBID_LEN 256\n#define ARC_MIN_FORBID_LEN 254\n\nvoid\tbah_start;\nvoid\tmovepout;\n__P((u_char __volatile *from, u_char *to, int len));\n\nvoid\nbah_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct bah_softc *sc;\n\tstruct mbuf *m,*mp;\n\t__volatile u_char *bah_ram_ptr;\n\tint len, tlen, offset, s, buffer;\n#ifdef BAHTIMINGS\n\tu_long copystart, lencopy, perbyte;\n#endif\n\n\tsc = ifp->if_softc;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 3)\n\tprintf(\"%s: start(0x%x)\\n\", sc->sc_dev.dv_xname, ifp);\n#endif\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\ts = splnet();\n\n\tif (sc->sc_tx_fillcount >= 2) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m);\n\tbuffer = sc->sc_tx_act ^ 1;\n\n\tsplx(s);\n\n\tif (m == 0)\n\t\treturn;\n\n#if NBPFILTER > 0\n\t/*\n\t * If bpf is listening on this interface, let it\n\t * see the packet before we commit it to the wire\n\t *\n\t * (can't give the copy in A2060 card RAM to bpf, because\n\t * that RAM is just accessed as on every other byte)\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n#ifdef BAH_DEBUG\n\tm = m_pullup(m,3);\t/* gcc does structure padding */\n\tprintf(\"%s: start: filling %ld from %ld to %ld type %ld\\n\",\n\t    sc->sc_dev.dv_xname, buffer, mtod(m, u_char *)[0],\n\t    mtod(m, u_char *)[1], mtod(m, u_char *)[2]);\n#else\n\tm = m_pullup(m, 2);\n#endif\n\tbah_ram_ptr = sc->sc_base->buffers + buffer*512*2;\n\n\t/* write the addresses to RAM and throw them away */\n\n\t/*\n\t * Hardware does this: Yet Another Microsecond Saved.\n\t * (btw, timing code says usually 2 microseconds)\n\t * bah_ram_ptr[0*2] = mtod(m, u_char *)[0];\n\t */\n\tbah_ram_ptr[1 * 2] = mtod(m, u_char *)[1];\n\tm_adj(m, 2);\n\t\t\n\t/* get total length left at this point */\n\ttlen = m->m_pkthdr.len;\n\tif (tlen < ARC_MIN_FORBID_LEN) {\n\t\toffset = 256 - tlen;\n\t\tbah_ram_ptr[2 * 2] = offset;\n\t} else {\n\t\tbah_ram_ptr[2 * 2] = 0;\n\t\tif (tlen <= ARC_MAX_FORBID_LEN)\n\t\t\toffset = 255;\t\t/* !!! */\n\t\telse {\n\t\t\tif (tlen > ARC_MAX_LEN)\n\t\t\t\ttlen = ARC_MAX_LEN;\n\t\t\toffset = 512 - tlen;\n\t\t}\n\t\tbah_ram_ptr[3 * 2] = offset;\n\n\t}\n\tbah_ram_ptr += offset * 2;\n\n\t/* lets loop through the mbuf chain */\n\n\tfor (mp = m; mp; mp = mp->m_next) {\n\t\tif ((len = mp->m_len)) {\t\t/* YAMS */\n#ifdef BAHTIMINGS\n\t\t\tlencopy = len;\n\t\t\tcopystart = clkread();\n#endif\n\t\t\tmovepout(mtod(mp, caddr_t), bah_ram_ptr, len);\n\n#ifdef BAHTIMINGS\n\t\t\tperbyte = 1000 * (clkread() - copystart) / lencopy;\n\t\t\tsc->sc_stats.mincopyout = \n\t\t\t    ulmin(sc->sc_stats.mincopyout, perbyte);\n\t\t\tsc->sc_stats.maxcopyout =\n\t\t\t    ulmax(sc->sc_stats.maxcopyout, perbyte);\n#endif\n\t\t\tbah_ram_ptr += len*2;\n\t\t}\n\t}\n\n\tsc->sc_broadcast[buffer] = (m->m_flags & M_BCAST) != 0;\n\tsc->sc_retransmits[buffer] = (m->m_flags & M_BCAST) ? 1 : 5;\n\n\t/* actually transmit the packet */\n\ts = splnet();\n\n\tif (++sc->sc_tx_fillcount > 1) { \n\t\t/*\n\t\t * We are filled up to the rim. No more bufs for the moment,\n\t\t * please.\n\t\t */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t} else {\n#ifdef BAH_DEBUG\n\t\tprintf(\"%s: start: starting transmitter on buffer %d\\n\", \n\t\t    sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t/* Transmitter was off, start it */\n\t\tsc->sc_tx_act = buffer;\n\n\t\t/*\n\t\t * We still can accept another buf, so don't:\n\t\t * ifp->if_flags |= IFF_OACTIVE;\n\t\t */\n\t\tsc->sc_intmask |= ARC_TA;\n\t\tsc->sc_base->command = ARC_TX(buffer);\n\t\tsc->sc_base->status  = sc->sc_intmask;\n\n\t\tsc->sc_arccom.ac_if.if_timer = ARCTIMEOUT;\n#ifdef BAHTIMINGS\n\t\tbcopy((caddr_t)&time,\n\t\t    (caddr_t)&(sc->sc_stats.lasttxstart_tv),\n\t\t    sizeof(struct timeval));\n\n\t\tsc->sc_stats.lasttxstart_mics = clkread();\n#endif\n\t}\n\tsplx(s);\n\tm_freem(m);\n\n\t/*\n\t * After 10 times reading the docs, I realized\n\t * that in the case the receiver NAKs the buffer request,\n\t * the hardware retries till shutdown.\n\t * This is integrated now in the code above.\n\t */\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bah_reset",
          "args": [
            "sc"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "bah_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "335-420",
          "snippet": "void\nbah_reset(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint linkaddress;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\t/* stop hardware in case it still runs */\n\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\tDELAY(200);\n\n\t/* and restart it */\n\tsc->sc_base->kick1 = 0xFF;\n\tsc->sc_base->kick2 = 0xFF;\n\n\tdo {\n\t\tDELAY(200);\n\t} while (!(sc->sc_base->status & ARC_POR)); \n\n\tlinkaddress = sc->sc_base->dipswitches;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 2)\n\tprintf(\"%s: reset: card reset, link addr = 0x%02x (%ld)\\n\",\n\t    sc->sc_dev.dv_xname, linkaddress, linkaddress);\n#endif\n\tsc->sc_arccom.ac_anaddr = linkaddress;\n\n\t/* tell the routing level about the (possibly changed) link address */\n\tarc_ifattach(ifp);\n\n\t/* POR is NMI, but we need it below: */\n\tsc->sc_intmask = ARC_RECON|ARC_POR;\n\tsc->sc_base->status\t= sc->sc_intmask;\n\tsc->sc_base->command = ARC_CONF(CONF_LONG);\n\t\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: chip configured, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_base->command = ARC_CLR(CLR_POR|CLR_RECONFIG);\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: bits cleared, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_reconcount_excessive = ARC_EXCESSIVE_RECONS;\n\n\t/* start receiver */\n\n\tsc->sc_intmask  |= ARC_RI;\n\tsc->sc_rx_fillcount = 0;\n\tsc->sc_rx_act = 2;\n\n\tsc->sc_base->command = ARC_RXBC(2);\n\tsc->sc_base->status\t= sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: started receiver, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\t/* and init transmitter status */\n\tsc->sc_tx_act = 0;\n\tsc->sc_tx_fillcount = 0;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef BAHTIMINGS\n\tbzero((caddr_t)&(sc->sc_stats), sizeof(sc->sc_stats));\n\tsc->sc_stats.mincopyin =\n\t    sc->sc_stats.mincopyout =\n\t    sc->sc_stats.minsend = ULONG_MAX;\n#endif\n\n\tbah_start(ifp);\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ARC_EXCESSIVE_RECONS 20"
          ],
          "globals_used": [
            "void\tbah_reset",
            "void\tbah_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ARC_EXCESSIVE_RECONS 20\n\nvoid\tbah_reset;\nvoid\tbah_start;\n\nvoid\nbah_reset(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint linkaddress;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n#endif\n\t/* stop hardware in case it still runs */\n\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\tDELAY(200);\n\n\t/* and restart it */\n\tsc->sc_base->kick1 = 0xFF;\n\tsc->sc_base->kick2 = 0xFF;\n\n\tdo {\n\t\tDELAY(200);\n\t} while (!(sc->sc_base->status & ARC_POR)); \n\n\tlinkaddress = sc->sc_base->dipswitches;\n\n#if defined(BAH_DEBUG) && (BAH_DEBUG > 2)\n\tprintf(\"%s: reset: card reset, link addr = 0x%02x (%ld)\\n\",\n\t    sc->sc_dev.dv_xname, linkaddress, linkaddress);\n#endif\n\tsc->sc_arccom.ac_anaddr = linkaddress;\n\n\t/* tell the routing level about the (possibly changed) link address */\n\tarc_ifattach(ifp);\n\n\t/* POR is NMI, but we need it below: */\n\tsc->sc_intmask = ARC_RECON|ARC_POR;\n\tsc->sc_base->status\t= sc->sc_intmask;\n\tsc->sc_base->command = ARC_CONF(CONF_LONG);\n\t\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: chip configured, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_base->command = ARC_CLR(CLR_POR|CLR_RECONFIG);\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: bits cleared, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\tsc->sc_reconcount_excessive = ARC_EXCESSIVE_RECONS;\n\n\t/* start receiver */\n\n\tsc->sc_intmask  |= ARC_RI;\n\tsc->sc_rx_fillcount = 0;\n\tsc->sc_rx_act = 2;\n\n\tsc->sc_base->command = ARC_RXBC(2);\n\tsc->sc_base->status\t= sc->sc_intmask;\n\n#ifdef BAH_DEBUG\n\tprintf(\"%s: reset: started receiver, status=0x%02x\\n\",\n\t    sc->sc_dev.dv_xname, sc->sc_base->status);\n#endif\n\n\t/* and init transmitter status */\n\tsc->sc_tx_act = 0;\n\tsc->sc_tx_fillcount = 0;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef BAHTIMINGS\n\tbzero((caddr_t)&(sc->sc_stats), sizeof(sc->sc_stats));\n\tsc->sc_stats.mincopyin =\n\t    sc->sc_stats.mincopyout =\n\t    sc->sc_stats.minsend = ULONG_MAX;\n#endif\n\n\tbah_start(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_init;\nvoid\tbah_reset;\nvoid\tbah_start;\n\nvoid\nbah_init(sc)\n\tstruct bah_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint s;\n\n\tifp = &sc->sc_arccom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\ts = splnet();\n\t\tifp->if_flags |= IFF_RUNNING;\n\t\tbah_reset(sc);\n\t\tbah_start(ifp);\n\t\tsplx(s);\n\t}\n}"
  },
  {
    "function_name": "bah_zbus_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "218-305",
    "snippet": "void\nbah_zbus_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct bah_softc *sc = (void *)self;\n\tstruct zbus_args *zap = aux;\n\tstruct ifnet *ifp = &sc->sc_arccom.ac_if;\n\tint s, linkaddress;\n\n#if (defined(BAH_DEBUG) && (BAH_DEBUG > 2))\n\tprintf(\"\\n%s: attach(0x%x, 0x%x, 0x%x)\\n\",\n\t    sc->sc_dev.dv_xname, parent, self, aux);\n#endif\n\ts = splhigh();\n\tsc->sc_base = zap->va;\n\n\t/*\n\t * read the arcnet address from the board\n\t */\n\n\tsc->sc_base->kick1 = 0x0;\n\tsc->sc_base->kick2 = 0x0;\n\tDELAY(200);\n\n\tsc->sc_base->kick1 = 0xFF;\n\tsc->sc_base->kick2 = 0xFF;\n\tdo {\n\t\tDELAY(200);\n\t} while (!(sc->sc_base->status & ARC_POR)); \n\n\tlinkaddress = sc->sc_base->dipswitches;\n\n#ifdef BAHTIMINGS\n\tprintf(\": link addr 0x%02x(%ld), with timer\\n\",\n\t    linkaddress, linkaddress);\n#else\n\tprintf(\": link addr 0x%02x(%ld)\\n\", linkaddress, linkaddress);\n#endif\n\n\tsc->sc_arccom.ac_anaddr = linkaddress;\n\n\t/* clear the int mask... */\n\n\tsc->sc_base->status = sc->sc_intmask = 0;\n\n\tsc->sc_base->command = ARC_CONF(CONF_LONG);\n\tsc->sc_base->command = ARC_CLR(CLR_POR|CLR_RECONFIG);\n\tsc->sc_recontime = sc->sc_reconcount = 0;\n\n\t/* and reenable kernel int level */\n\tsplx(s);\n\n\t/*\n\t * set interface to stopped condition (reset)\n\t */\n\tbah_stop(sc); \n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_output = arc_output;\n\tifp->if_start = bah_start;\n\tifp->if_ioctl = bah_ioctl;\n\tifp->if_timer = 0;\n\tifp->if_watchdog  = bah_watchdog;\n\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX |\n\t    IFF_NOTRAILERS | IFF_NOARP;\n\n\tifp->if_mtu = ARCMTU;\n\n\tif_attach(ifp);\n\tarc_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_ARCNET, ARC_HDRLEN);\n#endif\n\t/* under heavy load we need four of them: */\n\talloc_sicallback();\n\talloc_sicallback();\n\talloc_sicallback();\n\talloc_sicallback();\n\n\tsc->sc_isr.isr_intr = bahintr;\n\tsc->sc_isr.isr_arg = sc;\n\tsc->sc_isr.isr_ipl = 2;\n\tadd_isr(&sc->sc_isr);\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tbah_zbus_attach",
      "void\tbah_stop",
      "void\tbah_start",
      "int\tbahintr",
      "int\tbah_ioctl",
      "void\tbah_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_isr",
          "args": [
            "&sc->sc_isr"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_sicallback",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_sicallback",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_sicallback",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_sicallback",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_ARCNET",
            "ARC_HDRLEN"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc_ifattach",
          "args": [
            "ifp"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bah_stop",
          "args": [
            "sc"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "bah_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
          "lines": "425-459",
          "snippet": "void\nbah_stop(sc)\n\tstruct bah_softc *sc;\n{\n\t/* Stop the interrupts */\n\tsc->sc_base->status = 0;\n\n\t/* Stop the interface */\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\n\t/* Stop watchdog timer */\n\tsc->sc_arccom.ac_if.if_timer = 0;\n\n#ifdef BAHTIMINGS\n\tlog(LOG_DEBUG,\"%s: to board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyout, sc->sc_stats.maxcopyout);\n\n\tlog(LOG_DEBUG,\"%s: from board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyin, sc->sc_stats.maxcopyin);\n\t\n\tlog(LOG_DEBUG,\"%s: send time: %6lu .. %6lu mics/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.minsend, sc->sc_stats.maxsend);\n\n\tsc->sc_stats.minsend = \n\t    sc->sc_stats.mincopyout = \n\t    sc->sc_stats.mincopyin = ULONG_MAX;\n\tsc->sc_stats.maxsend = \n\t    sc->sc_stats.maxcopyout = \n\t    sc->sc_stats.maxcopyin = 0;\n#endif\n}",
          "includes": [
            "#include <amiga/dev/if_bahreg.h>",
            "#include <amiga/dev/zbusvar.h>",
            "#include <amiga/amiga/isr.h>",
            "#include <amiga/amiga/device.h>",
            "#include <machine/mtpr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_arc.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tbah_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_stop;\n\nvoid\nbah_stop(sc)\n\tstruct bah_softc *sc;\n{\n\t/* Stop the interrupts */\n\tsc->sc_base->status = 0;\n\n\t/* Stop the interface */\n\tsc->sc_base->kick1 = 0;\n\tsc->sc_base->kick2 = 0;\n\n\t/* Stop watchdog timer */\n\tsc->sc_arccom.ac_if.if_timer = 0;\n\n#ifdef BAHTIMINGS\n\tlog(LOG_DEBUG,\"%s: to board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyout, sc->sc_stats.maxcopyout);\n\n\tlog(LOG_DEBUG,\"%s: from board: %6lu .. %6lu ns/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.mincopyin, sc->sc_stats.maxcopyin);\n\t\n\tlog(LOG_DEBUG,\"%s: send time: %6lu .. %6lu mics/byte\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->sc_stats.minsend, sc->sc_stats.maxsend);\n\n\tsc->sc_stats.minsend = \n\t    sc->sc_stats.mincopyout = \n\t    sc->sc_stats.mincopyin = ULONG_MAX;\n\tsc->sc_stats.maxsend = \n\t    sc->sc_stats.maxcopyout = \n\t    sc->sc_stats.maxcopyin = 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARC_CLR",
          "args": [
            "CLR_POR|CLR_RECONFIG"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARC_CONF",
          "args": [
            "CONF_LONG"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": link addr 0x%02x(%ld)\\n\"",
            "linkaddress",
            "linkaddress"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tbah_zbus_attach;\nvoid\tbah_stop;\nvoid\tbah_start;\nint\tbahintr;\nint\tbah_ioctl;\nvoid\tbah_watchdog;\n\nvoid\nbah_zbus_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct bah_softc *sc = (void *)self;\n\tstruct zbus_args *zap = aux;\n\tstruct ifnet *ifp = &sc->sc_arccom.ac_if;\n\tint s, linkaddress;\n\n#if (defined(BAH_DEBUG) && (BAH_DEBUG > 2))\n\tprintf(\"\\n%s: attach(0x%x, 0x%x, 0x%x)\\n\",\n\t    sc->sc_dev.dv_xname, parent, self, aux);\n#endif\n\ts = splhigh();\n\tsc->sc_base = zap->va;\n\n\t/*\n\t * read the arcnet address from the board\n\t */\n\n\tsc->sc_base->kick1 = 0x0;\n\tsc->sc_base->kick2 = 0x0;\n\tDELAY(200);\n\n\tsc->sc_base->kick1 = 0xFF;\n\tsc->sc_base->kick2 = 0xFF;\n\tdo {\n\t\tDELAY(200);\n\t} while (!(sc->sc_base->status & ARC_POR)); \n\n\tlinkaddress = sc->sc_base->dipswitches;\n\n#ifdef BAHTIMINGS\n\tprintf(\": link addr 0x%02x(%ld), with timer\\n\",\n\t    linkaddress, linkaddress);\n#else\n\tprintf(\": link addr 0x%02x(%ld)\\n\", linkaddress, linkaddress);\n#endif\n\n\tsc->sc_arccom.ac_anaddr = linkaddress;\n\n\t/* clear the int mask... */\n\n\tsc->sc_base->status = sc->sc_intmask = 0;\n\n\tsc->sc_base->command = ARC_CONF(CONF_LONG);\n\tsc->sc_base->command = ARC_CLR(CLR_POR|CLR_RECONFIG);\n\tsc->sc_recontime = sc->sc_reconcount = 0;\n\n\t/* and reenable kernel int level */\n\tsplx(s);\n\n\t/*\n\t * set interface to stopped condition (reset)\n\t */\n\tbah_stop(sc); \n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_output = arc_output;\n\tifp->if_start = bah_start;\n\tifp->if_ioctl = bah_ioctl;\n\tifp->if_timer = 0;\n\tifp->if_watchdog  = bah_watchdog;\n\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX |\n\t    IFF_NOTRAILERS | IFF_NOARP;\n\n\tifp->if_mtu = ARCMTU;\n\n\tif_attach(ifp);\n\tarc_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_ARCNET, ARC_HDRLEN);\n#endif\n\t/* under heavy load we need four of them: */\n\talloc_sicallback();\n\talloc_sicallback();\n\talloc_sicallback();\n\talloc_sicallback();\n\n\tsc->sc_isr.isr_intr = bahintr;\n\tsc->sc_isr.isr_arg = sc;\n\tsc->sc_isr.isr_ipl = 2;\n\tadd_isr(&sc->sc_isr);\n}"
  },
  {
    "function_name": "bah_zbus_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc90cx6.c",
    "lines": "205-216",
    "snippet": "int\nbah_zbus_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct zbus_args *zap = aux;\n\n\tif ((zap->manid == 514 || zap->manid == 1053) && zap->prodid == 9)\n\t\treturn (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <amiga/dev/if_bahreg.h>",
      "#include <amiga/dev/zbusvar.h>",
      "#include <amiga/amiga/isr.h>",
      "#include <amiga/amiga/device.h>",
      "#include <machine/mtpr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_arc.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tbah_zbus_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <amiga/dev/if_bahreg.h>\n#include <amiga/dev/zbusvar.h>\n#include <amiga/amiga/isr.h>\n#include <amiga/amiga/device.h>\n#include <machine/mtpr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_arc.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tbah_zbus_match;\n\nint\nbah_zbus_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct zbus_args *zap = aux;\n\n\tif ((zap->manid == 514 || zap->manid == 1053) && zap->prodid == 9)\n\t\treturn (1);\n\n\treturn (0);\n}"
  }
]