[
  {
    "function_name": "usbd_driver_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "1144-1150",
    "snippet": "int\nusbd_driver_load(module_t mod, int what, void *arg)\n{\n\t/* XXX should implement something like a function that removes all generic devices */\n \n \treturn (0);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_driver_load(module_t mod, int what, void *arg)\n{\n\t/* XXX should implement something like a function that removes all generic devices */\n \n \treturn (0);\n}"
  },
  {
    "function_name": "usbd_ratecheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "1134-1141",
    "snippet": "int\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ratecheck",
          "args": [
            "last",
            "&errinterval"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_ratecheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1134-1141",
          "snippet": "int\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}"
  },
  {
    "function_name": "usbd_set_polling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "1100-1109",
    "snippet": "void\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}"
  },
  {
    "function_name": "usbd_dopoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "1093-1098",
    "snippet": "void\nusbd_dopoll(iface)\n\tusbd_interface_handle iface;\n{\n\tiface->device->bus->methods->do_poll(iface->device->bus);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iface->device->bus->methods->do_poll",
          "args": [
            "iface->device->bus"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusbd_dopoll(iface)\n\tusbd_interface_handle iface;\n{\n\tiface->device->bus->methods->do_poll(iface->device->bus);\n}"
  },
  {
    "function_name": "usbd_do_request_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "1059-1079",
    "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "xfer"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_default_xfer",
          "args": [
            "xfer",
            "dev",
            "0",
            "USBD_DEFAULT_TIMEOUT",
            "req",
            "data",
            "UGETW(req->wLength)",
            "0",
            "usbd_do_request_async_cb"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_default_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "446-473",
          "snippet": "void\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wLength"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "dev"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_do_request_async_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "1035-1053",
    "snippet": "void\nusbd_do_request_async_cb(xfer, priv, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle priv;\n\tusbd_status status;\n{\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t xfer->pipe->device->address, \n\t\t\t xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tusbd_free_xfer(xfer);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "u_int8_t index;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "u_int8_t address;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t xfer->pipe->device->address, \n\t\t\t xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "xfer->request.wLength"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "xfer->request.wIndex"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "xfer->request.wValue"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nu_int8_t index;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nu_int8_t address;\n\nvoid\nusbd_do_request_async_cb(xfer, priv, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle priv;\n\tusbd_status status;\n{\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t xfer->pipe->device->address, \n\t\t\t xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tusbd_free_xfer(xfer);\n}"
  },
  {
    "function_name": "usbd_do_request_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "952-1033",
    "snippet": "usbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "u_int8_t index;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
      "u_int8_t address;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_sync_transfer",
          "args": [
            "xfer"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_sync_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "342-348",
          "snippet": "usbd_status\nusbd_sync_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->flags |= USBD_SYNCHRONOUS;\n\treturn (usbd_transfer(xfer));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status\nusbd_sync_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->flags |= USBD_SYNCHRONOUS;\n\treturn (usbd_transfer(xfer));\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_default_xfer",
          "args": [
            "xfer",
            "dev",
            "0",
            "USBD_DEFAULT_TIMEOUT",
            "&treq",
            "&status",
            "0",
            "0",
            "0"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_default_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "446-473",
          "snippet": "void\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "treq.wLength",
            "0"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "treq.wIndex",
            "0"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "treq.wValue",
            "UF_ENDPOINT_HALT"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_do_request: status = 0x%04x\\n\", s)"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "status.wStatus"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "treq.wLength",
            "sizeof(usb_status_t)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "treq.wIndex",
            "0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "treq.wValue",
            "0"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen)"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "xfer->request.wLength"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "xfer->request.wIndex"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "xfer->request.wValue"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wLength"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "dev"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_do_request: not in process context\\n\""
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "intr_nesting_level == 0",
            "(\"usbd_do_request: in interrupt context\")"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nu_int8_t index;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nu_int8_t address;\n\nusbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}"
  },
  {
    "function_name": "usbd_do_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "943-950",
    "snippet": "usbd_status\nusbd_do_request(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\treturn (usbd_do_request_flags(dev, req, data, 0, 0));\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request_flags",
          "args": [
            "dev",
            "req",
            "data",
            "0",
            "0"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "952-1033",
          "snippet": "usbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "u_int8_t index;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nu_int8_t index;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nu_int8_t address;\n\nusbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\treturn (usbd_do_request_flags(dev, req, data, 0, 0));\n}"
  },
  {
    "function_name": "usbd_start_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "908-941",
    "snippet": "void\nusbd_start_next(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tSPLUSBCHECK;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_start_next: pipe == NULL\\n\");\n\t\treturn;\n\t}\n\tif (pipe->methods == NULL || pipe->methods->start == NULL) {\n\t\tprintf(\"usbd_start_next: pipe=%p no start method\\n\", pipe);\n\t\treturn;\n\t}\n#endif\n\n\t/* Get next request in queue. */\n\txfer = SIMPLEQ_FIRST(&pipe->queue);\n\tDPRINTFN(5, (\"usbd_start_next: pipe=%p, xfer=%p\\n\", pipe, xfer));\n\tif (xfer == NULL) {\n\t\tpipe->running = 0;\n\t} else {\n\t\terr = pipe->methods->start(xfer);\n\t\tif (err != USBD_IN_PROGRESS) {\n\t\t\tprintf(\"usbd_start_next: error=%d\\n\", err);\n\t\t\tpipe->running = 0;\n\t\t\t/* XXX do what? */\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_start_next: error=%d\\n\"",
            "err"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe->methods->start",
          "args": [
            "xfer"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_start_next: pipe=%p, xfer=%p\\n\", pipe, xfer)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pipe->queue"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_start_next(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tSPLUSBCHECK;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_start_next: pipe == NULL\\n\");\n\t\treturn;\n\t}\n\tif (pipe->methods == NULL || pipe->methods->start == NULL) {\n\t\tprintf(\"usbd_start_next: pipe=%p no start method\\n\", pipe);\n\t\treturn;\n\t}\n#endif\n\n\t/* Get next request in queue. */\n\txfer = SIMPLEQ_FIRST(&pipe->queue);\n\tDPRINTFN(5, (\"usbd_start_next: pipe=%p, xfer=%p\\n\", pipe, xfer));\n\tif (xfer == NULL) {\n\t\tpipe->running = 0;\n\t} else {\n\t\terr = pipe->methods->start(xfer);\n\t\tif (err != USBD_IN_PROGRESS) {\n\t\t\tprintf(\"usbd_start_next: error=%d\\n\", err);\n\t\t\tpipe->running = 0;\n\t\t\t/* XXX do what? */\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "usb_insert_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "885-905",
    "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&pipe->queue",
            "xfer",
            "next"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
  },
  {
    "function_name": "usb_transfer_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "789-883",
    "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_start_next",
          "args": [
            "pipe"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_start_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "908-941",
          "snippet": "void\nusbd_start_next(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tSPLUSBCHECK;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_start_next: pipe == NULL\\n\");\n\t\treturn;\n\t}\n\tif (pipe->methods == NULL || pipe->methods->start == NULL) {\n\t\tprintf(\"usbd_start_next: pipe=%p no start method\\n\", pipe);\n\t\treturn;\n\t}\n#endif\n\n\t/* Get next request in queue. */\n\txfer = SIMPLEQ_FIRST(&pipe->queue);\n\tDPRINTFN(5, (\"usbd_start_next: pipe=%p, xfer=%p\\n\", pipe, xfer));\n\tif (xfer == NULL) {\n\t\tpipe->running = 0;\n\t} else {\n\t\terr = pipe->methods->start(xfer);\n\t\tif (err != USBD_IN_PROGRESS) {\n\t\t\tprintf(\"usbd_start_next: error=%d\\n\", err);\n\t\t\tpipe->running = 0;\n\t\t\t/* XXX do what? */\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_start_next(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tSPLUSBCHECK;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_start_next: pipe == NULL\\n\");\n\t\treturn;\n\t}\n\tif (pipe->methods == NULL || pipe->methods->start == NULL) {\n\t\tprintf(\"usbd_start_next: pipe=%p no start method\\n\", pipe);\n\t\treturn;\n\t}\n#endif\n\n\t/* Get next request in queue. */\n\txfer = SIMPLEQ_FIRST(&pipe->queue);\n\tDPRINTFN(5, (\"usbd_start_next: pipe=%p, xfer=%p\\n\", pipe, xfer));\n\tif (xfer == NULL) {\n\t\tpipe->running = 0;\n\t} else {\n\t\terr = pipe->methods->start(xfer);\n\t\tif (err != USBD_IN_PROGRESS) {\n\t\t\tprintf(\"usbd_start_next: error=%d\\n\", err);\n\t\t\tpipe->running = 0;\n\t\t\t/* XXX do what? */\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "xfer"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe->methods->done",
          "args": [
            "xfer"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usb_transfer_complete: pipe->methods->done == NULL\\n\""
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe->methods->done",
          "args": [
            "xfer"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfer->callback",
          "args": [
            "xfer",
            "xfer->priv",
            "xfer->status"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue))"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pipe->queue"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&pipe->queue",
            "xfer",
            "next"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pipe->queue"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pipe->queue"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus->methods->freem",
          "args": [
            "bus",
            "dmap"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xfer->buffer",
            "KERNADDR(dmap)",
            "xfer->actlen"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "dmap"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_xfer_isread",
          "args": [
            "xfer"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_xfer_isread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "102-111",
          "snippet": "Static __inline int\nusbd_xfer_isread(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\treturn (xfer->request.bmRequestType & UT_READ);\n\telse\n\t\treturn (xfer->pipe->endpoint->edesc->bEndpointAddress &\n\t\t\tUE_DIR_IN);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "Static void",
            "Static void",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static __inline int",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic __inline int;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nStatic __inline int\nusbd_xfer_isread(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\treturn (xfer->request.bmRequestType & UT_READ);\n\telse\n\t\treturn (xfer->pipe->endpoint->edesc->bEndpointAddress &\n\t\t\tUE_DIR_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
  },
  {
    "function_name": "usbd_ar_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "762-786",
    "snippet": "Static usbd_status\nusbd_ar_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p\\n\", pipe));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\tpipe->repeat = 0;\n\tpipe->aborting = 1;\n\twhile ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {\n\t\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\\n\", \n\t\t\t    pipe, xfer, pipe->methods));\n\t\t/* Make the HC abort it (and invoke the callback). */\n\t\tpipe->methods->abort(xfer);\n\t\t/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */\n\t}\n\tpipe->aborting = 0;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "Static void",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static void",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe->methods->abort",
          "args": [
            "xfer"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\\n\", \n\t\t\t    pipe, xfer, pipe->methods)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pipe->queue"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_dump_queue",
          "args": [
            "pipe"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_dump_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "116-128",
          "snippet": "void\nusbd_dump_queue(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tprintf(\"usbd_dump_queue: pipe=%p\\n\", pipe);\n\tfor (xfer = SIMPLEQ_FIRST(&pipe->queue);\n\t     xfer;\n\t     xfer = SIMPLEQ_NEXT(xfer, next)) {\n\t\tprintf(\"  xfer=%p\\n\", xfer);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_dump_queue(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tprintf(\"usbd_dump_queue: pipe=%p\\n\", pipe);\n\tfor (xfer = SIMPLEQ_FIRST(&pipe->queue);\n\t     xfer;\n\t     xfer = SIMPLEQ_NEXT(xfer, next)) {\n\t\tprintf(\"  xfer=%p\\n\", xfer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"usbd_ar_pipe: pipe=%p\\n\", pipe)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nStatic void;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic void;\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nStatic usbd_status\nusbd_ar_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p\\n\", pipe));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\tpipe->repeat = 0;\n\tpipe->aborting = 1;\n\twhile ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {\n\t\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\\n\", \n\t\t\t    pipe, xfer, pipe->methods));\n\t\t/* Make the HC abort it (and invoke the callback). */\n\t\tpipe->methods->abort(xfer);\n\t\t/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */\n\t}\n\tpipe->aborting = 0;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_get_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "744-757",
    "snippet": "usbd_status\nusbd_get_interface(iface, aiface)\n\tusbd_interface_handle iface;\n\tu_int8_t *aiface;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_INTERFACE;\n\treq.bRequest = UR_GET_INTERFACE;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 1);\n\treturn (usbd_do_request(iface->device, &req, aiface));\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "iface->device",
            "&req",
            "aiface"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "1"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "iface->idesc->bInterfaceNumber"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status\nusbd_get_interface(iface, aiface)\n\tusbd_interface_handle iface;\n\tu_int8_t *aiface;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_INTERFACE;\n\treq.bRequest = UR_GET_INTERFACE;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 1);\n\treturn (usbd_do_request(iface->device, &req, aiface));\n}"
  },
  {
    "function_name": "usbd_get_interface_altindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "737-742",
    "snippet": "int\nusbd_get_interface_altindex(iface)\n\tusbd_interface_handle iface;\n{\n\treturn (iface->altindex);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nint\nusbd_get_interface_altindex(iface)\n\tusbd_interface_handle iface;\n{\n\treturn (iface->altindex);\n}"
  },
  {
    "function_name": "usbd_get_no_alts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "717-735",
    "snippet": "int\nusbd_get_no_alts(cdesc, ifaceno)\n\tusb_config_descriptor_t *cdesc;\n\tint ifaceno;\n{\n\tchar *p = (char *)cdesc;\n\tchar *end = p + UGETW(cdesc->wTotalLength);\n\tusb_interface_descriptor_t *d;\n\tint n;\n\n\tfor (n = 0; p < end; p += d->bLength) {\n\t\td = (usb_interface_descriptor_t *)p;\n\t\tif (p + d->bLength <= end && \n\t\t    d->bDescriptorType == UDESC_INTERFACE &&\n\t\t    d->bInterfaceNumber == ifaceno)\n\t\t\tn++;\n\t}\n\treturn (n);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "cdesc->wTotalLength"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_get_no_alts(cdesc, ifaceno)\n\tusb_config_descriptor_t *cdesc;\n\tint ifaceno;\n{\n\tchar *p = (char *)cdesc;\n\tchar *end = p + UGETW(cdesc->wTotalLength);\n\tusb_interface_descriptor_t *d;\n\tint n;\n\n\tfor (n = 0; p < end; p += d->bLength) {\n\t\td = (usb_interface_descriptor_t *)p;\n\t\tif (p + d->bLength <= end && \n\t\t    d->bDescriptorType == UDESC_INTERFACE &&\n\t\t    d->bInterfaceNumber == ifaceno)\n\t\t\tn++;\n\t}\n\treturn (n);\n}"
  },
  {
    "function_name": "usbd_set_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "689-715",
    "snippet": "usbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "u_int8_t index;",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "iface->device",
            "&req",
            "0"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "iface->idesc->bInterfaceNumber"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "iface->idesc->bAlternateSetting"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_fill_iface_data",
          "args": [
            "iface->device",
            "iface->index",
            "altidx"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_fill_iface_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "441-505",
          "snippet": "usbd_status\nusbd_fill_iface_data(dev, ifaceidx, altidx)\n\tusbd_device_handle dev;\n\tint ifaceidx;\n\tint altidx;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifaceidx];\n\tchar *p, *end;\n\tint endpt, nendpt;\n\n\tDPRINTFN(4,(\"usbd_fill_iface_data: ifaceidx=%d altidx=%d\\n\",\n\t\t    ifaceidx, altidx));\n\tifc->device = dev;\n\tifc->idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);\n\tif (ifc->idesc == 0)\n\t\treturn (USBD_INVAL);\n\tifc->index = ifaceidx;\n\tifc->altindex = altidx;\n\tnendpt = ifc->idesc->bNumEndpoints;\n\tDPRINTFN(4,(\"usbd_fill_iface_data: found idesc nendpt=%d\\n\", nendpt));\n\tif (nendpt != 0) {\n\t\tifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),\n\t\t\t\t\tM_USB, M_NOWAIT);\n\t\tif (ifc->endpoints == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t} else\n\t\tifc->endpoints = NULL;\n\tifc->priv = NULL;\n\tp = (char *)ifc->idesc + ifc->idesc->bLength;\n\tend = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);\n#define ed ((usb_endpoint_descriptor_t *)p)\n\tfor (endpt = 0; endpt < nendpt; endpt++) {\n\t\tDPRINTFN(10,(\"usbd_fill_iface_data: endpt=%d\\n\", endpt));\n\t\tfor (; p < end; p += ed->bLength) {\n\t\t\ted = (usb_endpoint_descriptor_t *)p;\n\t\t\tDPRINTFN(10,(\"usbd_fill_iface_data: p=%p end=%p \"\n\t\t\t\t     \"len=%d type=%d\\n\",\n\t\t\t\t p, end, ed->bLength, ed->bDescriptorType));\n\t\t\tif (p + ed->bLength <= end && ed->bLength != 0 &&\n\t\t\t    ed->bDescriptorType == UDESC_ENDPOINT)\n\t\t\t\tgoto found;\n\t\t\tif (ed->bLength == 0 ||\n\t\t\t    ed->bDescriptorType == UDESC_INTERFACE)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* passed end, or bad desc */\n\t\tDPRINTF((\"usbd_fill_iface_data: bad descriptor(s): %s\\n\",\n\t\t\t ed->bLength == 0 ? \"0 length\" :\n\t\t\t ed->bDescriptorType == UDESC_INTERFACE ? \"iface desc\":\n\t\t\t \"out of data\"));\n\t\tgoto bad;\n\tfound:\n\t\tifc->endpoints[endpt].edesc = ed;\n\t\tifc->endpoints[endpt].refcnt = 0;\n\t\tp += ed->bLength;\n\t}\n#undef ed\n\tLIST_INIT(&ifc->pipes);\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tif (ifc->endpoints != NULL)\n\t\tfree(ifc->endpoints, M_USB);\n\treturn (USBD_INVAL);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ed ((usb_endpoint_descriptor_t *)p)"
          ],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
            "int ifaceidx;",
            "int altidx;",
            "int ifaceidx;",
            "int altidx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ed ((usb_endpoint_descriptor_t *)p)\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nint ifaceidx;\nint altidx;\nint ifaceidx;\nint altidx;\n\nusbd_status\nusbd_fill_iface_data(dev, ifaceidx, altidx)\n\tusbd_device_handle dev;\n\tint ifaceidx;\n\tint altidx;\n{\n\tusbd_interface_handle ifc = &dev->ifaces[ifaceidx];\n\tchar *p, *end;\n\tint endpt, nendpt;\n\n\tDPRINTFN(4,(\"usbd_fill_iface_data: ifaceidx=%d altidx=%d\\n\",\n\t\t    ifaceidx, altidx));\n\tifc->device = dev;\n\tifc->idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);\n\tif (ifc->idesc == 0)\n\t\treturn (USBD_INVAL);\n\tifc->index = ifaceidx;\n\tifc->altindex = altidx;\n\tnendpt = ifc->idesc->bNumEndpoints;\n\tDPRINTFN(4,(\"usbd_fill_iface_data: found idesc nendpt=%d\\n\", nendpt));\n\tif (nendpt != 0) {\n\t\tifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),\n\t\t\t\t\tM_USB, M_NOWAIT);\n\t\tif (ifc->endpoints == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t} else\n\t\tifc->endpoints = NULL;\n\tifc->priv = NULL;\n\tp = (char *)ifc->idesc + ifc->idesc->bLength;\n\tend = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);\n#define ed ((usb_endpoint_descriptor_t *)p)\n\tfor (endpt = 0; endpt < nendpt; endpt++) {\n\t\tDPRINTFN(10,(\"usbd_fill_iface_data: endpt=%d\\n\", endpt));\n\t\tfor (; p < end; p += ed->bLength) {\n\t\t\ted = (usb_endpoint_descriptor_t *)p;\n\t\t\tDPRINTFN(10,(\"usbd_fill_iface_data: p=%p end=%p \"\n\t\t\t\t     \"len=%d type=%d\\n\",\n\t\t\t\t p, end, ed->bLength, ed->bDescriptorType));\n\t\t\tif (p + ed->bLength <= end && ed->bLength != 0 &&\n\t\t\t    ed->bDescriptorType == UDESC_ENDPOINT)\n\t\t\t\tgoto found;\n\t\t\tif (ed->bLength == 0 ||\n\t\t\t    ed->bDescriptorType == UDESC_INTERFACE)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* passed end, or bad desc */\n\t\tDPRINTF((\"usbd_fill_iface_data: bad descriptor(s): %s\\n\",\n\t\t\t ed->bLength == 0 ? \"0 length\" :\n\t\t\t ed->bDescriptorType == UDESC_INTERFACE ? \"iface desc\":\n\t\t\t \"out of data\"));\n\t\tgoto bad;\n\tfound:\n\t\tifc->endpoints[endpt].edesc = ed;\n\t\tifc->endpoints[endpt].refcnt = 0;\n\t\tp += ed->bLength;\n\t}\n#undef ed\n\tLIST_INIT(&ifc->pipes);\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\tif (ifc->endpoints != NULL)\n\t\tfree(ifc->endpoints, M_USB);\n\treturn (USBD_INVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "iface->endpoints",
            "M_USB"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&iface->pipes"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nu_int8_t index;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}"
  },
  {
    "function_name": "usbd_pipe2device_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "681-686",
    "snippet": "usbd_device_handle\nusbd_pipe2device_handle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\treturn (pipe->device);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_device_handle\nusbd_pipe2device_handle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\treturn (pipe->device);\n}"
  },
  {
    "function_name": "usbd_device2interface_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "667-679",
    "snippet": "usbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_interface2device_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "658-665",
    "snippet": "usbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_interface2device_handle(iface, dev)\n\tusbd_interface_handle iface;\n\tusbd_device_handle *dev;\n{\n\t*dev = iface->device;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_interface_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "647-656",
    "snippet": "usbd_status \nusbd_interface_count(dev, count)\n\tusbd_device_handle dev;\n\tu_int8_t *count;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\t*count = dev->cdesc->bNumInterface;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_interface_count(dev, count)\n\tusbd_device_handle dev;\n\tu_int8_t *count;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\t*count = dev->cdesc->bNumInterface;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_endpoint_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "638-645",
    "snippet": "usbd_status \nusbd_endpoint_count(iface, count)\n\tusbd_interface_handle iface;\n\tu_int8_t *count;\n{\n\t*count = iface->idesc->bNumEndpoints;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_endpoint_count(iface, count)\n\tusbd_interface_handle iface;\n\tu_int8_t *count;\n{\n\t*count = iface->idesc->bNumEndpoints;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_clear_endpoint_toggle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "631-636",
    "snippet": "void\nusbd_clear_endpoint_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->cleartoggle(pipe);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe->methods->cleartoggle",
          "args": [
            "pipe"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_clear_endpoint_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tpipe->methods->cleartoggle(pipe);\n}"
  },
  {
    "function_name": "usbd_clear_endpoint_stall_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "611-628",
    "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request_async",
          "args": [
            "dev",
            "&req",
            "0"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "pipe->endpoint->edesc->bEndpointAddress"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "UF_ENDPOINT_HALT"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe->methods->cleartoggle",
          "args": [
            "pipe"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
  },
  {
    "function_name": "usbd_clear_endpoint_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "579-609",
    "snippet": "usbd_status \nusbd_clear_endpoint_stall(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tDPRINTFN(8, (\"usbd_clear_endpoint_stall\\n\"));\n\n\t/* \n\t * Clearing en endpoint stall resets the enpoint toggle, so\n\t * do the same to the HC toggle.\n\t */\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request(dev, &req, 0);\n#if 0\nXXX should we do this?\n\tif (!err) {\n\t\tpipe->state = USBD_PIPE_ACTIVE;\n\t\t/* XXX activate pipe */\n\t}\n#endif\n\treturn (err);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "if",
          "args": [
            "!err"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "aue_ifmedia_sts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1666-1679",
          "snippet": "Static void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "aue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\naue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "dev",
            "&req",
            "0"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "pipe->endpoint->edesc->bEndpointAddress"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "UF_ENDPOINT_HALT"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe->methods->cleartoggle",
          "args": [
            "pipe"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"usbd_clear_endpoint_stall\\n\")"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tDPRINTFN(8, (\"usbd_clear_endpoint_stall\\n\"));\n\n\t/* \n\t * Clearing en endpoint stall resets the enpoint toggle, so\n\t * do the same to the HC toggle.\n\t */\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request(dev, &req, 0);\n#if 0\nXXX should we do this?\n\tif (!err) {\n\t\tpipe->state = USBD_PIPE_ACTIVE;\n\t\t/* XXX activate pipe */\n\t}\n#endif\n\treturn (err);\n}"
  },
  {
    "function_name": "usbd_abort_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "560-577",
    "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_ar_pipe",
          "args": [
            "pipe"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_ar_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "762-786",
          "snippet": "Static usbd_status\nusbd_ar_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p\\n\", pipe));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\tpipe->repeat = 0;\n\tpipe->aborting = 1;\n\twhile ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {\n\t\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\\n\", \n\t\t\t    pipe, xfer, pipe->methods));\n\t\t/* Make the HC abort it (and invoke the callback). */\n\t\tpipe->methods->abort(xfer);\n\t\t/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */\n\t}\n\tpipe->aborting = 0;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "Static void",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static void",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nStatic void;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic void;\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nStatic usbd_status\nusbd_ar_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p\\n\", pipe));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\tpipe->repeat = 0;\n\tpipe->aborting = 1;\n\twhile ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {\n\t\tDPRINTFN(2,(\"usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\\n\", \n\t\t\t    pipe, xfer, pipe->methods));\n\t\t/* Make the HC abort it (and invoke the callback). */\n\t\tpipe->methods->abort(xfer);\n\t\t/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */\n\t}\n\tpipe->aborting = 0;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_close_pipe: pipe==NULL\\n\""
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
  },
  {
    "function_name": "usbd_get_xfer_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "499-515",
    "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
  },
  {
    "function_name": "usbd_setup_isoc_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "475-497",
    "snippet": "void\nusbd_setup_isoc_xfer(xfer, pipe, priv, frlengths, nframes, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tu_int16_t *frlengths;\n\tu_int32_t nframes;\n\tu_int16_t flags;\n\tusbd_callback callback;\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = 0;\n\txfer->length = 0;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = USBD_NO_TIMEOUT;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->frlengths = frlengths;\n\txfer->nframes = nframes;\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_isoc_xfer(xfer, pipe, priv, frlengths, nframes, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tu_int16_t *frlengths;\n\tu_int32_t nframes;\n\tu_int16_t flags;\n\tusbd_callback callback;\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = 0;\n\txfer->length = 0;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = USBD_NO_TIMEOUT;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->frlengths = frlengths;\n\txfer->nframes = nframes;\n}"
  },
  {
    "function_name": "usbd_setup_default_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "446-473",
    "snippet": "void\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, \n\t\t\t   length, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_device_handle dev;\n\tusbd_private_handle priv;\n\tu_int32_t timeout;\n\tusb_device_request_t *req;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = dev->default_pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->request = *req;\n\txfer->rqflags |= URQ_REQUEST;\n\txfer->nframes = 0;\n}"
  },
  {
    "function_name": "usbd_setup_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "420-444",
    "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
  },
  {
    "function_name": "usbd_free_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "403-418",
    "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfer->device->bus->methods->freex",
          "args": [
            "xfer->device->bus",
            "xfer"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_free_xfer: timout_handle pending\""
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&xfer->timeout_handle"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_pending",
          "args": [
            "&xfer->timeout_handle"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_free_buffer",
          "args": [
            "xfer"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "365-377",
          "snippet": "void\nusbd_free_buffer(xfer)\n\tusbd_xfer_handle xfer;\n{\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {\n\t\tprintf(\"usbd_free_buffer: no buffer\\n\");\n\t\treturn;\n\t}\n#endif\n\txfer->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);\n\txfer->device->bus->methods->freem(xfer->device->bus, &xfer->dmabuf);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_free_buffer(xfer)\n\tusbd_xfer_handle xfer;\n{\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {\n\t\tprintf(\"usbd_free_buffer: no buffer\\n\");\n\t\treturn;\n\t}\n#endif\n\txfer->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);\n\txfer->device->bus->methods->freem(xfer->device->bus, &xfer->dmabuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_free_xfer: %p\\n\", xfer)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_alloc_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "388-401",
    "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
      "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
      "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_alloc_xfer() = %p\\n\", xfer)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout_init",
          "args": [
            "xfer->timeout_handle"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->bus->methods->allocx",
          "args": [
            "dev->bus"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
  },
  {
    "function_name": "usbd_free_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "365-377",
    "snippet": "void\nusbd_free_buffer(xfer)\n\tusbd_xfer_handle xfer;\n{\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {\n\t\tprintf(\"usbd_free_buffer: no buffer\\n\");\n\t\treturn;\n\t}\n#endif\n\txfer->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);\n\txfer->device->bus->methods->freem(xfer->device->bus, &xfer->dmabuf);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfer->device->bus->methods->freem",
          "args": [
            "xfer->device->bus",
            "&xfer->dmabuf"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_free_buffer: no buffer\\n\""
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_free_buffer(xfer)\n\tusbd_xfer_handle xfer;\n{\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {\n\t\tprintf(\"usbd_free_buffer: no buffer\\n\");\n\t\treturn;\n\t}\n#endif\n\txfer->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);\n\txfer->device->bus->methods->freem(xfer->device->bus, &xfer->dmabuf);\n}"
  },
  {
    "function_name": "usbd_sync_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "342-348",
    "snippet": "usbd_status\nusbd_sync_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->flags |= USBD_SYNCHRONOUS;\n\treturn (usbd_transfer(xfer));\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "Static usbd_status",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "xfer"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status\nusbd_sync_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\txfer->flags |= USBD_SYNCHRONOUS;\n\treturn (usbd_transfer(xfer));\n}"
  },
  {
    "function_name": "usbd_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "254-339",
    "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "u_int32_t size;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "xfer",
            "PRIBIO",
            "\"usbsyn\"",
            "0"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe->methods->abort",
          "args": [
            "xfer"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus->methods->do_poll",
          "args": [
            "bus"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"usbd_transfer: not done\\n\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus->methods->freem",
          "args": [
            "bus",
            "&xfer->dmabuf"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe->methods->transfer",
          "args": [
            "xfer"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "KERNADDR(dmap)",
            "xfer->buffer",
            "size"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "dmap"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_xfer_isread",
          "args": [
            "xfer"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_xfer_isread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "102-111",
          "snippet": "Static __inline int\nusbd_xfer_isread(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\treturn (xfer->request.bmRequestType & UT_READ);\n\telse\n\t\treturn (xfer->pipe->endpoint->edesc->bEndpointAddress &\n\t\t\tUE_DIR_IN);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "Static void",
            "Static void",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static __inline int",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic __inline int;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nStatic __inline int\nusbd_xfer_isread(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\treturn (xfer->request.bmRequestType & UT_READ);\n\telse\n\t\treturn (xfer->pipe->endpoint->edesc->bEndpointAddress &\n\t\t\tUE_DIR_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus->methods->allocm",
          "args": [
            "bus",
            "dmap",
            "size"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_transfer: has old buffer!\\n\""
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_dump_queue",
          "args": [
            "pipe"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_dump_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "116-128",
          "snippet": "void\nusbd_dump_queue(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tprintf(\"usbd_dump_queue: pipe=%p\\n\", pipe);\n\tfor (xfer = SIMPLEQ_FIRST(&pipe->queue);\n\t     xfer;\n\t     xfer = SIMPLEQ_NEXT(xfer, next)) {\n\t\tprintf(\"  xfer=%p\\n\", xfer);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_dump_queue(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tprintf(\"usbd_dump_queue: pipe=%p\\n\", pipe);\n\tfor (xfer = SIMPLEQ_FIRST(&pipe->queue);\n\t     xfer;\n\t     xfer = SIMPLEQ_NEXT(xfer, next)) {\n\t\tprintf(\"  xfer=%p\\n\", xfer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
  },
  {
    "function_name": "usbd_close_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "224-252",
    "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pipe",
            "M_USB"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usbd_close_pipe: abort_handle pending\""
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "callout_stop",
          "args": [
            "&pipe->abort_handle"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_pending",
          "args": [
            "&pipe->abort_handle"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe->methods->close",
          "args": [
            "pipe"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "pipe",
            "next"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pipe->queue"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_open_pipe_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "177-222",
    "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
      "u_int8_t address;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "ipipe"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "xfer"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "xfer",
            "ipipe",
            "priv",
            "buffer",
            "len",
            "flags",
            "USBD_NO_TIMEOUT",
            "cb"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "iface->device"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_open_pipe_ival",
          "args": [
            "iface",
            "address",
            "USBD_EXCLUSIVE_USE",
            "&ipipe",
            "ival"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_ival",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "142-175",
          "snippet": "usbd_status \nusbd_open_pipe_ival(iface, address, flags, pipe, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tint ival;\n{ \n\tusbd_pipe_handle p;\n\tstruct usbd_endpoint *ep;\n\tusbd_status err;\n\tint i;\n\n\tDPRINTFN(3,(\"usbd_open_pipe: iface=%p address=0x%x flags=0x%x\\n\",\n\t\t    iface, address, flags));\n\n\tfor (i = 0; i < iface->idesc->bNumEndpoints; i++) {\n\t\tep = &iface->endpoints[i];\n\t\tif (ep->edesc == NULL)\n\t\t\treturn (USBD_IOERROR);\n\t\tif (ep->edesc->bEndpointAddress == address)\n\t\t\tgoto found;\n\t}\n\treturn (USBD_BAD_ADDRESS);\n found:\n\tif ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)\n\t\treturn (USBD_IN_USE);\n\terr = usbd_setup_pipe(iface->device, iface, ep, ival, &p);\n\tif (err)\n\t\treturn (err);\n\tLIST_INSERT_HEAD(&iface->pipes, p, next);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_ival(iface, address, flags, pipe, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tint ival;\n{ \n\tusbd_pipe_handle p;\n\tstruct usbd_endpoint *ep;\n\tusbd_status err;\n\tint i;\n\n\tDPRINTFN(3,(\"usbd_open_pipe: iface=%p address=0x%x flags=0x%x\\n\",\n\t\t    iface, address, flags));\n\n\tfor (i = 0; i < iface->idesc->bNumEndpoints; i++) {\n\t\tep = &iface->endpoints[i];\n\t\tif (ep->edesc == NULL)\n\t\t\treturn (USBD_IOERROR);\n\t\tif (ep->edesc->bEndpointAddress == address)\n\t\t\tgoto found;\n\t}\n\treturn (USBD_BAD_ADDRESS);\n found:\n\tif ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)\n\t\treturn (USBD_IN_USE);\n\terr = usbd_setup_pipe(iface->device, iface, ep, ival, &p);\n\tif (err)\n\t\treturn (err);\n\tLIST_INSERT_HEAD(&iface->pipes, p, next);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
  },
  {
    "function_name": "usbd_open_pipe_ival",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "142-175",
    "snippet": "usbd_status \nusbd_open_pipe_ival(iface, address, flags, pipe, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tint ival;\n{ \n\tusbd_pipe_handle p;\n\tstruct usbd_endpoint *ep;\n\tusbd_status err;\n\tint i;\n\n\tDPRINTFN(3,(\"usbd_open_pipe: iface=%p address=0x%x flags=0x%x\\n\",\n\t\t    iface, address, flags));\n\n\tfor (i = 0; i < iface->idesc->bNumEndpoints; i++) {\n\t\tep = &iface->endpoints[i];\n\t\tif (ep->edesc == NULL)\n\t\t\treturn (USBD_IOERROR);\n\t\tif (ep->edesc->bEndpointAddress == address)\n\t\t\tgoto found;\n\t}\n\treturn (USBD_BAD_ADDRESS);\n found:\n\tif ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)\n\t\treturn (USBD_IN_USE);\n\terr = usbd_setup_pipe(iface->device, iface, ep, ival, &p);\n\tif (err)\n\t\treturn (err);\n\tLIST_INSERT_HEAD(&iface->pipes, p, next);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
      "u_int8_t address;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&iface->pipes",
            "p",
            "next"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_setup_pipe",
          "args": [
            "iface->device",
            "iface",
            "ep",
            "ival",
            "&p"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "677-718",
          "snippet": "usbd_status\nusbd_setup_pipe(dev, iface, ep, ival, pipe)\n\tusbd_device_handle dev;\n\tusbd_interface_handle iface; \n\tstruct usbd_endpoint *ep;\n\tint ival;\n\tusbd_pipe_handle *pipe;\n{\n\tusbd_pipe_handle p;\n\tusbd_status err;\n\n\tDPRINTFN(1,(\"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\\n\",\n\t\t    dev, iface, ep, pipe));\n\tp = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\tp->device = dev;\n\tp->iface = iface;\n\tp->endpoint = ep;\n\tep->refcnt++;\n\tp->refcnt = 1;\n\tp->intrxfer = 0;\n\tp->running = 0;\n\tp->aborting = 0;\n\tp->repeat = 0;\n\tp->interval = ival;\n\tSIMPLEQ_INIT(&p->queue);\n\tusb_callout_init(p->abort_handle);\n\terr = dev->bus->methods->open_pipe(p);\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usbd_setup_pipe: endpoint=0x%x failed, error=\"\n\t\t\t \"%s\\n\",\n\t\t\t ep->edesc->bEndpointAddress, usbd_errstr(err)));\n\t\tfree(p, M_USB);\n\t\treturn (err);\n\t}\n\t/* Clear any stall and make sure DATA0 toggle will be used next. */\n\tif (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)\n\t\tusbd_clear_endpoint_stall(p);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_kill_pipe __P((usbd_pipe_handle));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_kill_pipe __P((usbd_pipe_handle));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_setup_pipe(dev, iface, ep, ival, pipe)\n\tusbd_device_handle dev;\n\tusbd_interface_handle iface; \n\tstruct usbd_endpoint *ep;\n\tint ival;\n\tusbd_pipe_handle *pipe;\n{\n\tusbd_pipe_handle p;\n\tusbd_status err;\n\n\tDPRINTFN(1,(\"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\\n\",\n\t\t    dev, iface, ep, pipe));\n\tp = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\tp->device = dev;\n\tp->iface = iface;\n\tp->endpoint = ep;\n\tep->refcnt++;\n\tp->refcnt = 1;\n\tp->intrxfer = 0;\n\tp->running = 0;\n\tp->aborting = 0;\n\tp->repeat = 0;\n\tp->interval = ival;\n\tSIMPLEQ_INIT(&p->queue);\n\tusb_callout_init(p->abort_handle);\n\terr = dev->bus->methods->open_pipe(p);\n\tif (err) {\n\t\tDPRINTFN(-1,(\"usbd_setup_pipe: endpoint=0x%x failed, error=\"\n\t\t\t \"%s\\n\",\n\t\t\t ep->edesc->bEndpointAddress, usbd_errstr(err)));\n\t\tfree(p, M_USB);\n\t\treturn (err);\n\t}\n\t/* Clear any stall and make sure DATA0 toggle will be used next. */\n\tif (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)\n\t\tusbd_clear_endpoint_stall(p);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"usbd_open_pipe: iface=%p address=0x%x flags=0x%x\\n\",\n\t\t    iface, address, flags)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_ival(iface, address, flags, pipe, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tint ival;\n{ \n\tusbd_pipe_handle p;\n\tstruct usbd_endpoint *ep;\n\tusbd_status err;\n\tint i;\n\n\tDPRINTFN(3,(\"usbd_open_pipe: iface=%p address=0x%x flags=0x%x\\n\",\n\t\t    iface, address, flags));\n\n\tfor (i = 0; i < iface->idesc->bNumEndpoints; i++) {\n\t\tep = &iface->endpoints[i];\n\t\tif (ep->edesc == NULL)\n\t\t\treturn (USBD_IOERROR);\n\t\tif (ep->edesc->bEndpointAddress == address)\n\t\t\tgoto found;\n\t}\n\treturn (USBD_BAD_ADDRESS);\n found:\n\tif ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)\n\t\treturn (USBD_IN_USE);\n\terr = usbd_setup_pipe(iface->device, iface, ep, ival, &p);\n\tif (err)\n\t\treturn (err);\n\tLIST_INSERT_HEAD(&iface->pipes, p, next);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usbd_open_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "131-140",
    "snippet": "usbd_status \nusbd_open_pipe(iface, address, flags, pipe)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n{ \n\treturn (usbd_open_pipe_ival(iface, address, flags, pipe, \n\t\t\t\t    USBD_DEFAULT_INTERVAL));\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
      "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
      "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
      "u_int8_t address;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_open_pipe_ival",
          "args": [
            "iface",
            "address",
            "flags",
            "pipe",
            "USBD_DEFAULT_INTERVAL"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_ival",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "142-175",
          "snippet": "usbd_status \nusbd_open_pipe_ival(iface, address, flags, pipe, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tint ival;\n{ \n\tusbd_pipe_handle p;\n\tstruct usbd_endpoint *ep;\n\tusbd_status err;\n\tint i;\n\n\tDPRINTFN(3,(\"usbd_open_pipe: iface=%p address=0x%x flags=0x%x\\n\",\n\t\t    iface, address, flags));\n\n\tfor (i = 0; i < iface->idesc->bNumEndpoints; i++) {\n\t\tep = &iface->endpoints[i];\n\t\tif (ep->edesc == NULL)\n\t\t\treturn (USBD_IOERROR);\n\t\tif (ep->edesc->bEndpointAddress == address)\n\t\t\tgoto found;\n\t}\n\treturn (USBD_BAD_ADDRESS);\n found:\n\tif ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)\n\t\treturn (USBD_IN_USE);\n\terr = usbd_setup_pipe(iface->device, iface, ep, ival, &p);\n\tif (err)\n\t\treturn (err);\n\tLIST_INSERT_HEAD(&iface->pipes, p, next);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_ival(iface, address, flags, pipe, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tint ival;\n{ \n\tusbd_pipe_handle p;\n\tstruct usbd_endpoint *ep;\n\tusbd_status err;\n\tint i;\n\n\tDPRINTFN(3,(\"usbd_open_pipe: iface=%p address=0x%x flags=0x%x\\n\",\n\t\t    iface, address, flags));\n\n\tfor (i = 0; i < iface->idesc->bNumEndpoints; i++) {\n\t\tep = &iface->endpoints[i];\n\t\tif (ep->edesc == NULL)\n\t\t\treturn (USBD_IOERROR);\n\t\tif (ep->edesc->bEndpointAddress == address)\n\t\t\tgoto found;\n\t}\n\treturn (USBD_BAD_ADDRESS);\n found:\n\tif ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)\n\t\treturn (USBD_IN_USE);\n\terr = usbd_setup_pipe(iface->device, iface, ep, ival, &p);\n\tif (err)\n\t\treturn (err);\n\tLIST_INSERT_HEAD(&iface->pipes, p, next);\n\t*pipe = p;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe(iface, address, flags, pipe)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n{ \n\treturn (usbd_open_pipe_ival(iface, address, flags, pipe, \n\t\t\t\t    USBD_DEFAULT_INTERVAL));\n}"
  },
  {
    "function_name": "usbd_dump_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "116-128",
    "snippet": "void\nusbd_dump_queue(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tprintf(\"usbd_dump_queue: pipe=%p\\n\", pipe);\n\tfor (xfer = SIMPLEQ_FIRST(&pipe->queue);\n\t     xfer;\n\t     xfer = SIMPLEQ_NEXT(xfer, next)) {\n\t\tprintf(\"  xfer=%p\\n\", xfer);\n\t}\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  xfer=%p\\n\"",
            "xfer"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "xfer",
            "next"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pipe->queue"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_dump_queue(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_xfer_handle xfer;\n\n\tprintf(\"usbd_dump_queue: pipe=%p\\n\", pipe);\n\tfor (xfer = SIMPLEQ_FIRST(&pipe->queue);\n\t     xfer;\n\t     xfer = SIMPLEQ_NEXT(xfer, next)) {\n\t\tprintf(\"  xfer=%p\\n\", xfer);\n\t}\n}"
  },
  {
    "function_name": "usbd_xfer_isread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "102-111",
    "snippet": "Static __inline int\nusbd_xfer_isread(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\treturn (xfer->request.bmRequestType & UT_READ);\n\telse\n\t\treturn (xfer->pipe->endpoint->edesc->bEndpointAddress &\n\t\t\tUE_DIR_IN);\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "usbd_start_next __P((usbd_pipe_handle pipe));",
      "Static __inline int",
      "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
      "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
      "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
      "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic __inline int;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nStatic __inline int\nusbd_xfer_isread(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\treturn (xfer->request.bmRequestType & UT_READ);\n\telse\n\t\treturn (xfer->pipe->endpoint->edesc->bEndpointAddress &\n\t\t\tUE_DIR_IN);\n}"
  },
  {
    "function_name": "usbd_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "95-99",
    "snippet": "void\nusbd_finish()\n{\n\t--usbd_nbuses;\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static int usbd_nbuses = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic int usbd_nbuses = 0;\n\nvoid\nusbd_finish()\n{\n\t--usbd_nbuses;\n}"
  },
  {
    "function_name": "usbd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
    "lines": "89-93",
    "snippet": "void\nusbd_init()\n{\n\tusbd_nbuses++;\n}",
    "includes": [
      "#include \"usb_if.h\"",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/bus.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <machine/cpu.h>",
      "#include \"usb_if.h\"",
      "#include <sys/conf.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static int usbd_nbuses = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic int usbd_nbuses = 0;\n\nvoid\nusbd_init()\n{\n\tusbd_nbuses++;\n}"
  }
]