[
  {
    "function_name": "vgafbpcimmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/vgafb_pci.c",
    "lines": "371-380",
    "snippet": "int\nvgafbpcimmap(v, offset, prot)\n\tvoid *v;\n\toff_t offset;\n\tint prot;\n{\n\tstruct vgafb_pci_softc *sc = v;\n\n\treturn (vgafbmmap(sc->sc_vc, offset, prot));\n}",
    "includes": [
      "#include <dev/pci/vgafb_pcivar.h>",
      "#include <dev/ic/vgafbvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/pte.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tvgafbpcimmap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vgafbmmap",
          "args": [
            "sc->sc_vc",
            "offset",
            "prot"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "vgafbmmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/vgafb.c",
          "lines": "304-347",
          "snippet": "int\nvgafbmmap(v, offset, prot)\n\tvoid *v;\n\toff_t offset;\n\tint prot;\n{\n\tstruct vgafb_config *vc = v;\n\tbus_space_handle_t h;\n\tu_int32_t *port;\n\n\t/* memsize... */\n\tif (offset >= 0x00000 && offset < 0x800000)\t/* 8MB of mem??? */\n\t\th = vc->vc_memh + offset;\n\telse if (offset >= 0x10000000 && offset < 0x10040000 )\n\t\t/* 256KB of iohb */\n\t\th = vc->vc_ioh_b;\n\telse if (offset >= 0x10040000 && offset < 0x10080000)\n\t\t/* 256KB of iohc */\n\t\th = vc->vc_ioh_c;\n\telse if (offset >= 0x18880000 && offset < 0x100c0000)\n\t\t/* 256KB of iohd */\n\t\th = vc->vc_ioh_d;\n\telse if (offset >= 0x20000000 && offset < 0x30000000)\n\t\t/* mmiosize... */\n\t\th = vc->vc_mmioh + (offset - 0x20000000);\n\telse\n\t\treturn (-1);\n\n#ifdef alpha\n\tport = (u_int32_t *)(h << 5);\n\treturn alpha_btop(port);\t\t/* XXX */\n#elif defined(i386)\n\tport = (u_int32_t *)(h << 5);\n\treturn i386_btop(port);\n#elif defined(__powerpc__)\n\t{\n\t/* huh ??? */\n\treturn h;\n\t/*\n\treturn powerpc_btop(port);\n\t*/\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/wscons/wsconsvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void setPixel( struct vgafb_config *vc, int x, int y, int v);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/vgafbvar.h>\n#include <dev/wscons/wsconsvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void setPixel( struct vgafb_config *vc, int x, int y, int v);\n\nint\nvgafbmmap(v, offset, prot)\n\tvoid *v;\n\toff_t offset;\n\tint prot;\n{\n\tstruct vgafb_config *vc = v;\n\tbus_space_handle_t h;\n\tu_int32_t *port;\n\n\t/* memsize... */\n\tif (offset >= 0x00000 && offset < 0x800000)\t/* 8MB of mem??? */\n\t\th = vc->vc_memh + offset;\n\telse if (offset >= 0x10000000 && offset < 0x10040000 )\n\t\t/* 256KB of iohb */\n\t\th = vc->vc_ioh_b;\n\telse if (offset >= 0x10040000 && offset < 0x10080000)\n\t\t/* 256KB of iohc */\n\t\th = vc->vc_ioh_c;\n\telse if (offset >= 0x18880000 && offset < 0x100c0000)\n\t\t/* 256KB of iohd */\n\t\th = vc->vc_ioh_d;\n\telse if (offset >= 0x20000000 && offset < 0x30000000)\n\t\t/* mmiosize... */\n\t\th = vc->vc_mmioh + (offset - 0x20000000);\n\telse\n\t\treturn (-1);\n\n#ifdef alpha\n\tport = (u_int32_t *)(h << 5);\n\treturn alpha_btop(port);\t\t/* XXX */\n#elif defined(i386)\n\tport = (u_int32_t *)(h << 5);\n\treturn i386_btop(port);\n#elif defined(__powerpc__)\n\t{\n\t/* huh ??? */\n\treturn h;\n\t/*\n\treturn powerpc_btop(port);\n\t*/\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/vgafb_pcivar.h>\n#include <dev/ic/vgafbvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/pte.h>\n#include <machine/autoconf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tvgafbpcimmap;\n\nint\nvgafbpcimmap(v, offset, prot)\n\tvoid *v;\n\toff_t offset;\n\tint prot;\n{\n\tstruct vgafb_pci_softc *sc = v;\n\n\treturn (vgafbmmap(sc->sc_vc, offset, prot));\n}"
  },
  {
    "function_name": "vgafbpciioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/vgafb_pci.c",
    "lines": "358-369",
    "snippet": "int\nvgafbpciioctl(v, cmd, data, flag, p)\n\tvoid *v;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct vgafb_pci_softc *sc = v;\n\n\treturn (vgafbioctl(sc->sc_vc, cmd, data, flag, p));\n}",
    "includes": [
      "#include <dev/pci/vgafb_pcivar.h>",
      "#include <dev/ic/vgafbvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/pte.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tvgafbpciioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vgafbioctl",
          "args": [
            "sc->sc_vc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "vgafbioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/vgafb.c",
          "lines": "290-302",
          "snippet": "int\nvgafbioctl(v, cmd, data, flag, p)\n\tvoid *v;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\t/*struct vgafb_config *vc = v;*/\n\n\t/* XXX */\n\treturn -1;\n}",
          "includes": [
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/wscons/wsconsvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void setPixel( struct vgafb_config *vc, int x, int y, int v);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/vgafbvar.h>\n#include <dev/wscons/wsconsvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void setPixel( struct vgafb_config *vc, int x, int y, int v);\n\nint\nvgafbioctl(v, cmd, data, flag, p)\n\tvoid *v;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\t/*struct vgafb_config *vc = v;*/\n\n\t/* XXX */\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/vgafb_pcivar.h>\n#include <dev/ic/vgafbvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/pte.h>\n#include <machine/autoconf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tvgafbpciioctl;\n\nint\nvgafbpciioctl(v, cmd, data, flag, p)\n\tvoid *v;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct vgafb_pci_softc *sc = v;\n\n\treturn (vgafbioctl(sc->sc_vc, cmd, data, flag, p));\n}"
  },
  {
    "function_name": "vgafb_pci_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/vgafb_pci.c",
    "lines": "322-356",
    "snippet": "void\nvgafb_pci_console(iot, memt, pc, bus, device, function)\n\tbus_space_tag_t iot, memt;\n\tpci_chipset_tag_t pc;\n\tint bus, device, function;\n{\n\tstruct vgafb_config *vc = &vgafb_pci_console_vc;\n\tu_int32_t memaddr, memsize, mmioaddr;\n\tu_int32_t ioaddr, iosize, mmiosize;\n\tint retval;\n\tu_int32_t cacheable;\n\tstatic struct pci_attach_args spa;\n\tstruct pci_attach_args *pa = &spa;\n\n\t/* for later recognition */\n\tvgafb_pci_console_tag = pci_make_tag(pc, bus, device, function);\n\n\tpa->pa_iot = iot;\n\tpa->pa_memt = memt;\n\tpa->pa_tag = vgafb_pci_console_tag;\n\t/* \n\tpa->pa_pc = XXX;\n\t */\n\n/* XXX probe pci before pci bus config? */\n\n\tvgafb_pci_probe(pa, 0, &ioaddr, &iosize,\n\t\t&memaddr, &memsize, &cacheable, mmioaddr, mmiosize);\n\n\n\t/* set up bus-independent VGA configuration */\n\tvgafb_common_setup(iot, memt, vc, ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);\n\n\tvgafb_wscons_console(vc);\n}",
    "includes": [
      "#include <dev/pci/vgafb_pcivar.h>",
      "#include <dev/ic/vgafbvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/pte.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "pcitag_t vgafb_pci_console_tag;",
      "struct vgafb_config vgafb_pci_console_vc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vgafb_wscons_console",
          "args": [
            "vc"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "vgafb_wscons_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/vgafb.c",
          "lines": "260-277",
          "snippet": "void\nvgafb_wscons_console(vc)\n\tstruct vgafb_config *vc;\n{\n\tstruct wscons_odev_spec wo;\n\n        wo.wo_emulfuncs = &vgafb_emulfuncs;\n\two.wo_emulfuncs_cookie = vc;\n\n\t/* ioctl and mmap are unused until real attachment. */\n\n        wo.wo_nrows = vc->vc_nrow;\n        wo.wo_ncols = vc->vc_ncol;\n        wo.wo_crow = vc->vc_crow;\n        wo.wo_ccol = vc->vc_ccol;\n \n        wscons_attach_console(&wo);\n}",
          "includes": [
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/wscons/wsconsvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wscons_emulfuncs vgafb_emulfuncs = {\n\tvgafb_cursor,\n\tvgafb_putstr,\n\tvgafb_copycols,\n\tvgafb_erasecols,\n\tvgafb_copyrows,\n\tvgafb_eraserows,\n\tvgafb_set_attr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/vgafbvar.h>\n#include <dev/wscons/wsconsvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct wscons_emulfuncs vgafb_emulfuncs = {\n\tvgafb_cursor,\n\tvgafb_putstr,\n\tvgafb_copycols,\n\tvgafb_erasecols,\n\tvgafb_copyrows,\n\tvgafb_eraserows,\n\tvgafb_set_attr,\n};\n\nvoid\nvgafb_wscons_console(vc)\n\tstruct vgafb_config *vc;\n{\n\tstruct wscons_odev_spec wo;\n\n        wo.wo_emulfuncs = &vgafb_emulfuncs;\n\two.wo_emulfuncs_cookie = vc;\n\n\t/* ioctl and mmap are unused until real attachment. */\n\n        wo.wo_nrows = vc->vc_nrow;\n        wo.wo_ncols = vc->vc_ncol;\n        wo.wo_crow = vc->vc_crow;\n        wo.wo_ccol = vc->vc_ccol;\n \n        wscons_attach_console(&wo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vgafb_common_setup",
          "args": [
            "iot",
            "memt",
            "vc",
            "ioaddr",
            "iosize",
            "memaddr",
            "memsize",
            "mmioaddr",
            "mmiosize"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "vgafb_common_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/vgafb.c",
          "lines": "144-231",
          "snippet": "void\nvgafb_common_setup(iot, memt, vc, iobase, iosize, membase, memsize, mmiobase, mmiosize)\n\tbus_space_tag_t iot, memt;\n\tstruct vgafb_config *vc;\n\tu_int32_t iobase, membase, mmiobase;\n\tsize_t iosize, memsize, mmiosize;\n{\n\tint cpos;\n\tint width, height;\n\n        vc->vc_iot = iot;\n        vc->vc_memt = memt;\n\n\tif (iosize != 0) {\n           if (bus_space_map(vc->vc_iot, iobase+0x3b0, 0xc, 0, &vc->vc_ioh_b))\n\t\tpanic(\"vgafb_common_setup: couldn't map io b\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3c0, 0x10, 0, &vc->vc_ioh_c))\n\t\tpanic(\"vgafb_common_setup: couldn't map io c\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3d0, 0x10, 0, &vc->vc_ioh_d))\n\t\tpanic(\"vgafb_common_setup: couldn't map io d\");\n\t}\n\tif (mmiosize != 0) {\n           if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0, &vc->vc_mmioh))\n\t\tpanic(\"vgafb_common_setup: couldn't map mmio\");\n\t}\n        if (bus_space_map(vc->vc_memt, membase, memsize, 0, &vc->vc_memh))\n\t\tpanic(\"vgafb_common_setup: couldn't map memory\"); \n\n\tif (iosize != 0) {\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x1);\n\t\twidth = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t/* (stored value + 1) * depth -> pixel width */\n\t\twidth = ( width + 1 ) * 8;   \n\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t{ \n\t\t\tu_int8_t t1, t2, t3;\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t\tt1 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x7);\n\t\t\tt2 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\theight = t1 + ((t2&0x40) << 3) \n\t\t\t\t    + ((t2&0x02) << 7) + 1; \n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x17);\n\t\t\tt3 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\tif (t3 & 0x04) {\n\t\t\t\theight *= 2;\n\t\t\t}\n\t\t\tif (t1 == 0xff && t2 == 0xff && t3 == 0xff) {\n\t\t\t\t/* iospace not working??? */\n\t\t\t\t/* hope, better guess than 2048x2048 */\n\t\t\t\twidth = 640;\n\t\t\t\theight = 480;\n\t\t\t}\n\t\t}\n\t\tvc->vc_ncol = width / FONT_WIDTH;\n\t\tvc->vc_nrow = height / FONT_HEIGHT;\n\t} else {\n\t\t/* iosize == 0\n\t\t * default to 640x480 and hope \n\t\t */\n\t\tvc->vc_ncol = 640 / FONT_WIDTH;\n\t\tvc->vc_nrow = 480 / FONT_HEIGHT;\n\t}\n\tprintf(\", %dx%d\", vc->vc_ncol, vc->vc_nrow);\n\n\tvc->vc_crow = vc->vc_ccol = 0; /* Has to be some onscreen value */\n\tvc->vc_so = 0;\n\n\t/* clear screen, frob cursor, etc.? */\n\tvgafb_eraserows(vc, 0, vc->vc_nrow);\n\n#if defined(alpha)\n\t/*\n\t * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!\n\t * XXX Therefore, though the comments say \"blue bg\", the code uses\n\t * XXX the value for a red background!\n\t */\n\tvc->vc_at = 0x40 | 0x0f;\t\t/* blue bg|white fg */\n\tvc->vc_so_at = 0x40 | 0x0f | 0x80;\t/* blue bg|white fg|blink */\n#else\n\tvc->vc_at = 0x00 | 0xf;\t\t\t/* black bg|white fg */\n\tvc->vc_so_at = 0x00 | 0xf | 0x80;\t/* black bg|white fg|blink */\n#endif\n}",
          "includes": [
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/wscons/wsconsvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define FONT_HEIGHT 16",
            "#define FONT_WIDTH 8"
          ],
          "globals_used": [
            "void\tvgafb_eraserows"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/vgafbvar.h>\n#include <dev/wscons/wsconsvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define FONT_HEIGHT 16\n#define FONT_WIDTH 8\n\nvoid\tvgafb_eraserows;\n\nvoid\nvgafb_common_setup(iot, memt, vc, iobase, iosize, membase, memsize, mmiobase, mmiosize)\n\tbus_space_tag_t iot, memt;\n\tstruct vgafb_config *vc;\n\tu_int32_t iobase, membase, mmiobase;\n\tsize_t iosize, memsize, mmiosize;\n{\n\tint cpos;\n\tint width, height;\n\n        vc->vc_iot = iot;\n        vc->vc_memt = memt;\n\n\tif (iosize != 0) {\n           if (bus_space_map(vc->vc_iot, iobase+0x3b0, 0xc, 0, &vc->vc_ioh_b))\n\t\tpanic(\"vgafb_common_setup: couldn't map io b\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3c0, 0x10, 0, &vc->vc_ioh_c))\n\t\tpanic(\"vgafb_common_setup: couldn't map io c\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3d0, 0x10, 0, &vc->vc_ioh_d))\n\t\tpanic(\"vgafb_common_setup: couldn't map io d\");\n\t}\n\tif (mmiosize != 0) {\n           if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0, &vc->vc_mmioh))\n\t\tpanic(\"vgafb_common_setup: couldn't map mmio\");\n\t}\n        if (bus_space_map(vc->vc_memt, membase, memsize, 0, &vc->vc_memh))\n\t\tpanic(\"vgafb_common_setup: couldn't map memory\"); \n\n\tif (iosize != 0) {\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x1);\n\t\twidth = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t/* (stored value + 1) * depth -> pixel width */\n\t\twidth = ( width + 1 ) * 8;   \n\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t{ \n\t\t\tu_int8_t t1, t2, t3;\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t\tt1 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x7);\n\t\t\tt2 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\theight = t1 + ((t2&0x40) << 3) \n\t\t\t\t    + ((t2&0x02) << 7) + 1; \n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x17);\n\t\t\tt3 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\tif (t3 & 0x04) {\n\t\t\t\theight *= 2;\n\t\t\t}\n\t\t\tif (t1 == 0xff && t2 == 0xff && t3 == 0xff) {\n\t\t\t\t/* iospace not working??? */\n\t\t\t\t/* hope, better guess than 2048x2048 */\n\t\t\t\twidth = 640;\n\t\t\t\theight = 480;\n\t\t\t}\n\t\t}\n\t\tvc->vc_ncol = width / FONT_WIDTH;\n\t\tvc->vc_nrow = height / FONT_HEIGHT;\n\t} else {\n\t\t/* iosize == 0\n\t\t * default to 640x480 and hope \n\t\t */\n\t\tvc->vc_ncol = 640 / FONT_WIDTH;\n\t\tvc->vc_nrow = 480 / FONT_HEIGHT;\n\t}\n\tprintf(\", %dx%d\", vc->vc_ncol, vc->vc_nrow);\n\n\tvc->vc_crow = vc->vc_ccol = 0; /* Has to be some onscreen value */\n\tvc->vc_so = 0;\n\n\t/* clear screen, frob cursor, etc.? */\n\tvgafb_eraserows(vc, 0, vc->vc_nrow);\n\n#if defined(alpha)\n\t/*\n\t * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!\n\t * XXX Therefore, though the comments say \"blue bg\", the code uses\n\t * XXX the value for a red background!\n\t */\n\tvc->vc_at = 0x40 | 0x0f;\t\t/* blue bg|white fg */\n\tvc->vc_so_at = 0x40 | 0x0f | 0x80;\t/* blue bg|white fg|blink */\n#else\n\tvc->vc_at = 0x00 | 0xf;\t\t\t/* black bg|white fg */\n\tvc->vc_so_at = 0x00 | 0xf | 0x80;\t/* black bg|white fg|blink */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "vgafb_pci_probe",
          "args": [
            "pa",
            "0",
            "&ioaddr",
            "&iosize",
            "&memaddr",
            "&memsize",
            "&cacheable",
            "mmioaddr",
            "mmiosize"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "vgafb_pci_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/vgafb_pci.c",
          "lines": "80-196",
          "snippet": "int\nvgafb_pci_probe(pa, id, ioaddr, iosize, memaddr, memsize, cacheable, mmioaddr, mmiosize)\n\tstruct pci_attach_args *pa;\n\tint id;\n\tu_int32_t *ioaddr, *iosize;\n\tu_int32_t *memaddr, *memsize, *cacheable;\n\tu_int32_t *mmioaddr, *mmiosize;\n{\n\tu_int32_t addr, size, tcacheable;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint retval;\n\tint i;\n\n\t*iosize   = 0x0;\n\t*memsize  = 0x0;\n\t*mmiosize = 0x0;\n\tfor (i = 0x10; i < 0x18; i += 4) {\n#ifdef DEBUG_VGAFB\n\t\tprintf(\"vgafb confread %x %x\\n\",\n\t\t\ti, pci_conf_read(pc, pa->pa_tag, i));\n#endif\n\t\t/* need to check more than just two base addresses? */\n\t\tif (0x1 & pci_conf_read(pc, pa->pa_tag, i) ) {\n\t\t\tretval = pci_io_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size);\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: io %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*iosize == 0) {\n\t\t\t\t*ioaddr = addr;\n\t\t\t\t*iosize = size;\n\t\t\t}\n\n\t\t} else {\n\t\t\tretval = pci_mem_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size, &tcacheable);\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n#endif\n\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (size == 0) {\n\t\t\t\t/* ignore this entry */\n\t\t\t}else if (size <= (64 * 1024)) {\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x iosize %x\\n\",\n\t\ti, addr, size, *iosize);\n#endif\n\t\t\t\tif (*mmiosize == 0) {\n\t\t\t\t\t/* this is mmio, not memory */\n\t\t\t\t\t*mmioaddr = addr;\n\t\t\t\t\t*mmiosize = size;\n\t\t\t\t\t/* need skew in here for io memspace */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*memsize == 0) {\n\t\t\t\t\t*memaddr = addr;\n\t\t\t\t\t*memsize = size;\n\t\t\t\t\t*cacheable = tcacheable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\tif (*iosize == 0) {\n\t\tif (id == 0) {\n#ifdef powerpc\n\t\t\t/* this is only used if on openfirmware system and\n\t\t\t * the device does not have a iobase config register,\n\t\t\t * eg CirrusLogic 5434 VGA.  (they hardcode iobase to 0\n\t\t\t * thus giving standard PC addresses for the registers) \n\t\t\t */\n\t\t\tint s;\n\t\t\tu_int32_t sizedata;\n\n\t\t\t/*\n\t\t\t * Open Firmware (yuck) shuts down devices before\n\t\t\t * entering a program so we need to bring them back\n\t\t\t * 'online' to respond to bus accesses... so far\n\t\t\t * this is true on the power.4e.\n\t\t\t */\n\t\t\ts = splhigh();\n\t\t\tsizedata = pci_conf_read(pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\t\t\tsizedata |= (PCI_COMMAND_MASTER_ENABLE |\n\t\t\t\t     PCI_COMMAND_IO_ENABLE |\n\t\t\t\t     PCI_COMMAND_PARITY_ENABLE |\n\t\t\t\t     PCI_COMMAND_SERR_ENABLE);\n\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t\tsizedata);\n\t\t\tsplx(s);\n\n#endif\n\t\t\t/* if this is the first card, allow it\n\t\t\t * to be accessed in vga iospace\n\t\t\t */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize = 0x10000; /* 64k, good as any */\n\t\t} else {\n\t\t\t/* iospace not available, assume 640x480, pray */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize=0;\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/vgafb_pcivar.h>",
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/pte.h>",
            "#include <machine/autoconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_VGAFB"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/vgafb_pcivar.h>\n#include <dev/ic/vgafbvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/pte.h>\n#include <machine/autoconf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_VGAFB\n\nint\nvgafb_pci_probe(pa, id, ioaddr, iosize, memaddr, memsize, cacheable, mmioaddr, mmiosize)\n\tstruct pci_attach_args *pa;\n\tint id;\n\tu_int32_t *ioaddr, *iosize;\n\tu_int32_t *memaddr, *memsize, *cacheable;\n\tu_int32_t *mmioaddr, *mmiosize;\n{\n\tu_int32_t addr, size, tcacheable;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint retval;\n\tint i;\n\n\t*iosize   = 0x0;\n\t*memsize  = 0x0;\n\t*mmiosize = 0x0;\n\tfor (i = 0x10; i < 0x18; i += 4) {\n#ifdef DEBUG_VGAFB\n\t\tprintf(\"vgafb confread %x %x\\n\",\n\t\t\ti, pci_conf_read(pc, pa->pa_tag, i));\n#endif\n\t\t/* need to check more than just two base addresses? */\n\t\tif (0x1 & pci_conf_read(pc, pa->pa_tag, i) ) {\n\t\t\tretval = pci_io_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size);\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: io %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*iosize == 0) {\n\t\t\t\t*ioaddr = addr;\n\t\t\t\t*iosize = size;\n\t\t\t}\n\n\t\t} else {\n\t\t\tretval = pci_mem_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size, &tcacheable);\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n#endif\n\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (size == 0) {\n\t\t\t\t/* ignore this entry */\n\t\t\t}else if (size <= (64 * 1024)) {\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x iosize %x\\n\",\n\t\ti, addr, size, *iosize);\n#endif\n\t\t\t\tif (*mmiosize == 0) {\n\t\t\t\t\t/* this is mmio, not memory */\n\t\t\t\t\t*mmioaddr = addr;\n\t\t\t\t\t*mmiosize = size;\n\t\t\t\t\t/* need skew in here for io memspace */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*memsize == 0) {\n\t\t\t\t\t*memaddr = addr;\n\t\t\t\t\t*memsize = size;\n\t\t\t\t\t*cacheable = tcacheable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\tif (*iosize == 0) {\n\t\tif (id == 0) {\n#ifdef powerpc\n\t\t\t/* this is only used if on openfirmware system and\n\t\t\t * the device does not have a iobase config register,\n\t\t\t * eg CirrusLogic 5434 VGA.  (they hardcode iobase to 0\n\t\t\t * thus giving standard PC addresses for the registers) \n\t\t\t */\n\t\t\tint s;\n\t\t\tu_int32_t sizedata;\n\n\t\t\t/*\n\t\t\t * Open Firmware (yuck) shuts down devices before\n\t\t\t * entering a program so we need to bring them back\n\t\t\t * 'online' to respond to bus accesses... so far\n\t\t\t * this is true on the power.4e.\n\t\t\t */\n\t\t\ts = splhigh();\n\t\t\tsizedata = pci_conf_read(pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\t\t\tsizedata |= (PCI_COMMAND_MASTER_ENABLE |\n\t\t\t\t     PCI_COMMAND_IO_ENABLE |\n\t\t\t\t     PCI_COMMAND_PARITY_ENABLE |\n\t\t\t\t     PCI_COMMAND_SERR_ENABLE);\n\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t\tsizedata);\n\t\t\tsplx(s);\n\n#endif\n\t\t\t/* if this is the first card, allow it\n\t\t\t * to be accessed in vga iospace\n\t\t\t */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize = 0x10000; /* 64k, good as any */\n\t\t} else {\n\t\t\t/* iospace not available, assume 640x480, pray */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize=0;\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_make_tag",
          "args": [
            "pc",
            "bus",
            "device",
            "function"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/vgafb_pcivar.h>\n#include <dev/ic/vgafbvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/pte.h>\n#include <machine/autoconf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\npcitag_t vgafb_pci_console_tag;\nstruct vgafb_config vgafb_pci_console_vc;\n\nvoid\nvgafb_pci_console(iot, memt, pc, bus, device, function)\n\tbus_space_tag_t iot, memt;\n\tpci_chipset_tag_t pc;\n\tint bus, device, function;\n{\n\tstruct vgafb_config *vc = &vgafb_pci_console_vc;\n\tu_int32_t memaddr, memsize, mmioaddr;\n\tu_int32_t ioaddr, iosize, mmiosize;\n\tint retval;\n\tu_int32_t cacheable;\n\tstatic struct pci_attach_args spa;\n\tstruct pci_attach_args *pa = &spa;\n\n\t/* for later recognition */\n\tvgafb_pci_console_tag = pci_make_tag(pc, bus, device, function);\n\n\tpa->pa_iot = iot;\n\tpa->pa_memt = memt;\n\tpa->pa_tag = vgafb_pci_console_tag;\n\t/* \n\tpa->pa_pc = XXX;\n\t */\n\n/* XXX probe pci before pci bus config? */\n\n\tvgafb_pci_probe(pa, 0, &ioaddr, &iosize,\n\t\t&memaddr, &memsize, &cacheable, mmioaddr, mmiosize);\n\n\n\t/* set up bus-independent VGA configuration */\n\tvgafb_common_setup(iot, memt, vc, ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);\n\n\tvgafb_wscons_console(vc);\n}"
  },
  {
    "function_name": "vgafb_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/vgafb_pci.c",
    "lines": "274-320",
    "snippet": "void\nvgafb_pci_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tstruct vgafb_pci_softc *sc = (struct vgafb_pci_softc *)self;\n\tstruct vgafb_config *vc;\n\tu_int32_t memaddr, memsize, cacheable;\n\tu_int32_t ioaddr, iosize;\n\tu_int32_t mmioaddr, mmiosize;\n\tint console;\n\tstatic int id = 0;\n\tint myid;\n\n\tmyid = id;\n\n\tvgafb_pci_probe(pa, myid, &ioaddr, &iosize,\n\t\t&memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);\n\n\tconsole = (!bcmp(&pa->pa_tag, &vgafb_pci_console_tag, sizeof(pa->pa_tag)));\n\tif (console)\n\t\tvc = sc->sc_vc = &vgafb_pci_console_vc;\n\telse {\n\t\tvc = sc->sc_vc = (struct vgafb_config *)\n\t\t    malloc(sizeof(struct vgafb_config), M_DEVBUF, M_WAITOK);\n\n\t\t/* set up bus-independent VGA configuration */\n\t\tvgafb_common_setup(pa->pa_iot, pa->pa_memt, vc, \n\t\tioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);\n\t}\n\tvc->vc_mmap = vgafbpcimmap;\n\tvc->vc_ioctl = vgafbpciioctl;\n\n\tsc->sc_pcitag = pa->pa_tag;\n\n\tif (iosize == 0) {\n\t\tprintf (\", no io\");\n\t}\n\tif (mmiosize != 0) {\n\t\tprintf (\", mmio\");\n\t}\n\tprintf(\"\\n\");\n\n\tvgafb_wscons_attach(self, vc, console);\n\tid++;\n}",
    "includes": [
      "#include <dev/pci/vgafb_pcivar.h>",
      "#include <dev/ic/vgafbvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/pte.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tvgafb_pci_attach",
      "int\tvgafbpcimmap",
      "int\tvgafbpciioctl",
      "pcitag_t vgafb_pci_console_tag;",
      "struct vgafb_config vgafb_pci_console_vc;",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vgafb_wscons_attach",
          "args": [
            "self",
            "vc",
            "console"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "vgafb_wscons_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/vgafb.c",
          "lines": "233-258",
          "snippet": "void\nvgafb_wscons_attach(parent, vc, console)\n\tstruct device *parent;\n\tstruct vgafb_config *vc;\n\tint console;\n{\n\tstruct wscons_attach_args waa;\n\tstruct wscons_odev_spec *wo;\n\n        waa.waa_isconsole = console;\n        wo = &waa.waa_odev_spec;\n\n        wo->wo_emulfuncs = &vgafb_emulfuncs;\n\two->wo_emulfuncs_cookie = vc;\n\n        wo->wo_ioctl = vc->vc_ioctl;\n        wo->wo_mmap = vc->vc_mmap;\n        wo->wo_miscfuncs_cookie = vc;\n\n        wo->wo_nrows = vc->vc_nrow;\n        wo->wo_ncols = vc->vc_ncol;\n        wo->wo_crow = vc->vc_crow;\n        wo->wo_ccol = vc->vc_ccol;\n \n        config_found(parent, &waa, vgafb_print);\n}",
          "includes": [
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/wscons/wsconsvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wscons_emulfuncs vgafb_emulfuncs = {\n\tvgafb_cursor,\n\tvgafb_putstr,\n\tvgafb_copycols,\n\tvgafb_erasecols,\n\tvgafb_copyrows,\n\tvgafb_eraserows,\n\tvgafb_set_attr,\n};",
            "int\tvgafb_print"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/vgafbvar.h>\n#include <dev/wscons/wsconsvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct wscons_emulfuncs vgafb_emulfuncs = {\n\tvgafb_cursor,\n\tvgafb_putstr,\n\tvgafb_copycols,\n\tvgafb_erasecols,\n\tvgafb_copyrows,\n\tvgafb_eraserows,\n\tvgafb_set_attr,\n};\nint\tvgafb_print;\n\nvoid\nvgafb_wscons_attach(parent, vc, console)\n\tstruct device *parent;\n\tstruct vgafb_config *vc;\n\tint console;\n{\n\tstruct wscons_attach_args waa;\n\tstruct wscons_odev_spec *wo;\n\n        waa.waa_isconsole = console;\n        wo = &waa.waa_odev_spec;\n\n        wo->wo_emulfuncs = &vgafb_emulfuncs;\n\two->wo_emulfuncs_cookie = vc;\n\n        wo->wo_ioctl = vc->vc_ioctl;\n        wo->wo_mmap = vc->vc_mmap;\n        wo->wo_miscfuncs_cookie = vc;\n\n        wo->wo_nrows = vc->vc_nrow;\n        wo->wo_ncols = vc->vc_ncol;\n        wo->wo_crow = vc->vc_crow;\n        wo->wo_ccol = vc->vc_ccol;\n \n        config_found(parent, &waa, vgafb_print);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vgafb_common_setup",
          "args": [
            "pa->pa_iot",
            "pa->pa_memt",
            "vc",
            "ioaddr",
            "iosize",
            "memaddr",
            "memsize",
            "mmioaddr",
            "mmiosize"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "vgafb_common_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/vgafb.c",
          "lines": "144-231",
          "snippet": "void\nvgafb_common_setup(iot, memt, vc, iobase, iosize, membase, memsize, mmiobase, mmiosize)\n\tbus_space_tag_t iot, memt;\n\tstruct vgafb_config *vc;\n\tu_int32_t iobase, membase, mmiobase;\n\tsize_t iosize, memsize, mmiosize;\n{\n\tint cpos;\n\tint width, height;\n\n        vc->vc_iot = iot;\n        vc->vc_memt = memt;\n\n\tif (iosize != 0) {\n           if (bus_space_map(vc->vc_iot, iobase+0x3b0, 0xc, 0, &vc->vc_ioh_b))\n\t\tpanic(\"vgafb_common_setup: couldn't map io b\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3c0, 0x10, 0, &vc->vc_ioh_c))\n\t\tpanic(\"vgafb_common_setup: couldn't map io c\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3d0, 0x10, 0, &vc->vc_ioh_d))\n\t\tpanic(\"vgafb_common_setup: couldn't map io d\");\n\t}\n\tif (mmiosize != 0) {\n           if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0, &vc->vc_mmioh))\n\t\tpanic(\"vgafb_common_setup: couldn't map mmio\");\n\t}\n        if (bus_space_map(vc->vc_memt, membase, memsize, 0, &vc->vc_memh))\n\t\tpanic(\"vgafb_common_setup: couldn't map memory\"); \n\n\tif (iosize != 0) {\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x1);\n\t\twidth = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t/* (stored value + 1) * depth -> pixel width */\n\t\twidth = ( width + 1 ) * 8;   \n\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t{ \n\t\t\tu_int8_t t1, t2, t3;\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t\tt1 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x7);\n\t\t\tt2 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\theight = t1 + ((t2&0x40) << 3) \n\t\t\t\t    + ((t2&0x02) << 7) + 1; \n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x17);\n\t\t\tt3 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\tif (t3 & 0x04) {\n\t\t\t\theight *= 2;\n\t\t\t}\n\t\t\tif (t1 == 0xff && t2 == 0xff && t3 == 0xff) {\n\t\t\t\t/* iospace not working??? */\n\t\t\t\t/* hope, better guess than 2048x2048 */\n\t\t\t\twidth = 640;\n\t\t\t\theight = 480;\n\t\t\t}\n\t\t}\n\t\tvc->vc_ncol = width / FONT_WIDTH;\n\t\tvc->vc_nrow = height / FONT_HEIGHT;\n\t} else {\n\t\t/* iosize == 0\n\t\t * default to 640x480 and hope \n\t\t */\n\t\tvc->vc_ncol = 640 / FONT_WIDTH;\n\t\tvc->vc_nrow = 480 / FONT_HEIGHT;\n\t}\n\tprintf(\", %dx%d\", vc->vc_ncol, vc->vc_nrow);\n\n\tvc->vc_crow = vc->vc_ccol = 0; /* Has to be some onscreen value */\n\tvc->vc_so = 0;\n\n\t/* clear screen, frob cursor, etc.? */\n\tvgafb_eraserows(vc, 0, vc->vc_nrow);\n\n#if defined(alpha)\n\t/*\n\t * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!\n\t * XXX Therefore, though the comments say \"blue bg\", the code uses\n\t * XXX the value for a red background!\n\t */\n\tvc->vc_at = 0x40 | 0x0f;\t\t/* blue bg|white fg */\n\tvc->vc_so_at = 0x40 | 0x0f | 0x80;\t/* blue bg|white fg|blink */\n#else\n\tvc->vc_at = 0x00 | 0xf;\t\t\t/* black bg|white fg */\n\tvc->vc_so_at = 0x00 | 0xf | 0x80;\t/* black bg|white fg|blink */\n#endif\n}",
          "includes": [
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/wscons/wsconsvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define FONT_HEIGHT 16",
            "#define FONT_WIDTH 8"
          ],
          "globals_used": [
            "void\tvgafb_eraserows"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/vgafbvar.h>\n#include <dev/wscons/wsconsvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define FONT_HEIGHT 16\n#define FONT_WIDTH 8\n\nvoid\tvgafb_eraserows;\n\nvoid\nvgafb_common_setup(iot, memt, vc, iobase, iosize, membase, memsize, mmiobase, mmiosize)\n\tbus_space_tag_t iot, memt;\n\tstruct vgafb_config *vc;\n\tu_int32_t iobase, membase, mmiobase;\n\tsize_t iosize, memsize, mmiosize;\n{\n\tint cpos;\n\tint width, height;\n\n        vc->vc_iot = iot;\n        vc->vc_memt = memt;\n\n\tif (iosize != 0) {\n           if (bus_space_map(vc->vc_iot, iobase+0x3b0, 0xc, 0, &vc->vc_ioh_b))\n\t\tpanic(\"vgafb_common_setup: couldn't map io b\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3c0, 0x10, 0, &vc->vc_ioh_c))\n\t\tpanic(\"vgafb_common_setup: couldn't map io c\");\n           if (bus_space_map(vc->vc_iot, iobase+0x3d0, 0x10, 0, &vc->vc_ioh_d))\n\t\tpanic(\"vgafb_common_setup: couldn't map io d\");\n\t}\n\tif (mmiosize != 0) {\n           if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0, &vc->vc_mmioh))\n\t\tpanic(\"vgafb_common_setup: couldn't map mmio\");\n\t}\n        if (bus_space_map(vc->vc_memt, membase, memsize, 0, &vc->vc_memh))\n\t\tpanic(\"vgafb_common_setup: couldn't map memory\"); \n\n\tif (iosize != 0) {\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x1);\n\t\twidth = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t/* (stored value + 1) * depth -> pixel width */\n\t\twidth = ( width + 1 ) * 8;   \n\n\t\t/* CR1 - Horiz. Display End */\n\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t{ \n\t\t\tu_int8_t t1, t2, t3;\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);\n\t\t\tt1 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x7);\n\t\t\tt2 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\theight = t1 + ((t2&0x40) << 3) \n\t\t\t\t    + ((t2&0x02) << 7) + 1; \n\t\t\tbus_space_write_1(iot, vc->vc_ioh_d, 4, 0x17);\n\t\t\tt3 = bus_space_read_1(iot, vc->vc_ioh_d, 5);\n\t\t\tif (t3 & 0x04) {\n\t\t\t\theight *= 2;\n\t\t\t}\n\t\t\tif (t1 == 0xff && t2 == 0xff && t3 == 0xff) {\n\t\t\t\t/* iospace not working??? */\n\t\t\t\t/* hope, better guess than 2048x2048 */\n\t\t\t\twidth = 640;\n\t\t\t\theight = 480;\n\t\t\t}\n\t\t}\n\t\tvc->vc_ncol = width / FONT_WIDTH;\n\t\tvc->vc_nrow = height / FONT_HEIGHT;\n\t} else {\n\t\t/* iosize == 0\n\t\t * default to 640x480 and hope \n\t\t */\n\t\tvc->vc_ncol = 640 / FONT_WIDTH;\n\t\tvc->vc_nrow = 480 / FONT_HEIGHT;\n\t}\n\tprintf(\", %dx%d\", vc->vc_ncol, vc->vc_nrow);\n\n\tvc->vc_crow = vc->vc_ccol = 0; /* Has to be some onscreen value */\n\tvc->vc_so = 0;\n\n\t/* clear screen, frob cursor, etc.? */\n\tvgafb_eraserows(vc, 0, vc->vc_nrow);\n\n#if defined(alpha)\n\t/*\n\t * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!\n\t * XXX Therefore, though the comments say \"blue bg\", the code uses\n\t * XXX the value for a red background!\n\t */\n\tvc->vc_at = 0x40 | 0x0f;\t\t/* blue bg|white fg */\n\tvc->vc_so_at = 0x40 | 0x0f | 0x80;\t/* blue bg|white fg|blink */\n#else\n\tvc->vc_at = 0x00 | 0xf;\t\t\t/* black bg|white fg */\n\tvc->vc_so_at = 0x00 | 0xf | 0x80;\t/* black bg|white fg|blink */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct vgafb_config)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "&pa->pa_tag",
            "&vgafb_pci_console_tag",
            "sizeof(pa->pa_tag)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vgafb_pci_probe",
          "args": [
            "pa",
            "myid",
            "&ioaddr",
            "&iosize",
            "&memaddr",
            "&memsize",
            "&cacheable",
            "&mmioaddr",
            "&mmiosize"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "vgafb_pci_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/vgafb_pci.c",
          "lines": "80-196",
          "snippet": "int\nvgafb_pci_probe(pa, id, ioaddr, iosize, memaddr, memsize, cacheable, mmioaddr, mmiosize)\n\tstruct pci_attach_args *pa;\n\tint id;\n\tu_int32_t *ioaddr, *iosize;\n\tu_int32_t *memaddr, *memsize, *cacheable;\n\tu_int32_t *mmioaddr, *mmiosize;\n{\n\tu_int32_t addr, size, tcacheable;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint retval;\n\tint i;\n\n\t*iosize   = 0x0;\n\t*memsize  = 0x0;\n\t*mmiosize = 0x0;\n\tfor (i = 0x10; i < 0x18; i += 4) {\n#ifdef DEBUG_VGAFB\n\t\tprintf(\"vgafb confread %x %x\\n\",\n\t\t\ti, pci_conf_read(pc, pa->pa_tag, i));\n#endif\n\t\t/* need to check more than just two base addresses? */\n\t\tif (0x1 & pci_conf_read(pc, pa->pa_tag, i) ) {\n\t\t\tretval = pci_io_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size);\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: io %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*iosize == 0) {\n\t\t\t\t*ioaddr = addr;\n\t\t\t\t*iosize = size;\n\t\t\t}\n\n\t\t} else {\n\t\t\tretval = pci_mem_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size, &tcacheable);\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n#endif\n\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (size == 0) {\n\t\t\t\t/* ignore this entry */\n\t\t\t}else if (size <= (64 * 1024)) {\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x iosize %x\\n\",\n\t\ti, addr, size, *iosize);\n#endif\n\t\t\t\tif (*mmiosize == 0) {\n\t\t\t\t\t/* this is mmio, not memory */\n\t\t\t\t\t*mmioaddr = addr;\n\t\t\t\t\t*mmiosize = size;\n\t\t\t\t\t/* need skew in here for io memspace */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*memsize == 0) {\n\t\t\t\t\t*memaddr = addr;\n\t\t\t\t\t*memsize = size;\n\t\t\t\t\t*cacheable = tcacheable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\tif (*iosize == 0) {\n\t\tif (id == 0) {\n#ifdef powerpc\n\t\t\t/* this is only used if on openfirmware system and\n\t\t\t * the device does not have a iobase config register,\n\t\t\t * eg CirrusLogic 5434 VGA.  (they hardcode iobase to 0\n\t\t\t * thus giving standard PC addresses for the registers) \n\t\t\t */\n\t\t\tint s;\n\t\t\tu_int32_t sizedata;\n\n\t\t\t/*\n\t\t\t * Open Firmware (yuck) shuts down devices before\n\t\t\t * entering a program so we need to bring them back\n\t\t\t * 'online' to respond to bus accesses... so far\n\t\t\t * this is true on the power.4e.\n\t\t\t */\n\t\t\ts = splhigh();\n\t\t\tsizedata = pci_conf_read(pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\t\t\tsizedata |= (PCI_COMMAND_MASTER_ENABLE |\n\t\t\t\t     PCI_COMMAND_IO_ENABLE |\n\t\t\t\t     PCI_COMMAND_PARITY_ENABLE |\n\t\t\t\t     PCI_COMMAND_SERR_ENABLE);\n\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t\tsizedata);\n\t\t\tsplx(s);\n\n#endif\n\t\t\t/* if this is the first card, allow it\n\t\t\t * to be accessed in vga iospace\n\t\t\t */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize = 0x10000; /* 64k, good as any */\n\t\t} else {\n\t\t\t/* iospace not available, assume 640x480, pray */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize=0;\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/vgafb_pcivar.h>",
            "#include <dev/ic/vgafbvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/pte.h>",
            "#include <machine/autoconf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_VGAFB"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/vgafb_pcivar.h>\n#include <dev/ic/vgafbvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/pte.h>\n#include <machine/autoconf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_VGAFB\n\nint\nvgafb_pci_probe(pa, id, ioaddr, iosize, memaddr, memsize, cacheable, mmioaddr, mmiosize)\n\tstruct pci_attach_args *pa;\n\tint id;\n\tu_int32_t *ioaddr, *iosize;\n\tu_int32_t *memaddr, *memsize, *cacheable;\n\tu_int32_t *mmioaddr, *mmiosize;\n{\n\tu_int32_t addr, size, tcacheable;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint retval;\n\tint i;\n\n\t*iosize   = 0x0;\n\t*memsize  = 0x0;\n\t*mmiosize = 0x0;\n\tfor (i = 0x10; i < 0x18; i += 4) {\n#ifdef DEBUG_VGAFB\n\t\tprintf(\"vgafb confread %x %x\\n\",\n\t\t\ti, pci_conf_read(pc, pa->pa_tag, i));\n#endif\n\t\t/* need to check more than just two base addresses? */\n\t\tif (0x1 & pci_conf_read(pc, pa->pa_tag, i) ) {\n\t\t\tretval = pci_io_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size);\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: io %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*iosize == 0) {\n\t\t\t\t*ioaddr = addr;\n\t\t\t\t*iosize = size;\n\t\t\t}\n\n\t\t} else {\n\t\t\tretval = pci_mem_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size, &tcacheable);\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n#endif\n\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (size == 0) {\n\t\t\t\t/* ignore this entry */\n\t\t\t}else if (size <= (64 * 1024)) {\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x iosize %x\\n\",\n\t\ti, addr, size, *iosize);\n#endif\n\t\t\t\tif (*mmiosize == 0) {\n\t\t\t\t\t/* this is mmio, not memory */\n\t\t\t\t\t*mmioaddr = addr;\n\t\t\t\t\t*mmiosize = size;\n\t\t\t\t\t/* need skew in here for io memspace */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*memsize == 0) {\n\t\t\t\t\t*memaddr = addr;\n\t\t\t\t\t*memsize = size;\n\t\t\t\t\t*cacheable = tcacheable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\tif (*iosize == 0) {\n\t\tif (id == 0) {\n#ifdef powerpc\n\t\t\t/* this is only used if on openfirmware system and\n\t\t\t * the device does not have a iobase config register,\n\t\t\t * eg CirrusLogic 5434 VGA.  (they hardcode iobase to 0\n\t\t\t * thus giving standard PC addresses for the registers) \n\t\t\t */\n\t\t\tint s;\n\t\t\tu_int32_t sizedata;\n\n\t\t\t/*\n\t\t\t * Open Firmware (yuck) shuts down devices before\n\t\t\t * entering a program so we need to bring them back\n\t\t\t * 'online' to respond to bus accesses... so far\n\t\t\t * this is true on the power.4e.\n\t\t\t */\n\t\t\ts = splhigh();\n\t\t\tsizedata = pci_conf_read(pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\t\t\tsizedata |= (PCI_COMMAND_MASTER_ENABLE |\n\t\t\t\t     PCI_COMMAND_IO_ENABLE |\n\t\t\t\t     PCI_COMMAND_PARITY_ENABLE |\n\t\t\t\t     PCI_COMMAND_SERR_ENABLE);\n\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t\tsizedata);\n\t\t\tsplx(s);\n\n#endif\n\t\t\t/* if this is the first card, allow it\n\t\t\t * to be accessed in vga iospace\n\t\t\t */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize = 0x10000; /* 64k, good as any */\n\t\t} else {\n\t\t\t/* iospace not available, assume 640x480, pray */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize=0;\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/vgafb_pcivar.h>\n#include <dev/ic/vgafbvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/pte.h>\n#include <machine/autoconf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tvgafb_pci_attach;\nint\tvgafbpcimmap;\nint\tvgafbpciioctl;\npcitag_t vgafb_pci_console_tag;\nstruct vgafb_config vgafb_pci_console_vc;\nvoid *aux;\n\nvoid\nvgafb_pci_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tstruct vgafb_pci_softc *sc = (struct vgafb_pci_softc *)self;\n\tstruct vgafb_config *vc;\n\tu_int32_t memaddr, memsize, cacheable;\n\tu_int32_t ioaddr, iosize;\n\tu_int32_t mmioaddr, mmiosize;\n\tint console;\n\tstatic int id = 0;\n\tint myid;\n\n\tmyid = id;\n\n\tvgafb_pci_probe(pa, myid, &ioaddr, &iosize,\n\t\t&memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);\n\n\tconsole = (!bcmp(&pa->pa_tag, &vgafb_pci_console_tag, sizeof(pa->pa_tag)));\n\tif (console)\n\t\tvc = sc->sc_vc = &vgafb_pci_console_vc;\n\telse {\n\t\tvc = sc->sc_vc = (struct vgafb_config *)\n\t\t    malloc(sizeof(struct vgafb_config), M_DEVBUF, M_WAITOK);\n\n\t\t/* set up bus-independent VGA configuration */\n\t\tvgafb_common_setup(pa->pa_iot, pa->pa_memt, vc, \n\t\tioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);\n\t}\n\tvc->vc_mmap = vgafbpcimmap;\n\tvc->vc_ioctl = vgafbpciioctl;\n\n\tsc->sc_pcitag = pa->pa_tag;\n\n\tif (iosize == 0) {\n\t\tprintf (\", no io\");\n\t}\n\tif (mmiosize != 0) {\n\t\tprintf (\", mmio\");\n\t}\n\tprintf(\"\\n\");\n\n\tvgafb_wscons_attach(self, vc, console);\n\tid++;\n}"
  },
  {
    "function_name": "vgafb_pci_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/vgafb_pci.c",
    "lines": "80-196",
    "snippet": "int\nvgafb_pci_probe(pa, id, ioaddr, iosize, memaddr, memsize, cacheable, mmioaddr, mmiosize)\n\tstruct pci_attach_args *pa;\n\tint id;\n\tu_int32_t *ioaddr, *iosize;\n\tu_int32_t *memaddr, *memsize, *cacheable;\n\tu_int32_t *mmioaddr, *mmiosize;\n{\n\tu_int32_t addr, size, tcacheable;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint retval;\n\tint i;\n\n\t*iosize   = 0x0;\n\t*memsize  = 0x0;\n\t*mmiosize = 0x0;\n\tfor (i = 0x10; i < 0x18; i += 4) {\n#ifdef DEBUG_VGAFB\n\t\tprintf(\"vgafb confread %x %x\\n\",\n\t\t\ti, pci_conf_read(pc, pa->pa_tag, i));\n#endif\n\t\t/* need to check more than just two base addresses? */\n\t\tif (0x1 & pci_conf_read(pc, pa->pa_tag, i) ) {\n\t\t\tretval = pci_io_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size);\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: io %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*iosize == 0) {\n\t\t\t\t*ioaddr = addr;\n\t\t\t\t*iosize = size;\n\t\t\t}\n\n\t\t} else {\n\t\t\tretval = pci_mem_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size, &tcacheable);\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n#endif\n\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (size == 0) {\n\t\t\t\t/* ignore this entry */\n\t\t\t}else if (size <= (64 * 1024)) {\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x iosize %x\\n\",\n\t\ti, addr, size, *iosize);\n#endif\n\t\t\t\tif (*mmiosize == 0) {\n\t\t\t\t\t/* this is mmio, not memory */\n\t\t\t\t\t*mmioaddr = addr;\n\t\t\t\t\t*mmiosize = size;\n\t\t\t\t\t/* need skew in here for io memspace */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*memsize == 0) {\n\t\t\t\t\t*memaddr = addr;\n\t\t\t\t\t*memsize = size;\n\t\t\t\t\t*cacheable = tcacheable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\tif (*iosize == 0) {\n\t\tif (id == 0) {\n#ifdef powerpc\n\t\t\t/* this is only used if on openfirmware system and\n\t\t\t * the device does not have a iobase config register,\n\t\t\t * eg CirrusLogic 5434 VGA.  (they hardcode iobase to 0\n\t\t\t * thus giving standard PC addresses for the registers) \n\t\t\t */\n\t\t\tint s;\n\t\t\tu_int32_t sizedata;\n\n\t\t\t/*\n\t\t\t * Open Firmware (yuck) shuts down devices before\n\t\t\t * entering a program so we need to bring them back\n\t\t\t * 'online' to respond to bus accesses... so far\n\t\t\t * this is true on the power.4e.\n\t\t\t */\n\t\t\ts = splhigh();\n\t\t\tsizedata = pci_conf_read(pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\t\t\tsizedata |= (PCI_COMMAND_MASTER_ENABLE |\n\t\t\t\t     PCI_COMMAND_IO_ENABLE |\n\t\t\t\t     PCI_COMMAND_PARITY_ENABLE |\n\t\t\t\t     PCI_COMMAND_SERR_ENABLE);\n\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t\tsizedata);\n\t\t\tsplx(s);\n\n#endif\n\t\t\t/* if this is the first card, allow it\n\t\t\t * to be accessed in vga iospace\n\t\t\t */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize = 0x10000; /* 64k, good as any */\n\t\t} else {\n\t\t\t/* iospace not available, assume 640x480, pray */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize=0;\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/vgafb_pcivar.h>",
      "#include <dev/ic/vgafbvar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/pte.h>",
      "#include <machine/autoconf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_VGAFB"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\"",
            "id",
            "*ioaddr",
            "*iosize",
            "*memaddr",
            "*memsize",
            "*mmioaddr",
            "*mmiosize"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "sizedata"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "i",
            "&addr",
            "&size",
            "&tcacheable"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "i",
            "&addr",
            "&size"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "i"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "i"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/vgafb_pcivar.h>\n#include <dev/ic/vgafbvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/pte.h>\n#include <machine/autoconf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_VGAFB\n\nint\nvgafb_pci_probe(pa, id, ioaddr, iosize, memaddr, memsize, cacheable, mmioaddr, mmiosize)\n\tstruct pci_attach_args *pa;\n\tint id;\n\tu_int32_t *ioaddr, *iosize;\n\tu_int32_t *memaddr, *memsize, *cacheable;\n\tu_int32_t *mmioaddr, *mmiosize;\n{\n\tu_int32_t addr, size, tcacheable;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint retval;\n\tint i;\n\n\t*iosize   = 0x0;\n\t*memsize  = 0x0;\n\t*mmiosize = 0x0;\n\tfor (i = 0x10; i < 0x18; i += 4) {\n#ifdef DEBUG_VGAFB\n\t\tprintf(\"vgafb confread %x %x\\n\",\n\t\t\ti, pci_conf_read(pc, pa->pa_tag, i));\n#endif\n\t\t/* need to check more than just two base addresses? */\n\t\tif (0x1 & pci_conf_read(pc, pa->pa_tag, i) ) {\n\t\t\tretval = pci_io_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size);\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: io %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*iosize == 0) {\n\t\t\t\t*ioaddr = addr;\n\t\t\t\t*iosize = size;\n\t\t\t}\n\n\t\t} else {\n\t\t\tretval = pci_mem_find(pc, pa->pa_tag, i,\n\t\t\t\t&addr, &size, &tcacheable);\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n#endif\n\n\t\t\tif (retval) {\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x\\n\", i, addr, size);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (size == 0) {\n\t\t\t\t/* ignore this entry */\n\t\t\t}else if (size <= (64 * 1024)) {\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: mem %x addr %x size %x iosize %x\\n\",\n\t\ti, addr, size, *iosize);\n#endif\n\t\t\t\tif (*mmiosize == 0) {\n\t\t\t\t\t/* this is mmio, not memory */\n\t\t\t\t\t*mmioaddr = addr;\n\t\t\t\t\t*mmiosize = size;\n\t\t\t\t\t/* need skew in here for io memspace */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*memsize == 0) {\n\t\t\t\t\t*memaddr = addr;\n\t\t\t\t\t*memsize = size;\n\t\t\t\t\t*cacheable = tcacheable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\tif (*iosize == 0) {\n\t\tif (id == 0) {\n#ifdef powerpc\n\t\t\t/* this is only used if on openfirmware system and\n\t\t\t * the device does not have a iobase config register,\n\t\t\t * eg CirrusLogic 5434 VGA.  (they hardcode iobase to 0\n\t\t\t * thus giving standard PC addresses for the registers) \n\t\t\t */\n\t\t\tint s;\n\t\t\tu_int32_t sizedata;\n\n\t\t\t/*\n\t\t\t * Open Firmware (yuck) shuts down devices before\n\t\t\t * entering a program so we need to bring them back\n\t\t\t * 'online' to respond to bus accesses... so far\n\t\t\t * this is true on the power.4e.\n\t\t\t */\n\t\t\ts = splhigh();\n\t\t\tsizedata = pci_conf_read(pc, pa->pa_tag,\n\t\t\t\tPCI_COMMAND_STATUS_REG);\n\t\t\tsizedata |= (PCI_COMMAND_MASTER_ENABLE |\n\t\t\t\t     PCI_COMMAND_IO_ENABLE |\n\t\t\t\t     PCI_COMMAND_PARITY_ENABLE |\n\t\t\t\t     PCI_COMMAND_SERR_ENABLE);\n\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t\tsizedata);\n\t\t\tsplx(s);\n\n#endif\n\t\t\t/* if this is the first card, allow it\n\t\t\t * to be accessed in vga iospace\n\t\t\t */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize = 0x10000; /* 64k, good as any */\n\t\t} else {\n\t\t\t/* iospace not available, assume 640x480, pray */\n\t\t\t*ioaddr = 0;\n\t\t\t*iosize=0;\n\t\t}\n\t}\n#ifdef DEBUG_VGAFB\n\tprintf(\"vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\\n memsize %x, mmioaddr %x, mmiosize %x\\n\",\n\t\tid, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);\n#endif\n\treturn 1;\n}"
  }
]