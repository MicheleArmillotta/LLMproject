[
  {
    "function_name": "ie_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
    "lines": "297-305",
    "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [
      "int \ti82596_start_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "status & mask",
            "0",
            "0",
            "0"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_SCB_STATUS(sc->scb)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_STATUS",
          "args": [
            "sc->scb"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "0",
            "0",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
  }
]