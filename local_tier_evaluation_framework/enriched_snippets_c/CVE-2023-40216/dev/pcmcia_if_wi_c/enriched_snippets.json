[
  {
    "function_name": "wi_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "1424-1433",
    "snippet": "STATIC void wi_shutdown(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct wi_softc\t\t*sc;\n\n\tsc = arg;\n\twi_stop(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wi_stop",
          "args": [
            "sc"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "wi_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1386-1406",
          "snippet": "STATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_STOP\t0x10",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_STOP\t0x10\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_shutdown(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct wi_softc\t\t*sc;\n\n\tsc = arg;\n\twi_stop(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "1408-1422",
    "snippet": "STATIC void wi_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct wi_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tprintf(WI_PRT_FMT \": device timeout\\n\", WI_PRT_ARG(sc));\n\n\twi_init(sc);\n\n\tifp->if_oerrors++;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wi_init",
          "args": [
            "sc"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "wi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1147-1254",
          "snippet": "STATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_INIT\t0x08",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_INIT\t0x08\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": device timeout\\n\"",
            "WI_PRT_ARG(sc)"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct wi_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tprintf(WI_PRT_FMT \": device timeout\\n\", WI_PRT_ARG(sc));\n\n\twi_init(sc);\n\n\tifp->if_oerrors++;\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "1386-1406",
    "snippet": "STATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WID_STOP\t0x10",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UNTIMEOUT",
          "args": [
            "wi_inquire",
            "sc",
            "sc->wi_stat_ch"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_DISABLE|sc->wi_portnum",
            "0"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_INT_EN",
            "0"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "WID_STOP",
            "(\"wi_stop: sc %p\\n\", sc)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_STOP\t0x10\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_mgmt_xmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "1349-1384",
    "snippet": "STATIC int wi_mgmt_xmit(sc, data, len)\n\tstruct wi_softc\t\t*sc;\n\tcaddr_t\t\t\tdata;\n\tint\t\t\tlen;\n{\n\tstruct wi_frame\t\ttx_frame;\n\tint\t\t\tid;\n\tstruct wi_80211_hdr\t*hdr;\n\tcaddr_t\t\t\tdptr;\n\n\tif (sc->wi_gone)\n\t\treturn(ENODEV);\n\n\thdr = (struct wi_80211_hdr *)data;\n\tdptr = data + sizeof(struct wi_80211_hdr);\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_mgmt_id;\n\n\tbcopy((char *)hdr, (char *)&tx_frame.wi_frame_ctl,\n\t   sizeof(struct wi_80211_hdr));\n\n\ttx_frame.wi_dat_len = len - WI_SNAPHDR_LEN;\n\ttx_frame.wi_len = htons(len - WI_SNAPHDR_LEN);\n\n\twi_write_data(sc, id, 0, (caddr_t)&tx_frame, sizeof(struct wi_frame));\n\twi_write_data(sc, id, WI_802_11_OFFSET_RAW, dptr,\n\t    (len - sizeof(struct wi_80211_hdr)) + 2);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id)) {\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\t\treturn(EIO);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": xmit failed\\n\"",
            "WI_PRT_ARG(sc)"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_TX|WI_RECLAIM",
            "id"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_write_data",
          "args": [
            "sc",
            "id",
            "WI_802_11_OFFSET_RAW",
            "dptr",
            "(len - sizeof(struct wi_80211_hdr)) + 2"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "wi_write_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "832-865",
          "snippet": "STATIC int wi_write_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n#ifdef WI_HERMES_AUTOINC_WAR\nagain:\n#endif\n\n\tif (wi_seek(sc, id, off, WI_BAP0))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, ptr[i]);\n\n#ifdef WI_HERMES_AUTOINC_WAR\n\tCSR_WRITE_2(sc, WI_DATA0, 0x1234);\n\tCSR_WRITE_2(sc, WI_DATA0, 0x5678);\n\n\tif (wi_seek(sc, id, off + len, WI_BAP0))\n\t\treturn(EIO);\n\n\tif (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||\n\t    CSR_READ_2(sc, WI_DATA0) != 0x5678)\n\t\tgoto again;\n#endif\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC",
            "#define WI_HERMES_AUTOINC_WAR\t/* Work around data write autoinc bug. */"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n#define WI_HERMES_AUTOINC_WAR\t/* Work around data write autoinc bug. */\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_write_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n#ifdef WI_HERMES_AUTOINC_WAR\nagain:\n#endif\n\n\tif (wi_seek(sc, id, off, WI_BAP0))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, ptr[i]);\n\n#ifdef WI_HERMES_AUTOINC_WAR\n\tCSR_WRITE_2(sc, WI_DATA0, 0x1234);\n\tCSR_WRITE_2(sc, WI_DATA0, 0x5678);\n\n\tif (wi_seek(sc, id, off + len, WI_BAP0))\n\t\treturn(EIO);\n\n\tif (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||\n\t    CSR_READ_2(sc, WI_DATA0) != 0x5678)\n\t\tgoto again;\n#endif\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "len - WI_SNAPHDR_LEN"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)hdr",
            "(char *)&tx_frame.wi_frame_ctl",
            "sizeof(struct wi_80211_hdr)"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&tx_frame",
            "sizeof(tx_frame)"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_mgmt_xmit(sc, data, len)\n\tstruct wi_softc\t\t*sc;\n\tcaddr_t\t\t\tdata;\n\tint\t\t\tlen;\n{\n\tstruct wi_frame\t\ttx_frame;\n\tint\t\t\tid;\n\tstruct wi_80211_hdr\t*hdr;\n\tcaddr_t\t\t\tdptr;\n\n\tif (sc->wi_gone)\n\t\treturn(ENODEV);\n\n\thdr = (struct wi_80211_hdr *)data;\n\tdptr = data + sizeof(struct wi_80211_hdr);\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_mgmt_id;\n\n\tbcopy((char *)hdr, (char *)&tx_frame.wi_frame_ctl,\n\t   sizeof(struct wi_80211_hdr));\n\n\ttx_frame.wi_dat_len = len - WI_SNAPHDR_LEN;\n\ttx_frame.wi_len = htons(len - WI_SNAPHDR_LEN);\n\n\twi_write_data(sc, id, 0, (caddr_t)&tx_frame, sizeof(struct wi_frame));\n\twi_write_data(sc, id, WI_802_11_OFFSET_RAW, dptr,\n\t    (len - sizeof(struct wi_80211_hdr)) + 2);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id)) {\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\t\treturn(EIO);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "1256-1347",
    "snippet": "STATIC void wi_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct wi_softc\t\t*sc;\n\tstruct mbuf\t\t*m0;\n\tstruct wi_frame\t\ttx_frame;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\n\tsc = ifp->if_softc;\n\n\tDPRINTF(WID_START, (\"wi_start: ifp %p sc %p\\n\", ifp, sc));\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == NULL)\n\t\treturn;\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_data_id;\n\teh = mtod(m0, struct ether_header *);\n\n\t/*\n\t * Use RFC1042 encoding for IP and ARP datagrams,\n\t * 802.3 for anything else.\n\t */\n\tif (ntohs(eh->ether_type) == ETHERTYPE_IP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_ARP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_REVARP) {\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_addr1, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;\n\t\ttx_frame.wi_frame_ctl = WI_FTYPE_DATA;\n\t\ttx_frame.wi_dat[0] = htons(WI_SNAP_WORD0);\n\t\ttx_frame.wi_dat[1] = htons(WI_SNAP_WORD1);\n\t\ttx_frame.wi_len = htons(m0->m_pkthdr.len - WI_SNAPHDR_LEN);\n\t\ttx_frame.wi_type = eh->ether_type;\n\n\t\tm_copydata(m0, sizeof(struct ether_header),\n\t\t    m0->m_pkthdr.len - sizeof(struct ether_header),\n\t\t    (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_11_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    (m0->m_pkthdr.len - sizeof(struct ether_header)) + 2);\n\t} else {\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len;\n\n\t\tm_copydata(m0, 0, m0->m_pkthdr.len, (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_3_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    m0->m_pkthdr.len + 2);\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listner, bounce a copy of\n\t * this frame to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m0);\n#endif\n\n\tm_freem(m0);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id))\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WID_START\t0x02",
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": xmit failed\\n\"",
            "WI_PRT_ARG(sc)"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_TX|WI_RECLAIM",
            "id"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m0"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_write_data",
          "args": [
            "sc",
            "id",
            "WI_802_3_OFFSET",
            "(caddr_t)&sc->wi_txbuf",
            "m0->m_pkthdr.len + 2"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "wi_write_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "832-865",
          "snippet": "STATIC int wi_write_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n#ifdef WI_HERMES_AUTOINC_WAR\nagain:\n#endif\n\n\tif (wi_seek(sc, id, off, WI_BAP0))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, ptr[i]);\n\n#ifdef WI_HERMES_AUTOINC_WAR\n\tCSR_WRITE_2(sc, WI_DATA0, 0x1234);\n\tCSR_WRITE_2(sc, WI_DATA0, 0x5678);\n\n\tif (wi_seek(sc, id, off + len, WI_BAP0))\n\t\treturn(EIO);\n\n\tif (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||\n\t    CSR_READ_2(sc, WI_DATA0) != 0x5678)\n\t\tgoto again;\n#endif\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC",
            "#define WI_HERMES_AUTOINC_WAR\t/* Work around data write autoinc bug. */"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n#define WI_HERMES_AUTOINC_WAR\t/* Work around data write autoinc bug. */\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_write_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n#ifdef WI_HERMES_AUTOINC_WAR\nagain:\n#endif\n\n\tif (wi_seek(sc, id, off, WI_BAP0))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, ptr[i]);\n\n#ifdef WI_HERMES_AUTOINC_WAR\n\tCSR_WRITE_2(sc, WI_DATA0, 0x1234);\n\tCSR_WRITE_2(sc, WI_DATA0, 0x5678);\n\n\tif (wi_seek(sc, id, off + len, WI_BAP0))\n\t\treturn(EIO);\n\n\tif (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||\n\t    CSR_READ_2(sc, WI_DATA0) != 0x5678)\n\t\tgoto again;\n#endif\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m0",
            "0",
            "m0->m_pkthdr.len",
            "(caddr_t)&sc->wi_txbuf"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m0",
            "sizeof(struct ether_header)",
            "m0->m_pkthdr.len - sizeof(struct ether_header)",
            "(caddr_t)&sc->wi_txbuf"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "m0->m_pkthdr.len - WI_SNAPHDR_LEN"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "WI_SNAP_WORD1"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "WI_SNAP_WORD0"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&eh->ether_shost",
            "(char *)&tx_frame.wi_src_addr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "eh->ether_type"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "eh->ether_type"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "eh->ether_type"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "structether_header*"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&tx_frame",
            "sizeof(tx_frame)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "WID_START",
            "(\"wi_start: ifp %p sc %p\\n\", ifp, sc)"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_START\t0x02\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC void wi_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct wi_softc\t\t*sc;\n\tstruct mbuf\t\t*m0;\n\tstruct wi_frame\t\ttx_frame;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\n\tsc = ifp->if_softc;\n\n\tDPRINTF(WID_START, (\"wi_start: ifp %p sc %p\\n\", ifp, sc));\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == NULL)\n\t\treturn;\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_data_id;\n\teh = mtod(m0, struct ether_header *);\n\n\t/*\n\t * Use RFC1042 encoding for IP and ARP datagrams,\n\t * 802.3 for anything else.\n\t */\n\tif (ntohs(eh->ether_type) == ETHERTYPE_IP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_ARP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_REVARP) {\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_addr1, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;\n\t\ttx_frame.wi_frame_ctl = WI_FTYPE_DATA;\n\t\ttx_frame.wi_dat[0] = htons(WI_SNAP_WORD0);\n\t\ttx_frame.wi_dat[1] = htons(WI_SNAP_WORD1);\n\t\ttx_frame.wi_len = htons(m0->m_pkthdr.len - WI_SNAPHDR_LEN);\n\t\ttx_frame.wi_type = eh->ether_type;\n\n\t\tm_copydata(m0, sizeof(struct ether_header),\n\t\t    m0->m_pkthdr.len - sizeof(struct ether_header),\n\t\t    (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_11_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    (m0->m_pkthdr.len - sizeof(struct ether_header)) + 2);\n\t} else {\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len;\n\n\t\tm_copydata(m0, 0, m0->m_pkthdr.len, (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_3_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    m0->m_pkthdr.len + 2);\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listner, bounce a copy of\n\t * this frame to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m0);\n#endif\n\n\tm_freem(m0);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id))\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "1147-1254",
    "snippet": "STATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WID_INIT\t0x08",
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TIMEOUT",
          "args": [
            "sc->wi_stat_ch",
            "wi_inquire",
            "sc",
            "hz * 60"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_INT_EN",
            "WI_INTRS"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": mgmt. buffer allocation failed\\n\"",
            "WI_PRT_ARG(sc)"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_alloc_nicmem",
          "args": [
            "sc",
            "1518 + sizeof(struct wi_frame) + 8",
            "&id"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "wi_alloc_nicmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "871-902",
          "snippet": "STATIC int wi_alloc_nicmem(sc, len, id)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (wi_cmd(sc, WI_CMD_ALLOC_MEM, len)) {\n\t\tprintf(WI_PRT_FMT \": failed to allocate %d bytes on NIC\\n\",\n\t\t    WI_PRT_ARG(sc), len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);\n\t*id = CSR_READ_2(sc, WI_ALLOC_FID);\n\n\tif (wi_seek(sc, *id, 0, WI_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, 0);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_alloc_nicmem(sc, len, id)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (wi_cmd(sc, WI_CMD_ALLOC_MEM, len)) {\n\t\tprintf(WI_PRT_FMT \": failed to allocate %d bytes on NIC\\n\",\n\t\t    WI_PRT_ARG(sc), len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);\n\t*id = CSR_READ_2(sc, WI_ALLOC_FID);\n\n\tif (wi_seek(sc, *id, 0, WI_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, 0);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_ENABLE|sc->wi_portnum",
            "0"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_setmulti",
          "args": [
            "sc"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "wi_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "904-946",
          "snippet": "STATIC void wi_setmulti(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti = 0;\n\tstruct wi_ltv_mcast\tmcast;\n\tstruct ether_multistep\tstep;\n\tstruct ether_multi\t*enm;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbzero((char *)&mcast, sizeof(mcast));\n\n\tmcast.wi_type = WI_RID_MCAST;\n\tmcast.wi_len = (3 * 16) + 1;\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\twhile (enm != NULL) {\n\t\tif (i >= 16) {\n\t\t\tbzero((char *)&mcast, sizeof(mcast));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Punt on ranges. */\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0)\n\t\t\tbreak;\n\t\tbcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],\n\t\t    ETHER_ADDR_LEN);\n\t\ti++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tmcast.wi_len = (i * 3) + 1;\n\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_setmulti(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti = 0;\n\tstruct wi_ltv_mcast\tmcast;\n\tstruct ether_multistep\tstep;\n\tstruct ether_multi\t*enm;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbzero((char *)&mcast, sizeof(mcast));\n\n\tmcast.wi_type = WI_RID_MCAST;\n\tmcast.wi_len = (3 * 16) + 1;\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\twhile (enm != NULL) {\n\t\tif (i >= 16) {\n\t\t\tbzero((char *)&mcast, sizeof(mcast));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Punt on ranges. */\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0)\n\t\t\tbreak;\n\t\tbcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],\n\t\t    ETHER_ADDR_LEN);\n\t\ti++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tmcast.wi_len = (i * 3) + 1;\n\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_PROMISC",
            "0"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_PROMISC",
            "1"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_write_record",
          "args": [
            "sc",
            "(struct wi_ltv_gen *)&sc->wi_keys"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "wi_write_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "742-763",
          "snippet": "STATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_TX_CRYPT_KEY",
            "sc->wi_tx_key"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_ENCRYPTION",
            "sc->wi_use_wep"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&sc->arpcom.ac_enaddr",
            "(char *)&mac.wi_mac_addr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_SETSTR",
          "args": [
            "WI_RID_NODENAME",
            "sc->wi_node_name"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_OWN_CHNL",
            "sc->wi_channel"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETSTR",
          "args": [
            "WI_RID_DESIRED_SSID",
            "sc->wi_net_name"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETSTR",
          "args": [
            "WI_RID_OWN_SSID",
            "sc->wi_ibss_name"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_MAX_SLEEP",
            "sc->wi_max_sleep"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_PM_ENABLED",
            "sc->wi_pm_enabled"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_SYSTEM_SCALE",
            "sc->wi_ap_density"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_TX_RATE",
            "sc->wi_tx_rate"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_RTS_THRESH",
            "sc->wi_rts_thresh"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_PORTTYPE",
            "sc->wi_ptype"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_CREATE_IBSS",
            "sc->wi_create_ibss"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_MAX_DATALEN",
            "sc->wi_max_data_len"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_reset",
          "args": [
            "sc"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "wi_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "682-696",
          "snippet": "STATIC void wi_reset(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tDPRINTF(WID_RESET, (\"wi_reset: sc %p\\n\", sc));\n\n\tif (wi_cmd(sc, WI_CMD_INI, 0))\n\t\tprintf(WI_PRT_FMT \": init failed\\n\", WI_PRT_ARG(sc));\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\t/* Calibrate timer. */\n\tWI_SETVAL(WI_RID_TICK_TIME, 8);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_RESET\t0x20",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_RESET\t0x20\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_reset(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tDPRINTF(WID_RESET, (\"wi_reset: sc %p\\n\", sc));\n\n\tif (wi_cmd(sc, WI_CMD_INI, 0))\n\t\tprintf(WI_PRT_FMT \": init failed\\n\", WI_PRT_ARG(sc));\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\t/* Calibrate timer. */\n\tWI_SETVAL(WI_RID_TICK_TIME, 8);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_stop",
          "args": [
            "sc"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "wi_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1386-1406",
          "snippet": "STATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_STOP\t0x10",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_STOP\t0x10\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "WID_INIT",
            "(\"wi_init: sc %p\\n\", sc)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_INIT\t0x08\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "1026-1145",
    "snippet": "STATIC int wi_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tint\t\t\ts, error = 0;\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_req\t\twreq;\n\tstruct ifreq\t\t*ifr;\n\tstruct proc *p = curproc;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\n\ts = splimp();\n\n\tsc = ifp->if_softc;\n\tifr = (struct ifreq *)data;\n\n\tif (sc->wi_gone)\n\t\treturn(ENODEV);\n\n\tDPRINTF (WID_IOCTL, (\"wi_ioctl: command %lu data %p\", command, data));\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\twi_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\t\tdefault:\n\t\t\twi_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->wi_if_flags & IFF_PROMISC)) {\n\t\t\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->wi_if_flags & IFF_PROMISC) {\n\t\t\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t\t\t} else\n\t\t\t\twi_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\twi_stop(sc);\n\t\t\t}\n\t\t}\n\t\tsc->wi_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\twi_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCGWAVELAN:\n\t\terror = copyin(ifr->ifr_data, &wreq, sizeof(wreq));\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (wreq.wi_type == WI_RID_IFACE_STATS) {\n\t\t\tbcopy((char *)&sc->wi_stats, (char *)&wreq.wi_val,\n\t\t\t    sizeof(sc->wi_stats));\n\t\t\twreq.wi_len = (sizeof(sc->wi_stats) / 2) + 1;\n\t\t} else if (wreq.wi_type == WI_RID_DEFLT_CRYPT_KEYS) {\n\t\t\t/* For non-root user, return all-zeroes keys */\n\t\t\tif (suser(p->p_ucred, &p->p_acflag))\n\t\t\t\tbzero((char *)&wreq,\n\t\t\t    \t\tsizeof(struct wi_ltv_keys));\n\t\t\telse\n\t\t\t\tbcopy((char *)&sc->wi_keys, (char *)&wreq,\n\t\t\t    \t\tsizeof(struct wi_ltv_keys));\n\t\t} else {\n\t\t\tif (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terror = copyout(&wreq, ifr->ifr_data, sizeof(wreq));\n\t\tbreak;\n\tcase SIOCSWAVELAN:\n\t\terror = suser(p->p_ucred, &p->p_acflag);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = copyin(ifr->ifr_data, &wreq, sizeof(wreq));\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (wreq.wi_type == WI_RID_IFACE_STATS) {\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t} else if (wreq.wi_type == WI_RID_MGMT_XMIT) {\n\t\t\terror = wi_mgmt_xmit(sc, (caddr_t)&wreq.wi_val,\n\t\t\t    wreq.wi_len);\n\t\t} else {\n\t\t\terror = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);\n\t\t\tif (!error)\n\t\t\t\twi_setdef(sc, &wreq);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WID_IOCTL\t0x04",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "wi_setdef\t\t__P((struct wi_softc *, struct wi_req *));",
      "STATIC int",
      "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_setdef",
          "args": [
            "sc",
            "&wreq"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "wi_setdef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "948-1024",
          "snippet": "STATIC void wi_setdef(sc, wreq)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_req\t\t*wreq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(wreq->wi_type) {\n\tcase WI_RID_MAC_NODE:\n\t\tifa = ifnet_addrs[ifp->if_index];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&wreq->wi_val, LLADDR(sdl), ETHER_ADDR_LEN);\n\t\tbcopy((char *)&wreq->wi_val, (char *)&sc->arpcom.ac_enaddr,\n\t\t      ETHER_ADDR_LEN);\n\t\tbreak;\n\tcase WI_RID_PORTTYPE:\n\t\tsc->wi_ptype = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_RATE:\n\t\tsc->wi_tx_rate = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_DATALEN:\n\t\tsc->wi_max_data_len = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_RTS_THRESH:\n\t\tsc->wi_rts_thresh = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_SYSTEM_SCALE:\n\t\tsc->wi_ap_density = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_CREATE_IBSS:\n\t\tsc->wi_create_ibss = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_OWN_CHNL:\n\t\tsc->wi_channel = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_NODENAME:\n\t\tbzero(sc->wi_node_name, sizeof(sc->wi_node_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_node_name, 30);\n\t\tbreak;\n\tcase WI_RID_DESIRED_SSID:\n\t\tbzero(sc->wi_net_name, sizeof(sc->wi_net_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_net_name, 30);\n\t\tbreak;\n\tcase WI_RID_OWN_SSID:\n\t\tbzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_ibss_name, 30);\n\t\tbreak;\n\tcase WI_RID_PM_ENABLED:\n\t\tsc->wi_pm_enabled = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_SLEEP:\n\t\tsc->wi_max_sleep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_ENCRYPTION:\n\t\tsc->wi_use_wep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_CRYPT_KEY:\n\t\tsc->wi_tx_key = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_DEFLT_CRYPT_KEYS:\n\t\tbcopy((char *)wreq, (char *)&sc->wi_keys,\n\t\t    sizeof(struct wi_ltv_keys));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Reinitialize WaveLAN. */\n\twi_init(sc);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "wi_setdef\t\t__P((struct wi_softc *, struct wi_req *));",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nwi_setdef\t\t__P((struct wi_softc *, struct wi_req *));\nSTATIC int;\n\nSTATIC void wi_setdef(sc, wreq)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_req\t\t*wreq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(wreq->wi_type) {\n\tcase WI_RID_MAC_NODE:\n\t\tifa = ifnet_addrs[ifp->if_index];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&wreq->wi_val, LLADDR(sdl), ETHER_ADDR_LEN);\n\t\tbcopy((char *)&wreq->wi_val, (char *)&sc->arpcom.ac_enaddr,\n\t\t      ETHER_ADDR_LEN);\n\t\tbreak;\n\tcase WI_RID_PORTTYPE:\n\t\tsc->wi_ptype = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_RATE:\n\t\tsc->wi_tx_rate = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_DATALEN:\n\t\tsc->wi_max_data_len = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_RTS_THRESH:\n\t\tsc->wi_rts_thresh = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_SYSTEM_SCALE:\n\t\tsc->wi_ap_density = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_CREATE_IBSS:\n\t\tsc->wi_create_ibss = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_OWN_CHNL:\n\t\tsc->wi_channel = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_NODENAME:\n\t\tbzero(sc->wi_node_name, sizeof(sc->wi_node_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_node_name, 30);\n\t\tbreak;\n\tcase WI_RID_DESIRED_SSID:\n\t\tbzero(sc->wi_net_name, sizeof(sc->wi_net_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_net_name, 30);\n\t\tbreak;\n\tcase WI_RID_OWN_SSID:\n\t\tbzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_ibss_name, 30);\n\t\tbreak;\n\tcase WI_RID_PM_ENABLED:\n\t\tsc->wi_pm_enabled = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_SLEEP:\n\t\tsc->wi_max_sleep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_ENCRYPTION:\n\t\tsc->wi_use_wep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_CRYPT_KEY:\n\t\tsc->wi_tx_key = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_DEFLT_CRYPT_KEYS:\n\t\tbcopy((char *)wreq, (char *)&sc->wi_keys,\n\t\t    sizeof(struct wi_ltv_keys));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Reinitialize WaveLAN. */\n\twi_init(sc);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_write_record",
          "args": [
            "sc",
            "(struct wi_ltv_gen *)&wreq"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "wi_write_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "742-763",
          "snippet": "STATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_mgmt_xmit",
          "args": [
            "sc",
            "(caddr_t)&wreq.wi_val",
            "wreq.wi_len"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "wi_mgmt_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1349-1384",
          "snippet": "STATIC int wi_mgmt_xmit(sc, data, len)\n\tstruct wi_softc\t\t*sc;\n\tcaddr_t\t\t\tdata;\n\tint\t\t\tlen;\n{\n\tstruct wi_frame\t\ttx_frame;\n\tint\t\t\tid;\n\tstruct wi_80211_hdr\t*hdr;\n\tcaddr_t\t\t\tdptr;\n\n\tif (sc->wi_gone)\n\t\treturn(ENODEV);\n\n\thdr = (struct wi_80211_hdr *)data;\n\tdptr = data + sizeof(struct wi_80211_hdr);\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_mgmt_id;\n\n\tbcopy((char *)hdr, (char *)&tx_frame.wi_frame_ctl,\n\t   sizeof(struct wi_80211_hdr));\n\n\ttx_frame.wi_dat_len = len - WI_SNAPHDR_LEN;\n\ttx_frame.wi_len = htons(len - WI_SNAPHDR_LEN);\n\n\twi_write_data(sc, id, 0, (caddr_t)&tx_frame, sizeof(struct wi_frame));\n\twi_write_data(sc, id, WI_802_11_OFFSET_RAW, dptr,\n\t    (len - sizeof(struct wi_80211_hdr)) + 2);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id)) {\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\t\treturn(EIO);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_mgmt_xmit(sc, data, len)\n\tstruct wi_softc\t\t*sc;\n\tcaddr_t\t\t\tdata;\n\tint\t\t\tlen;\n{\n\tstruct wi_frame\t\ttx_frame;\n\tint\t\t\tid;\n\tstruct wi_80211_hdr\t*hdr;\n\tcaddr_t\t\t\tdptr;\n\n\tif (sc->wi_gone)\n\t\treturn(ENODEV);\n\n\thdr = (struct wi_80211_hdr *)data;\n\tdptr = data + sizeof(struct wi_80211_hdr);\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_mgmt_id;\n\n\tbcopy((char *)hdr, (char *)&tx_frame.wi_frame_ctl,\n\t   sizeof(struct wi_80211_hdr));\n\n\ttx_frame.wi_dat_len = len - WI_SNAPHDR_LEN;\n\ttx_frame.wi_len = htons(len - WI_SNAPHDR_LEN);\n\n\twi_write_data(sc, id, 0, (caddr_t)&tx_frame, sizeof(struct wi_frame));\n\twi_write_data(sc, id, WI_802_11_OFFSET_RAW, dptr,\n\t    (len - sizeof(struct wi_80211_hdr)) + 2);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id)) {\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\t\treturn(EIO);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "&wreq",
            "sizeof(wreq)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "&wreq",
            "ifr->ifr_data",
            "sizeof(wreq)"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_read_record",
          "args": [
            "sc",
            "(struct wi_ltv_gen *)&wreq"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "wi_read_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "701-737",
          "snippet": "STATIC int wi_read_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len, code;\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))\n\t\treturn(EIO);\n\n\t/* Seek to the record. */\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, WI_DATA1);\n\tif (len > ltv->wi_len)\n\t\treturn(ENOSPC);\n\tcode = CSR_READ_2(sc, WI_DATA1);\n\tif (code != ltv->wi_type)\n\t\treturn(EIO);\n\n\tltv->wi_len = len;\n\tltv->wi_type = code;\n\n\t/* Now read the data. */\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_read_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len, code;\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))\n\t\treturn(EIO);\n\n\t/* Seek to the record. */\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, WI_DATA1);\n\tif (len > ltv->wi_len)\n\t\treturn(ENOSPC);\n\tcode = CSR_READ_2(sc, WI_DATA1);\n\tif (code != ltv->wi_type)\n\t\treturn(EIO);\n\n\tltv->wi_len = len;\n\tltv->wi_type = code;\n\n\t/* Now read the data. */\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&sc->wi_keys",
            "(char *)&wreq",
            "sizeof(struct wi_ltv_keys)"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&wreq",
            "sizeof(struct wi_ltv_keys)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "&wreq",
            "sizeof(wreq)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_setmulti",
          "args": [
            "sc"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "wi_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "904-946",
          "snippet": "STATIC void wi_setmulti(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti = 0;\n\tstruct wi_ltv_mcast\tmcast;\n\tstruct ether_multistep\tstep;\n\tstruct ether_multi\t*enm;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbzero((char *)&mcast, sizeof(mcast));\n\n\tmcast.wi_type = WI_RID_MCAST;\n\tmcast.wi_len = (3 * 16) + 1;\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\twhile (enm != NULL) {\n\t\tif (i >= 16) {\n\t\t\tbzero((char *)&mcast, sizeof(mcast));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Punt on ranges. */\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0)\n\t\t\tbreak;\n\t\tbcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],\n\t\t    ETHER_ADDR_LEN);\n\t\ti++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tmcast.wi_len = (i * 3) + 1;\n\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_setmulti(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti = 0;\n\tstruct wi_ltv_mcast\tmcast;\n\tstruct ether_multistep\tstep;\n\tstruct ether_multi\t*enm;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbzero((char *)&mcast, sizeof(mcast));\n\n\tmcast.wi_type = WI_RID_MCAST;\n\tmcast.wi_len = (3 * 16) + 1;\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\twhile (enm != NULL) {\n\t\tif (i >= 16) {\n\t\t\tbzero((char *)&mcast, sizeof(mcast));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Punt on ranges. */\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0)\n\t\t\tbreak;\n\t\tbcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],\n\t\t    ETHER_ADDR_LEN);\n\t\ti++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tmcast.wi_len = (i * 3) + 1;\n\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_stop",
          "args": [
            "sc"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "wi_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1386-1406",
          "snippet": "STATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_STOP\t0x10",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_STOP\t0x10\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_init",
          "args": [
            "sc"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "wi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1147-1254",
          "snippet": "STATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_INIT\t0x08",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_INIT\t0x08\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_PROMISC",
            "0"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_PROMISC",
            "1"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "xe_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1190-1240",
          "snippet": "int\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\txe_ether_ioctl",
            "void\txe_init",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_ether_ioctl;\nvoid\txe_init;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "WID_IOCTL",
            "(\"wi_ioctl: command %lu data %p\", command, data)"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_IOCTL\t0x04\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nwi_setdef\t\t__P((struct wi_softc *, struct wi_req *));\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tint\t\t\ts, error = 0;\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_req\t\twreq;\n\tstruct ifreq\t\t*ifr;\n\tstruct proc *p = curproc;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\n\ts = splimp();\n\n\tsc = ifp->if_softc;\n\tifr = (struct ifreq *)data;\n\n\tif (sc->wi_gone)\n\t\treturn(ENODEV);\n\n\tDPRINTF (WID_IOCTL, (\"wi_ioctl: command %lu data %p\", command, data));\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\twi_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\t\tdefault:\n\t\t\twi_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->wi_if_flags & IFF_PROMISC)) {\n\t\t\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->wi_if_flags & IFF_PROMISC) {\n\t\t\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t\t\t} else\n\t\t\t\twi_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\twi_stop(sc);\n\t\t\t}\n\t\t}\n\t\tsc->wi_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\twi_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCGWAVELAN:\n\t\terror = copyin(ifr->ifr_data, &wreq, sizeof(wreq));\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (wreq.wi_type == WI_RID_IFACE_STATS) {\n\t\t\tbcopy((char *)&sc->wi_stats, (char *)&wreq.wi_val,\n\t\t\t    sizeof(sc->wi_stats));\n\t\t\twreq.wi_len = (sizeof(sc->wi_stats) / 2) + 1;\n\t\t} else if (wreq.wi_type == WI_RID_DEFLT_CRYPT_KEYS) {\n\t\t\t/* For non-root user, return all-zeroes keys */\n\t\t\tif (suser(p->p_ucred, &p->p_acflag))\n\t\t\t\tbzero((char *)&wreq,\n\t\t\t    \t\tsizeof(struct wi_ltv_keys));\n\t\t\telse\n\t\t\t\tbcopy((char *)&sc->wi_keys, (char *)&wreq,\n\t\t\t    \t\tsizeof(struct wi_ltv_keys));\n\t\t} else {\n\t\t\tif (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terror = copyout(&wreq, ifr->ifr_data, sizeof(wreq));\n\t\tbreak;\n\tcase SIOCSWAVELAN:\n\t\terror = suser(p->p_ucred, &p->p_acflag);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = copyin(ifr->ifr_data, &wreq, sizeof(wreq));\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (wreq.wi_type == WI_RID_IFACE_STATS) {\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t} else if (wreq.wi_type == WI_RID_MGMT_XMIT) {\n\t\t\terror = wi_mgmt_xmit(sc, (caddr_t)&wreq.wi_val,\n\t\t\t    wreq.wi_len);\n\t\t} else {\n\t\t\terror = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);\n\t\t\tif (!error)\n\t\t\t\twi_setdef(sc, &wreq);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "wi_setdef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "948-1024",
    "snippet": "STATIC void wi_setdef(sc, wreq)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_req\t\t*wreq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(wreq->wi_type) {\n\tcase WI_RID_MAC_NODE:\n\t\tifa = ifnet_addrs[ifp->if_index];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&wreq->wi_val, LLADDR(sdl), ETHER_ADDR_LEN);\n\t\tbcopy((char *)&wreq->wi_val, (char *)&sc->arpcom.ac_enaddr,\n\t\t      ETHER_ADDR_LEN);\n\t\tbreak;\n\tcase WI_RID_PORTTYPE:\n\t\tsc->wi_ptype = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_RATE:\n\t\tsc->wi_tx_rate = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_DATALEN:\n\t\tsc->wi_max_data_len = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_RTS_THRESH:\n\t\tsc->wi_rts_thresh = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_SYSTEM_SCALE:\n\t\tsc->wi_ap_density = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_CREATE_IBSS:\n\t\tsc->wi_create_ibss = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_OWN_CHNL:\n\t\tsc->wi_channel = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_NODENAME:\n\t\tbzero(sc->wi_node_name, sizeof(sc->wi_node_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_node_name, 30);\n\t\tbreak;\n\tcase WI_RID_DESIRED_SSID:\n\t\tbzero(sc->wi_net_name, sizeof(sc->wi_net_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_net_name, 30);\n\t\tbreak;\n\tcase WI_RID_OWN_SSID:\n\t\tbzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_ibss_name, 30);\n\t\tbreak;\n\tcase WI_RID_PM_ENABLED:\n\t\tsc->wi_pm_enabled = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_SLEEP:\n\t\tsc->wi_max_sleep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_ENCRYPTION:\n\t\tsc->wi_use_wep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_CRYPT_KEY:\n\t\tsc->wi_tx_key = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_DEFLT_CRYPT_KEYS:\n\t\tbcopy((char *)wreq, (char *)&sc->wi_keys,\n\t\t    sizeof(struct wi_ltv_keys));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Reinitialize WaveLAN. */\n\twi_init(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "wi_setdef\t\t__P((struct wi_softc *, struct wi_req *));",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wi_init",
          "args": [
            "sc"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "wi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1147-1254",
          "snippet": "STATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_INIT\t0x08",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_INIT\t0x08\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)wreq",
            "(char *)&sc->wi_keys",
            "sizeof(struct wi_ltv_keys)"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->wi_ibss_name",
            "sizeof(sc->wi_ibss_name)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->wi_net_name",
            "sizeof(sc->wi_net_name)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->wi_node_name",
            "sizeof(sc->wi_node_name)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "sdl"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nwi_setdef\t\t__P((struct wi_softc *, struct wi_req *));\nSTATIC int;\n\nSTATIC void wi_setdef(sc, wreq)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_req\t\t*wreq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch(wreq->wi_type) {\n\tcase WI_RID_MAC_NODE:\n\t\tifa = ifnet_addrs[ifp->if_index];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&wreq->wi_val, LLADDR(sdl), ETHER_ADDR_LEN);\n\t\tbcopy((char *)&wreq->wi_val, (char *)&sc->arpcom.ac_enaddr,\n\t\t      ETHER_ADDR_LEN);\n\t\tbreak;\n\tcase WI_RID_PORTTYPE:\n\t\tsc->wi_ptype = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_RATE:\n\t\tsc->wi_tx_rate = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_DATALEN:\n\t\tsc->wi_max_data_len = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_RTS_THRESH:\n\t\tsc->wi_rts_thresh = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_SYSTEM_SCALE:\n\t\tsc->wi_ap_density = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_CREATE_IBSS:\n\t\tsc->wi_create_ibss = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_OWN_CHNL:\n\t\tsc->wi_channel = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_NODENAME:\n\t\tbzero(sc->wi_node_name, sizeof(sc->wi_node_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_node_name, 30);\n\t\tbreak;\n\tcase WI_RID_DESIRED_SSID:\n\t\tbzero(sc->wi_net_name, sizeof(sc->wi_net_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_net_name, 30);\n\t\tbreak;\n\tcase WI_RID_OWN_SSID:\n\t\tbzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));\n\t\tbcopy((char *)&wreq->wi_val[1], sc->wi_ibss_name, 30);\n\t\tbreak;\n\tcase WI_RID_PM_ENABLED:\n\t\tsc->wi_pm_enabled = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_MAX_SLEEP:\n\t\tsc->wi_max_sleep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_ENCRYPTION:\n\t\tsc->wi_use_wep = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_TX_CRYPT_KEY:\n\t\tsc->wi_tx_key = wreq->wi_val[0];\n\t\tbreak;\n\tcase WI_RID_DEFLT_CRYPT_KEYS:\n\t\tbcopy((char *)wreq, (char *)&sc->wi_keys,\n\t\t    sizeof(struct wi_ltv_keys));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Reinitialize WaveLAN. */\n\twi_init(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "904-946",
    "snippet": "STATIC void wi_setmulti(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti = 0;\n\tstruct wi_ltv_mcast\tmcast;\n\tstruct ether_multistep\tstep;\n\tstruct ether_multi\t*enm;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbzero((char *)&mcast, sizeof(mcast));\n\n\tmcast.wi_type = WI_RID_MCAST;\n\tmcast.wi_len = (3 * 16) + 1;\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\twhile (enm != NULL) {\n\t\tif (i >= 16) {\n\t\t\tbzero((char *)&mcast, sizeof(mcast));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Punt on ranges. */\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0)\n\t\t\tbreak;\n\t\tbcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],\n\t\t    ETHER_ADDR_LEN);\n\t\ti++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tmcast.wi_len = (i * 3) + 1;\n\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wi_write_record",
          "args": [
            "sc",
            "(struct wi_ltv_gen *)&mcast"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "wi_write_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "742-763",
          "snippet": "STATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enm->enm_addrlo",
            "(char *)&mcast.wi_mcast[i]",
            "ETHER_ADDR_LEN"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "sizeof(enm->enm_addrlo)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&mcast",
            "sizeof(mcast)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->arpcom",
            "enm"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&mcast",
            "sizeof(mcast)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_setmulti(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti = 0;\n\tstruct wi_ltv_mcast\tmcast;\n\tstruct ether_multistep\tstep;\n\tstruct ether_multi\t*enm;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbzero((char *)&mcast, sizeof(mcast));\n\n\tmcast.wi_type = WI_RID_MCAST;\n\tmcast.wi_len = (3 * 16) + 1;\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\twhile (enm != NULL) {\n\t\tif (i >= 16) {\n\t\t\tbzero((char *)&mcast, sizeof(mcast));\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Punt on ranges. */\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0)\n\t\t\tbreak;\n\t\tbcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],\n\t\t    ETHER_ADDR_LEN);\n\t\ti++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tmcast.wi_len = (i * 3) + 1;\n\twi_write_record(sc, (struct wi_ltv_gen *)&mcast);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_alloc_nicmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "871-902",
    "snippet": "STATIC int wi_alloc_nicmem(sc, len, id)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (wi_cmd(sc, WI_CMD_ALLOC_MEM, len)) {\n\t\tprintf(WI_PRT_FMT \": failed to allocate %d bytes on NIC\\n\",\n\t\t    WI_PRT_ARG(sc), len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);\n\t*id = CSR_READ_2(sc, WI_ALLOC_FID);\n\n\tif (wi_seek(sc, *id, 0, WI_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, 0);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_DATA0",
            "0"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_seek",
          "args": [
            "sc",
            "*id",
            "0",
            "WI_BAP0"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "wi_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "765-799",
          "snippet": "STATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_ALLOC_FID"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_ALLOC"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_EVENT_STAT"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": failed to allocate %d bytes on NIC\\n\"",
            "WI_PRT_ARG(sc)",
            "len"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_ALLOC_MEM",
            "len"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_alloc_nicmem(sc, len, id)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (wi_cmd(sc, WI_CMD_ALLOC_MEM, len)) {\n\t\tprintf(WI_PRT_FMT \": failed to allocate %d bytes on NIC\\n\",\n\t\t    WI_PRT_ARG(sc), len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);\n\t*id = CSR_READ_2(sc, WI_ALLOC_FID);\n\n\tif (wi_seek(sc, *id, 0, WI_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, 0);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_write_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "832-865",
    "snippet": "STATIC int wi_write_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n#ifdef WI_HERMES_AUTOINC_WAR\nagain:\n#endif\n\n\tif (wi_seek(sc, id, off, WI_BAP0))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, ptr[i]);\n\n#ifdef WI_HERMES_AUTOINC_WAR\n\tCSR_WRITE_2(sc, WI_DATA0, 0x1234);\n\tCSR_WRITE_2(sc, WI_DATA0, 0x5678);\n\n\tif (wi_seek(sc, id, off + len, WI_BAP0))\n\t\treturn(EIO);\n\n\tif (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||\n\t    CSR_READ_2(sc, WI_DATA0) != 0x5678)\n\t\tgoto again;\n#endif\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC",
      "#define WI_HERMES_AUTOINC_WAR\t/* Work around data write autoinc bug. */"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_DATA0"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_DATA0"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_seek",
          "args": [
            "sc",
            "id",
            "off + len",
            "WI_BAP0"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "wi_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "765-799",
          "snippet": "STATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_DATA0",
            "0x5678"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_DATA0",
            "0x1234"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_DATA0",
            "ptr[i]"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n#define WI_HERMES_AUTOINC_WAR\t/* Work around data write autoinc bug. */\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_write_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n#ifdef WI_HERMES_AUTOINC_WAR\nagain:\n#endif\n\n\tif (wi_seek(sc, id, off, WI_BAP0))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, WI_DATA0, ptr[i]);\n\n#ifdef WI_HERMES_AUTOINC_WAR\n\tCSR_WRITE_2(sc, WI_DATA0, 0x1234);\n\tCSR_WRITE_2(sc, WI_DATA0, 0x5678);\n\n\tif (wi_seek(sc, id, off + len, WI_BAP0))\n\t\treturn(EIO);\n\n\tif (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||\n\t    CSR_READ_2(sc, WI_DATA0) != 0x5678)\n\t\tgoto again;\n#endif\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_read_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "801-818",
    "snippet": "STATIC int wi_read_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n\tif (wi_seek(sc, id, off, WI_BAP1))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_DATA1"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_seek",
          "args": [
            "sc",
            "id",
            "off",
            "WI_BAP1"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "wi_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "765-799",
          "snippet": "STATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_read_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n\tif (wi_seek(sc, id, off, WI_BAP1))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "765-799",
    "snippet": "STATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "offreg"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "offreg",
            "off"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "selreg",
            "id"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": invalid data path: %x\\n\"",
            "WI_PRT_ARG(sc)",
            "chan"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_write_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "742-763",
    "snippet": "STATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_ACCESS|WI_ACCESS_WRITE",
            "ltv->wi_type"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_DATA1",
            "ptr[i]"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_DATA1",
            "ltv->wi_type"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_DATA1",
            "ltv->wi_len"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_seek",
          "args": [
            "sc",
            "ltv->wi_type",
            "0",
            "WI_BAP1"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "wi_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "765-799",
          "snippet": "STATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_write_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);\n\tCSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);\n\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tCSR_WRITE_2(sc, WI_DATA1, ptr[i]);\n\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_read_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "701-737",
    "snippet": "STATIC int wi_read_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len, code;\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))\n\t\treturn(EIO);\n\n\t/* Seek to the record. */\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, WI_DATA1);\n\tif (len > ltv->wi_len)\n\t\treturn(ENOSPC);\n\tcode = CSR_READ_2(sc, WI_DATA1);\n\tif (code != ltv->wi_type)\n\t\treturn(EIO);\n\n\tltv->wi_len = len;\n\tltv->wi_type = code;\n\n\t/* Now read the data. */\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_DATA1"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_DATA1"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_DATA1"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_seek",
          "args": [
            "sc",
            "ltv->wi_type",
            "0",
            "WI_BAP1"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "wi_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "765-799",
          "snippet": "STATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_seek(sc, id, off, chan)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase WI_BAP0:\n\t\tselreg = WI_SEL0;\n\t\toffreg = WI_OFF0;\n\t\tbreak;\n\tcase WI_BAP1:\n\t\tselreg = WI_SEL1;\n\t\toffreg = WI_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(WI_PRT_FMT \": invalid data path: %x\\n\", WI_PRT_ARG(sc),\n\t\t    chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_ACCESS|WI_ACCESS_READ",
            "ltv->wi_type"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_read_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len, code;\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))\n\t\treturn(EIO);\n\n\t/* Seek to the record. */\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, WI_DATA1);\n\tif (len > ltv->wi_len)\n\t\treturn(ENOSPC);\n\tcode = CSR_READ_2(sc, WI_DATA1);\n\tif (code != ltv->wi_type)\n\t\treturn(EIO);\n\n\tltv->wi_len = len;\n\tltv->wi_type = code;\n\n\t/* Now read the data. */\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "682-696",
    "snippet": "STATIC void wi_reset(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tDPRINTF(WID_RESET, (\"wi_reset: sc %p\\n\", sc));\n\n\tif (wi_cmd(sc, WI_CMD_INI, 0))\n\t\tprintf(WI_PRT_FMT \": init failed\\n\", WI_PRT_ARG(sc));\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\t/* Calibrate timer. */\n\tWI_SETVAL(WI_RID_TICK_TIME, 8);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WID_RESET\t0x20",
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WI_SETVAL",
          "args": [
            "WI_RID_TICK_TIME",
            "8"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "0xFFFF"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_INT_EN",
            "0"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": init failed\\n\"",
            "WI_PRT_ARG(sc)"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_INI",
            "0"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "WID_RESET",
            "(\"wi_reset: sc %p\\n\", sc)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_RESET\t0x20\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_reset(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tDPRINTF(WID_RESET, (\"wi_reset: sc %p\\n\", sc));\n\n\tif (wi_cmd(sc, WI_CMD_INI, 0))\n\t\tprintf(WI_PRT_FMT \": init failed\\n\", WI_PRT_ARG(sc));\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\t/* Calibrate timer. */\n\tWI_SETVAL(WI_RID_TICK_TIME, 8);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "646-680",
    "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_CMD"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_STATUS"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_EVENT_STAT"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_COMMAND",
            "cmd"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_PARAM0",
            "val"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "wi_update_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "608-644",
    "snippet": "void wi_update_stats(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct wi_ltv_gen\tgen;\n\tu_int16_t\t\tid;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti;\n\tu_int16_t\t\tt;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_INFO_FID);\n\n\twi_read_data(sc, id, 0, (char *)&gen, 4);\n\n\tif (gen.wi_type != WI_INFO_COUNTERS ||\n\t    gen.wi_len > (sizeof(sc->wi_stats) / 4) + 1)\n\t\treturn;\n\n\tptr = (u_int32_t *)&sc->wi_stats;\n\n\tfor (i = 0; i < gen.wi_len - 1; i++) {\n\t\tt = CSR_READ_2(sc, WI_DATA1);\n#ifdef WI_HERMES_STATS_WAR\n\t\tif (t > 0xF000)\n\t\t\tt = ~t & 0xFFFF;\n#endif\n\t\tptr[i] += t;\n\t}\n\n\tifp->if_collisions = sc->wi_stats.wi_tx_single_retries +\n\t    sc->wi_stats.wi_tx_multi_retries +\n\t    sc->wi_stats.wi_tx_retry_limit;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WI_HERMES_STATS_WAR\t/* Work around stats counter bug. */"
    ],
    "globals_used": [
      "wi_reset\t\t__P((struct wi_softc *));",
      "wi_start\t\t__P((struct ifnet *));",
      "wi_stop\t\t__P((struct wi_softc *));",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "wi_update_stats\t__P((struct wi_softc *));",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_DATA1"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_read_data",
          "args": [
            "sc",
            "id",
            "0",
            "(char *)&gen",
            "4"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "wi_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "801-818",
          "snippet": "STATIC int wi_read_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n\tif (wi_seek(sc, id, off, WI_BAP1))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_read_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n\tif (wi_seek(sc, id, off, WI_BAP1))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_INFO_FID"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_HERMES_STATS_WAR\t/* Work around stats counter bug. */\n\nwi_reset\t\t__P((struct wi_softc *));\nwi_start\t\t__P((struct ifnet *));\nwi_stop\t\t__P((struct wi_softc *));\nwi_watchdog\t\t__P((struct ifnet *));\nwi_rxeof\t\t__P((struct wi_softc *));\nwi_txeof\t\t__P((struct wi_softc *, int));\nwi_update_stats\t__P((struct wi_softc *));\nwi_setmulti\t\t__P((struct wi_softc *));\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\n\nvoid wi_update_stats(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct wi_ltv_gen\tgen;\n\tu_int16_t\t\tid;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti;\n\tu_int16_t\t\tt;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_INFO_FID);\n\n\twi_read_data(sc, id, 0, (char *)&gen, 4);\n\n\tif (gen.wi_type != WI_INFO_COUNTERS ||\n\t    gen.wi_len > (sizeof(sc->wi_stats) / 4) + 1)\n\t\treturn;\n\n\tptr = (u_int32_t *)&sc->wi_stats;\n\n\tfor (i = 0; i < gen.wi_len - 1; i++) {\n\t\tt = CSR_READ_2(sc, WI_DATA1);\n#ifdef WI_HERMES_STATS_WAR\n\t\tif (t > 0xF000)\n\t\t\tt = ~t & 0xFFFF;\n#endif\n\t\tptr[i] += t;\n\t}\n\n\tifp->if_collisions = sc->wi_stats.wi_tx_single_retries +\n\t    sc->wi_stats.wi_tx_multi_retries +\n\t    sc->wi_stats.wi_tx_retry_limit;\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_inquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "588-606",
    "snippet": "void wi_inquire(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\t/* Don't do this while we're transmitting */\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\twi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "wi_reset\t\t__P((struct wi_softc *));",
      "wi_start\t\t__P((struct ifnet *));",
      "wi_stop\t\t__P((struct wi_softc *));",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "wi_update_stats\t__P((struct wi_softc *));",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wi_cmd",
          "args": [
            "sc",
            "WI_CMD_INQUIRE",
            "WI_INFO_COUNTERS"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "wi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "646-680",
          "snippet": "STATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_cmd(sc, cmd, val)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tcmd;\n\tint\t\t\tval;\n{\n\tint\t\t\ti, s = 0;\n\n\tCSR_WRITE_2(sc, WI_PARAM0, val);\n\tCSR_WRITE_2(sc, WI_COMMAND, cmd);\n\n\tfor (i = 0; i < WI_TIMEOUT; i++) {\n\t\t/*\n\t\t * Wait for 'command complete' bit to be\n\t\t * set in the event status register.\n\t\t */\n\t\ts = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;\n\t\tif (s) {\n\t\t\t/* Ack the event and read result code. */\n\t\t\ts = CSR_READ_2(sc, WI_STATUS);\n\t\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);\n#ifdef foo\n\t\t\tif ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))\n\t\t\t\treturn(EIO);\n#endif\n\t\t\tif (s & WI_STAT_CMD_RESULT)\n\t\t\t\treturn(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == WI_TIMEOUT)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMEOUT",
          "args": [
            "sc->wi_stat_ch",
            "wi_inquire",
            "sc",
            "hz * 60"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nwi_reset\t\t__P((struct wi_softc *));\nwi_start\t\t__P((struct ifnet *));\nwi_stop\t\t__P((struct wi_softc *));\nwi_watchdog\t\t__P((struct ifnet *));\nwi_rxeof\t\t__P((struct wi_softc *));\nwi_txeof\t\t__P((struct wi_softc *, int));\nwi_update_stats\t__P((struct wi_softc *));\nwi_setmulti\t\t__P((struct wi_softc *));\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\n\nvoid wi_inquire(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\t/* Don't do this while we're transmitting */\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\twi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "569-586",
    "snippet": "STATIC void wi_txeof(sc, status)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status & WI_EV_TX_EXC)\n\t\tifp->if_oerrors++;\n\telse\n\t\tifp->if_opackets++;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_txeof(sc, status)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status & WI_EV_TX_EXC)\n\t\tifp->if_oerrors++;\n\telse\n\t\tifp->if_opackets++;\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "464-567",
    "snippet": "STATIC void wi_rxeof(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n\tstruct wi_frame\t\trx_frame;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_RX_FID);\n\n\t/* First read in the frame header */\n\tif (wi_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame.wi_status & WI_STAT_ERRSTAT) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\teh = mtod(m, struct ether_header *);\n\tm->m_pkthdr.rcvif = ifp;\n\n\tif (rx_frame.wi_status == WI_STAT_1042 ||\n\t    rx_frame.wi_status == WI_STAT_TUNNEL ||\n\t    rx_frame.wi_status == WI_STAT_WMP_MSG) {\n\t\tif((rx_frame.wi_dat_len + WI_SNAPHDR_LEN) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + WI_SNAPHDR_LEN;\n\n\t\tbcopy((char *)&rx_frame.wi_addr1,\n\t\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_addr2,\n\t\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_type,\n\t\t    (char *)&eh->ether_type, sizeof(u_int16_t));\n\n\t\tif (wi_read_data(sc, id, WI_802_11_OFFSET,\n\t\t    mtod(m, caddr_t) + sizeof(struct ether_header),\n\t\t    m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif((rx_frame.wi_dat_len +\n\t\t    sizeof(struct ether_header)) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + sizeof(struct ether_header);\n\n\t\tif (wi_read_data(sc, id, WI_802_3_OFFSET,\n\t\t    mtod(m, caddr_t), m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m);\n#endif\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WI_PRT_FMT \"%s\"",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "wi_reset\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "STATIC void",
      "STATIC void",
      "wi_start\t\t__P((struct ifnet *));",
      "STATIC void",
      "wi_stop\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "STATIC void",
      "STATIC void",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "STATIC void",
      "wi_update_stats\t__P((struct wi_softc *));",
      "STATIC void",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "STATIC int",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
      "STATIC int",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "STATIC int",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_read_data",
          "args": [
            "sc",
            "id",
            "WI_802_3_OFFSET",
            "mtod(m, caddr_t)",
            "m->m_len + 2"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "wi_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "801-818",
          "snippet": "STATIC int wi_read_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n\tif (wi_seek(sc, id, off, WI_BAP1))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC int wi_read_data(sc, id, off, buf, len)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\n\tif (wi_seek(sc, id, off, WI_BAP1))\n\t\treturn(EIO);\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\"",
            "WI_PRT_ARG(sc)",
            "rx_frame.wi_dat_len",
            "rx_frame.wi_status"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&rx_frame.wi_type",
            "(char *)&eh->ether_type",
            "sizeof(u_int16_t)"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_RX_FID"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC void wi_rxeof(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n\tstruct wi_frame\t\trx_frame;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_RX_FID);\n\n\t/* First read in the frame header */\n\tif (wi_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame.wi_status & WI_STAT_ERRSTAT) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\teh = mtod(m, struct ether_header *);\n\tm->m_pkthdr.rcvif = ifp;\n\n\tif (rx_frame.wi_status == WI_STAT_1042 ||\n\t    rx_frame.wi_status == WI_STAT_TUNNEL ||\n\t    rx_frame.wi_status == WI_STAT_WMP_MSG) {\n\t\tif((rx_frame.wi_dat_len + WI_SNAPHDR_LEN) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + WI_SNAPHDR_LEN;\n\n\t\tbcopy((char *)&rx_frame.wi_addr1,\n\t\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_addr2,\n\t\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_type,\n\t\t    (char *)&eh->ether_type, sizeof(u_int16_t));\n\n\t\tif (wi_read_data(sc, id, WI_802_11_OFFSET,\n\t\t    mtod(m, caddr_t) + sizeof(struct ether_header),\n\t\t    m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif((rx_frame.wi_dat_len +\n\t\t    sizeof(struct ether_header)) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + sizeof(struct ether_header);\n\n\t\tif (wi_read_data(sc, id, WI_802_3_OFFSET,\n\t\t    mtod(m, caddr_t), m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m);\n#endif\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\treturn;\n}"
  },
  {
    "function_name": "wi_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "400-462",
    "snippet": "int wi_intr(vsc)\n\tvoid\t\t\t*vsc;\n{\n\tstruct wi_softc\t\t*sc = vsc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\n\tDPRINTF(WID_INTR, (\"wi_intr: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\t\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\t\treturn (0);\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\n\tstatus = CSR_READ_2(sc, WI_EVENT_STAT);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, ~WI_INTRS);\n\n\tif (status & WI_EV_RX) {\n\t\twi_rxeof(sc);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_RX);\n\t}\n\n\tif (status & WI_EV_TX) {\n\t\twi_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX);\n\t}\n\n\tif (status & WI_EV_ALLOC) {\n\t\tint\t\t\tid;\n\t\tid = CSR_READ_2(sc, WI_ALLOC_FID);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);\n\t\tif (id == sc->wi_tx_data_id)\n\t\t\twi_txeof(sc, status);\n\t}\n\n\tif (status & WI_EV_INFO) {\n\t\twi_update_stats(sc);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO);\n\t}\n\n\tif (status & WI_EV_TX_EXC) {\n\t\twi_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX_EXC);\n\t}\n\n\tif (status & WI_EV_INFO_DROP) {\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO_DROP);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\twi_start(ifp);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define WID_INTR\t0x01"
    ],
    "globals_used": [
      "wi_reset\t\t__P((struct wi_softc *));",
      "wi_start\t\t__P((struct ifnet *));",
      "wi_stop\t\t__P((struct wi_softc *));",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "wi_update_stats\t__P((struct wi_softc *));",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "int\twi_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wi_start",
          "args": [
            "ifp"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "wi_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1256-1347",
          "snippet": "STATIC void wi_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct wi_softc\t\t*sc;\n\tstruct mbuf\t\t*m0;\n\tstruct wi_frame\t\ttx_frame;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\n\tsc = ifp->if_softc;\n\n\tDPRINTF(WID_START, (\"wi_start: ifp %p sc %p\\n\", ifp, sc));\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == NULL)\n\t\treturn;\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_data_id;\n\teh = mtod(m0, struct ether_header *);\n\n\t/*\n\t * Use RFC1042 encoding for IP and ARP datagrams,\n\t * 802.3 for anything else.\n\t */\n\tif (ntohs(eh->ether_type) == ETHERTYPE_IP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_ARP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_REVARP) {\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_addr1, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;\n\t\ttx_frame.wi_frame_ctl = WI_FTYPE_DATA;\n\t\ttx_frame.wi_dat[0] = htons(WI_SNAP_WORD0);\n\t\ttx_frame.wi_dat[1] = htons(WI_SNAP_WORD1);\n\t\ttx_frame.wi_len = htons(m0->m_pkthdr.len - WI_SNAPHDR_LEN);\n\t\ttx_frame.wi_type = eh->ether_type;\n\n\t\tm_copydata(m0, sizeof(struct ether_header),\n\t\t    m0->m_pkthdr.len - sizeof(struct ether_header),\n\t\t    (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_11_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    (m0->m_pkthdr.len - sizeof(struct ether_header)) + 2);\n\t} else {\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len;\n\n\t\tm_copydata(m0, 0, m0->m_pkthdr.len, (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_3_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    m0->m_pkthdr.len + 2);\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listner, bounce a copy of\n\t * this frame to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m0);\n#endif\n\n\tm_freem(m0);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id))\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_START\t0x02",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_START\t0x02\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC void wi_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct wi_softc\t\t*sc;\n\tstruct mbuf\t\t*m0;\n\tstruct wi_frame\t\ttx_frame;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\n\tsc = ifp->if_softc;\n\n\tDPRINTF(WID_START, (\"wi_start: ifp %p sc %p\\n\", ifp, sc));\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == NULL)\n\t\treturn;\n\n\tbzero((char *)&tx_frame, sizeof(tx_frame));\n\tid = sc->wi_tx_data_id;\n\teh = mtod(m0, struct ether_header *);\n\n\t/*\n\t * Use RFC1042 encoding for IP and ARP datagrams,\n\t * 802.3 for anything else.\n\t */\n\tif (ntohs(eh->ether_type) == ETHERTYPE_IP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_ARP ||\n\t    ntohs(eh->ether_type) == ETHERTYPE_REVARP) {\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_addr1, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame.wi_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame.wi_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;\n\t\ttx_frame.wi_frame_ctl = WI_FTYPE_DATA;\n\t\ttx_frame.wi_dat[0] = htons(WI_SNAP_WORD0);\n\t\ttx_frame.wi_dat[1] = htons(WI_SNAP_WORD1);\n\t\ttx_frame.wi_len = htons(m0->m_pkthdr.len - WI_SNAPHDR_LEN);\n\t\ttx_frame.wi_type = eh->ether_type;\n\n\t\tm_copydata(m0, sizeof(struct ether_header),\n\t\t    m0->m_pkthdr.len - sizeof(struct ether_header),\n\t\t    (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_11_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    (m0->m_pkthdr.len - sizeof(struct ether_header)) + 2);\n\t} else {\n\t\ttx_frame.wi_dat_len = m0->m_pkthdr.len;\n\n\t\tm_copydata(m0, 0, m0->m_pkthdr.len, (caddr_t)&sc->wi_txbuf);\n\n\t\twi_write_data(sc, id, 0, (caddr_t)&tx_frame,\n\t\t    sizeof(struct wi_frame));\n\t\twi_write_data(sc, id, WI_802_3_OFFSET, (caddr_t)&sc->wi_txbuf,\n\t\t    m0->m_pkthdr.len + 2);\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listner, bounce a copy of\n\t * this frame to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m0);\n#endif\n\n\tm_freem(m0);\n\n\tif (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id))\n\t\tprintf(WI_PRT_FMT \": xmit failed\\n\", WI_PRT_ARG(sc));\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_INT_EN",
            "WI_INTRS"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_INFO_DROP"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_TX_EXC"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_txeof",
          "args": [
            "sc",
            "status"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "wi_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "569-586",
          "snippet": "STATIC void wi_txeof(sc, status)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status & WI_EV_TX_EXC)\n\t\tifp->if_oerrors++;\n\telse\n\t\tifp->if_opackets++;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_txeof(sc, status)\n\tstruct wi_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status & WI_EV_TX_EXC)\n\t\tifp->if_oerrors++;\n\telse\n\t\tifp->if_opackets++;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_INFO"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_update_stats",
          "args": [
            "sc"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "wi_update_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "608-644",
          "snippet": "void wi_update_stats(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct wi_ltv_gen\tgen;\n\tu_int16_t\t\tid;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti;\n\tu_int16_t\t\tt;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_INFO_FID);\n\n\twi_read_data(sc, id, 0, (char *)&gen, 4);\n\n\tif (gen.wi_type != WI_INFO_COUNTERS ||\n\t    gen.wi_len > (sizeof(sc->wi_stats) / 4) + 1)\n\t\treturn;\n\n\tptr = (u_int32_t *)&sc->wi_stats;\n\n\tfor (i = 0; i < gen.wi_len - 1; i++) {\n\t\tt = CSR_READ_2(sc, WI_DATA1);\n#ifdef WI_HERMES_STATS_WAR\n\t\tif (t > 0xF000)\n\t\t\tt = ~t & 0xFFFF;\n#endif\n\t\tptr[i] += t;\n\t}\n\n\tifp->if_collisions = sc->wi_stats.wi_tx_single_retries +\n\t    sc->wi_stats.wi_tx_multi_retries +\n\t    sc->wi_stats.wi_tx_retry_limit;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_HERMES_STATS_WAR\t/* Work around stats counter bug. */"
          ],
          "globals_used": [
            "wi_reset\t\t__P((struct wi_softc *));",
            "wi_start\t\t__P((struct ifnet *));",
            "wi_stop\t\t__P((struct wi_softc *));",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "wi_update_stats\t__P((struct wi_softc *));",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_HERMES_STATS_WAR\t/* Work around stats counter bug. */\n\nwi_reset\t\t__P((struct wi_softc *));\nwi_start\t\t__P((struct ifnet *));\nwi_stop\t\t__P((struct wi_softc *));\nwi_watchdog\t\t__P((struct ifnet *));\nwi_rxeof\t\t__P((struct wi_softc *));\nwi_txeof\t\t__P((struct wi_softc *, int));\nwi_update_stats\t__P((struct wi_softc *));\nwi_setmulti\t\t__P((struct wi_softc *));\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\n\nvoid wi_update_stats(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct wi_ltv_gen\tgen;\n\tu_int16_t\t\tid;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\t*ptr;\n\tint\t\t\ti;\n\tu_int16_t\t\tt;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_INFO_FID);\n\n\twi_read_data(sc, id, 0, (char *)&gen, 4);\n\n\tif (gen.wi_type != WI_INFO_COUNTERS ||\n\t    gen.wi_len > (sizeof(sc->wi_stats) / 4) + 1)\n\t\treturn;\n\n\tptr = (u_int32_t *)&sc->wi_stats;\n\n\tfor (i = 0; i < gen.wi_len - 1; i++) {\n\t\tt = CSR_READ_2(sc, WI_DATA1);\n#ifdef WI_HERMES_STATS_WAR\n\t\tif (t > 0xF000)\n\t\t\tt = ~t & 0xFFFF;\n#endif\n\t\tptr[i] += t;\n\t}\n\n\tifp->if_collisions = sc->wi_stats.wi_tx_single_retries +\n\t    sc->wi_stats.wi_tx_multi_retries +\n\t    sc->wi_stats.wi_tx_retry_limit;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_ALLOC"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_ALLOC_FID"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_TX"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "WI_EV_RX"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_rxeof",
          "args": [
            "sc"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "wi_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "464-567",
          "snippet": "STATIC void wi_rxeof(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n\tstruct wi_frame\t\trx_frame;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_RX_FID);\n\n\t/* First read in the frame header */\n\tif (wi_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame.wi_status & WI_STAT_ERRSTAT) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\teh = mtod(m, struct ether_header *);\n\tm->m_pkthdr.rcvif = ifp;\n\n\tif (rx_frame.wi_status == WI_STAT_1042 ||\n\t    rx_frame.wi_status == WI_STAT_TUNNEL ||\n\t    rx_frame.wi_status == WI_STAT_WMP_MSG) {\n\t\tif((rx_frame.wi_dat_len + WI_SNAPHDR_LEN) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + WI_SNAPHDR_LEN;\n\n\t\tbcopy((char *)&rx_frame.wi_addr1,\n\t\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_addr2,\n\t\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_type,\n\t\t    (char *)&eh->ether_type, sizeof(u_int16_t));\n\n\t\tif (wi_read_data(sc, id, WI_802_11_OFFSET,\n\t\t    mtod(m, caddr_t) + sizeof(struct ether_header),\n\t\t    m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif((rx_frame.wi_dat_len +\n\t\t    sizeof(struct ether_header)) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + sizeof(struct ether_header);\n\n\t\tif (wi_read_data(sc, id, WI_802_3_OFFSET,\n\t\t    mtod(m, caddr_t), m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m);\n#endif\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "wi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_read_data\t\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_write_data\t__P((struct wi_softc *, int,\n\t\t\t\t\tint, caddr_t, int));\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\nwi_mgmt_xmit\t\t__P((struct wi_softc *, caddr_t, int));\n\nSTATIC void wi_rxeof(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n\tstruct wi_frame\t\trx_frame;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, WI_RX_FID);\n\n\t/* First read in the frame header */\n\tif (wi_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame.wi_status & WI_STAT_ERRSTAT) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\teh = mtod(m, struct ether_header *);\n\tm->m_pkthdr.rcvif = ifp;\n\n\tif (rx_frame.wi_status == WI_STAT_1042 ||\n\t    rx_frame.wi_status == WI_STAT_TUNNEL ||\n\t    rx_frame.wi_status == WI_STAT_WMP_MSG) {\n\t\tif((rx_frame.wi_dat_len + WI_SNAPHDR_LEN) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + WI_SNAPHDR_LEN;\n\n\t\tbcopy((char *)&rx_frame.wi_addr1,\n\t\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_addr2,\n\t\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&rx_frame.wi_type,\n\t\t    (char *)&eh->ether_type, sizeof(u_int16_t));\n\n\t\tif (wi_read_data(sc, id, WI_802_11_OFFSET,\n\t\t    mtod(m, caddr_t) + sizeof(struct ether_header),\n\t\t    m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif((rx_frame.wi_dat_len +\n\t\t    sizeof(struct ether_header)) > MCLBYTES) {\n\t\t\tprintf(WI_PRT_FMT \": oversized packet received \"\n\t\t\t    \"(wi_dat_len=%d, wi_status=0x%x)\\n\",\n\t\t\t    WI_PRT_ARG(sc), rx_frame.wi_dat_len,\n\t\t\t    rx_frame.wi_status);\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t    rx_frame.wi_dat_len + sizeof(struct ether_header);\n\n\t\tif (wi_read_data(sc, id, WI_802_3_OFFSET,\n\t\t    mtod(m, caddr_t), m->m_len + 2)) {\n\t\t\tm_freem(m);\n\t\t\tifp->if_ierrors++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_ipackets++;\n\n#if NBPFILTER > 0\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m);\n#endif\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "~WI_INTRS"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "WI_EVENT_STAT"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_INT_EN",
            "0"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_INT_EN",
            "0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "0xFFFF"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "WID_INTR",
            "(\"wi_intr: sc %p\\n\", sc)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_INTR\t0x01\n\nwi_reset\t\t__P((struct wi_softc *));\nwi_start\t\t__P((struct ifnet *));\nwi_stop\t\t__P((struct wi_softc *));\nwi_watchdog\t\t__P((struct ifnet *));\nwi_rxeof\t\t__P((struct wi_softc *));\nwi_txeof\t\t__P((struct wi_softc *, int));\nwi_update_stats\t__P((struct wi_softc *));\nwi_setmulti\t\t__P((struct wi_softc *));\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nint\twi_intr;\n\nint wi_intr(vsc)\n\tvoid\t\t\t*vsc;\n{\n\tstruct wi_softc\t\t*sc = vsc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\n\tDPRINTF(WID_INTR, (\"wi_intr: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\t\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\t\treturn (0);\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\n\tstatus = CSR_READ_2(sc, WI_EVENT_STAT);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, ~WI_INTRS);\n\n\tif (status & WI_EV_RX) {\n\t\twi_rxeof(sc);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_RX);\n\t}\n\n\tif (status & WI_EV_TX) {\n\t\twi_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX);\n\t}\n\n\tif (status & WI_EV_ALLOC) {\n\t\tint\t\t\tid;\n\t\tid = CSR_READ_2(sc, WI_ALLOC_FID);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);\n\t\tif (id == sc->wi_tx_data_id)\n\t\t\twi_txeof(sc, status);\n\t}\n\n\tif (status & WI_EV_INFO) {\n\t\twi_update_stats(sc);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO);\n\t}\n\n\tif (status & WI_EV_TX_EXC) {\n\t\twi_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX_EXC);\n\t}\n\n\tif (status & WI_EV_INFO_DROP) {\n\t\tCSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO_DROP);\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\twi_start(ifp);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "wi_pcmcia_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "368-398",
    "snippet": "int\nwi_pcmcia_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct wi_softc *sc = (struct wi_softc *)dev;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s;\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", WI_PRT_ARG(sc));\n\t\tsc->sc_ih =\n\t\t    pcmcia_intr_establish(sc->sc_pf, IPL_NET, wi_intr, sc);\n\t\tprintf(\"\\n\");\n\t\twi_init(sc);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tifp->if_timer = 0;\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\twi_stop(sc);\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "wi_reset\t\t__P((struct wi_softc *));",
      "wi_start\t\t__P((struct ifnet *));",
      "wi_stop\t\t__P((struct wi_softc *));",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "wi_update_stats\t__P((struct wi_softc *));",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "int\twi_pcmcia_activate",
      "int\twi_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_stop",
          "args": [
            "sc"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "wi_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1386-1406",
          "snippet": "STATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_STOP\t0x10",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_STOP\t0x10\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_init",
          "args": [
            "sc"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "wi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1147-1254",
          "snippet": "STATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_INIT\t0x08",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_INIT\t0x08\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_NET",
            "wi_intr",
            "sc"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WI_PRT_ARG",
          "args": [
            "sc"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nwi_reset\t\t__P((struct wi_softc *));\nwi_start\t\t__P((struct ifnet *));\nwi_stop\t\t__P((struct wi_softc *));\nwi_watchdog\t\t__P((struct ifnet *));\nwi_rxeof\t\t__P((struct wi_softc *));\nwi_txeof\t\t__P((struct wi_softc *, int));\nwi_update_stats\t__P((struct wi_softc *));\nwi_setmulti\t\t__P((struct wi_softc *));\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nint\twi_pcmcia_activate;\nint\twi_intr;\n\nint\nwi_pcmcia_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct wi_softc *sc = (struct wi_softc *)dev;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s;\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", WI_PRT_ARG(sc));\n\t\tsc->sc_ih =\n\t\t    pcmcia_intr_establish(sc->sc_pf, IPL_NET, wi_intr, sc);\n\t\tprintf(\"\\n\");\n\t\twi_init(sc);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tifp->if_timer = 0;\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\twi_stop(sc);\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "wi_pcmcia_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "350-366",
    "snippet": "int\nwi_pcmcia_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct wi_softc *sc = (struct wi_softc *)dev;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint rv = 0;\n\n\tpcmcia_io_unmap(sc->sc_pf, sc->sc_io_window);\n\tpcmcia_io_free(sc->sc_pf, &sc->sc_pcioh);\n\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "wi_reset\t\t__P((struct wi_softc *));",
      "wi_start\t\t__P((struct ifnet *));",
      "wi_stop\t\t__P((struct wi_softc *));",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "wi_update_stats\t__P((struct wi_softc *));",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "int\twi_pcmcia_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "if_detach",
          "args": [
            "ifp"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifdetach",
          "args": [
            "ifp"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "sc->sc_pf",
            "&sc->sc_pcioh"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "sc->sc_pf",
            "sc->sc_io_window"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nwi_reset\t\t__P((struct wi_softc *));\nwi_start\t\t__P((struct ifnet *));\nwi_stop\t\t__P((struct wi_softc *));\nwi_watchdog\t\t__P((struct ifnet *));\nwi_rxeof\t\t__P((struct wi_softc *));\nwi_txeof\t\t__P((struct wi_softc *, int));\nwi_update_stats\t__P((struct wi_softc *));\nwi_setmulti\t\t__P((struct wi_softc *));\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nint\twi_pcmcia_detach;\n\nint\nwi_pcmcia_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct wi_softc *sc = (struct wi_softc *)dev;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint rv = 0;\n\n\tpcmcia_io_unmap(sc->sc_pf, sc->sc_io_window);\n\tpcmcia_io_free(sc->sc_pf, &sc->sc_pcioh);\n\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "wi_pcmcia_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "206-348",
    "snippet": "void\nwi_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wi_softc\t\t*sc = (struct wi_softc *)self;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_function\t*pf = pa->pf;\n\tstruct pcmcia_config_entry *cfe = pf->cfe_head.sqh_first;\n\tstruct wi_ltv_macaddr\tmac;\n\tstruct wi_ltv_gen\tgen;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tstate = 0;\n\n\tsc->sc_pf = pf;\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pf, cfe);\n\tif (pcmcia_function_enable(pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tif (pcmcia_io_alloc(pf, 0, WI_IOSIZ, WI_IOSIZ, &sc->sc_pcioh)) {\n\t\tprintf(\": can't alloc i/o space\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tif (pcmcia_io_map(pf, PCMCIA_WIDTH_IO16, 0, WI_IOSIZ, &sc->sc_pcioh,\n\t    &sc->sc_io_window)) {\n\t\tprintf(\": can't map io space\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tsc->wi_gone = 0;\n\tsc->wi_btag = sc->sc_pcioh.iot;\n\tsc->wi_bhandle = sc->sc_pcioh.ioh;\n\n\t/* Make sure interrupts are disabled. */\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\twi_reset(sc);\n\n\t/* Read the station address. */\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tmac.wi_len = 4;\n\twi_read_record(sc, (struct wi_ltv_gen *)&mac);\n\tbcopy((char *)&mac.wi_mac_addr, (char *)&sc->arpcom.ac_enaddr,\n\t    ETHER_ADDR_LEN);\n\n\tprintf(\": address %s\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tifp = &sc->arpcom.ac_if;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = wi_ioctl;\n\tifp->if_start = wi_start;\n\tifp->if_watchdog = wi_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tbzero(sc->wi_node_name, sizeof(sc->wi_node_name));\n\tbcopy(WI_DEFAULT_NODENAME, sc->wi_node_name,\n\t    sizeof(WI_DEFAULT_NODENAME) - 1);\n\n\tbzero(sc->wi_net_name, sizeof(sc->wi_net_name));\n\tbcopy(WI_DEFAULT_NETNAME, sc->wi_net_name,\n\t    sizeof(WI_DEFAULT_NETNAME) - 1);\n\n\tbzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));\n\tbcopy(WI_DEFAULT_IBSS, sc->wi_ibss_name,\n\t    sizeof(WI_DEFAULT_IBSS) - 1);\n\n\tsc->wi_portnum = WI_DEFAULT_PORT;\n\tsc->wi_ptype = WI_PORTTYPE_ADHOC;\n\tsc->wi_ap_density = WI_DEFAULT_AP_DENSITY;\n\tsc->wi_rts_thresh = WI_DEFAULT_RTS_THRESH;\n\tsc->wi_tx_rate = WI_DEFAULT_TX_RATE;\n\tsc->wi_max_data_len = WI_DEFAULT_DATALEN;\n\tsc->wi_create_ibss = WI_DEFAULT_CREATE_IBSS;\n\tsc->wi_pm_enabled = WI_DEFAULT_PM_ENABLED;\n\tsc->wi_max_sleep = WI_DEFAULT_MAX_SLEEP;\n\n\t/*\n\t * Read the default channel from the NIC. This may vary\n\t * depending on the country where the NIC was purchased, so\n\t * we can't hard-code a default and expect it to work for\n\t * everyone.\n\t */\n\tgen.wi_type = WI_RID_OWN_CHNL;\n\tgen.wi_len = 2;\n\twi_read_record(sc, &gen);\n\tsc->wi_channel = gen.wi_val;\n\n\t/*\n\t * Find out if we support WEP on this card.\n\t */\n\tgen.wi_type = WI_RID_WEP_AVAIL;\n\tgen.wi_len = 2;\n\twi_read_record(sc, &gen);\n\tsc->wi_has_wep = gen.wi_val;\n\n\tbzero((char *)&sc->wi_stats, sizeof(sc->wi_stats));\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tBPFATTACH(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tshutdownhook_establish(wi_shutdown, sc);\n\n\t/* Establish the interrupt. */\n\tsc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto bad;\n\t}\n\tprintf(\"\\n\");\n\n\twi_init(sc);\n\twi_stop(sc);\n\treturn;\n\nbad:\n\tif (state > 2)\n\t\tpcmcia_io_unmap(pf, sc->sc_io_window);\n\tif (state > 1)\n\t\tpcmcia_io_free(pf, &sc->sc_pcioh);\n\tif (state > 0)\n\t\tpcmcia_function_disable(pf);\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "wi_reset\t\t__P((struct wi_softc *));",
      "wi_start\t\t__P((struct ifnet *));",
      "wi_stop\t\t__P((struct wi_softc *));",
      "wi_watchdog\t\t__P((struct ifnet *));",
      "wi_rxeof\t\t__P((struct wi_softc *));",
      "wi_txeof\t\t__P((struct wi_softc *, int));",
      "wi_update_stats\t__P((struct wi_softc *));",
      "wi_setmulti\t\t__P((struct wi_softc *));",
      "wi_cmd\t\t__P((struct wi_softc *, int, int));",
      "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
      "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
      "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
      "void\twi_pcmcia_attach",
      "int\twi_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "pf"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "pf",
            "&sc->sc_pcioh"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "pf",
            "sc->sc_io_window"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_stop",
          "args": [
            "sc"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "wi_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1386-1406",
          "snippet": "STATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_STOP\t0x10",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_STOP\t0x10\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_stop(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_STOP, (\"wi_stop: sc %p\\n\", sc));\n\n\tifp = &sc->arpcom.ac_if;\n\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\twi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);\n\n\tUNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wi_init",
          "args": [
            "sc"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "wi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "1147-1254",
          "snippet": "STATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_INIT\t0x08",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "wi_start\t\t__P((struct ifnet *));",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_watchdog\t\t__P((struct ifnet *));",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_INIT\t0x08\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nwi_start\t\t__P((struct ifnet *));\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_watchdog\t\t__P((struct ifnet *));\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct wi_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\tstruct wi_ltv_macaddr\tmac;\n\tint\t\t\tid = 0;\n\n\tif (sc->wi_gone)\n\t\treturn;\n\n\tDPRINTF(WID_INIT, (\"wi_init: sc %p\\n\", sc));\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\twi_stop(sc);\n\n\twi_reset(sc);\n\n\t/* Program max data length. */\n\tWI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);\n\n\t/* Enable/disable IBSS creation. */\n\tWI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);\n\n\t/* Set the port type. */\n\tWI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);\n\n\t/* Program the RTS/CTS threshold. */\n\tWI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);\n\n\t/* Program the TX rate */\n\tWI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);\n\n\t/* Access point density */\n\tWI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);\n\n\t/* Power Management Enabled */\n\tWI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);\n\n\t/* Power Managment Max Sleep */\n\tWI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);\n\n\t/* Specify the IBSS name */\n\tWI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);\n\n\t/* Specify the network name */\n\tWI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);\n\n\t/* Specify the frequency to use */\n\tWI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);\n\n\t/* Program the nodename. */\n\tWI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);\n\n\t/* Set our MAC address. */\n\tmac.wi_len = 4;\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);\n\twi_write_record(sc, (struct wi_ltv_gen *)&mac);\n\n\t/* Configure WEP. */\n\tif (sc->wi_has_wep) {\n\t\tWI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);\n\t\tWI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);\n\t\tsc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;\n\t\tsc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;\n\t\twi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);\n\t}\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tWI_SETVAL(WI_RID_PROMISC, 1);\n\t} else {\n\t\tWI_SETVAL(WI_RID_PROMISC, 0);\n\t}\n\n\t/* Set multicast filter. */\n\twi_setmulti(sc);\n\n\t/* Enable desired port */\n\twi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": tx buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_data_id = id;\n\n\tif (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))\n\t\tprintf(WI_PRT_FMT \": mgmt. buffer allocation failed\\n\",\n\t\t    WI_PRT_ARG(sc));\n\tsc->wi_tx_mgmt_id = id;\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "pa->pf",
            "IPL_NET",
            "wi_intr",
            "sc"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "wi_shutdown",
            "sc"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPFATTACH",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->wi_stats",
            "sizeof(sc->wi_stats)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_read_record",
          "args": [
            "sc",
            "&gen"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "wi_read_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "701-737",
          "snippet": "STATIC int wi_read_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len, code;\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))\n\t\treturn(EIO);\n\n\t/* Seek to the record. */\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, WI_DATA1);\n\tif (len > ltv->wi_len)\n\t\treturn(ENOSPC);\n\tcode = CSR_READ_2(sc, WI_DATA1);\n\tif (code != ltv->wi_type)\n\t\treturn(EIO);\n\n\tltv->wi_len = len;\n\tltv->wi_type = code;\n\n\t/* Now read the data. */\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "wi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "wi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int wi_read_record(sc, ltv)\n\tstruct wi_softc\t\t*sc;\n\tstruct wi_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len, code;\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))\n\t\treturn(EIO);\n\n\t/* Seek to the record. */\n\tif (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))\n\t\treturn(EIO);\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, WI_DATA1);\n\tif (len > ltv->wi_len)\n\t\treturn(ENOSPC);\n\tcode = CSR_READ_2(sc, WI_DATA1);\n\tif (code != ltv->wi_type)\n\t\treturn(EIO);\n\n\tltv->wi_len = len;\n\tltv->wi_type = code;\n\n\t/* Now read the data. */\n\tptr = &ltv->wi_val;\n\tfor (i = 0; i < ltv->wi_len - 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, WI_DATA1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "WI_DEFAULT_IBSS",
            "sc->wi_ibss_name",
            "sizeof(WI_DEFAULT_IBSS) - 1"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->wi_ibss_name",
            "sizeof(sc->wi_ibss_name)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->wi_net_name",
            "sizeof(sc->wi_net_name)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->wi_node_name",
            "sizeof(sc->wi_node_name)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_reset",
          "args": [
            "sc"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "wi_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
          "lines": "682-696",
          "snippet": "STATIC void wi_reset(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tDPRINTF(WID_RESET, (\"wi_reset: sc %p\\n\", sc));\n\n\tif (wi_cmd(sc, WI_CMD_INI, 0))\n\t\tprintf(WI_PRT_FMT \": init failed\\n\", WI_PRT_ARG(sc));\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\t/* Calibrate timer. */\n\tWI_SETVAL(WI_RID_TICK_TIME, 8);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pcmcia/if_wavelan_ieee.h>",
            "#include <dev/pcmcia/if_wireg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <i386/isa/icu.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define WID_RESET\t0x20",
            "#define WI_PRT_FMT \"%s\"",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC void",
            "wi_reset\t\t__P((struct wi_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_stop\t\t__P((struct wi_softc *));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "wi_rxeof\t\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_txeof\t\t__P((struct wi_softc *, int));",
            "STATIC void",
            "wi_update_stats\t__P((struct wi_softc *));",
            "STATIC void",
            "wi_setmulti\t\t__P((struct wi_softc *));",
            "STATIC int",
            "wi_cmd\t\t__P((struct wi_softc *, int, int));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "wi_seek\t\t__P((struct wi_softc *, int, int, int));",
            "STATIC int",
            "wi_alloc_nicmem\t__P((struct wi_softc *, int, int *));",
            "STATIC void",
            "STATIC void",
            "STATIC int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define WID_RESET\t0x20\n#define WI_PRT_FMT \"%s\"\n#define STATIC\n\nSTATIC void;\nwi_reset\t\t__P((struct wi_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_stop\t\t__P((struct wi_softc *));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nwi_rxeof\t\t__P((struct wi_softc *));\nSTATIC void;\nwi_txeof\t\t__P((struct wi_softc *, int));\nSTATIC void;\nwi_update_stats\t__P((struct wi_softc *));\nSTATIC void;\nwi_setmulti\t\t__P((struct wi_softc *));\nSTATIC int;\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nSTATIC int;\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC void wi_reset(sc)\n\tstruct wi_softc\t\t*sc;\n{\n\tDPRINTF(WID_RESET, (\"wi_reset: sc %p\\n\", sc));\n\n\tif (wi_cmd(sc, WI_CMD_INI, 0))\n\t\tprintf(WI_PRT_FMT \": init failed\\n\", WI_PRT_ARG(sc));\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\t/* Calibrate timer. */\n\tWI_SETVAL(WI_RID_TICK_TIME, 8);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_EVENT_ACK",
            "0xFFFF"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "WI_INT_EN",
            "0"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_io_map",
          "args": [
            "pf",
            "PCMCIA_WIDTH_IO16",
            "0",
            "WI_IOSIZ",
            "&sc->sc_pcioh",
            "&sc->sc_io_window"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "624-679",
          "snippet": "int\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_alloc",
          "args": [
            "pf",
            "0",
            "WI_IOSIZ",
            "WI_IOSIZ",
            "&sc->sc_pcioh"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1803-1863",
          "snippet": "STATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "STATIC void",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "STATIC int",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\nSTATIC void;\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\nSTATIC int;\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "pf"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_init",
          "args": [
            "pf",
            "cfe"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "392-402",
          "snippet": "void\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nwi_reset\t\t__P((struct wi_softc *));\nwi_start\t\t__P((struct ifnet *));\nwi_stop\t\t__P((struct wi_softc *));\nwi_watchdog\t\t__P((struct ifnet *));\nwi_rxeof\t\t__P((struct wi_softc *));\nwi_txeof\t\t__P((struct wi_softc *, int));\nwi_update_stats\t__P((struct wi_softc *));\nwi_setmulti\t\t__P((struct wi_softc *));\nwi_cmd\t\t__P((struct wi_softc *, int, int));\nwi_read_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nwi_write_record\t__P((struct wi_softc *, struct wi_ltv_gen *));\nwi_seek\t\t__P((struct wi_softc *, int, int, int));\nwi_alloc_nicmem\t__P((struct wi_softc *, int, int *));\nvoid\twi_pcmcia_attach;\nint\twi_intr;\n\nvoid\nwi_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wi_softc\t\t*sc = (struct wi_softc *)self;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_function\t*pf = pa->pf;\n\tstruct pcmcia_config_entry *cfe = pf->cfe_head.sqh_first;\n\tstruct wi_ltv_macaddr\tmac;\n\tstruct wi_ltv_gen\tgen;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tstate = 0;\n\n\tsc->sc_pf = pf;\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pf, cfe);\n\tif (pcmcia_function_enable(pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tif (pcmcia_io_alloc(pf, 0, WI_IOSIZ, WI_IOSIZ, &sc->sc_pcioh)) {\n\t\tprintf(\": can't alloc i/o space\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tif (pcmcia_io_map(pf, PCMCIA_WIDTH_IO16, 0, WI_IOSIZ, &sc->sc_pcioh,\n\t    &sc->sc_io_window)) {\n\t\tprintf(\": can't map io space\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tsc->wi_gone = 0;\n\tsc->wi_btag = sc->sc_pcioh.iot;\n\tsc->wi_bhandle = sc->sc_pcioh.ioh;\n\n\t/* Make sure interrupts are disabled. */\n\tCSR_WRITE_2(sc, WI_INT_EN, 0);\n\tCSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);\n\n\twi_reset(sc);\n\n\t/* Read the station address. */\n\tmac.wi_type = WI_RID_MAC_NODE;\n\tmac.wi_len = 4;\n\twi_read_record(sc, (struct wi_ltv_gen *)&mac);\n\tbcopy((char *)&mac.wi_mac_addr, (char *)&sc->arpcom.ac_enaddr,\n\t    ETHER_ADDR_LEN);\n\n\tprintf(\": address %s\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tifp = &sc->arpcom.ac_if;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = wi_ioctl;\n\tifp->if_start = wi_start;\n\tifp->if_watchdog = wi_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tbzero(sc->wi_node_name, sizeof(sc->wi_node_name));\n\tbcopy(WI_DEFAULT_NODENAME, sc->wi_node_name,\n\t    sizeof(WI_DEFAULT_NODENAME) - 1);\n\n\tbzero(sc->wi_net_name, sizeof(sc->wi_net_name));\n\tbcopy(WI_DEFAULT_NETNAME, sc->wi_net_name,\n\t    sizeof(WI_DEFAULT_NETNAME) - 1);\n\n\tbzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));\n\tbcopy(WI_DEFAULT_IBSS, sc->wi_ibss_name,\n\t    sizeof(WI_DEFAULT_IBSS) - 1);\n\n\tsc->wi_portnum = WI_DEFAULT_PORT;\n\tsc->wi_ptype = WI_PORTTYPE_ADHOC;\n\tsc->wi_ap_density = WI_DEFAULT_AP_DENSITY;\n\tsc->wi_rts_thresh = WI_DEFAULT_RTS_THRESH;\n\tsc->wi_tx_rate = WI_DEFAULT_TX_RATE;\n\tsc->wi_max_data_len = WI_DEFAULT_DATALEN;\n\tsc->wi_create_ibss = WI_DEFAULT_CREATE_IBSS;\n\tsc->wi_pm_enabled = WI_DEFAULT_PM_ENABLED;\n\tsc->wi_max_sleep = WI_DEFAULT_MAX_SLEEP;\n\n\t/*\n\t * Read the default channel from the NIC. This may vary\n\t * depending on the country where the NIC was purchased, so\n\t * we can't hard-code a default and expect it to work for\n\t * everyone.\n\t */\n\tgen.wi_type = WI_RID_OWN_CHNL;\n\tgen.wi_len = 2;\n\twi_read_record(sc, &gen);\n\tsc->wi_channel = gen.wi_val;\n\n\t/*\n\t * Find out if we support WEP on this card.\n\t */\n\tgen.wi_type = WI_RID_WEP_AVAIL;\n\tgen.wi_len = 2;\n\twi_read_record(sc, &gen);\n\tsc->wi_has_wep = gen.wi_val;\n\n\tbzero((char *)&sc->wi_stats, sizeof(sc->wi_stats));\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tBPFATTACH(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tshutdownhook_establish(wi_shutdown, sc);\n\n\t/* Establish the interrupt. */\n\tsc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto bad;\n\t}\n\tprintf(\"\\n\");\n\n\twi_init(sc);\n\twi_stop(sc);\n\treturn;\n\nbad:\n\tif (state > 2)\n\t\tpcmcia_io_unmap(pf, sc->sc_io_window);\n\tif (state > 1)\n\t\tpcmcia_io_free(pf, &sc->sc_pcioh);\n\tif (state > 0)\n\t\tpcmcia_function_disable(pf);\n}"
  },
  {
    "function_name": "wi_pcmcia_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_wi.c",
    "lines": "186-204",
    "snippet": "int\nwi_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\t\n\tif (pa->pf->function != PCMCIA_FUNCTION_NETWORK)\n\t\treturn (0);\n\n\tswitch (pa->manufacturer) {\n\tcase PCMCIA_VENDOR_LUCENT:\n\t\t/* XXX Per-productid checking here. */\n\t\treturn (1);\n\n\tdefault:\n\t\treturn (0);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_wavelan_ieee.h>",
      "#include <dev/pcmcia/if_wireg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <i386/isa/icu.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\twi_pcmcia_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pcmcia/if_wavelan_ieee.h>\n#include <dev/pcmcia/if_wireg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <i386/isa/icu.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\twi_pcmcia_match;\n\nint\nwi_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\t\n\tif (pa->pf->function != PCMCIA_FUNCTION_NETWORK)\n\t\treturn (0);\n\n\tswitch (pa->manufacturer) {\n\tcase PCMCIA_VENDOR_LUCENT:\n\t\t/* XXX Per-productid checking here. */\n\t\treturn (1);\n\n\tdefault:\n\t\treturn (0);\n\t}\n}"
  }
]