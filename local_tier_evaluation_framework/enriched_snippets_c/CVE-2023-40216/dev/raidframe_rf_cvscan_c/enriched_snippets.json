[
  {
    "function_name": "rf_CvscanPromote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "396-439",
    "snippet": "int \nrf_CvscanPromote(void *q_in, RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tRF_DiskQueueData_t *trailer = NULL, *tmp = hdr->burner, *tlist = NULL;\n\tint     retval = 0;\n\n\tDO_CHECK_STATE(hdr);\n\twhile (tmp) {\t\t/* handle entries at the front of the list */\n\t\tif (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {\n\t\t\thdr->burner = tmp->next;\n\t\t\ttmp->priority = RF_IO_NORMAL_PRIORITY;\n\t\t\ttmp->next = tlist;\n\t\t\ttlist = tmp;\n\t\t\ttmp = hdr->burner;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (tmp) {\n\t\ttrailer = tmp;\n\t\ttmp = tmp->next;\n\t}\n\twhile (tmp) {\t\t/* handle entries on the rest of the list */\n\t\tif (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {\n\t\t\ttrailer->next = tmp->next;\n\t\t\ttmp->priority = RF_IO_NORMAL_PRIORITY;\n\t\t\ttmp->next = tlist;\n\t\t\ttlist = tmp;\t/* insert on a temp queue */\n\t\t\ttmp = trailer->next;\n\t\t} else {\n\t\t\ttrailer = tmp;\n\t\t\ttmp = tmp->next;\n\t\t}\n\t}\n\twhile (tlist) {\n\t\tretval++;\n\t\ttmp = tlist->next;\n\t\tRealEnqueue(hdr, tlist);\n\t\ttlist = tmp;\n\t}\n\tRF_ASSERT(retval == 0 || retval == 1);\n\tDO_CHECK_STATE((RF_CvscanHeader_t *) q_in);\n\treturn (retval);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "(RF_CvscanHeader_t *) q_in"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "retval == 0 || retval == 1"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RealEnqueue",
          "args": [
            "hdr",
            "tlist"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "RealEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "165-201",
          "snippet": "static void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "hdr"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nint \nrf_CvscanPromote(void *q_in, RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tRF_DiskQueueData_t *trailer = NULL, *tmp = hdr->burner, *tlist = NULL;\n\tint     retval = 0;\n\n\tDO_CHECK_STATE(hdr);\n\twhile (tmp) {\t\t/* handle entries at the front of the list */\n\t\tif (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {\n\t\t\thdr->burner = tmp->next;\n\t\t\ttmp->priority = RF_IO_NORMAL_PRIORITY;\n\t\t\ttmp->next = tlist;\n\t\t\ttlist = tmp;\n\t\t\ttmp = hdr->burner;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (tmp) {\n\t\ttrailer = tmp;\n\t\ttmp = tmp->next;\n\t}\n\twhile (tmp) {\t\t/* handle entries on the rest of the list */\n\t\tif (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {\n\t\t\ttrailer->next = tmp->next;\n\t\t\ttmp->priority = RF_IO_NORMAL_PRIORITY;\n\t\t\ttmp->next = tlist;\n\t\t\ttlist = tmp;\t/* insert on a temp queue */\n\t\t\ttmp = trailer->next;\n\t\t} else {\n\t\t\ttrailer = tmp;\n\t\t\ttmp = tmp->next;\n\t\t}\n\t}\n\twhile (tlist) {\n\t\tretval++;\n\t\ttmp = tlist->next;\n\t\tRealEnqueue(hdr, tlist);\n\t\ttlist = tmp;\n\t}\n\tRF_ASSERT(retval == 0 || retval == 1);\n\tDO_CHECK_STATE((RF_CvscanHeader_t *) q_in);\n\treturn (retval);\n}"
  },
  {
    "function_name": "PrintCvscanQueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "356-387",
    "snippet": "static void \nPrintCvscanQueue(RF_CvscanHeader_t * hdr)\n{\n\tRF_DiskQueueData_t *tmp;\n\n\tprintf(\"CVSCAN(%d,%d) at %d going %s\\n\",\n\t    (int) hdr->range_for_avg,\n\t    (int) hdr->change_penalty,\n\t    (int) hdr->cur_block,\n\t    (hdr->direction == rf_cvscan_LEFT) ? \"LEFT\" : \"RIGHT\");\n\tprintf(\"\\tLeft(%d): \", hdr->left_cnt);\n\tfor (tmp = hdr->left; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)\n\t\tprintf(\"(%d,%ld,%d) \",\n\t\t    (int) tmp->sectorOffset,\n\t\t    (long) (tmp->sectorOffset + tmp->numSector),\n\t\t    tmp->priority);\n\tprintf(\"\\n\");\n\tprintf(\"\\tRight(%d): \", hdr->right_cnt);\n\tfor (tmp = hdr->right; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)\n\t\tprintf(\"(%d,%ld,%d) \",\n\t\t    (int) tmp->sectorOffset,\n\t\t    (long) (tmp->sectorOffset + tmp->numSector),\n\t\t    tmp->priority);\n\tprintf(\"\\n\");\n\tprintf(\"\\tBurner: \");\n\tfor (tmp = hdr->burner; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)\n\t\tprintf(\"(%d,%ld,%d) \",\n\t\t    (int) tmp->sectorOffset,\n\t\t    (long) (tmp->sectorOffset + tmp->numSector),\n\t\t    tmp->priority);\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nPrintCvscanQueue(RF_CvscanHeader_t * hdr)\n{\n\tRF_DiskQueueData_t *tmp;\n\n\tprintf(\"CVSCAN(%d,%d) at %d going %s\\n\",\n\t    (int) hdr->range_for_avg,\n\t    (int) hdr->change_penalty,\n\t    (int) hdr->cur_block,\n\t    (hdr->direction == rf_cvscan_LEFT) ? \"LEFT\" : \"RIGHT\");\n\tprintf(\"\\tLeft(%d): \", hdr->left_cnt);\n\tfor (tmp = hdr->left; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)\n\t\tprintf(\"(%d,%ld,%d) \",\n\t\t    (int) tmp->sectorOffset,\n\t\t    (long) (tmp->sectorOffset + tmp->numSector),\n\t\t    tmp->priority);\n\tprintf(\"\\n\");\n\tprintf(\"\\tRight(%d): \", hdr->right_cnt);\n\tfor (tmp = hdr->right; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)\n\t\tprintf(\"(%d,%ld,%d) \",\n\t\t    (int) tmp->sectorOffset,\n\t\t    (long) (tmp->sectorOffset + tmp->numSector),\n\t\t    tmp->priority);\n\tprintf(\"\\n\");\n\tprintf(\"\\tBurner: \");\n\tfor (tmp = hdr->burner; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)\n\t\tprintf(\"(%d,%ld,%d) \",\n\t\t    (int) tmp->sectorOffset,\n\t\t    (long) (tmp->sectorOffset + tmp->numSector),\n\t\t    tmp->priority);\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "rf_CvscanCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "329-350",
    "snippet": "void   *\nrf_CvscanCreate(RF_SectorCount_t sectPerDisk,\n    RF_AllocListElem_t * clList,\n    RF_ShutdownList_t ** listp)\n{\n\tRF_CvscanHeader_t *hdr;\n\tlong    range = 2;\t/* Currently no mechanism to change these */\n\tlong    penalty = sectPerDisk / 5;\n\n\tRF_MallocAndAdd(hdr, sizeof(RF_CvscanHeader_t), (RF_CvscanHeader_t *), clList);\n\tbzero((char *) hdr, sizeof(RF_CvscanHeader_t));\n\thdr->range_for_avg = RF_MAX(range, 1);\n\thdr->change_penalty = RF_MAX(penalty, 0);\n\thdr->direction = rf_cvscan_RIGHT;\n\thdr->cur_block = 0;\n\thdr->left_cnt = hdr->right_cnt = 0;\n\thdr->left = hdr->right = (RF_DiskQueueData_t *) NULL;\n\thdr->burner = (RF_DiskQueueData_t *) NULL;\n\tDO_CHECK_STATE(hdr);\n\n\treturn ((void *) hdr);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "hdr"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "penalty",
            "0"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "range",
            "1"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) hdr",
            "sizeof(RF_CvscanHeader_t)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "hdr",
            "sizeof(RF_CvscanHeader_t)",
            "(RF_CvscanHeader_t *), clList"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nvoid   *\nrf_CvscanCreate(RF_SectorCount_t sectPerDisk,\n    RF_AllocListElem_t * clList,\n    RF_ShutdownList_t ** listp)\n{\n\tRF_CvscanHeader_t *hdr;\n\tlong    range = 2;\t/* Currently no mechanism to change these */\n\tlong    penalty = sectPerDisk / 5;\n\n\tRF_MallocAndAdd(hdr, sizeof(RF_CvscanHeader_t), (RF_CvscanHeader_t *), clList);\n\tbzero((char *) hdr, sizeof(RF_CvscanHeader_t));\n\thdr->range_for_avg = RF_MAX(range, 1);\n\thdr->change_penalty = RF_MAX(penalty, 0);\n\thdr->direction = rf_cvscan_RIGHT;\n\thdr->cur_block = 0;\n\thdr->left_cnt = hdr->right_cnt = 0;\n\thdr->left = hdr->right = (RF_DiskQueueData_t *) NULL;\n\thdr->burner = (RF_DiskQueueData_t *) NULL;\n\tDO_CHECK_STATE(hdr);\n\n\treturn ((void *) hdr);\n}"
  },
  {
    "function_name": "rf_CvscanConfigure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "321-325",
    "snippet": "int \nrf_CvscanConfigure()\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nint \nrf_CvscanConfigure()\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_CvscanPeek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "277-309",
    "snippet": "RF_DiskQueueData_t *\nrf_CvscanPeek(void *q_in)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tlong    range, i, sum_dist_left, sum_dist_right;\n\tRF_DiskQueueData_t *tmp, *headElement;\n\n\tDO_CHECK_STATE(hdr);\n\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0)\n\t\theadElement = NULL;\n\telse {\n\t\trange = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt, hdr->right_cnt));\n\t\tfor (i = 0, tmp = hdr->left, sum_dist_left =\n\t\t    ((hdr->direction == rf_cvscan_RIGHT) ? range * hdr->change_penalty : 0);\n\t\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t\t    tmp = tmp->next, i++) {\n\t\t\tsum_dist_left += hdr->cur_block - tmp->sectorOffset;\n\t\t}\n\t\tfor (i = 0, tmp = hdr->right, sum_dist_right =\n\t\t    ((hdr->direction == rf_cvscan_LEFT) ? range * hdr->change_penalty : 0);\n\t\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t\t    tmp = tmp->next, i++) {\n\t\t\tsum_dist_right += tmp->sectorOffset - hdr->cur_block;\n\t\t}\n\n\t\tif (hdr->right_cnt == 0 || sum_dist_left < sum_dist_right)\n\t\t\theadElement = hdr->left;\n\t\telse\n\t\t\theadElement = hdr->right;\n\t}\n\treturn (headElement);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "hdr->range_for_avg",
            "RF_MIN(hdr->left_cnt, hdr->right_cnt)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "hdr->left_cnt",
            "hdr->right_cnt"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "hdr"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nRF_DiskQueueData_t *\nrf_CvscanPeek(void *q_in)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tlong    range, i, sum_dist_left, sum_dist_right;\n\tRF_DiskQueueData_t *tmp, *headElement;\n\n\tDO_CHECK_STATE(hdr);\n\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0)\n\t\theadElement = NULL;\n\telse {\n\t\trange = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt, hdr->right_cnt));\n\t\tfor (i = 0, tmp = hdr->left, sum_dist_left =\n\t\t    ((hdr->direction == rf_cvscan_RIGHT) ? range * hdr->change_penalty : 0);\n\t\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t\t    tmp = tmp->next, i++) {\n\t\t\tsum_dist_left += hdr->cur_block - tmp->sectorOffset;\n\t\t}\n\t\tfor (i = 0, tmp = hdr->right, sum_dist_right =\n\t\t    ((hdr->direction == rf_cvscan_LEFT) ? range * hdr->change_penalty : 0);\n\t\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t\t    tmp = tmp->next, i++) {\n\t\t\tsum_dist_right += tmp->sectorOffset - hdr->cur_block;\n\t\t}\n\n\t\tif (hdr->right_cnt == 0 || sum_dist_left < sum_dist_right)\n\t\t\theadElement = hdr->left;\n\t\telse\n\t\t\theadElement = hdr->right;\n\t}\n\treturn (headElement);\n}"
  },
  {
    "function_name": "rf_CvscanDequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "214-273",
    "snippet": "RF_DiskQueueData_t *\nrf_CvscanDequeue(void *q_in)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tlong    range, i, sum_dist_left, sum_dist_right;\n\tRF_DiskQueueData_t *ret;\n\tRF_DiskQueueData_t *tmp;\n\n\tDO_CHECK_STATE(hdr);\n\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0)\n\t\treturn ((RF_DiskQueueData_t *) NULL);\n\n\trange = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt, hdr->right_cnt));\n\tfor (i = 0, tmp = hdr->left, sum_dist_left =\n\t    ((hdr->direction == rf_cvscan_RIGHT) ? range * hdr->change_penalty : 0);\n\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t    tmp = tmp->next, i++) {\n\t\tsum_dist_left += hdr->cur_block - tmp->sectorOffset;\n\t}\n\tfor (i = 0, tmp = hdr->right, sum_dist_right =\n\t    ((hdr->direction == rf_cvscan_LEFT) ? range * hdr->change_penalty : 0);\n\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t    tmp = tmp->next, i++) {\n\t\tsum_dist_right += tmp->sectorOffset - hdr->cur_block;\n\t}\n\n\tif (hdr->right_cnt == 0 || sum_dist_left < sum_dist_right) {\n\t\thdr->direction = rf_cvscan_LEFT;\n\t\thdr->cur_block = hdr->left->sectorOffset + hdr->left->numSector;\n\t\thdr->left_cnt = RF_MAX(hdr->left_cnt - 1, 0);\n\t\ttmp = hdr->left;\n\t\tret = (ReqDequeue(&hdr->left)) /*->parent*/ ;\n\t} else {\n\t\thdr->direction = rf_cvscan_RIGHT;\n\t\thdr->cur_block = hdr->right->sectorOffset + hdr->right->numSector;\n\t\thdr->right_cnt = RF_MAX(hdr->right_cnt - 1, 0);\n\t\ttmp = hdr->right;\n\t\tret = (ReqDequeue(&hdr->right)) /*->parent*/ ;\n\t}\n\tReBalance(hdr);\n\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0\n\t    && hdr->burner != (RF_DiskQueueData_t *) NULL) {\n\t\t/*\n\t\t** restore low priority requests for next dequeue\n\t\t*/\n\t\tRF_DiskQueueData_t *burner = hdr->burner;\n\t\thdr->nxt_priority = burner->priority;\n\t\twhile (burner != (RF_DiskQueueData_t *) NULL\n\t\t    && burner->priority == hdr->nxt_priority) {\n\t\t\tRF_DiskQueueData_t *next = burner->next;\n\t\t\tRealEnqueue(hdr, burner);\n\t\t\tburner = next;\n\t\t}\n\t\thdr->burner = burner;\n\t}\n\tDO_CHECK_STATE(hdr);\n\treturn (ret);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "hdr"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RealEnqueue",
          "args": [
            "hdr",
            "burner"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "RealEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "165-201",
          "snippet": "static void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReBalance",
          "args": [
            "hdr"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ReBalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "136-147",
          "snippet": "static void \nReBalance(RF_CvscanHeader_t * hdr)\n{\n\t/* DO_CHECK_STATE(hdr); */\n\twhile (hdr->right != (RF_DiskQueueData_t *) NULL\n\t    && hdr->right->sectorOffset < hdr->cur_block) {\n\t\thdr->right_cnt--;\n\t\thdr->left_cnt++;\n\t\tReqInsert(&hdr->left, ReqDequeue(&hdr->right), rf_cvscan_LEFT);\n\t}\n\t/* DO_CHECK_STATE(hdr); */\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nReBalance(RF_CvscanHeader_t * hdr)\n{\n\t/* DO_CHECK_STATE(hdr); */\n\twhile (hdr->right != (RF_DiskQueueData_t *) NULL\n\t    && hdr->right->sectorOffset < hdr->cur_block) {\n\t\thdr->right_cnt--;\n\t\thdr->left_cnt++;\n\t\tReqInsert(&hdr->left, ReqDequeue(&hdr->right), rf_cvscan_LEFT);\n\t}\n\t/* DO_CHECK_STATE(hdr); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReqDequeue",
          "args": [
            "&hdr->right"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ReqDequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "124-132",
          "snippet": "static RF_DiskQueueData_t *\nReqDequeue(RF_DiskQueueData_t ** list_ptr)\n{\n\tRF_DiskQueueData_t *ret = (*list_ptr);\n\tif ((*list_ptr) != (RF_DiskQueueData_t *) NULL) {\n\t\t(*list_ptr) = (*list_ptr)->next;\n\t}\n\treturn (ret);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic RF_DiskQueueData_t *\nReqDequeue(RF_DiskQueueData_t ** list_ptr)\n{\n\tRF_DiskQueueData_t *ret = (*list_ptr);\n\tif ((*list_ptr) != (RF_DiskQueueData_t *) NULL) {\n\t\t(*list_ptr) = (*list_ptr)->next;\n\t}\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "hdr->right_cnt - 1",
            "0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "hdr->left_cnt - 1",
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "hdr->range_for_avg",
            "RF_MIN(hdr->left_cnt, hdr->right_cnt)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "hdr->left_cnt",
            "hdr->right_cnt"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "hdr"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nRF_DiskQueueData_t *\nrf_CvscanDequeue(void *q_in)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tlong    range, i, sum_dist_left, sum_dist_right;\n\tRF_DiskQueueData_t *ret;\n\tRF_DiskQueueData_t *tmp;\n\n\tDO_CHECK_STATE(hdr);\n\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0)\n\t\treturn ((RF_DiskQueueData_t *) NULL);\n\n\trange = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt, hdr->right_cnt));\n\tfor (i = 0, tmp = hdr->left, sum_dist_left =\n\t    ((hdr->direction == rf_cvscan_RIGHT) ? range * hdr->change_penalty : 0);\n\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t    tmp = tmp->next, i++) {\n\t\tsum_dist_left += hdr->cur_block - tmp->sectorOffset;\n\t}\n\tfor (i = 0, tmp = hdr->right, sum_dist_right =\n\t    ((hdr->direction == rf_cvscan_LEFT) ? range * hdr->change_penalty : 0);\n\t    tmp != (RF_DiskQueueData_t *) NULL && i < range;\n\t    tmp = tmp->next, i++) {\n\t\tsum_dist_right += tmp->sectorOffset - hdr->cur_block;\n\t}\n\n\tif (hdr->right_cnt == 0 || sum_dist_left < sum_dist_right) {\n\t\thdr->direction = rf_cvscan_LEFT;\n\t\thdr->cur_block = hdr->left->sectorOffset + hdr->left->numSector;\n\t\thdr->left_cnt = RF_MAX(hdr->left_cnt - 1, 0);\n\t\ttmp = hdr->left;\n\t\tret = (ReqDequeue(&hdr->left)) /*->parent*/ ;\n\t} else {\n\t\thdr->direction = rf_cvscan_RIGHT;\n\t\thdr->cur_block = hdr->right->sectorOffset + hdr->right->numSector;\n\t\thdr->right_cnt = RF_MAX(hdr->right_cnt - 1, 0);\n\t\ttmp = hdr->right;\n\t\tret = (ReqDequeue(&hdr->right)) /*->parent*/ ;\n\t}\n\tReBalance(hdr);\n\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0\n\t    && hdr->burner != (RF_DiskQueueData_t *) NULL) {\n\t\t/*\n\t\t** restore low priority requests for next dequeue\n\t\t*/\n\t\tRF_DiskQueueData_t *burner = hdr->burner;\n\t\thdr->nxt_priority = burner->priority;\n\t\twhile (burner != (RF_DiskQueueData_t *) NULL\n\t\t    && burner->priority == hdr->nxt_priority) {\n\t\t\tRF_DiskQueueData_t *next = burner->next;\n\t\t\tRealEnqueue(hdr, burner);\n\t\t\tburner = next;\n\t\t}\n\t\thdr->burner = burner;\n\t}\n\tDO_CHECK_STATE(hdr);\n\treturn (ret);\n}"
  },
  {
    "function_name": "rf_CvscanEnqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "205-210",
    "snippet": "void \nrf_CvscanEnqueue(void *q_in, RF_DiskQueueData_t * elem, int priority)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tRealEnqueue(hdr, elem /* req */ );\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RealEnqueue",
          "args": [
            "hdr",
            "elem/* req */"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "RealEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "165-201",
          "snippet": "static void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_CvscanEnqueue(void *q_in, RF_DiskQueueData_t * elem, int priority)\n{\n\tRF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;\n\tRealEnqueue(hdr, elem /* req */ );\n}"
  },
  {
    "function_name": "RealEnqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "165-201",
    "snippet": "static void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "hdr"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReqInsert",
          "args": [
            "&hdr->right",
            "req",
            "rf_cvscan_RIGHT"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ReqInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "105-120",
          "snippet": "static void \nReqInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req, RF_CvscanArmDir_t order)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\n\t    ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)\n\t\t|| (order == rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset));\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nReqInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req, RF_CvscanArmDir_t order)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\n\t    ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)\n\t\t|| (order == rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset));\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PriorityInsert",
          "args": [
            "&hdr->burner",
            "req"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "PriorityInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "88-101",
          "snippet": "static void \nPriorityInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\t    (*list_ptr)->priority > req->priority;\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nPriorityInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\t    (*list_ptr)->priority > req->priority;\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Transfer",
          "args": [
            "&hdr->burner",
            "&hdr->right"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "Transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "151-161",
          "snippet": "static void \nTransfer(RF_DiskQueueData_t ** to_list_ptr, RF_DiskQueueData_t ** from_list_ptr)\n{\n\tRF_DiskQueueData_t *gp;\n\tfor (gp = (*from_list_ptr); gp != (RF_DiskQueueData_t *) NULL;) {\n\t\tRF_DiskQueueData_t *p = gp->next;\n\t\tPriorityInsert(to_list_ptr, gp);\n\t\tgp = p;\n\t}\n\t(*from_list_ptr) = (RF_DiskQueueData_t *) NULL;\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nTransfer(RF_DiskQueueData_t ** to_list_ptr, RF_DiskQueueData_t ** from_list_ptr)\n{\n\tRF_DiskQueueData_t *gp;\n\tfor (gp = (*from_list_ptr); gp != (RF_DiskQueueData_t *) NULL;) {\n\t\tRF_DiskQueueData_t *p = gp->next;\n\t\tPriorityInsert(to_list_ptr, gp);\n\t\tgp = p;\n\t}\n\t(*from_list_ptr) = (RF_DiskQueueData_t *) NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_CHECK_STATE",
          "args": [
            "hdr"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)\n{\n\tRF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);\n\n\tDO_CHECK_STATE(hdr);\n\tif (hdr->left_cnt == 0 && hdr->right_cnt == 0) {\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority > hdr->nxt_priority) {\n\t\t/*\n\t\t** dump all other outstanding requests on the back burner\n\t\t*/\n\t\tTransfer(&hdr->burner, &hdr->left);\n\t\tTransfer(&hdr->burner, &hdr->right);\n\t\thdr->left_cnt = 0;\n\t\thdr->right_cnt = 0;\n\t\thdr->nxt_priority = req->priority;\n\t}\n\tif (req->priority < hdr->nxt_priority) {\n\t\t/*\n\t\t** yet another low priority task!\n\t\t*/\n\t\tPriorityInsert(&hdr->burner, req);\n\t} else {\n\t\tif (req->sectorOffset < hdr->cur_block) {\n\t\t\t/* this request is to the left of the current arms */\n\t\t\tReqInsert(&hdr->left, req, rf_cvscan_LEFT);\n\t\t\thdr->left_cnt++;\n\t\t} else {\n\t\t\t/* this request is to the right of the current arms */\n\t\t\tReqInsert(&hdr->right, req, rf_cvscan_RIGHT);\n\t\t\thdr->right_cnt++;\n\t\t}\n\t}\n\tDO_CHECK_STATE(hdr);\n}"
  },
  {
    "function_name": "Transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "151-161",
    "snippet": "static void \nTransfer(RF_DiskQueueData_t ** to_list_ptr, RF_DiskQueueData_t ** from_list_ptr)\n{\n\tRF_DiskQueueData_t *gp;\n\tfor (gp = (*from_list_ptr); gp != (RF_DiskQueueData_t *) NULL;) {\n\t\tRF_DiskQueueData_t *p = gp->next;\n\t\tPriorityInsert(to_list_ptr, gp);\n\t\tgp = p;\n\t}\n\t(*from_list_ptr) = (RF_DiskQueueData_t *) NULL;\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PriorityInsert",
          "args": [
            "to_list_ptr",
            "gp"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "PriorityInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "88-101",
          "snippet": "static void \nPriorityInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\t    (*list_ptr)->priority > req->priority;\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nPriorityInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\t    (*list_ptr)->priority > req->priority;\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nTransfer(RF_DiskQueueData_t ** to_list_ptr, RF_DiskQueueData_t ** from_list_ptr)\n{\n\tRF_DiskQueueData_t *gp;\n\tfor (gp = (*from_list_ptr); gp != (RF_DiskQueueData_t *) NULL;) {\n\t\tRF_DiskQueueData_t *p = gp->next;\n\t\tPriorityInsert(to_list_ptr, gp);\n\t\tgp = p;\n\t}\n\t(*from_list_ptr) = (RF_DiskQueueData_t *) NULL;\n}"
  },
  {
    "function_name": "ReBalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "136-147",
    "snippet": "static void \nReBalance(RF_CvscanHeader_t * hdr)\n{\n\t/* DO_CHECK_STATE(hdr); */\n\twhile (hdr->right != (RF_DiskQueueData_t *) NULL\n\t    && hdr->right->sectorOffset < hdr->cur_block) {\n\t\thdr->right_cnt--;\n\t\thdr->left_cnt++;\n\t\tReqInsert(&hdr->left, ReqDequeue(&hdr->right), rf_cvscan_LEFT);\n\t}\n\t/* DO_CHECK_STATE(hdr); */\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReqInsert",
          "args": [
            "&hdr->left",
            "ReqDequeue(&hdr->right)",
            "rf_cvscan_LEFT"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ReqInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "105-120",
          "snippet": "static void \nReqInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req, RF_CvscanArmDir_t order)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\n\t    ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)\n\t\t|| (order == rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset));\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nReqInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req, RF_CvscanArmDir_t order)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\n\t    ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)\n\t\t|| (order == rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset));\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReqDequeue",
          "args": [
            "&hdr->right"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ReqDequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
          "lines": "124-132",
          "snippet": "static RF_DiskQueueData_t *\nReqDequeue(RF_DiskQueueData_t ** list_ptr)\n{\n\tRF_DiskQueueData_t *ret = (*list_ptr);\n\tif ((*list_ptr) != (RF_DiskQueueData_t *) NULL) {\n\t\t(*list_ptr) = (*list_ptr)->next;\n\t}\n\treturn (ret);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic RF_DiskQueueData_t *\nReqDequeue(RF_DiskQueueData_t ** list_ptr)\n{\n\tRF_DiskQueueData_t *ret = (*list_ptr);\n\tif ((*list_ptr) != (RF_DiskQueueData_t *) NULL) {\n\t\t(*list_ptr) = (*list_ptr)->next;\n\t}\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nReBalance(RF_CvscanHeader_t * hdr)\n{\n\t/* DO_CHECK_STATE(hdr); */\n\twhile (hdr->right != (RF_DiskQueueData_t *) NULL\n\t    && hdr->right->sectorOffset < hdr->cur_block) {\n\t\thdr->right_cnt--;\n\t\thdr->left_cnt++;\n\t\tReqInsert(&hdr->left, ReqDequeue(&hdr->right), rf_cvscan_LEFT);\n\t}\n\t/* DO_CHECK_STATE(hdr); */\n}"
  },
  {
    "function_name": "ReqDequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "124-132",
    "snippet": "static RF_DiskQueueData_t *\nReqDequeue(RF_DiskQueueData_t ** list_ptr)\n{\n\tRF_DiskQueueData_t *ret = (*list_ptr);\n\tif ((*list_ptr) != (RF_DiskQueueData_t *) NULL) {\n\t\t(*list_ptr) = (*list_ptr)->next;\n\t}\n\treturn (ret);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic RF_DiskQueueData_t *\nReqDequeue(RF_DiskQueueData_t ** list_ptr)\n{\n\tRF_DiskQueueData_t *ret = (*list_ptr);\n\tif ((*list_ptr) != (RF_DiskQueueData_t *) NULL) {\n\t\t(*list_ptr) = (*list_ptr)->next;\n\t}\n\treturn (ret);\n}"
  },
  {
    "function_name": "ReqInsert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "105-120",
    "snippet": "static void \nReqInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req, RF_CvscanArmDir_t order)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\n\t    ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)\n\t\t|| (order == rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset));\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nReqInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req, RF_CvscanArmDir_t order)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\n\t    ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)\n\t\t|| (order == rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset));\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}"
  },
  {
    "function_name": "PriorityInsert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "88-101",
    "snippet": "static void \nPriorityInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\t    (*list_ptr)->priority > req->priority;\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nPriorityInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req)\n{\n\t/* * insert block pointed to by req in to list whose first * entry is\n\t * pointed to by the pointer that list_ptr points to * ie., list_ptr\n\t * is a grandparent of the first entry */\n\n\tfor (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&\n\t    (*list_ptr)->priority > req->priority;\n\t    list_ptr = &((*list_ptr)->next)) {\n\t}\n\treq->next = (*list_ptr);\n\t(*list_ptr) = req;\n}"
  },
  {
    "function_name": "CheckCvscanState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_cvscan.c",
    "lines": "51-84",
    "snippet": "static void \nCheckCvscanState(RF_CvscanHeader_t * hdr, char *file, int line)\n{\n\tlong    i, key;\n\tRF_DiskQueueData_t *tmp;\n\n\tif (hdr->left != (RF_DiskQueueData_t *) NULL)\n\t\tRF_ASSERT(hdr->left->sectorOffset < hdr->cur_block);\n\tfor (key = hdr->cur_block, i = 0, tmp = hdr->left;\n\t    tmp != (RF_DiskQueueData_t *) NULL;\n\t    key = tmp->sectorOffset, i++, tmp = tmp->next)\n\t\tRF_ASSERT(tmp->sectorOffset <= key\n\t\t    && tmp->priority == hdr->nxt_priority && pri_ok(tmp->priority));\n\tRF_ASSERT(i == hdr->left_cnt);\n\n\tfor (key = hdr->cur_block, i = 0, tmp = hdr->right;\n\t    tmp != (RF_DiskQueueData_t *) NULL;\n\t    key = tmp->sectorOffset, i++, tmp = tmp->next) {\n\t\tRF_ASSERT(key <= tmp->sectorOffset);\n\t\tRF_ASSERT(tmp->priority == hdr->nxt_priority);\n\t\tRF_ASSERT(pri_ok(tmp->priority));\n\t}\n\tRF_ASSERT(i == hdr->right_cnt);\n\n\tfor (key = hdr->nxt_priority - 1, tmp = hdr->burner;\n\t    tmp != (RF_DiskQueueData_t *) NULL;\n\t    key = tmp->priority, tmp = tmp->next) {\n\t\tRF_ASSERT(tmp);\n\t\tRF_ASSERT(hdr);\n\t\tRF_ASSERT(pri_ok(tmp->priority));\n\t\tRF_ASSERT(key >= tmp->priority);\n\t\tRF_ASSERT(tmp->priority < hdr->nxt_priority);\n\t}\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_cvscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "tmp->priority < hdr->nxt_priority"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "key >= tmp->priority"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pri_ok(tmp->priority)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pri_ok",
          "args": [
            "tmp->priority"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "hdr"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "tmp"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == hdr->right_cnt"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pri_ok(tmp->priority)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pri_ok",
          "args": [
            "tmp->priority"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "tmp->priority == hdr->nxt_priority"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "key <= tmp->sectorOffset"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == hdr->left_cnt"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "tmp->sectorOffset <= key\n\t\t    && tmp->priority == hdr->nxt_priority && pri_ok(tmp->priority)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pri_ok",
          "args": [
            "tmp->priority"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "hdr->left->sectorOffset < hdr->cur_block"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_types.h\"\n\nstatic void \nCheckCvscanState(RF_CvscanHeader_t * hdr, char *file, int line)\n{\n\tlong    i, key;\n\tRF_DiskQueueData_t *tmp;\n\n\tif (hdr->left != (RF_DiskQueueData_t *) NULL)\n\t\tRF_ASSERT(hdr->left->sectorOffset < hdr->cur_block);\n\tfor (key = hdr->cur_block, i = 0, tmp = hdr->left;\n\t    tmp != (RF_DiskQueueData_t *) NULL;\n\t    key = tmp->sectorOffset, i++, tmp = tmp->next)\n\t\tRF_ASSERT(tmp->sectorOffset <= key\n\t\t    && tmp->priority == hdr->nxt_priority && pri_ok(tmp->priority));\n\tRF_ASSERT(i == hdr->left_cnt);\n\n\tfor (key = hdr->cur_block, i = 0, tmp = hdr->right;\n\t    tmp != (RF_DiskQueueData_t *) NULL;\n\t    key = tmp->sectorOffset, i++, tmp = tmp->next) {\n\t\tRF_ASSERT(key <= tmp->sectorOffset);\n\t\tRF_ASSERT(tmp->priority == hdr->nxt_priority);\n\t\tRF_ASSERT(pri_ok(tmp->priority));\n\t}\n\tRF_ASSERT(i == hdr->right_cnt);\n\n\tfor (key = hdr->nxt_priority - 1, tmp = hdr->burner;\n\t    tmp != (RF_DiskQueueData_t *) NULL;\n\t    key = tmp->priority, tmp = tmp->next) {\n\t\tRF_ASSERT(tmp);\n\t\tRF_ASSERT(hdr);\n\t\tRF_ASSERT(pri_ok(tmp->priority));\n\t\tRF_ASSERT(key >= tmp->priority);\n\t\tRF_ASSERT(tmp->priority < hdr->nxt_priority);\n\t}\n}"
  }
]