[
  {
    "function_name": "rd_server_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "603-654",
    "snippet": "static int\nrd_server_loop(sc)\n\tstruct rd_softc *sc;\n{\n\tstruct buf *bp;\n\tcaddr_t addr;\t/* user space address */\n\tsize_t  off;\t/* offset into \"device\" */\n\tsize_t  xfer;\t/* amount to transfer */\n\tint error;\n\n\tfor (;;) {\n\t\t/* Wait for some work to arrive. */\n\t\twhile (sc->sc_buflist == NULL) {\n\t\t\terror = tsleep((caddr_t)sc, rd_sleep_pri, \"rd_idle\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* Unlink buf from head of list. */\n\t\tbp = sc->sc_buflist;\n\t\tsc->sc_buflist = bp->b_actf;\n\t\tbp->b_actf = NULL;\n\n\t\t/* Do the transfer to/from user space. */\n\t\terror = 0;\n\t\tbp->b_resid = bp->b_bcount;\n\t\toff = (bp->b_blkno << DEV_BSHIFT);\n\t\tif (off >= sc->sc_size) {\n\t\t\tif (bp->b_flags & B_READ)\n\t\t\t\tgoto done;\t/* EOF (not an error) */\n\t\t\terror = EIO;\n\t\t\tgoto done;\n\t\t}\n\t\txfer = bp->b_resid;\n\t\tif (xfer > (sc->sc_size - off))\n\t\t\txfer = (sc->sc_size - off);\n\t\taddr = sc->sc_addr + off;\n\t\tif (bp->b_flags & B_READ)\n\t\t\terror = copyin(addr, bp->b_data, xfer);\n\t\telse\n\t\t\terror = copyout(bp->b_data, addr, xfer);\n\t\tif (!error)\n\t\t\tbp->b_resid -= xfer;\n\n\tdone:\n\t\tif (error) {\n\t\t\tbp->b_error = error;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t}\n\t\tbiodone(bp);\n\t}\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define sc_size sc_rd.rd_size",
      "#define sc_addr sc_rd.rd_addr"
    ],
    "globals_used": [
      "struct rd_softc *sc));",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "bp->b_data",
            "addr",
            "xfer"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "addr",
            "bp->b_data",
            "xfer"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)sc",
            "rd_sleep_pri",
            "\"rd_idle\"",
            "0"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_size sc_rd.rd_size\n#define sc_addr sc_rd.rd_addr\n\nstruct rd_softc *sc));\nstruct rd_softc *sc;\n\nstatic int\nrd_server_loop(sc)\n\tstruct rd_softc *sc;\n{\n\tstruct buf *bp;\n\tcaddr_t addr;\t/* user space address */\n\tsize_t  off;\t/* offset into \"device\" */\n\tsize_t  xfer;\t/* amount to transfer */\n\tint error;\n\n\tfor (;;) {\n\t\t/* Wait for some work to arrive. */\n\t\twhile (sc->sc_buflist == NULL) {\n\t\t\terror = tsleep((caddr_t)sc, rd_sleep_pri, \"rd_idle\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* Unlink buf from head of list. */\n\t\tbp = sc->sc_buflist;\n\t\tsc->sc_buflist = bp->b_actf;\n\t\tbp->b_actf = NULL;\n\n\t\t/* Do the transfer to/from user space. */\n\t\terror = 0;\n\t\tbp->b_resid = bp->b_bcount;\n\t\toff = (bp->b_blkno << DEV_BSHIFT);\n\t\tif (off >= sc->sc_size) {\n\t\t\tif (bp->b_flags & B_READ)\n\t\t\t\tgoto done;\t/* EOF (not an error) */\n\t\t\terror = EIO;\n\t\t\tgoto done;\n\t\t}\n\t\txfer = bp->b_resid;\n\t\tif (xfer > (sc->sc_size - off))\n\t\t\txfer = (sc->sc_size - off);\n\t\taddr = sc->sc_addr + off;\n\t\tif (bp->b_flags & B_READ)\n\t\t\terror = copyin(addr, bp->b_data, xfer);\n\t\telse\n\t\t\terror = copyout(bp->b_data, addr, xfer);\n\t\tif (!error)\n\t\t\tbp->b_resid -= xfer;\n\n\tdone:\n\t\tif (error) {\n\t\t\tbp->b_error = error;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t}\n\t\tbiodone(bp);\n\t}\n}"
  },
  {
    "function_name": "rd_ioctl_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "570-599",
    "snippet": "static int\nrd_ioctl_server(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t end;\n\tint error;\n\n\t/* Sanity check addr, size. */\n\tend = (vaddr_t) (urd->rd_addr + urd->rd_size);\n\n\tif ((end >= VM_MAXUSER_ADDRESS) || (end < ((vaddr_t) urd->rd_addr)) )\n\t\treturn EINVAL;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = urd->rd_addr; \t/* user space */\n\tsc->sc_size = urd->rd_size;\n\tsc->sc_type = RD_UMEM_SERVER;\n\n\t/* Become the server daemon */\n\terror = rd_server_loop(sc);\n\n\t/* This server is now going away! */\n\tsc->sc_type = RD_UNCONFIGURED;\n\tsc->sc_addr = 0;\n\tsc->sc_size = 0;\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define sc_type sc_rd.rd_type",
      "#define sc_size sc_rd.rd_size",
      "#define sc_addr sc_rd.rd_addr"
    ],
    "globals_used": [
      "struct rd_softc *sc));",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rd_server_loop",
          "args": [
            "sc"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "rd_server_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
          "lines": "603-654",
          "snippet": "static int\nrd_server_loop(sc)\n\tstruct rd_softc *sc;\n{\n\tstruct buf *bp;\n\tcaddr_t addr;\t/* user space address */\n\tsize_t  off;\t/* offset into \"device\" */\n\tsize_t  xfer;\t/* amount to transfer */\n\tint error;\n\n\tfor (;;) {\n\t\t/* Wait for some work to arrive. */\n\t\twhile (sc->sc_buflist == NULL) {\n\t\t\terror = tsleep((caddr_t)sc, rd_sleep_pri, \"rd_idle\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* Unlink buf from head of list. */\n\t\tbp = sc->sc_buflist;\n\t\tsc->sc_buflist = bp->b_actf;\n\t\tbp->b_actf = NULL;\n\n\t\t/* Do the transfer to/from user space. */\n\t\terror = 0;\n\t\tbp->b_resid = bp->b_bcount;\n\t\toff = (bp->b_blkno << DEV_BSHIFT);\n\t\tif (off >= sc->sc_size) {\n\t\t\tif (bp->b_flags & B_READ)\n\t\t\t\tgoto done;\t/* EOF (not an error) */\n\t\t\terror = EIO;\n\t\t\tgoto done;\n\t\t}\n\t\txfer = bp->b_resid;\n\t\tif (xfer > (sc->sc_size - off))\n\t\t\txfer = (sc->sc_size - off);\n\t\taddr = sc->sc_addr + off;\n\t\tif (bp->b_flags & B_READ)\n\t\t\terror = copyin(addr, bp->b_data, xfer);\n\t\telse\n\t\t\terror = copyout(bp->b_data, addr, xfer);\n\t\tif (!error)\n\t\t\tbp->b_resid -= xfer;\n\n\tdone:\n\t\tif (error) {\n\t\t\tbp->b_error = error;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t}\n\t\tbiodone(bp);\n\t}\n}",
          "includes": [
            "#include <dev/ramdisk.h>",
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/dkio.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/disk.h>",
            "#include <sys/file.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define sc_size sc_rd.rd_size",
            "#define sc_addr sc_rd.rd_addr"
          ],
          "globals_used": [
            "struct rd_softc *sc));",
            "struct rd_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_size sc_rd.rd_size\n#define sc_addr sc_rd.rd_addr\n\nstruct rd_softc *sc));\nstruct rd_softc *sc;\n\nstatic int\nrd_server_loop(sc)\n\tstruct rd_softc *sc;\n{\n\tstruct buf *bp;\n\tcaddr_t addr;\t/* user space address */\n\tsize_t  off;\t/* offset into \"device\" */\n\tsize_t  xfer;\t/* amount to transfer */\n\tint error;\n\n\tfor (;;) {\n\t\t/* Wait for some work to arrive. */\n\t\twhile (sc->sc_buflist == NULL) {\n\t\t\terror = tsleep((caddr_t)sc, rd_sleep_pri, \"rd_idle\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* Unlink buf from head of list. */\n\t\tbp = sc->sc_buflist;\n\t\tsc->sc_buflist = bp->b_actf;\n\t\tbp->b_actf = NULL;\n\n\t\t/* Do the transfer to/from user space. */\n\t\terror = 0;\n\t\tbp->b_resid = bp->b_bcount;\n\t\toff = (bp->b_blkno << DEV_BSHIFT);\n\t\tif (off >= sc->sc_size) {\n\t\t\tif (bp->b_flags & B_READ)\n\t\t\t\tgoto done;\t/* EOF (not an error) */\n\t\t\terror = EIO;\n\t\t\tgoto done;\n\t\t}\n\t\txfer = bp->b_resid;\n\t\tif (xfer > (sc->sc_size - off))\n\t\t\txfer = (sc->sc_size - off);\n\t\taddr = sc->sc_addr + off;\n\t\tif (bp->b_flags & B_READ)\n\t\t\terror = copyin(addr, bp->b_data, xfer);\n\t\telse\n\t\t\terror = copyout(bp->b_data, addr, xfer);\n\t\tif (!error)\n\t\t\tbp->b_resid -= xfer;\n\n\tdone:\n\t\tif (error) {\n\t\t\tbp->b_error = error;\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t}\n\t\tbiodone(bp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "urd->rd_addr + urd->rd_size"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_type sc_rd.rd_type\n#define sc_size sc_rd.rd_size\n#define sc_addr sc_rd.rd_addr\n\nstruct rd_softc *sc));\nstruct rd_softc *sc;\n\nstatic int\nrd_ioctl_server(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t end;\n\tint error;\n\n\t/* Sanity check addr, size. */\n\tend = (vaddr_t) (urd->rd_addr + urd->rd_size);\n\n\tif ((end >= VM_MAXUSER_ADDRESS) || (end < ((vaddr_t) urd->rd_addr)) )\n\t\treturn EINVAL;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = urd->rd_addr; \t/* user space */\n\tsc->sc_size = urd->rd_size;\n\tsc->sc_type = RD_UMEM_SERVER;\n\n\t/* Become the server daemon */\n\terror = rd_server_loop(sc);\n\n\t/* This server is now going away! */\n\tsc->sc_type = RD_UNCONFIGURED;\n\tsc->sc_addr = 0;\n\tsc->sc_size = 0;\n\n\treturn (error);\n}"
  },
  {
    "function_name": "rd_ioctl_kalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "538-562",
    "snippet": "static int\nrd_ioctl_kalloc(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t addr;\n\tvsize_t size;\n\n\t/* Sanity check the size. */\n\tsize = urd->rd_size;\n#if defined(UVM)\n\taddr = uvm_km_zalloc(kernel_map, size);\n#else\n\taddr = kmem_alloc(kernel_map, size);\n#endif\n\tif (!addr)\n\t\treturn ENOMEM;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = (caddr_t)addr; \t/* kernel space */\n\tsc->sc_size = (size_t)size;\n\tsc->sc_type = RD_KMEM_ALLOCATED;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define sc_type sc_rd.rd_type",
      "#define sc_size sc_rd.rd_size",
      "#define sc_addr sc_rd.rd_addr"
    ],
    "globals_used": [
      "struct rd_softc *sc));",
      "static int rd_ioctl_kalloc",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "kernel_map",
            "size"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uvm_km_zalloc",
          "args": [
            "kernel_map",
            "size"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_type sc_rd.rd_type\n#define sc_size sc_rd.rd_size\n#define sc_addr sc_rd.rd_addr\n\nstruct rd_softc *sc));\nstatic int rd_ioctl_kalloc;\nstruct rd_softc *sc;\n\nstatic int\nrd_ioctl_kalloc(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t addr;\n\tvsize_t size;\n\n\t/* Sanity check the size. */\n\tsize = urd->rd_size;\n#if defined(UVM)\n\taddr = uvm_km_zalloc(kernel_map, size);\n#else\n\taddr = kmem_alloc(kernel_map, size);\n#endif\n\tif (!addr)\n\t\treturn ENOMEM;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = (caddr_t)addr; \t/* kernel space */\n\tsc->sc_size = (size_t)size;\n\tsc->sc_type = RD_KMEM_ALLOCATED;\n\treturn 0;\n}"
  },
  {
    "function_name": "rdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "395-481",
    "snippet": "int\nrdioctl(dev, cmd, data, flag, proc)\n\tdev_t\tdev;\n\tu_long\tcmd;\n\tint\t\tflag;\n\tcaddr_t\tdata;\n\tstruct proc\t*proc;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct cpu_disklabel clp;\n\tstruct disklabel lp, *lpp;\n\tint error;\n\n\tmd = minor(dev);\n\tunit = RD_UNIT(md);\n\tsc = ramdisk_devs[unit];\n\n\turd = (struct rd_conf *)data;\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\t\tif (sc->sc_type == RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tlpp = rdgetdisklabel(dev, sc);\n\t\tif (lpp)\n\t\t\t*(struct disklabel *)data = *lpp;\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif (sc->sc_type == RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\terror = setdisklabel(&lp, (struct disklabel *)data,\n\t\t    /*sd->sc_dk.dk_openmask : */0, &clp);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(RDLABELDEV(dev),\n\t\t\t\t    rdstrategy, &lp, &clp);\n\t\t}\n\n\t\treturn error;\n\n\tcase DIOCWLABEL:\n\t\tif (sc->sc_type == RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\treturn 0;\n\n\tcase RD_GETCONF:\n\t\t/* If this is not the control device, punt! */\n\t\tif (RD_IS_CTRL(md) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*urd = sc->sc_rd;\n\t\treturn 0;\n\n\tcase RD_SETCONF:\n\t\t/* If this is not the control device, punt! */\n\t\tif (RD_IS_CTRL(md) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Can only set it once. */\n\t\tif (sc->sc_type != RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (urd->rd_type) {\n\t\tcase RD_KMEM_ALLOCATED:\n\t\t\treturn rd_ioctl_kalloc(sc, urd, proc);\n#if RAMDISK_SERVER\n\t\tcase RD_UMEM_SERVER:\n\t\t\treturn rd_ioctl_server(sc, urd, proc);\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn EINVAL;\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define sc_type sc_rd.rd_type",
      "#define\tRAMDISK_SERVER 1"
    ],
    "globals_used": [
      "struct disklabel *rdgetdisklabel",
      "struct rd_softc *sc));",
      "void rdstrategy",
      "static void *ramdisk_devs[RD_MAX_UNITS];",
      "static int rd_ioctl_kalloc",
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rd_ioctl_server",
          "args": [
            "sc",
            "urd",
            "proc"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "rd_ioctl_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
          "lines": "570-599",
          "snippet": "static int\nrd_ioctl_server(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t end;\n\tint error;\n\n\t/* Sanity check addr, size. */\n\tend = (vaddr_t) (urd->rd_addr + urd->rd_size);\n\n\tif ((end >= VM_MAXUSER_ADDRESS) || (end < ((vaddr_t) urd->rd_addr)) )\n\t\treturn EINVAL;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = urd->rd_addr; \t/* user space */\n\tsc->sc_size = urd->rd_size;\n\tsc->sc_type = RD_UMEM_SERVER;\n\n\t/* Become the server daemon */\n\terror = rd_server_loop(sc);\n\n\t/* This server is now going away! */\n\tsc->sc_type = RD_UNCONFIGURED;\n\tsc->sc_addr = 0;\n\tsc->sc_size = 0;\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/ramdisk.h>",
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/dkio.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/disk.h>",
            "#include <sys/file.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define sc_type sc_rd.rd_type",
            "#define sc_size sc_rd.rd_size",
            "#define sc_addr sc_rd.rd_addr"
          ],
          "globals_used": [
            "struct rd_softc *sc));",
            "struct rd_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_type sc_rd.rd_type\n#define sc_size sc_rd.rd_size\n#define sc_addr sc_rd.rd_addr\n\nstruct rd_softc *sc));\nstruct rd_softc *sc;\n\nstatic int\nrd_ioctl_server(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t end;\n\tint error;\n\n\t/* Sanity check addr, size. */\n\tend = (vaddr_t) (urd->rd_addr + urd->rd_size);\n\n\tif ((end >= VM_MAXUSER_ADDRESS) || (end < ((vaddr_t) urd->rd_addr)) )\n\t\treturn EINVAL;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = urd->rd_addr; \t/* user space */\n\tsc->sc_size = urd->rd_size;\n\tsc->sc_type = RD_UMEM_SERVER;\n\n\t/* Become the server daemon */\n\terror = rd_server_loop(sc);\n\n\t/* This server is now going away! */\n\tsc->sc_type = RD_UNCONFIGURED;\n\tsc->sc_addr = 0;\n\tsc->sc_size = 0;\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rd_ioctl_kalloc",
          "args": [
            "sc",
            "urd",
            "proc"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "rd_ioctl_kalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
          "lines": "538-562",
          "snippet": "static int\nrd_ioctl_kalloc(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t addr;\n\tvsize_t size;\n\n\t/* Sanity check the size. */\n\tsize = urd->rd_size;\n#if defined(UVM)\n\taddr = uvm_km_zalloc(kernel_map, size);\n#else\n\taddr = kmem_alloc(kernel_map, size);\n#endif\n\tif (!addr)\n\t\treturn ENOMEM;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = (caddr_t)addr; \t/* kernel space */\n\tsc->sc_size = (size_t)size;\n\tsc->sc_type = RD_KMEM_ALLOCATED;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ramdisk.h>",
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/dkio.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/disk.h>",
            "#include <sys/file.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define sc_type sc_rd.rd_type",
            "#define sc_size sc_rd.rd_size",
            "#define sc_addr sc_rd.rd_addr"
          ],
          "globals_used": [
            "struct rd_softc *sc));",
            "static int rd_ioctl_kalloc",
            "struct rd_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_type sc_rd.rd_type\n#define sc_size sc_rd.rd_size\n#define sc_addr sc_rd.rd_addr\n\nstruct rd_softc *sc));\nstatic int rd_ioctl_kalloc;\nstruct rd_softc *sc;\n\nstatic int\nrd_ioctl_kalloc(sc, urd, proc)\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct proc\t*proc;\n{\n\tvaddr_t addr;\n\tvsize_t size;\n\n\t/* Sanity check the size. */\n\tsize = urd->rd_size;\n#if defined(UVM)\n\taddr = uvm_km_zalloc(kernel_map, size);\n#else\n\taddr = kmem_alloc(kernel_map, size);\n#endif\n\tif (!addr)\n\t\treturn ENOMEM;\n\n\t/* This unit is now configured. */\n\tsc->sc_addr = (caddr_t)addr; \t/* kernel space */\n\tsc->sc_size = (size_t)size;\n\tsc->sc_type = RD_KMEM_ALLOCATED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RD_IS_CTRL",
          "args": [
            "md"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RD_IS_CTRL",
          "args": [
            "md"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writedisklabel",
          "args": [
            "RDLABELDEV(dev)",
            "rdstrategy",
            "&lp",
            "&clp"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "&lp",
            "(struct disklabel *)data",
            "/*sd->sc_dk.dk_openmask : */0",
            "&clp"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdgetdisklabel",
          "args": [
            "dev",
            "sc"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RD_UNIT",
          "args": [
            "md"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_type sc_rd.rd_type\n#define\tRAMDISK_SERVER 1\n\nstruct disklabel *rdgetdisklabel;\nstruct rd_softc *sc));\nvoid rdstrategy;\nstatic void *ramdisk_devs[RD_MAX_UNITS];\nstatic int rd_ioctl_kalloc;\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\nstruct rd_softc *sc;\n\nint\nrdioctl(dev, cmd, data, flag, proc)\n\tdev_t\tdev;\n\tu_long\tcmd;\n\tint\t\tflag;\n\tcaddr_t\tdata;\n\tstruct proc\t*proc;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\tstruct rd_conf *urd;\n\tstruct cpu_disklabel clp;\n\tstruct disklabel lp, *lpp;\n\tint error;\n\n\tmd = minor(dev);\n\tunit = RD_UNIT(md);\n\tsc = ramdisk_devs[unit];\n\n\turd = (struct rd_conf *)data;\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\t\tif (sc->sc_type == RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tlpp = rdgetdisklabel(dev, sc);\n\t\tif (lpp)\n\t\t\t*(struct disklabel *)data = *lpp;\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif (sc->sc_type == RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\terror = setdisklabel(&lp, (struct disklabel *)data,\n\t\t    /*sd->sc_dk.dk_openmask : */0, &clp);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(RDLABELDEV(dev),\n\t\t\t\t    rdstrategy, &lp, &clp);\n\t\t}\n\n\t\treturn error;\n\n\tcase DIOCWLABEL:\n\t\tif (sc->sc_type == RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\treturn 0;\n\n\tcase RD_GETCONF:\n\t\t/* If this is not the control device, punt! */\n\t\tif (RD_IS_CTRL(md) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t*urd = sc->sc_rd;\n\t\treturn 0;\n\n\tcase RD_SETCONF:\n\t\t/* If this is not the control device, punt! */\n\t\tif (RD_IS_CTRL(md) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Can only set it once. */\n\t\tif (sc->sc_type != RD_UNCONFIGURED) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch (urd->rd_type) {\n\t\tcase RD_KMEM_ALLOCATED:\n\t\t\treturn rd_ioctl_kalloc(sc, urd, proc);\n#if RAMDISK_SERVER\n\t\tcase RD_UMEM_SERVER:\n\t\t\treturn rd_ioctl_server(sc, urd, proc);\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn EINVAL;\n}"
  },
  {
    "function_name": "rdstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "336-393",
    "snippet": "void\nrdstrategy(bp)\n\tstruct buf *bp;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\tcaddr_t addr;\n\tsize_t  off, xfer;\n\n\tmd = minor(bp->b_dev);\n\tunit = RD_UNIT(md);\n\tsc = ramdisk_devs[unit];\n\n\tswitch (sc->sc_type) {\n#if RAMDISK_SERVER\n\tcase RD_UMEM_SERVER:\n\t\t/* Just add this job to the server's queue. */\n\t\tbp->b_actf = sc->sc_buflist;\n\t\tsc->sc_buflist = bp;\n\t\tif (bp->b_actf == NULL) {\n\t\t\t/* server queue was empty. */\n\t\t\twakeup((caddr_t)sc);\n\t\t\t/* see rd_server_loop() */\n\t\t}\n\t\t/* no biodone in this case */\n\t\treturn;\n#endif\t/* RAMDISK_SERVER */\n\n\tcase RD_KMEM_FIXED:\n\tcase RD_KMEM_ALLOCATED:\n\t\t/* These are in kernel space.  Access directly. */\n\t\tbp->b_resid = bp->b_bcount;\n\t\toff = (bp->b_blkno << DEV_BSHIFT);\n\t\tif (off >= sc->sc_size) {\n\t\t\tif (bp->b_flags & B_READ)\n\t\t\t\tbreak;\t/* EOF */\n\t\t\tgoto set_eio;\n\t\t}\n\t\txfer = bp->b_resid;\n\t\tif (xfer > (sc->sc_size - off))\n\t\t\txfer = (sc->sc_size - off);\n\t\taddr = sc->sc_addr + off;\n\t\tif (bp->b_flags & B_READ)\n\t\t\tbcopy(addr, bp->b_data, xfer);\n\t\telse\n\t\t\tbcopy(bp->b_data, addr, xfer);\n\t\tbp->b_resid -= xfer;\n\t\tbreak;\n\n\tdefault:\n\t\tbp->b_resid = bp->b_bcount;\n\tset_eio:\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbreak;\n\t}\n\tbiodone(bp);\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define sc_type sc_rd.rd_type",
      "#define sc_size sc_rd.rd_size",
      "#define sc_addr sc_rd.rd_addr",
      "#define\tRAMDISK_SERVER 1"
    ],
    "globals_used": [
      "struct rd_softc *sc));",
      "void rdstrategy",
      "static void *ramdisk_devs[RD_MAX_UNITS];",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "bp->b_data",
            "addr",
            "xfer"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)sc"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RD_UNIT",
          "args": [
            "md"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "bp->b_dev"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_type sc_rd.rd_type\n#define sc_size sc_rd.rd_size\n#define sc_addr sc_rd.rd_addr\n#define\tRAMDISK_SERVER 1\n\nstruct rd_softc *sc));\nvoid rdstrategy;\nstatic void *ramdisk_devs[RD_MAX_UNITS];\nstruct rd_softc *sc;\n\nvoid\nrdstrategy(bp)\n\tstruct buf *bp;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\tcaddr_t addr;\n\tsize_t  off, xfer;\n\n\tmd = minor(bp->b_dev);\n\tunit = RD_UNIT(md);\n\tsc = ramdisk_devs[unit];\n\n\tswitch (sc->sc_type) {\n#if RAMDISK_SERVER\n\tcase RD_UMEM_SERVER:\n\t\t/* Just add this job to the server's queue. */\n\t\tbp->b_actf = sc->sc_buflist;\n\t\tsc->sc_buflist = bp;\n\t\tif (bp->b_actf == NULL) {\n\t\t\t/* server queue was empty. */\n\t\t\twakeup((caddr_t)sc);\n\t\t\t/* see rd_server_loop() */\n\t\t}\n\t\t/* no biodone in this case */\n\t\treturn;\n#endif\t/* RAMDISK_SERVER */\n\n\tcase RD_KMEM_FIXED:\n\tcase RD_KMEM_ALLOCATED:\n\t\t/* These are in kernel space.  Access directly. */\n\t\tbp->b_resid = bp->b_bcount;\n\t\toff = (bp->b_blkno << DEV_BSHIFT);\n\t\tif (off >= sc->sc_size) {\n\t\t\tif (bp->b_flags & B_READ)\n\t\t\t\tbreak;\t/* EOF */\n\t\t\tgoto set_eio;\n\t\t}\n\t\txfer = bp->b_resid;\n\t\tif (xfer > (sc->sc_size - off))\n\t\t\txfer = (sc->sc_size - off);\n\t\taddr = sc->sc_addr + off;\n\t\tif (bp->b_flags & B_READ)\n\t\t\tbcopy(addr, bp->b_data, xfer);\n\t\telse\n\t\t\tbcopy(bp->b_data, addr, xfer);\n\t\tbp->b_resid -= xfer;\n\t\tbreak;\n\n\tdefault:\n\t\tbp->b_resid = bp->b_bcount;\n\tset_eio:\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbreak;\n\t}\n\tbiodone(bp);\n}"
  },
  {
    "function_name": "rdwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "323-330",
    "snippet": "int\nrdwrite(dev, uio, flags)\n\tdev_t\t\tdev;\n\tstruct uio\t*uio;\n\tint\t\tflags;\n{\n\treturn (physio(rdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rdstrategy",
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "rdstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid rdstrategy;\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\n\nint\nrdwrite(dev, uio, flags)\n\tdev_t\t\tdev;\n\tstruct uio\t*uio;\n\tint\t\tflags;\n{\n\treturn (physio(rdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "rdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "314-321",
    "snippet": "int\nrdread(dev, uio, flags)\n\tdev_t\t\tdev;\n\tstruct uio\t*uio;\n\tint\t\tflags;\n{\n\treturn (physio(rdstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rdstrategy",
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "rdstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nvoid rdstrategy;\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\n\nint\nrdread(dev, uio, flags)\n\tdev_t\t\tdev;\n\tstruct uio\t*uio;\n\tint\t\tflags;\n{\n\treturn (physio(rdstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "rdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "292-312",
    "snippet": "int\nrdclose(dev, flag, fmt, proc)\n\tdev_t   dev;\n\tint     flag, fmt;\n\tstruct proc *proc;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\n\tmd = minor(dev);\n\tunit = RD_UNIT(md);\n\tsc = ramdisk_devs[unit];\n\n\tif (RD_IS_CTRL(md))\n\t\treturn 0;\n\n\t/* Normal device. */\n\tsc->sc_flags = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rd_softc *sc));",
      "static void *ramdisk_devs[RD_MAX_UNITS];",
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RD_IS_CTRL",
          "args": [
            "md"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RD_UNIT",
          "args": [
            "md"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nstruct rd_softc *sc));\nstatic void *ramdisk_devs[RD_MAX_UNITS];\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\nstruct rd_softc *sc;\n\nint\nrdclose(dev, flag, fmt, proc)\n\tdev_t   dev;\n\tint     flag, fmt;\n\tstruct proc *proc;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\n\tmd = minor(dev);\n\tunit = RD_UNIT(md);\n\tsc = ramdisk_devs[unit];\n\n\tif (RD_IS_CTRL(md))\n\t\treturn 0;\n\n\t/* Normal device. */\n\tsc->sc_flags = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "251-290",
    "snippet": "int\nrdopen(dev, flag, fmt, proc)\n\tdev_t   dev;\n\tint     flag, fmt;\n\tstruct proc *proc;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\n\tmd = minor(dev);\n\tunit = RD_UNIT(md);\n\tif (unit >= ramdisk_ndevs)\n\t\treturn ENXIO;\n\tsc = ramdisk_devs[unit];\n\tif (sc == NULL)\n\t\treturn ENXIO;\n\n\t/*\n\t * The control device is not exclusive, and can\n\t * open uninitialized units (so you can setconf).\n\t */\n\tif (RD_IS_CTRL(md))\n\t\treturn 0;\n\n#ifdef\tRAMDISK_HOOKS\n\t/* Call the open hook to allow loading the device. */\n\trd_open_hook(unit, &sc->sc_rd);\n#endif\n\n\t/*\n\t * This is a normal, \"slave\" device, so\n\t * enforce initialized, exclusive open.\n\t */\n\tif (sc->sc_type == RD_UNCONFIGURED)\n\t\treturn ENXIO;\n\tif (sc->sc_flags & RD_ISOPEN)\n\t\treturn EBUSY;\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define RD_ISOPEN\t0x01",
      "#define sc_type sc_rd.rd_type"
    ],
    "globals_used": [
      "struct rd_softc *sc));",
      "static int   ramdisk_ndevs;",
      "static void *ramdisk_devs[RD_MAX_UNITS];",
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rd_open_hook",
          "args": [
            "unit",
            "&sc->sc_rd"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RD_IS_CTRL",
          "args": [
            "md"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RD_UNIT",
          "args": [
            "md"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define RD_ISOPEN\t0x01\n#define sc_type sc_rd.rd_type\n\nstruct rd_softc *sc));\nstatic int   ramdisk_ndevs;\nstatic void *ramdisk_devs[RD_MAX_UNITS];\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\nstruct rd_softc *sc;\n\nint\nrdopen(dev, flag, fmt, proc)\n\tdev_t   dev;\n\tint     flag, fmt;\n\tstruct proc *proc;\n{\n\tint md, unit;\n\tstruct rd_softc *sc;\n\n\tmd = minor(dev);\n\tunit = RD_UNIT(md);\n\tif (unit >= ramdisk_ndevs)\n\t\treturn ENXIO;\n\tsc = ramdisk_devs[unit];\n\tif (sc == NULL)\n\t\treturn ENXIO;\n\n\t/*\n\t * The control device is not exclusive, and can\n\t * open uninitialized units (so you can setconf).\n\t */\n\tif (RD_IS_CTRL(md))\n\t\treturn 0;\n\n#ifdef\tRAMDISK_HOOKS\n\t/* Call the open hook to allow loading the device. */\n\trd_open_hook(unit, &sc->sc_rd);\n#endif\n\n\t/*\n\t * This is a normal, \"slave\" device, so\n\t * enforce initialized, exclusive open.\n\t */\n\tif (sc->sc_type == RD_UNCONFIGURED)\n\t\treturn ENXIO;\n\tif (sc->sc_flags & RD_ISOPEN)\n\t\treturn EBUSY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rdsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "232-249",
    "snippet": "int rdsize(dev_t dev)\n{\n\tint unit;\n\tstruct rd_softc *sc;\n\n\t/* Disallow control units. */\n\tunit = minor(dev);\n\tif (unit >= ramdisk_ndevs)\n\t\treturn 0;\n\tsc = ramdisk_devs[unit];\n\tif (sc == NULL)\n\t\treturn 0;\n\n\tif (sc->sc_type == RD_UNCONFIGURED)\n\t\treturn 0;\n\n\treturn (sc->sc_size >> DEV_BSHIFT);\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define sc_type sc_rd.rd_type",
      "#define sc_size sc_rd.rd_size"
    ],
    "globals_used": [
      "struct rd_softc *sc));",
      "static int   ramdisk_ndevs;",
      "static void *ramdisk_devs[RD_MAX_UNITS];",
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define sc_type sc_rd.rd_type\n#define sc_size sc_rd.rd_size\n\nstruct rd_softc *sc));\nstatic int   ramdisk_ndevs;\nstatic void *ramdisk_devs[RD_MAX_UNITS];\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\nstruct rd_softc *sc;\n\nint rdsize(dev_t dev)\n{\n\tint unit;\n\tstruct rd_softc *sc;\n\n\t/* Disallow control units. */\n\tunit = minor(dev);\n\tif (unit >= ramdisk_ndevs)\n\t\treturn 0;\n\tsc = ramdisk_devs[unit];\n\tif (sc == NULL)\n\t\treturn 0;\n\n\tif (sc->sc_type == RD_UNCONFIGURED)\n\t\treturn 0;\n\n\treturn (sc->sc_size >> DEV_BSHIFT);\n}"
  },
  {
    "function_name": "rddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "223-230",
    "snippet": "int rddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\treturn ENODEV;\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\n\nint rddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\treturn ENODEV;\n}"
  },
  {
    "function_name": "rd_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "176-199",
    "snippet": "static void\nrd_attach(parent, self, aux)\n\tstruct device\t*parent, *self;\n\tvoid\t\t*aux;\n{\n\tstruct rd_softc *sc = (struct rd_softc *)self;\n\n\t/* XXX - Could accept aux info here to set the config. */\n#ifdef\tRAMDISK_HOOKS\n\t/*\n\t * This external function might setup a pre-loaded disk.\n\t * All it would need to do is setup the rd_conf struct.\n\t * See sys/arch/sun3/dev/rd_root.c for an example.\n\t */\n\trd_attach_hook(sc->sc_dev.dv_unit, &sc->sc_rd);\n#endif\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tsc->sc_dkdev.dk_driver = &rddkdriver;\n\tsc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;\n\tdisk_attach(&sc->sc_dkdev);\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rd_attach",
      "struct rd_softc *sc));",
      "struct dkdriver rddkdriver = { rdstrategy };",
      "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&sc->sc_dkdev"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rd_attach_hook",
          "args": [
            "sc->sc_dev.dv_unit",
            "&sc->sc_rd"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nstatic void rd_attach;\nstruct rd_softc *sc));\nstruct dkdriver rddkdriver = { rdstrategy };\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\nstruct rd_softc *sc;\n\nstatic void\nrd_attach(parent, self, aux)\n\tstruct device\t*parent, *self;\n\tvoid\t\t*aux;\n{\n\tstruct rd_softc *sc = (struct rd_softc *)self;\n\n\t/* XXX - Could accept aux info here to set the config. */\n#ifdef\tRAMDISK_HOOKS\n\t/*\n\t * This external function might setup a pre-loaded disk.\n\t * All it would need to do is setup the rd_conf struct.\n\t * See sys/arch/sun3/dev/rd_root.c for an example.\n\t */\n\trd_attach_hook(sc->sc_dev.dv_unit, &sc->sc_rd);\n#endif\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tsc->sc_dkdev.dk_driver = &rddkdriver;\n\tsc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;\n\tdisk_attach(&sc->sc_dkdev);\n}"
  },
  {
    "function_name": "rdattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
    "lines": "135-174",
    "snippet": "void\nrdattach(n)\n\tint n;\n{\n\tstruct rd_softc *sc;\n\tint i;\n\n#ifdef\tDIAGNOSTIC\n\tif (ramdisk_ndevs) {\n\t\tprintf(\"ramdisk: multiple attach calls?\\n\");\n\t\treturn;\n\t}\n#endif\n\n\t/* XXX:  Are we supposed to provide a default? */\n\tif (n <= 1)\n\t\tn = 1;\n\tif (n > RD_MAX_UNITS)\n\t\tn = RD_MAX_UNITS;\n\tramdisk_ndevs = n;\n\n\t/* XXX: Fake-up rd_cd (see above) */\n\trd_cd.cd_ndevs = ramdisk_ndevs;\n\trd_cd.cd_devs  = ramdisk_devs;\n\n\t/* Attach as if by autoconfig. */\n\tfor (i = 0; i < n; i++) {\n\n\t\tsc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK);\n\t\tif (!sc) {\n\t\t\tprintf(\"ramdisk: malloc for attach failed!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbzero((caddr_t)sc, sizeof(*sc));\n\t\tramdisk_devs[i] = sc;\n\t\tsc->sc_dev.dv_unit = i;\n\t\tsprintf(sc->sc_dev.dv_xname, \"rd%d\", i);\n\t\trd_attach(NULL, &sc->sc_dev, NULL);\n\t}\n}",
    "includes": [
      "#include <dev/ramdisk.h>",
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/dkio.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/disk.h>",
      "#include <sys/file.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define RD_MAX_UNITS\t0x10"
    ],
    "globals_used": [
      "void rdattach",
      "static void rd_attach",
      "struct rd_softc *sc));",
      "struct cfdriver rd_cd = {\n\tNULL, \"rd\", DV_DULL, NULL, 0\n};",
      "static int   ramdisk_ndevs;",
      "static void *ramdisk_devs[RD_MAX_UNITS];",
      "struct rd_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rd_attach",
          "args": [
            "NULL",
            "&sc->sc_dev",
            "NULL"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rd_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ramdisk.c",
          "lines": "176-199",
          "snippet": "static void\nrd_attach(parent, self, aux)\n\tstruct device\t*parent, *self;\n\tvoid\t\t*aux;\n{\n\tstruct rd_softc *sc = (struct rd_softc *)self;\n\n\t/* XXX - Could accept aux info here to set the config. */\n#ifdef\tRAMDISK_HOOKS\n\t/*\n\t * This external function might setup a pre-loaded disk.\n\t * All it would need to do is setup the rd_conf struct.\n\t * See sys/arch/sun3/dev/rd_root.c for an example.\n\t */\n\trd_attach_hook(sc->sc_dev.dv_unit, &sc->sc_rd);\n#endif\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tsc->sc_dkdev.dk_driver = &rddkdriver;\n\tsc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;\n\tdisk_attach(&sc->sc_dkdev);\n}",
          "includes": [
            "#include <dev/ramdisk.h>",
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/dkio.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/disk.h>",
            "#include <sys/file.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rd_attach",
            "struct rd_softc *sc));",
            "struct dkdriver rddkdriver = { rdstrategy };",
            "struct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;",
            "struct rd_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\nstatic void rd_attach;\nstruct rd_softc *sc));\nstruct dkdriver rddkdriver = { rdstrategy };\nstruct disklabel *\nrdgetdisklabel(dev, sc)\n\tdev_t dev;\nstruct rd_softc *sc;\n\nstatic void\nrd_attach(parent, self, aux)\n\tstruct device\t*parent, *self;\n\tvoid\t\t*aux;\n{\n\tstruct rd_softc *sc = (struct rd_softc *)self;\n\n\t/* XXX - Could accept aux info here to set the config. */\n#ifdef\tRAMDISK_HOOKS\n\t/*\n\t * This external function might setup a pre-loaded disk.\n\t * All it would need to do is setup the rd_conf struct.\n\t * See sys/arch/sun3/dev/rd_root.c for an example.\n\t */\n\trd_attach_hook(sc->sc_dev.dv_unit, &sc->sc_rd);\n#endif\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tsc->sc_dkdev.dk_driver = &rddkdriver;\n\tsc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;\n\tdisk_attach(&sc->sc_dkdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "sc->sc_dev.dv_xname",
            "\"rd%d\"",
            "i"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t)sc",
            "sizeof(*sc)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ramdisk: malloc for attach failed!\\n\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*sc)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ramdisk.h>\n#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/dkio.h>\n#include <sys/disklabel.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/disk.h>\n#include <sys/file.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/param.h>\n\n#define RD_MAX_UNITS\t0x10\n\nvoid rdattach;\nstatic void rd_attach;\nstruct rd_softc *sc));\nstruct cfdriver rd_cd = {\n\tNULL, \"rd\", DV_DULL, NULL, 0\n};\nstatic int   ramdisk_ndevs;\nstatic void *ramdisk_devs[RD_MAX_UNITS];\nstruct rd_softc *sc;\n\nvoid\nrdattach(n)\n\tint n;\n{\n\tstruct rd_softc *sc;\n\tint i;\n\n#ifdef\tDIAGNOSTIC\n\tif (ramdisk_ndevs) {\n\t\tprintf(\"ramdisk: multiple attach calls?\\n\");\n\t\treturn;\n\t}\n#endif\n\n\t/* XXX:  Are we supposed to provide a default? */\n\tif (n <= 1)\n\t\tn = 1;\n\tif (n > RD_MAX_UNITS)\n\t\tn = RD_MAX_UNITS;\n\tramdisk_ndevs = n;\n\n\t/* XXX: Fake-up rd_cd (see above) */\n\trd_cd.cd_ndevs = ramdisk_ndevs;\n\trd_cd.cd_devs  = ramdisk_devs;\n\n\t/* Attach as if by autoconfig. */\n\tfor (i = 0; i < n; i++) {\n\n\t\tsc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK);\n\t\tif (!sc) {\n\t\t\tprintf(\"ramdisk: malloc for attach failed!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbzero((caddr_t)sc, sizeof(*sc));\n\t\tramdisk_devs[i] = sc;\n\t\tsc->sc_dev.dv_unit = i;\n\t\tsprintf(sc->sc_dev.dv_xname, \"rd%d\", i);\n\t\trd_attach(NULL, &sc->sc_dev, NULL);\n\t}\n}"
  }
]