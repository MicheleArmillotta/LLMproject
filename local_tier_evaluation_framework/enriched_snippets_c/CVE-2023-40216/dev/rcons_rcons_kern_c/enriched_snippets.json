[
  {
    "function_name": "rcons_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_kern.c",
    "lines": "168-254",
    "snippet": "void\nrcons_init(rc)\n\tregister struct rconsole *rc;\n{\n\t/* XXX this should go away */\n\tstatic struct raster xxxraster;\n\tregister struct raster *rp = rc->rc_sp = &xxxraster;\n\tregister struct winsize *ws;\n\tregister int i;\n\tstatic int row, col;\n\n\tmydevicep = rc;\n\n\t/* XXX mostly duplicates of data in other places */\n\trp->width = rc->rc_width;\n\trp->height = rc->rc_height;\n\trp->depth = rc->rc_depth;\n\tif (rc->rc_linebytes & 0x3) {\n\t\tprintf(\"rcons_init: linebytes assumption botched (0x%x)\\n\",\n\t\t    rc->rc_linebytes);\n\t\treturn;\n\t}\n\trp->linelongs = rc->rc_linebytes >> 2;\n\trp->pixels = (u_int32_t *)rc->rc_pixels;\n\n\trc->rc_ras_blank = RAS_CLEAR;\n\n\t/* Impose upper bounds on rc_max{row,col} */\n\ti = rc->rc_height / rc->rc_font->height;\n\tif (rc->rc_maxrow > i)\n\t\trc->rc_maxrow = i;\n\ti = rc->rc_width / rc->rc_font->width;\n\tif (rc->rc_maxcol > i)\n\t\trc->rc_maxcol = i;\n\n\t/* Let the system know how big the console is */\n\tws = &fbconstty->t_winsize;\n\tws->ws_row = rc->rc_maxrow;\n\tws->ws_col = rc->rc_maxcol;\n\tws->ws_xpixel = rc->rc_width;\n\tws->ws_ypixel = rc->rc_height;\n\n\t/* Center emulator screen (but align x origin to 32 bits) */\n\trc->rc_xorigin =\n\t    ((rc->rc_width - rc->rc_maxcol * rc->rc_font->width) / 2) & ~0x1f;\n\trc->rc_yorigin =\n\t    (rc->rc_height - rc->rc_maxrow * rc->rc_font->height) / 2;\n\n\t/* Emulator width and height used for scrolling */\n\trc->rc_emuwidth = rc->rc_maxcol * rc->rc_font->width;\n\tif (rc->rc_emuwidth & 0x1f) {\n\t\t/* Pad to 32 bits */\n\t\ti = (rc->rc_emuwidth + 0x1f) & ~0x1f;\n\t\t/* Make sure emulator width isn't too wide */\n\t\tif (rc->rc_xorigin + i <= rc->rc_width)\n\t\t\trc->rc_emuwidth = i;\n\t}\n\trc->rc_emuheight = rc->rc_maxrow * rc->rc_font->height;\n\n#ifdef RASTERCONS_WONB\n\trc->rc_ras_blank = RAS_NOT(rc->rc_ras_blank);\n\trc->rc_bits |= FB_INVERT;\n#endif\n\n\tif (rc->rc_row == NULL || rc->rc_col == NULL) {\n\t\t/*\n\t\t * No address passed; use private copies\n\t\t * go to LL corner and scroll.\n\t\t */\n\t\trc->rc_row = &row;\n\t\trc->rc_col = &col;\n\t\trow = rc->rc_maxrow;\n\t\tcol = 0;\n#if 0\n\t\trcons_clear2eop(rc);\t/* clear the display */\n#endif\n\t\trcons_scroll(rc, 1);\n\t\trcons_cursor(rc);\t/* and draw the initial cursor */\n\t} else {\n\t\t/* Prom emulator cursor is currently visible */\n\t\trc->rc_bits |= FB_CURSOR;\n\t}\n\n\t/* Initialization done; hook us up */\n\tfbconstty->t_oproc = rcons_output;\n\t/*fbconstty->t_stop = (void (*)()) nullop;*/\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/rcons.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct tty *fbconstty;",
      "static struct rconsole *mydevicep;",
      "static void rcons_output"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcons_cursor",
          "args": [
            "rc"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "393-411",
          "snippet": "void\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_cursor(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int x, y;\n\n\tx = *rc->rc_col * rc->rc_font->width + rc->rc_xorigin;\n\ty = *rc->rc_row * rc->rc_font->height + rc->rc_yorigin;\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\trc->rc_bits ^= FB_CURSOR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_scroll",
          "args": [
            "rc",
            "1"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_scroll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "470-496",
          "snippet": "void\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_scroll(rc, n)\n\tregister struct rconsole *rc;\n\tregister int n;\n{\n\tregister int ydiv;\n\n\t/* Can't scroll more than the whole screen */\n\tif (n > rc->rc_maxrow)\n\t\tn = rc->rc_maxrow;\n\n\t/* Calculate new row */\n\t*rc->rc_row -= n;\n\tif (*rc->rc_row < 0)\n\t\t*rc->rc_row  = 0;\n\n\t/* Calculate number of pixels to scroll */\n\tydiv = rc->rc_font->height * n;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin,\n\t    rc->rc_emuwidth, rc->rc_emuheight - ydiv,\n\t    RAS_SRC, rc->rc_sp, rc->rc_xorigin, ydiv + rc->rc_yorigin);\n\n\traster_op(rc->rc_sp,\n\t    rc->rc_xorigin, rc->rc_yorigin + rc->rc_emuheight - ydiv,\n\t    rc->rc_emuwidth, ydiv, rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcons_clear2eop",
          "args": [
            "rc"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_clear2eop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "431-451",
          "snippet": "void\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_clear2eop(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int y;\n\n\tif (*rc->rc_col == 0 && *rc->rc_row == 0) {\n\t\t/* Clear the entire frame buffer */\n\t\traster_op(rc->rc_sp, 0, 0,\n\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t} else {\n\t\t/* Only clear what needs to be cleared */\n\t\trcons_clear2eol(rc);\n\t\ty = (*rc->rc_row + 1) * rc->rc_font->height;\n\n\t\traster_op(rc->rc_sp, rc->rc_xorigin, rc->rc_yorigin + y,\n\t\t    rc->rc_emuwidth, rc->rc_emuheight - y,\n\t\t    rc->rc_ras_blank, (struct raster *) 0, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAS_NOT",
          "args": [
            "rc->rc_ras_blank"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"rcons_init: linebytes assumption botched (0x%x)\\n\"",
            "rc->rc_linebytes"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/rcons.h>\n#include <dev/rcons/raster.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern struct tty *fbconstty;\nstatic struct rconsole *mydevicep;\nstatic void rcons_output;\n\nvoid\nrcons_init(rc)\n\tregister struct rconsole *rc;\n{\n\t/* XXX this should go away */\n\tstatic struct raster xxxraster;\n\tregister struct raster *rp = rc->rc_sp = &xxxraster;\n\tregister struct winsize *ws;\n\tregister int i;\n\tstatic int row, col;\n\n\tmydevicep = rc;\n\n\t/* XXX mostly duplicates of data in other places */\n\trp->width = rc->rc_width;\n\trp->height = rc->rc_height;\n\trp->depth = rc->rc_depth;\n\tif (rc->rc_linebytes & 0x3) {\n\t\tprintf(\"rcons_init: linebytes assumption botched (0x%x)\\n\",\n\t\t    rc->rc_linebytes);\n\t\treturn;\n\t}\n\trp->linelongs = rc->rc_linebytes >> 2;\n\trp->pixels = (u_int32_t *)rc->rc_pixels;\n\n\trc->rc_ras_blank = RAS_CLEAR;\n\n\t/* Impose upper bounds on rc_max{row,col} */\n\ti = rc->rc_height / rc->rc_font->height;\n\tif (rc->rc_maxrow > i)\n\t\trc->rc_maxrow = i;\n\ti = rc->rc_width / rc->rc_font->width;\n\tif (rc->rc_maxcol > i)\n\t\trc->rc_maxcol = i;\n\n\t/* Let the system know how big the console is */\n\tws = &fbconstty->t_winsize;\n\tws->ws_row = rc->rc_maxrow;\n\tws->ws_col = rc->rc_maxcol;\n\tws->ws_xpixel = rc->rc_width;\n\tws->ws_ypixel = rc->rc_height;\n\n\t/* Center emulator screen (but align x origin to 32 bits) */\n\trc->rc_xorigin =\n\t    ((rc->rc_width - rc->rc_maxcol * rc->rc_font->width) / 2) & ~0x1f;\n\trc->rc_yorigin =\n\t    (rc->rc_height - rc->rc_maxrow * rc->rc_font->height) / 2;\n\n\t/* Emulator width and height used for scrolling */\n\trc->rc_emuwidth = rc->rc_maxcol * rc->rc_font->width;\n\tif (rc->rc_emuwidth & 0x1f) {\n\t\t/* Pad to 32 bits */\n\t\ti = (rc->rc_emuwidth + 0x1f) & ~0x1f;\n\t\t/* Make sure emulator width isn't too wide */\n\t\tif (rc->rc_xorigin + i <= rc->rc_width)\n\t\t\trc->rc_emuwidth = i;\n\t}\n\trc->rc_emuheight = rc->rc_maxrow * rc->rc_font->height;\n\n#ifdef RASTERCONS_WONB\n\trc->rc_ras_blank = RAS_NOT(rc->rc_ras_blank);\n\trc->rc_bits |= FB_INVERT;\n#endif\n\n\tif (rc->rc_row == NULL || rc->rc_col == NULL) {\n\t\t/*\n\t\t * No address passed; use private copies\n\t\t * go to LL corner and scroll.\n\t\t */\n\t\trc->rc_row = &row;\n\t\trc->rc_col = &col;\n\t\trow = rc->rc_maxrow;\n\t\tcol = 0;\n#if 0\n\t\trcons_clear2eop(rc);\t/* clear the display */\n#endif\n\t\trcons_scroll(rc, 1);\n\t\trcons_cursor(rc);\t/* and draw the initial cursor */\n\t} else {\n\t\t/* Prom emulator cursor is currently visible */\n\t\trc->rc_bits |= FB_CURSOR;\n\t}\n\n\t/* Initialization done; hook us up */\n\tfbconstty->t_oproc = rcons_output;\n\t/*fbconstty->t_stop = (void (*)()) nullop;*/\n}"
  },
  {
    "function_name": "rcons_belltmr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_kern.c",
    "lines": "145-166",
    "snippet": "static void\nrcons_belltmr(p)\n\tvoid *p;\n{\n\tregister struct rconsole *rc = p;\n\tregister int s = splhigh(), i;\n\n\tif (rc->rc_ringing) {\n\t\trc->rc_ringing = 0;\n\t\ti = --rc->rc_belldepth;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(0);\n\t\tif (i != 0)\n\t\t\t/* XXX Chris doesn't like the following divide */\n\t\t\ttimeout(rcons_belltmr, rc, hz/30);\n\t} else {\n\t\trc->rc_ringing = 1;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(1);\n\t\ttimeout(rcons_belltmr, rc, hz/10);\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/rcons.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcons_belltmr(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "rcons_belltmr",
            "rc",
            "hz/10"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "1"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "0"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/rcons.h>\n#include <dev/rcons/raster.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic void rcons_belltmr(void *);\n\nstatic void\nrcons_belltmr(p)\n\tvoid *p;\n{\n\tregister struct rconsole *rc = p;\n\tregister int s = splhigh(), i;\n\n\tif (rc->rc_ringing) {\n\t\trc->rc_ringing = 0;\n\t\ti = --rc->rc_belldepth;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(0);\n\t\tif (i != 0)\n\t\t\t/* XXX Chris doesn't like the following divide */\n\t\t\ttimeout(rcons_belltmr, rc, hz/30);\n\t} else {\n\t\trc->rc_ringing = 1;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(1);\n\t\ttimeout(rcons_belltmr, rc, hz/10);\n\t}\n}"
  },
  {
    "function_name": "rcons_bell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_kern.c",
    "lines": "116-142",
    "snippet": "void\nrcons_bell(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int i, s;\n\n\tif (rc->rc_bits & FB_VISBELL) {\n\t\t/* invert the screen twice */\n\t\tfor (i = 0; i < 2; ++i)\n\t\t\traster_op(rc->rc_sp, 0, 0,\n\t\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\t}\n\n\ts = splhigh();\n\tif (rc->rc_belldepth++) {\n\t\tif (rc->rc_belldepth > 3)\n\t\t\trc->rc_belldepth = 3;\n\t\tsplx(s);\n\t} else {\n\t\trc->rc_ringing = 1;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(1);\n\t\t/* XXX Chris doesn't like the following divide */\n\t\ttimeout(rcons_belltmr, rc, hz/10);\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/rcons.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcons_belltmr(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "rcons_belltmr",
            "rc",
            "hz/10"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "0",
            "0",
            "rc->rc_sp->width",
            "rc->rc_sp->height",
            "RAS_INVERT",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/rcons.h>\n#include <dev/rcons/raster.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic void rcons_belltmr(void *);\n\nvoid\nrcons_bell(rc)\n\tregister struct rconsole *rc;\n{\n\tregister int i, s;\n\n\tif (rc->rc_bits & FB_VISBELL) {\n\t\t/* invert the screen twice */\n\t\tfor (i = 0; i < 2; ++i)\n\t\t\traster_op(rc->rc_sp, 0, 0,\n\t\t\t    rc->rc_sp->width, rc->rc_sp->height,\n\t\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\t}\n\n\ts = splhigh();\n\tif (rc->rc_belldepth++) {\n\t\tif (rc->rc_belldepth > 3)\n\t\t\trc->rc_belldepth = 3;\n\t\tsplx(s);\n\t} else {\n\t\trc->rc_ringing = 1;\n\t\tsplx(s);\n\t\t(*rc->rc_bell)(1);\n\t\t/* XXX Chris doesn't like the following divide */\n\t\ttimeout(rcons_belltmr, rc, hz/10);\n\t}\n}"
  },
  {
    "function_name": "rcons_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_kern.c",
    "lines": "81-113",
    "snippet": "static void\nrcons_output(tp)\n\tregister struct tty *tp;\n{\n\tregister int s, n;\n\tchar buf[OBUFSIZ];\n\n\ts = spltty();\n\tif (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\ttp->t_state |= TS_BUSY;\n\tsplx(s);\n\tn = q_to_b(&tp->t_outq, buf, sizeof(buf));\n\trcons_puts(mydevicep, buf, n);\n\n\ts = spltty();\n\ttp->t_state &= ~TS_BUSY;\n\t/* Come back if there's more to do */\n\tif (tp->t_outq.c_cc) {\n\t\ttp->t_state |= TS_TIMEOUT;\n\t\ttimeout(ttrstrt, tp, 1);\n\t}\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (tp->t_state&TS_ASLEEP) {\n\t\t\ttp->t_state &= ~TS_ASLEEP;\n\t\t\twakeup((caddr_t)&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/rcons.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rconsole *mydevicep;",
      "static void rcons_output"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&tp->t_wsel"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)&tp->t_outq"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ttrstrt",
            "tp",
            "1"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcons_puts",
          "args": [
            "mydevicep",
            "buf",
            "n"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "67-136",
          "snippet": "void\nrcons_puts(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int c, i, j;\n\tregister unsigned char *cp;\n\n\t/* Jump scroll */\n\t/* XXX maybe this should be an option? */\n\tif ((rc->rc_bits & FB_INESC) == 0) {\n\t\t/* Count newlines up to an escape sequence */\n\t\ti = 0;\n\t\tj = 0;\n\t\tfor (cp = str; j++ < n && *cp != '\\033'; ++cp) {\n\t\t\tif (*cp == '\\n')\n\t\t\t\t++i;\n\t\t\telse if (*cp == '\\013')\n\t\t\t\t--i;\n\t\t}\n\n\t\t/* Only jump scroll two or more rows */\n\t\tif (*rc->rc_row + i >= rc->rc_maxrow + 1) {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\trcons_scroll(rc, i);\n\t\t}\n\t}\n\n\t/* Process characters */\n\twhile (--n >= 0) {\n\t\tc = *str;\n\t\tif (c == '\\033') {\n\t\t\t/* Start an escape (perhaps aborting one in progress) */\n\t\t\trc->rc_bits |= FB_INESC | FB_P0_DEFAULT | FB_P1_DEFAULT;\n\t\t\trc->rc_bits &= ~(FB_P0 | FB_P1);\n\n\t\t\t/* Most parameters default to 1 */\n\t\t\trc->rc_p0 = rc->rc_p1 = 1;\n\t\t} else if (rc->rc_bits & FB_INESC) {\n\t\t\trcons_esc(rc, c);\n\t\t} else {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\t/* Display the character */\n\t\t\tif (RCONS_ISPRINT(c)) {\n\t\t\t\t/* Try to output as much as possible */\n\t\t\t\tj = rc->rc_maxcol - (*rc->rc_col + 1);\n\t\t\t\tif (j > n)\n\t\t\t\t\tj = n;\n\t\t\t\tfor (i = 1; i < j && RCONS_ISPRINT(str[i]); ++i)\n\t\t\t\t\tcontinue;\n\t\t\t\trcons_text(rc, str, i);\n\t\t\t\t--i;\n\t\t\t\tstr += i;\n\t\t\t\tn -= i;\n\t\t\t} else\n\t\t\t\trcons_pctrl(rc, c);\n\t\t}\n\t\t++str;\n\t}\n\t/* Redraw the cursor (if necessary) */\n\tif ((rc->rc_bits & FB_CURSOR) == 0)\n\t\trcons_cursor(rc);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_puts(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int c, i, j;\n\tregister unsigned char *cp;\n\n\t/* Jump scroll */\n\t/* XXX maybe this should be an option? */\n\tif ((rc->rc_bits & FB_INESC) == 0) {\n\t\t/* Count newlines up to an escape sequence */\n\t\ti = 0;\n\t\tj = 0;\n\t\tfor (cp = str; j++ < n && *cp != '\\033'; ++cp) {\n\t\t\tif (*cp == '\\n')\n\t\t\t\t++i;\n\t\t\telse if (*cp == '\\013')\n\t\t\t\t--i;\n\t\t}\n\n\t\t/* Only jump scroll two or more rows */\n\t\tif (*rc->rc_row + i >= rc->rc_maxrow + 1) {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\trcons_scroll(rc, i);\n\t\t}\n\t}\n\n\t/* Process characters */\n\twhile (--n >= 0) {\n\t\tc = *str;\n\t\tif (c == '\\033') {\n\t\t\t/* Start an escape (perhaps aborting one in progress) */\n\t\t\trc->rc_bits |= FB_INESC | FB_P0_DEFAULT | FB_P1_DEFAULT;\n\t\t\trc->rc_bits &= ~(FB_P0 | FB_P1);\n\n\t\t\t/* Most parameters default to 1 */\n\t\t\trc->rc_p0 = rc->rc_p1 = 1;\n\t\t} else if (rc->rc_bits & FB_INESC) {\n\t\t\trcons_esc(rc, c);\n\t\t} else {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\t/* Display the character */\n\t\t\tif (RCONS_ISPRINT(c)) {\n\t\t\t\t/* Try to output as much as possible */\n\t\t\t\tj = rc->rc_maxcol - (*rc->rc_col + 1);\n\t\t\t\tif (j > n)\n\t\t\t\t\tj = n;\n\t\t\t\tfor (i = 1; i < j && RCONS_ISPRINT(str[i]); ++i)\n\t\t\t\t\tcontinue;\n\t\t\t\trcons_text(rc, str, i);\n\t\t\t\t--i;\n\t\t\t\tstr += i;\n\t\t\t\tn -= i;\n\t\t\t} else\n\t\t\t\trcons_pctrl(rc, c);\n\t\t}\n\t\t++str;\n\t}\n\t/* Redraw the cursor (if necessary) */\n\tif ((rc->rc_bits & FB_CURSOR) == 0)\n\t\trcons_cursor(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "q_to_b",
          "args": [
            "&tp->t_outq",
            "buf",
            "sizeof(buf)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/rcons.h>\n#include <dev/rcons/raster.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic struct rconsole *mydevicep;\nstatic void rcons_output;\n\nstatic void\nrcons_output(tp)\n\tregister struct tty *tp;\n{\n\tregister int s, n;\n\tchar buf[OBUFSIZ];\n\n\ts = spltty();\n\tif (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\ttp->t_state |= TS_BUSY;\n\tsplx(s);\n\tn = q_to_b(&tp->t_outq, buf, sizeof(buf));\n\trcons_puts(mydevicep, buf, n);\n\n\ts = spltty();\n\ttp->t_state &= ~TS_BUSY;\n\t/* Come back if there's more to do */\n\tif (tp->t_outq.c_cc) {\n\t\ttp->t_state |= TS_TIMEOUT;\n\t\ttimeout(ttrstrt, tp, 1);\n\t}\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (tp->t_state&TS_ASLEEP) {\n\t\t\ttp->t_state &= ~TS_ASLEEP;\n\t\t\twakeup((caddr_t)&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "rcons_cnputc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_kern.c",
    "lines": "67-79",
    "snippet": "void\nrcons_cnputc(c)\n\tint c;\n{\n\tchar buf[1];\n\n\tif (c == '\\n')\n\t\trcons_puts(mydevicep, \"\\r\\n\", 2);\n\telse {\n\t\tbuf[0] = c;\n\t\trcons_puts(mydevicep, buf, 1);\n\t}\n}",
    "includes": [
      "#include \"rcons_subr.h\"",
      "#include <dev/rcons/rcons.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rconsole *mydevicep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcons_puts",
          "args": [
            "mydevicep",
            "buf",
            "1"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/rcons_subr.c",
          "lines": "67-136",
          "snippet": "void\nrcons_puts(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int c, i, j;\n\tregister unsigned char *cp;\n\n\t/* Jump scroll */\n\t/* XXX maybe this should be an option? */\n\tif ((rc->rc_bits & FB_INESC) == 0) {\n\t\t/* Count newlines up to an escape sequence */\n\t\ti = 0;\n\t\tj = 0;\n\t\tfor (cp = str; j++ < n && *cp != '\\033'; ++cp) {\n\t\t\tif (*cp == '\\n')\n\t\t\t\t++i;\n\t\t\telse if (*cp == '\\013')\n\t\t\t\t--i;\n\t\t}\n\n\t\t/* Only jump scroll two or more rows */\n\t\tif (*rc->rc_row + i >= rc->rc_maxrow + 1) {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\trcons_scroll(rc, i);\n\t\t}\n\t}\n\n\t/* Process characters */\n\twhile (--n >= 0) {\n\t\tc = *str;\n\t\tif (c == '\\033') {\n\t\t\t/* Start an escape (perhaps aborting one in progress) */\n\t\t\trc->rc_bits |= FB_INESC | FB_P0_DEFAULT | FB_P1_DEFAULT;\n\t\t\trc->rc_bits &= ~(FB_P0 | FB_P1);\n\n\t\t\t/* Most parameters default to 1 */\n\t\t\trc->rc_p0 = rc->rc_p1 = 1;\n\t\t} else if (rc->rc_bits & FB_INESC) {\n\t\t\trcons_esc(rc, c);\n\t\t} else {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\t/* Display the character */\n\t\t\tif (RCONS_ISPRINT(c)) {\n\t\t\t\t/* Try to output as much as possible */\n\t\t\t\tj = rc->rc_maxcol - (*rc->rc_col + 1);\n\t\t\t\tif (j > n)\n\t\t\t\t\tj = n;\n\t\t\t\tfor (i = 1; i < j && RCONS_ISPRINT(str[i]); ++i)\n\t\t\t\t\tcontinue;\n\t\t\t\trcons_text(rc, str, i);\n\t\t\t\t--i;\n\t\t\t\tstr += i;\n\t\t\t\tn -= i;\n\t\t\t} else\n\t\t\t\trcons_pctrl(rc, c);\n\t\t}\n\t\t++str;\n\t}\n\t/* Redraw the cursor (if necessary) */\n\tif ((rc->rc_bits & FB_CURSOR) == 0)\n\t\trcons_cursor(rc);\n}",
          "includes": [
            "#include \"rcons_subr.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <dev/rcons/rcons.h>",
            "#include \"myfbdevice.h\"",
            "#include <sys/types.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void rcons_bell(struct rconsole *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/raster.h>\n#include <dev/rcons/rcons.h>\n#include \"myfbdevice.h\"\n#include <sys/types.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nextern void rcons_bell(struct rconsole *);\n\nvoid\nrcons_puts(rc, str, n)\n\tregister struct rconsole *rc;\n\tregister unsigned char *str;\n\tregister int n;\n{\n\tregister int c, i, j;\n\tregister unsigned char *cp;\n\n\t/* Jump scroll */\n\t/* XXX maybe this should be an option? */\n\tif ((rc->rc_bits & FB_INESC) == 0) {\n\t\t/* Count newlines up to an escape sequence */\n\t\ti = 0;\n\t\tj = 0;\n\t\tfor (cp = str; j++ < n && *cp != '\\033'; ++cp) {\n\t\t\tif (*cp == '\\n')\n\t\t\t\t++i;\n\t\t\telse if (*cp == '\\013')\n\t\t\t\t--i;\n\t\t}\n\n\t\t/* Only jump scroll two or more rows */\n\t\tif (*rc->rc_row + i >= rc->rc_maxrow + 1) {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\trcons_scroll(rc, i);\n\t\t}\n\t}\n\n\t/* Process characters */\n\twhile (--n >= 0) {\n\t\tc = *str;\n\t\tif (c == '\\033') {\n\t\t\t/* Start an escape (perhaps aborting one in progress) */\n\t\t\trc->rc_bits |= FB_INESC | FB_P0_DEFAULT | FB_P1_DEFAULT;\n\t\t\trc->rc_bits &= ~(FB_P0 | FB_P1);\n\n\t\t\t/* Most parameters default to 1 */\n\t\t\trc->rc_p0 = rc->rc_p1 = 1;\n\t\t} else if (rc->rc_bits & FB_INESC) {\n\t\t\trcons_esc(rc, c);\n\t\t} else {\n\t\t\t/* Erase the cursor (if necessary) */\n\t\t\tif (rc->rc_bits & FB_CURSOR)\n\t\t\t\trcons_cursor(rc);\n\n\t\t\t/* Display the character */\n\t\t\tif (RCONS_ISPRINT(c)) {\n\t\t\t\t/* Try to output as much as possible */\n\t\t\t\tj = rc->rc_maxcol - (*rc->rc_col + 1);\n\t\t\t\tif (j > n)\n\t\t\t\t\tj = n;\n\t\t\t\tfor (i = 1; i < j && RCONS_ISPRINT(str[i]); ++i)\n\t\t\t\t\tcontinue;\n\t\t\t\trcons_text(rc, str, i);\n\t\t\t\t--i;\n\t\t\t\tstr += i;\n\t\t\t\tn -= i;\n\t\t\t} else\n\t\t\t\trcons_pctrl(rc, c);\n\t\t}\n\t\t++str;\n\t}\n\t/* Redraw the cursor (if necessary) */\n\tif ((rc->rc_bits & FB_CURSOR) == 0)\n\t\trcons_cursor(rc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcons_subr.h\"\n#include <dev/rcons/rcons.h>\n#include <dev/rcons/raster.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nstatic struct rconsole *mydevicep;\n\nvoid\nrcons_cnputc(c)\n\tint c;\n{\n\tchar buf[1];\n\n\tif (c == '\\n')\n\t\trcons_puts(mydevicep, \"\\r\\n\", 2);\n\telse {\n\t\tbuf[0] = c;\n\t\trcons_puts(mydevicep, buf, 1);\n\t}\n}"
  }
]