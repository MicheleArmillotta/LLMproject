[
  {
    "function_name": "cardslot_event_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "298-439",
    "snippet": "static void\ncardslot_event_thread(arg)\n     void *arg;\n{\n  struct cardslot_softc *sc = arg;\n  struct cardslot_event *ce;\n  int s;\n  static int antonym_ev[4] = {\n    CARDSLOT_EVENT_REMOVAL_16, CARDSLOT_EVENT_INSERTION_16,\n    CARDSLOT_EVENT_REMOVAL_CB, CARDSLOT_EVENT_INSERTION_CB\n  };\n\n  while (sc->sc_th_enable) {\n    s = spltty();\n    if ((ce = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {\n      splx(s);\n      (void) tsleep(&sc->sc_events, PWAIT, \"cardslotev\", 0);\n      continue;\n    }\n    SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce, ce_q);\n    splx(s);\n\n    if (IS_CARDSLOT_INSERT_REMOVE_EV(ce->ce_type)) {\n      /* Chattering supression */\n      s = spltty();\n      while (1) {\n\tstruct cardslot_event *ce1, *ce2;\n\n\tif ((ce1 = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {\n\t  break;\n\t}\n\tif (ce1->ce_type != antonym_ev[ce->ce_type]) {\n\t  break;\n\t}\n\tif ((ce2 = SIMPLEQ_NEXT(ce1, ce_q)) == NULL) {\n\t  break;\n\t}\n\tif (ce2->ce_type == ce->ce_type) {\n\t  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce1, ce_q);\n\t  free(ce1, M_TEMP);\n\t  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce2, ce_q);\n\t  free(ce2, M_TEMP);\n\t}\n      }\n      splx(s);\n    }\n\n    switch (ce->ce_type) {\n    case CARDSLOT_EVENT_INSERTION_CB:\n      if ((CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB)\n\t  || (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_16)) {\n\tif (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {\n\t  /* A card has already been inserted and work. */\n\t  break;\n\t}\n      }\n\n      if (sc->sc_cb_softc) {\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_CB);\n\tif (cardbus_attach_card(sc->sc_cb_softc) > 0) {\n\t  /* at least one function works */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);\n\t} else {\n\t  /* no functions work or this card is not known */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n\t}\n      } else {\n\tpanic(\"no cardbus on %s\", sc->sc_dev.dv_xname);\n      }\n\n      break;\n\n    case CARDSLOT_EVENT_INSERTION_16:\n      if ((CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB)\n\t  || (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_16)) {\n\tif (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {\n\t  /* A card has already been inserted and work. */\n\t  break;\n\t}\n      }\n      if (sc->sc_16_softc) {\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_16);\n\tif (pcmcia_card_attach((struct device *)sc->sc_16_softc)) {\n\t  /* Do not attach */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n\t} else {\n\t  /* working */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);\n\t}\n      } else {\n\tpanic(\"no 16-bit pcmcia on %s\", sc->sc_dev.dv_xname);\n      }\n\n      break;\n\n    case CARDSLOT_EVENT_REMOVAL_CB:\n      if (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB) {\n\t/* CardBus card has not been inserted. */\n\tif (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {\n\t  cardbus_detach_card(sc->sc_cb_softc);\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n\t}\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n      } else if (CARDSLOT_CARDTYPE(sc->sc_status) != CARDSLOT_STATUS_CARD_16) {\n\t/* Unknown card... */\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n      }\n      CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n      break;\n\n    case CARDSLOT_EVENT_REMOVAL_16:\n      DPRINTF((\"%s: removal event\\n\", sc->sc_dev.dv_xname));\n      if (CARDSLOT_CARDTYPE(sc->sc_status) != CARDSLOT_STATUS_CARD_16) {\n\t/* 16-bit card has not been inserted. */\n\tbreak;\n      }\n      if ((sc->sc_16_softc != NULL)\n\t  && (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING)) {\n\tstruct pcmcia_softc *psc = sc->sc_16_softc;\n\n\tpcmcia_card_deactivate((struct device *)psc);\n\tpcmcia_chip_socket_disable(psc->pct, psc->pch);\n\tpcmcia_card_detach((struct device *)psc, DETACH_FORCE);\n      }\n      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n      CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n      break;\n\n    default:\n      panic(\"cardslot_event_thread: unknown event %d\", ce->ce_type);\n    }\n    free(ce, M_TEMP);\n  }\n\n  sc->sc_event_thread = NULL;\n\n  /* In case parent is waiting for us to exit. */\n  wakeup(sc);\n\n  kthread_exit(0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cardslotattach __P((struct device *, struct device *, void *));",
      "cardslotmatch __P((struct device *, void *, void *));",
      "static void cardslot_event_thread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ce",
            "M_TEMP"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cardslot_event_thread: unknown event %d\"",
            "ce->ce_type"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_NOTWORK"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_CARDTYPE",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_NONE"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_card_detach",
          "args": [
            "(struct device *)psc",
            "DETACH_FORCE"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "252-280",
          "snippet": "void\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_chip_socket_disable",
          "args": [
            "psc->pct",
            "psc->pch"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_card_deactivate",
          "args": [
            "(struct device *)psc"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "282-304",
          "snippet": "void\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CARDSLOT_WORK",
          "args": [
            "sc->sc_status"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_CARDTYPE",
          "args": [
            "sc->sc_status"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: removal event\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_NOTWORK"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_CARDTYPE",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_NONE"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_CARDTYPE",
          "args": [
            "sc->sc_status"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_CARDTYPE",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_NONE"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_NONE"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_NOTWORK"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_detach_card",
          "args": [
            "sc->sc_cb_softc"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_detach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "610-638",
          "snippet": "void\ncardbus_detach_card(sc)\n     struct cardbus_softc *sc;\n{\n    struct cardbus_devfunc *ct, *ct_next, **prev_next;\n\n    prev_next = &(sc->sc_funcs->ct_next);\n\n    for (ct = sc->sc_funcs; ct != NULL; ct = ct_next) {\n\tstruct device *fndev = ct->ct_device;\n\tct_next = ct->ct_next;\n\n\tDPRINTF((\"%s: detaching %s\\n\", sc->sc_dev.dv_xname, fndev->dv_xname));\n\t/* call device detach function */\n\n\tif (0 != config_detach(fndev, 0)) {\n\t    printf(\"%s: cannot detaching dev %s, function %d\\n\",\n\t\t   sc->sc_dev.dv_xname, fndev->dv_xname, ct->ct_func);\n\t    prev_next = &(ct->ct_next);\n\t} else {\n\t    sc->sc_poweron_func &= ~(1 << ct->ct_func);\n\t    *prev_next = ct->ct_next;\n\t    free(ct, M_DEVBUF);\n\t}\n    }\n\n    sc->sc_poweron_func = 0;\n    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cardbusattach __P((struct device *, struct device *, void *));",
            "cardbusmatch __P((struct device *, void *, void *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncardbusattach __P((struct device *, struct device *, void *));\ncardbusmatch __P((struct device *, void *, void *));\n\nvoid\ncardbus_detach_card(sc)\n     struct cardbus_softc *sc;\n{\n    struct cardbus_devfunc *ct, *ct_next, **prev_next;\n\n    prev_next = &(sc->sc_funcs->ct_next);\n\n    for (ct = sc->sc_funcs; ct != NULL; ct = ct_next) {\n\tstruct device *fndev = ct->ct_device;\n\tct_next = ct->ct_next;\n\n\tDPRINTF((\"%s: detaching %s\\n\", sc->sc_dev.dv_xname, fndev->dv_xname));\n\t/* call device detach function */\n\n\tif (0 != config_detach(fndev, 0)) {\n\t    printf(\"%s: cannot detaching dev %s, function %d\\n\",\n\t\t   sc->sc_dev.dv_xname, fndev->dv_xname, ct->ct_func);\n\t    prev_next = &(ct->ct_next);\n\t} else {\n\t    sc->sc_poweron_func &= ~(1 << ct->ct_func);\n\t    *prev_next = ct->ct_next;\n\t    free(ct, M_DEVBUF);\n\t}\n    }\n\n    sc->sc_poweron_func = 0;\n    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CARDSLOT_WORK",
          "args": [
            "sc->sc_status"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_CARDTYPE",
          "args": [
            "sc->sc_status"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"no 16-bit pcmcia on %s\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_WORKING"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_NOTWORK"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_card_attach",
          "args": [
            "(struct device *)sc->sc_16_softc"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "159-250",
          "snippet": "int\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcmcia_submatch",
            "int\tpcmcia_print",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_submatch;\nint\tpcmcia_print;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\nvoid *ih_arg;\n\nint\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_CARDTYPE",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_16"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_WORK",
          "args": [
            "sc->sc_status"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_CARDTYPE",
          "args": [
            "sc->sc_status"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_CARDTYPE",
          "args": [
            "sc->sc_status"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"no cardbus on %s\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_NOTWORK"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_WORKING"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_attach_card",
          "args": [
            "sc->sc_cb_softc"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_attach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "382-543",
          "snippet": "int\ncardbus_attach_card(sc)\n     struct cardbus_softc *sc;\n{\n  cardbus_chipset_tag_t cc;\n  cardbus_function_tag_t cf;\n  int cdstatus;\n  cardbustag_t tag;\n  cardbusreg_t id, class, cis_ptr;\n  cardbusreg_t bhlc;\n  u_int8_t tuple[2048];\n  int function, nfunction;\n  struct cardbus_devfunc **previous_next = &(sc->sc_funcs);\n  struct device *csc;\n  int no_work_funcs = 0;\n  cardbus_devfunc_t ct;\n\n  cc = sc->sc_cc;\n  cf = sc->sc_cf;\n\n  DPRINTF((\"cardbus_attach_card: cb%d start\\n\", sc->sc_dev.dv_unit));\n\n  /* inspect initial voltage */\n  if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {\n    DPRINTF((\"cardbusattach: no CardBus card on cb%d\\n\", sc->sc_dev.dv_unit));\n    return 0;\n  }\n\n  enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to\n\t\t\t\t       keep power on during whole\n\t\t\t\t       configuration */\n\n  function = 0;\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n\n  /*\n   * Wait until power comes up.  Maxmum 500 ms.\n   */\n  {\n    int i;\n    for (i = 0; i < 5; ++i) {\n      id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n      if (id != 0xffffffff && id != 0) {\n\tbreak;\n      }\n      if (cold) {\t\t/* before kernel thread invoked */\n\tdelay(100*1000);\n      } else {\t\t\t/* thread context */\n\tif (tsleep((void *)sc, PCATCH, \"cardbus\", hz/10) != EWOULDBLOCK) {\n\t  break;\n\t}\n      }\n    }\n    if (i == 5) {\n      return 0;\n    }\n  }\n  \n  bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);\n  if (CARDBUS_LATTIMER(bhlc) < 0x10) {\n    bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n    bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);\n  }\n\n  nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;\n\n  for(function = 0; function < nfunction; function++) {\n    struct cardbus_attach_args ca;\n\n    tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n  \n    id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n    class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);\n    cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);\n  \n    /* Invalid vendor ID value? */\n    if (CARDBUS_VENDOR(id) == CARDBUS_VENDOR_INVALID) {\n      continue;\n    }\n      \n    DPRINTF((\"cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\\n\",\n\t     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr));\n\n    enable_function(sc, cdstatus, function);\n\n    /* clean up every BAR */\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);\n    \n    /*\n     * We need to allocate the ct here, since we might \n     * need it when reading the CIS\n     */\n    if (NULL == (ct = (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),\n\t\t\t\t\t\tM_DEVBUF, M_NOWAIT))) {\n      panic(\"no room for cardbus_tag\");\n    }\n\n    ct->ct_cc = sc->sc_cc;\n    ct->ct_cf = sc->sc_cf;\n    ct->ct_bus = sc->sc_bus;\n    ct->ct_dev = sc->sc_device;\n    ct->ct_func = function;\n    ct->ct_sc = sc;\n    ct->ct_next = NULL;\n    *previous_next = ct;\n\n    memset(&ca, 0, sizeof(ca));\n\n    ca.ca_unit = sc->sc_dev.dv_unit;\n    ca.ca_ct = ct;\n\n    ca.ca_iot = sc->sc_iot;\n    ca.ca_memt = sc->sc_memt;\n    ca.ca_dmat = sc->sc_dmat;\n\n    ca.ca_tag = tag;\n    ca.ca_device = sc->sc_device;\n    ca.ca_function = function;\n    ca.ca_id = id;\n    ca.ca_class = class;\n\n    ca.ca_intrline = sc->sc_intrline;\n\n    bzero(tuple, 2048);\n\n    if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {\n      printf(\"cardbus_attach_card: failed to read CIS\\n\");\n    } else {\n#ifdef CARDBUS_DEBUG\n      decode_tuples(tuple, 2048, print_tuple, NULL);\n#endif\n      decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);\n    }\n\n    if (NULL == (csc = config_found_sm((void *)sc, &ca, cardbusprint, cardbussubmatch))) {\n      /* do not match */\n      disable_function(sc, function);\n      free(ct, M_DEVBUF);\n      *previous_next = NULL;\n    } else {\n      /* found */\n      previous_next = &(ct->ct_next);\n      ct->ct_device = csc;\n      ++no_work_funcs;\n    }\n  }\n  /*\n   * XXX power down pseudo function 8 (this will power down the card\n   * if no functions were attached).\n   */\n  disable_function(sc, 8);\n\n  return no_work_funcs;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int cold;",
            "cardbusattach __P((struct device *, struct device *, void *));",
            "int cardbus_attach_card",
            "cardbusmatch __P((struct device *, void *, void *));",
            "static int cardbussubmatch",
            "static int cardbusprint",
            "static int decode_tuples",
            "static int cardbus_read_tuples",
            "static void enable_function",
            "static void disable_function",
            "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
            "cardbus_function_tag_t cf;",
            "static u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nextern int cold;\ncardbusattach __P((struct device *, struct device *, void *));\nint cardbus_attach_card;\ncardbusmatch __P((struct device *, void *, void *));\nstatic int cardbussubmatch;\nstatic int cardbusprint;\nstatic int decode_tuples;\nstatic int cardbus_read_tuples;\nstatic void enable_function;\nstatic void disable_function;\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\nstatic u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;\n\nint\ncardbus_attach_card(sc)\n     struct cardbus_softc *sc;\n{\n  cardbus_chipset_tag_t cc;\n  cardbus_function_tag_t cf;\n  int cdstatus;\n  cardbustag_t tag;\n  cardbusreg_t id, class, cis_ptr;\n  cardbusreg_t bhlc;\n  u_int8_t tuple[2048];\n  int function, nfunction;\n  struct cardbus_devfunc **previous_next = &(sc->sc_funcs);\n  struct device *csc;\n  int no_work_funcs = 0;\n  cardbus_devfunc_t ct;\n\n  cc = sc->sc_cc;\n  cf = sc->sc_cf;\n\n  DPRINTF((\"cardbus_attach_card: cb%d start\\n\", sc->sc_dev.dv_unit));\n\n  /* inspect initial voltage */\n  if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {\n    DPRINTF((\"cardbusattach: no CardBus card on cb%d\\n\", sc->sc_dev.dv_unit));\n    return 0;\n  }\n\n  enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to\n\t\t\t\t       keep power on during whole\n\t\t\t\t       configuration */\n\n  function = 0;\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n\n  /*\n   * Wait until power comes up.  Maxmum 500 ms.\n   */\n  {\n    int i;\n    for (i = 0; i < 5; ++i) {\n      id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n      if (id != 0xffffffff && id != 0) {\n\tbreak;\n      }\n      if (cold) {\t\t/* before kernel thread invoked */\n\tdelay(100*1000);\n      } else {\t\t\t/* thread context */\n\tif (tsleep((void *)sc, PCATCH, \"cardbus\", hz/10) != EWOULDBLOCK) {\n\t  break;\n\t}\n      }\n    }\n    if (i == 5) {\n      return 0;\n    }\n  }\n  \n  bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);\n  if (CARDBUS_LATTIMER(bhlc) < 0x10) {\n    bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n    bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);\n  }\n\n  nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;\n\n  for(function = 0; function < nfunction; function++) {\n    struct cardbus_attach_args ca;\n\n    tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n  \n    id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n    class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);\n    cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);\n  \n    /* Invalid vendor ID value? */\n    if (CARDBUS_VENDOR(id) == CARDBUS_VENDOR_INVALID) {\n      continue;\n    }\n      \n    DPRINTF((\"cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\\n\",\n\t     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr));\n\n    enable_function(sc, cdstatus, function);\n\n    /* clean up every BAR */\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);\n    \n    /*\n     * We need to allocate the ct here, since we might \n     * need it when reading the CIS\n     */\n    if (NULL == (ct = (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),\n\t\t\t\t\t\tM_DEVBUF, M_NOWAIT))) {\n      panic(\"no room for cardbus_tag\");\n    }\n\n    ct->ct_cc = sc->sc_cc;\n    ct->ct_cf = sc->sc_cf;\n    ct->ct_bus = sc->sc_bus;\n    ct->ct_dev = sc->sc_device;\n    ct->ct_func = function;\n    ct->ct_sc = sc;\n    ct->ct_next = NULL;\n    *previous_next = ct;\n\n    memset(&ca, 0, sizeof(ca));\n\n    ca.ca_unit = sc->sc_dev.dv_unit;\n    ca.ca_ct = ct;\n\n    ca.ca_iot = sc->sc_iot;\n    ca.ca_memt = sc->sc_memt;\n    ca.ca_dmat = sc->sc_dmat;\n\n    ca.ca_tag = tag;\n    ca.ca_device = sc->sc_device;\n    ca.ca_function = function;\n    ca.ca_id = id;\n    ca.ca_class = class;\n\n    ca.ca_intrline = sc->sc_intrline;\n\n    bzero(tuple, 2048);\n\n    if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {\n      printf(\"cardbus_attach_card: failed to read CIS\\n\");\n    } else {\n#ifdef CARDBUS_DEBUG\n      decode_tuples(tuple, 2048, print_tuple, NULL);\n#endif\n      decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);\n    }\n\n    if (NULL == (csc = config_found_sm((void *)sc, &ca, cardbusprint, cardbussubmatch))) {\n      /* do not match */\n      disable_function(sc, function);\n      free(ct, M_DEVBUF);\n      *previous_next = NULL;\n    } else {\n      /* found */\n      previous_next = &(ct->ct_next);\n      ct->ct_device = csc;\n      ++no_work_funcs;\n    }\n  }\n  /*\n   * XXX power down pseudo function 8 (this will power down the card\n   * if no functions were attached).\n   */\n  disable_function(sc, 8);\n\n  return no_work_funcs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_CARDTYPE",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_CB"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_WORK",
          "args": [
            "sc->sc_status"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_CARDTYPE",
          "args": [
            "sc->sc_status"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_CARDTYPE",
          "args": [
            "sc->sc_status"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&sc->sc_events",
            "ce2",
            "ce_q"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&sc->sc_events",
            "ce1",
            "ce_q"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "ce1",
            "ce_q"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->sc_events"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_CARDSLOT_INSERT_REMOVE_EV",
          "args": [
            "ce->ce_type"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&sc->sc_events",
            "ce",
            "ce_q"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&sc->sc_events",
            "PWAIT",
            "\"cardslotev\"",
            "0"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->sc_events"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncardslotattach __P((struct device *, struct device *, void *));\ncardslotmatch __P((struct device *, void *, void *));\nstatic void cardslot_event_thread;\n\nstatic void\ncardslot_event_thread(arg)\n     void *arg;\n{\n  struct cardslot_softc *sc = arg;\n  struct cardslot_event *ce;\n  int s;\n  static int antonym_ev[4] = {\n    CARDSLOT_EVENT_REMOVAL_16, CARDSLOT_EVENT_INSERTION_16,\n    CARDSLOT_EVENT_REMOVAL_CB, CARDSLOT_EVENT_INSERTION_CB\n  };\n\n  while (sc->sc_th_enable) {\n    s = spltty();\n    if ((ce = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {\n      splx(s);\n      (void) tsleep(&sc->sc_events, PWAIT, \"cardslotev\", 0);\n      continue;\n    }\n    SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce, ce_q);\n    splx(s);\n\n    if (IS_CARDSLOT_INSERT_REMOVE_EV(ce->ce_type)) {\n      /* Chattering supression */\n      s = spltty();\n      while (1) {\n\tstruct cardslot_event *ce1, *ce2;\n\n\tif ((ce1 = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {\n\t  break;\n\t}\n\tif (ce1->ce_type != antonym_ev[ce->ce_type]) {\n\t  break;\n\t}\n\tif ((ce2 = SIMPLEQ_NEXT(ce1, ce_q)) == NULL) {\n\t  break;\n\t}\n\tif (ce2->ce_type == ce->ce_type) {\n\t  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce1, ce_q);\n\t  free(ce1, M_TEMP);\n\t  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce2, ce_q);\n\t  free(ce2, M_TEMP);\n\t}\n      }\n      splx(s);\n    }\n\n    switch (ce->ce_type) {\n    case CARDSLOT_EVENT_INSERTION_CB:\n      if ((CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB)\n\t  || (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_16)) {\n\tif (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {\n\t  /* A card has already been inserted and work. */\n\t  break;\n\t}\n      }\n\n      if (sc->sc_cb_softc) {\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_CB);\n\tif (cardbus_attach_card(sc->sc_cb_softc) > 0) {\n\t  /* at least one function works */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);\n\t} else {\n\t  /* no functions work or this card is not known */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n\t}\n      } else {\n\tpanic(\"no cardbus on %s\", sc->sc_dev.dv_xname);\n      }\n\n      break;\n\n    case CARDSLOT_EVENT_INSERTION_16:\n      if ((CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB)\n\t  || (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_16)) {\n\tif (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {\n\t  /* A card has already been inserted and work. */\n\t  break;\n\t}\n      }\n      if (sc->sc_16_softc) {\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_16);\n\tif (pcmcia_card_attach((struct device *)sc->sc_16_softc)) {\n\t  /* Do not attach */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n\t} else {\n\t  /* working */\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);\n\t}\n      } else {\n\tpanic(\"no 16-bit pcmcia on %s\", sc->sc_dev.dv_xname);\n      }\n\n      break;\n\n    case CARDSLOT_EVENT_REMOVAL_CB:\n      if (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB) {\n\t/* CardBus card has not been inserted. */\n\tif (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {\n\t  cardbus_detach_card(sc->sc_cb_softc);\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n\t  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n\t}\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n      } else if (CARDSLOT_CARDTYPE(sc->sc_status) != CARDSLOT_STATUS_CARD_16) {\n\t/* Unknown card... */\n\tCARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n      }\n      CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n      break;\n\n    case CARDSLOT_EVENT_REMOVAL_16:\n      DPRINTF((\"%s: removal event\\n\", sc->sc_dev.dv_xname));\n      if (CARDSLOT_CARDTYPE(sc->sc_status) != CARDSLOT_STATUS_CARD_16) {\n\t/* 16-bit card has not been inserted. */\n\tbreak;\n      }\n      if ((sc->sc_16_softc != NULL)\n\t  && (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING)) {\n\tstruct pcmcia_softc *psc = sc->sc_16_softc;\n\n\tpcmcia_card_deactivate((struct device *)psc);\n\tpcmcia_chip_socket_disable(psc->pct, psc->pch);\n\tpcmcia_card_detach((struct device *)psc, DETACH_FORCE);\n      }\n      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);\n      CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n      break;\n\n    default:\n      panic(\"cardslot_event_thread: unknown event %d\", ce->ce_type);\n    }\n    free(ce, M_TEMP);\n  }\n\n  sc->sc_event_thread = NULL;\n\n  /* In case parent is waiting for us to exit. */\n  wakeup(sc);\n\n  kthread_exit(0);\n}"
  },
  {
    "function_name": "cardslot_event_throw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "260-288",
    "snippet": "void\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_events"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&sc->sc_events",
            "ce",
            "ce_q"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cardslot_enevt\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct cardslot_event)",
            "M_TEMP",
            "M_NOWAIT"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\")"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}"
  },
  {
    "function_name": "create_slot_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "235-249",
    "snippet": "static void\ncreate_slot_manager(arg)\n     void *arg;\n{\n  struct cardslot_softc *sc = (struct cardslot_softc *)arg;\n\n  sc->sc_th_enable = 1;\n\n if (kthread_create(cardslot_event_thread, sc, &sc->sc_event_thread, \"%s\",\n\t\t     sc->sc_dev.dv_xname)) {\n    printf(\"%s: unable to create event thread for slot %d\\n\",\n\t   sc->sc_dev.dv_xname, sc->sc_slot);\n    panic(\"create_slot_manager\");\n  }\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void create_slot_manager",
      "static void cardslot_event_thread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"create_slot_manager\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to create event thread for slot %d\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_slot"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "cardslot_event_thread",
            "sc",
            "&sc->sc_event_thread",
            "\"%s\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void create_slot_manager;\nstatic void cardslot_event_thread;\n\nstatic void\ncreate_slot_manager(arg)\n     void *arg;\n{\n  struct cardslot_softc *sc = (struct cardslot_softc *)arg;\n\n  sc->sc_th_enable = 1;\n\n if (kthread_create(cardslot_event_thread, sc, &sc->sc_event_thread, \"%s\",\n\t\t     sc->sc_dev.dv_xname)) {\n    printf(\"%s: unable to create event thread for slot %d\\n\",\n\t   sc->sc_dev.dv_xname, sc->sc_slot);\n    panic(\"create_slot_manager\");\n  }\n}"
  },
  {
    "function_name": "cardslot_16_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "219-230",
    "snippet": "static int\ncardslot_16_print(arg, pnp)\n     void *arg;\n     const char *pnp;\n{\n\n  if (pnp) {\n    printf(\"pcmciabus at %s\", pnp);\n  }\n\n  return UNCONF;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cardslot_16_print"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pcmciabus at %s\"",
            "pnp"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cardslot_16_print;\n\nstatic int\ncardslot_16_print(arg, pnp)\n     void *arg;\n     const char *pnp;\n{\n\n  if (pnp) {\n    printf(\"pcmciabus at %s\", pnp);\n  }\n\n  return UNCONF;\n}"
  },
  {
    "function_name": "cardslot_16_submatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "199-215",
    "snippet": "static int\ncardslot_16_submatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cfdata *cf = match;\n\n  if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != 0)\n    return 0;\n\n  if (cf->cf_loc[0] == -1) {\n    return ((*cf->cf_attach->ca_match)(parent, cf, aux));\n  }\n\n  return 0;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cardslotattach __P((struct device *, struct device *, void *));",
      "cardslotmatch __P((struct device *, void *, void *));",
      "static int cardslot_16_submatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "cf",
            "aux"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncardslotattach __P((struct device *, struct device *, void *));\ncardslotmatch __P((struct device *, void *, void *));\nstatic int cardslot_16_submatch;\n\nstatic int\ncardslot_16_submatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cfdata *cf = match;\n\n  if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != 0)\n    return 0;\n\n  if (cf->cf_loc[0] == -1) {\n    return ((*cf->cf_attach->ca_match)(parent, cf, aux));\n  }\n\n  return 0;\n}"
  },
  {
    "function_name": "cardslot_cb_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "184-196",
    "snippet": "STATIC int\ncardslot_cb_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct cbslot_attach_args *cba = aux;\n\n\tif (pnp) {\n\t\tprintf(\"cardbus at %s subordinate bus %d\", pnp, cba->cba_bus);\n\t}\n\n\treturn UNCONF;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "STATIC int",
      "STATIC int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus at %s subordinate bus %d\"",
            "pnp",
            "cba->cba_bus"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC void;\nSTATIC int;\nSTATIC int;\n\nSTATIC int\ncardslot_cb_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct cbslot_attach_args *cba = aux;\n\n\tif (pnp) {\n\t\tprintf(\"cardbus at %s subordinate bus %d\", pnp, cba->cba_bus);\n\t}\n\n\treturn UNCONF;\n}"
  },
  {
    "function_name": "cardslotattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "102-180",
    "snippet": "STATIC void\ncardslotattach(parent, self, aux)\n     struct device *parent;\n     struct device *self;\n     void *aux;\n{\n  struct cardslot_softc *sc = (struct cardslot_softc *)self;\n  struct cardslot_attach_args *caa = aux;\n\n  struct cbslot_attach_args *cba = caa->caa_cb_attach;\n  struct pcmciabus_attach_args *pa = caa->caa_16_attach;\n\n  struct cardbus_softc *csc;\n  struct pcmcia_softc *psc;\n\n  int card_attach_now;\n\n  sc->sc_slot = sc->sc_dev.dv_unit;\n  sc->sc_cb_softc = NULL;\n  sc->sc_16_softc = NULL;\n  SIMPLEQ_INIT(&sc->sc_events);\n  sc->sc_th_enable = 0;\n\n  printf(\" slot %d flags %x\\n\", sc->sc_slot, sc->sc_dev.dv_cfdata->cf_flags);\n\n  DPRINTF((\"%s attaching CardBus bus...\\n\", sc->sc_dev.dv_xname));\n  if (cba != NULL) {\n    if (NULL != (csc = (void *)config_found(self, cba, cardslot_cb_print))) {\n      /* cardbus found */\n      DPRINTF((\"cardslotattach: found cardbus on %s\\n\", sc->sc_dev.dv_xname));\n      sc->sc_cb_softc = csc;\n    }\n  }\n\n  if (pa != NULL) {\n    if (NULL != (psc = (void *)config_found_sm(self, pa, cardslot_16_print, \n\t\t\t\t       cardslot_16_submatch))) {\n      /* pcmcia 16-bit bus found */\n      DPRINTF((\"cardslotattach: found 16-bit pcmcia bus\\n\"));\n      sc->sc_16_softc = psc;\n      /* XXX: dirty.  This code should be removed to achieve MI */\n      caa->caa_ph->pcmcia = (struct device *)psc;\n    }\n  }\n\n  if (csc != NULL || psc != NULL)\n    kthread_create_deferred(create_slot_manager, (void *)sc);\n\n  card_attach_now = sc->sc_dev.dv_cfdata->cf_flags & 0x01;\n\n  if (csc && (csc->sc_cf->cardbus_ctrl)(csc->sc_cc, CARDBUS_CD)) {\n    DPRINTF((\"cardslotattach: CardBus card found\\n\"));\n    if (card_attach_now) {\n      if (cardbus_attach_card(sc->sc_cb_softc) > 0) {\n\t/* at least one function works */\n\tCARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);\n      } else {\n\t/* no functions work or this card is not known */\n\tCARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n      }\n      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_CB);\n    } else {\n      /* attach deffered */\n      cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_CB);\n    }\n  }\n\n  if (psc && (psc->pct->card_detect)(psc->pch)) {\n    DPRINTF((\"cardbusattach: 16-bit card found\\n\"));\n    if (card_attach_now) {\n      /* attach now */\n      pcmcia_card_attach((struct device *)sc->sc_16_softc);\n      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_16);\n    } else {\n      /* attach deffered */\n      cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_16);\n    }\n  }\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "cardslotattach __P((struct device *, struct device *, void *));",
      "STATIC int",
      "cardslotmatch __P((struct device *, void *, void *));",
      "static void create_slot_manager",
      "STATIC int",
      "static int cardslot_16_print",
      "static int cardslot_16_submatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cardslot_event_throw",
          "args": [
            "sc",
            "CARDSLOT_EVENT_INSERTION_16"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "cardslot_event_throw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
          "lines": "260-288",
          "snippet": "void\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/kthread.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_CARDTYPE",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_16"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_card_attach",
          "args": [
            "(struct device *)sc->sc_16_softc"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "159-250",
          "snippet": "int\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcmcia_submatch",
            "int\tpcmcia_print",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_submatch;\nint\tpcmcia_print;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\nvoid *ih_arg;\n\nint\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardbusattach: 16-bit card found\\n\")"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "psc->pch"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_CARDTYPE",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_CARD_CB"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_NOTWORK"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDSLOT_SET_WORK",
          "args": [
            "sc->sc_status",
            "CARDSLOT_STATUS_WORKING"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_attach_card",
          "args": [
            "sc->sc_cb_softc"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_attach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "382-543",
          "snippet": "int\ncardbus_attach_card(sc)\n     struct cardbus_softc *sc;\n{\n  cardbus_chipset_tag_t cc;\n  cardbus_function_tag_t cf;\n  int cdstatus;\n  cardbustag_t tag;\n  cardbusreg_t id, class, cis_ptr;\n  cardbusreg_t bhlc;\n  u_int8_t tuple[2048];\n  int function, nfunction;\n  struct cardbus_devfunc **previous_next = &(sc->sc_funcs);\n  struct device *csc;\n  int no_work_funcs = 0;\n  cardbus_devfunc_t ct;\n\n  cc = sc->sc_cc;\n  cf = sc->sc_cf;\n\n  DPRINTF((\"cardbus_attach_card: cb%d start\\n\", sc->sc_dev.dv_unit));\n\n  /* inspect initial voltage */\n  if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {\n    DPRINTF((\"cardbusattach: no CardBus card on cb%d\\n\", sc->sc_dev.dv_unit));\n    return 0;\n  }\n\n  enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to\n\t\t\t\t       keep power on during whole\n\t\t\t\t       configuration */\n\n  function = 0;\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n\n  /*\n   * Wait until power comes up.  Maxmum 500 ms.\n   */\n  {\n    int i;\n    for (i = 0; i < 5; ++i) {\n      id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n      if (id != 0xffffffff && id != 0) {\n\tbreak;\n      }\n      if (cold) {\t\t/* before kernel thread invoked */\n\tdelay(100*1000);\n      } else {\t\t\t/* thread context */\n\tif (tsleep((void *)sc, PCATCH, \"cardbus\", hz/10) != EWOULDBLOCK) {\n\t  break;\n\t}\n      }\n    }\n    if (i == 5) {\n      return 0;\n    }\n  }\n  \n  bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);\n  if (CARDBUS_LATTIMER(bhlc) < 0x10) {\n    bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n    bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);\n  }\n\n  nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;\n\n  for(function = 0; function < nfunction; function++) {\n    struct cardbus_attach_args ca;\n\n    tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n  \n    id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n    class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);\n    cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);\n  \n    /* Invalid vendor ID value? */\n    if (CARDBUS_VENDOR(id) == CARDBUS_VENDOR_INVALID) {\n      continue;\n    }\n      \n    DPRINTF((\"cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\\n\",\n\t     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr));\n\n    enable_function(sc, cdstatus, function);\n\n    /* clean up every BAR */\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);\n    \n    /*\n     * We need to allocate the ct here, since we might \n     * need it when reading the CIS\n     */\n    if (NULL == (ct = (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),\n\t\t\t\t\t\tM_DEVBUF, M_NOWAIT))) {\n      panic(\"no room for cardbus_tag\");\n    }\n\n    ct->ct_cc = sc->sc_cc;\n    ct->ct_cf = sc->sc_cf;\n    ct->ct_bus = sc->sc_bus;\n    ct->ct_dev = sc->sc_device;\n    ct->ct_func = function;\n    ct->ct_sc = sc;\n    ct->ct_next = NULL;\n    *previous_next = ct;\n\n    memset(&ca, 0, sizeof(ca));\n\n    ca.ca_unit = sc->sc_dev.dv_unit;\n    ca.ca_ct = ct;\n\n    ca.ca_iot = sc->sc_iot;\n    ca.ca_memt = sc->sc_memt;\n    ca.ca_dmat = sc->sc_dmat;\n\n    ca.ca_tag = tag;\n    ca.ca_device = sc->sc_device;\n    ca.ca_function = function;\n    ca.ca_id = id;\n    ca.ca_class = class;\n\n    ca.ca_intrline = sc->sc_intrline;\n\n    bzero(tuple, 2048);\n\n    if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {\n      printf(\"cardbus_attach_card: failed to read CIS\\n\");\n    } else {\n#ifdef CARDBUS_DEBUG\n      decode_tuples(tuple, 2048, print_tuple, NULL);\n#endif\n      decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);\n    }\n\n    if (NULL == (csc = config_found_sm((void *)sc, &ca, cardbusprint, cardbussubmatch))) {\n      /* do not match */\n      disable_function(sc, function);\n      free(ct, M_DEVBUF);\n      *previous_next = NULL;\n    } else {\n      /* found */\n      previous_next = &(ct->ct_next);\n      ct->ct_device = csc;\n      ++no_work_funcs;\n    }\n  }\n  /*\n   * XXX power down pseudo function 8 (this will power down the card\n   * if no functions were attached).\n   */\n  disable_function(sc, 8);\n\n  return no_work_funcs;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int cold;",
            "cardbusattach __P((struct device *, struct device *, void *));",
            "int cardbus_attach_card",
            "cardbusmatch __P((struct device *, void *, void *));",
            "static int cardbussubmatch",
            "static int cardbusprint",
            "static int decode_tuples",
            "static int cardbus_read_tuples",
            "static void enable_function",
            "static void disable_function",
            "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
            "cardbus_function_tag_t cf;",
            "static u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nextern int cold;\ncardbusattach __P((struct device *, struct device *, void *));\nint cardbus_attach_card;\ncardbusmatch __P((struct device *, void *, void *));\nstatic int cardbussubmatch;\nstatic int cardbusprint;\nstatic int decode_tuples;\nstatic int cardbus_read_tuples;\nstatic void enable_function;\nstatic void disable_function;\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\nstatic u_int8_t *\ndecode_tuple(tuple, func, data)\n     u_int8_t *tuple;\n\nint\ncardbus_attach_card(sc)\n     struct cardbus_softc *sc;\n{\n  cardbus_chipset_tag_t cc;\n  cardbus_function_tag_t cf;\n  int cdstatus;\n  cardbustag_t tag;\n  cardbusreg_t id, class, cis_ptr;\n  cardbusreg_t bhlc;\n  u_int8_t tuple[2048];\n  int function, nfunction;\n  struct cardbus_devfunc **previous_next = &(sc->sc_funcs);\n  struct device *csc;\n  int no_work_funcs = 0;\n  cardbus_devfunc_t ct;\n\n  cc = sc->sc_cc;\n  cf = sc->sc_cf;\n\n  DPRINTF((\"cardbus_attach_card: cb%d start\\n\", sc->sc_dev.dv_unit));\n\n  /* inspect initial voltage */\n  if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {\n    DPRINTF((\"cardbusattach: no CardBus card on cb%d\\n\", sc->sc_dev.dv_unit));\n    return 0;\n  }\n\n  enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to\n\t\t\t\t       keep power on during whole\n\t\t\t\t       configuration */\n\n  function = 0;\n\n  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n\n  /*\n   * Wait until power comes up.  Maxmum 500 ms.\n   */\n  {\n    int i;\n    for (i = 0; i < 5; ++i) {\n      id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n      if (id != 0xffffffff && id != 0) {\n\tbreak;\n      }\n      if (cold) {\t\t/* before kernel thread invoked */\n\tdelay(100*1000);\n      } else {\t\t\t/* thread context */\n\tif (tsleep((void *)sc, PCATCH, \"cardbus\", hz/10) != EWOULDBLOCK) {\n\t  break;\n\t}\n      }\n    }\n    if (i == 5) {\n      return 0;\n    }\n  }\n  \n  bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);\n  if (CARDBUS_LATTIMER(bhlc) < 0x10) {\n    bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n    bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);\n  }\n\n  nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;\n\n  for(function = 0; function < nfunction; function++) {\n    struct cardbus_attach_args ca;\n\n    tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);\n  \n    id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);\n    class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);\n    cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);\n  \n    /* Invalid vendor ID value? */\n    if (CARDBUS_VENDOR(id) == CARDBUS_VENDOR_INVALID) {\n      continue;\n    }\n      \n    DPRINTF((\"cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\\n\",\n\t     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr));\n\n    enable_function(sc, cdstatus, function);\n\n    /* clean up every BAR */\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);\n    cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);\n    \n    /*\n     * We need to allocate the ct here, since we might \n     * need it when reading the CIS\n     */\n    if (NULL == (ct = (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),\n\t\t\t\t\t\tM_DEVBUF, M_NOWAIT))) {\n      panic(\"no room for cardbus_tag\");\n    }\n\n    ct->ct_cc = sc->sc_cc;\n    ct->ct_cf = sc->sc_cf;\n    ct->ct_bus = sc->sc_bus;\n    ct->ct_dev = sc->sc_device;\n    ct->ct_func = function;\n    ct->ct_sc = sc;\n    ct->ct_next = NULL;\n    *previous_next = ct;\n\n    memset(&ca, 0, sizeof(ca));\n\n    ca.ca_unit = sc->sc_dev.dv_unit;\n    ca.ca_ct = ct;\n\n    ca.ca_iot = sc->sc_iot;\n    ca.ca_memt = sc->sc_memt;\n    ca.ca_dmat = sc->sc_dmat;\n\n    ca.ca_tag = tag;\n    ca.ca_device = sc->sc_device;\n    ca.ca_function = function;\n    ca.ca_id = id;\n    ca.ca_class = class;\n\n    ca.ca_intrline = sc->sc_intrline;\n\n    bzero(tuple, 2048);\n\n    if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {\n      printf(\"cardbus_attach_card: failed to read CIS\\n\");\n    } else {\n#ifdef CARDBUS_DEBUG\n      decode_tuples(tuple, 2048, print_tuple, NULL);\n#endif\n      decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);\n    }\n\n    if (NULL == (csc = config_found_sm((void *)sc, &ca, cardbusprint, cardbussubmatch))) {\n      /* do not match */\n      disable_function(sc, function);\n      free(ct, M_DEVBUF);\n      *previous_next = NULL;\n    } else {\n      /* found */\n      previous_next = &(ct->ct_next);\n      ct->ct_device = csc;\n      ++no_work_funcs;\n    }\n  }\n  /*\n   * XXX power down pseudo function 8 (this will power down the card\n   * if no functions were attached).\n   */\n  disable_function(sc, 8);\n\n  return no_work_funcs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardslotattach: CardBus card found\\n\")"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "csc->sc_cc",
            "CARDBUS_CD"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_deferred",
          "args": [
            "create_slot_manager",
            "(void *)sc"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardslotattach: found 16-bit pcmcia bus\\n\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found_sm",
          "args": [
            "self",
            "pa",
            "cardslot_16_print",
            "cardslot_16_submatch"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"cardslotattach: found cardbus on %s\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "cba",
            "cardslot_cb_print"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s attaching CardBus bus...\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" slot %d flags %x\\n\"",
            "sc->sc_slot",
            "sc->sc_dev.dv_cfdata->cf_flags"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&sc->sc_events"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC void;\ncardslotattach __P((struct device *, struct device *, void *));\nSTATIC int;\ncardslotmatch __P((struct device *, void *, void *));\nstatic void create_slot_manager;\nSTATIC int;\nstatic int cardslot_16_print;\nstatic int cardslot_16_submatch;\n\nSTATIC void\ncardslotattach(parent, self, aux)\n     struct device *parent;\n     struct device *self;\n     void *aux;\n{\n  struct cardslot_softc *sc = (struct cardslot_softc *)self;\n  struct cardslot_attach_args *caa = aux;\n\n  struct cbslot_attach_args *cba = caa->caa_cb_attach;\n  struct pcmciabus_attach_args *pa = caa->caa_16_attach;\n\n  struct cardbus_softc *csc;\n  struct pcmcia_softc *psc;\n\n  int card_attach_now;\n\n  sc->sc_slot = sc->sc_dev.dv_unit;\n  sc->sc_cb_softc = NULL;\n  sc->sc_16_softc = NULL;\n  SIMPLEQ_INIT(&sc->sc_events);\n  sc->sc_th_enable = 0;\n\n  printf(\" slot %d flags %x\\n\", sc->sc_slot, sc->sc_dev.dv_cfdata->cf_flags);\n\n  DPRINTF((\"%s attaching CardBus bus...\\n\", sc->sc_dev.dv_xname));\n  if (cba != NULL) {\n    if (NULL != (csc = (void *)config_found(self, cba, cardslot_cb_print))) {\n      /* cardbus found */\n      DPRINTF((\"cardslotattach: found cardbus on %s\\n\", sc->sc_dev.dv_xname));\n      sc->sc_cb_softc = csc;\n    }\n  }\n\n  if (pa != NULL) {\n    if (NULL != (psc = (void *)config_found_sm(self, pa, cardslot_16_print, \n\t\t\t\t       cardslot_16_submatch))) {\n      /* pcmcia 16-bit bus found */\n      DPRINTF((\"cardslotattach: found 16-bit pcmcia bus\\n\"));\n      sc->sc_16_softc = psc;\n      /* XXX: dirty.  This code should be removed to achieve MI */\n      caa->caa_ph->pcmcia = (struct device *)psc;\n    }\n  }\n\n  if (csc != NULL || psc != NULL)\n    kthread_create_deferred(create_slot_manager, (void *)sc);\n\n  card_attach_now = sc->sc_dev.dv_cfdata->cf_flags & 0x01;\n\n  if (csc && (csc->sc_cf->cardbus_ctrl)(csc->sc_cc, CARDBUS_CD)) {\n    DPRINTF((\"cardslotattach: CardBus card found\\n\"));\n    if (card_attach_now) {\n      if (cardbus_attach_card(sc->sc_cb_softc) > 0) {\n\t/* at least one function works */\n\tCARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);\n      } else {\n\t/* no functions work or this card is not known */\n\tCARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);\n      }\n      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_CB);\n    } else {\n      /* attach deffered */\n      cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_CB);\n    }\n  }\n\n  if (psc && (psc->pct->card_detect)(psc->pch)) {\n    DPRINTF((\"cardbusattach: 16-bit card found\\n\"));\n    if (card_attach_now) {\n      /* attach now */\n      pcmcia_card_attach((struct device *)sc->sc_16_softc);\n      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_16);\n    } else {\n      /* attach deffered */\n      cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_16);\n    }\n  }\n}"
  },
  {
    "function_name": "cardslotmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
    "lines": "84-98",
    "snippet": "STATIC int\ncardslotmatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cardslot_attach_args *caa = aux;\n\n  if (caa->caa_cb_attach == NULL && caa->caa_16_attach == NULL) {\n    /* Neither CardBus nor 16-bit PCMCIA are defined. */\n    return 0;\n  }\n\n  return 1;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/pcmcia/pcmciachip.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <machine/bus.h>",
      "#include <sys/kthread.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC void",
      "cardslotattach __P((struct device *, struct device *, void *));",
      "STATIC int",
      "cardslotmatch __P((struct device *, void *, void *));",
      "STATIC int"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC void;\ncardslotattach __P((struct device *, struct device *, void *));\nSTATIC int;\ncardslotmatch __P((struct device *, void *, void *));\nSTATIC int;\n\nSTATIC int\ncardslotmatch(parent, match, aux)\n     struct device *parent;\n     void *match;\n     void *aux;\n{\n  struct cardslot_attach_args *caa = aux;\n\n  if (caa->caa_cb_attach == NULL && caa->caa_16_attach == NULL) {\n    /* Neither CardBus nor 16-bit PCMCIA are defined. */\n    return 0;\n  }\n\n  return 1;\n}"
  }
]